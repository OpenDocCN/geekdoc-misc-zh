# 测试

# 好测试

测试金字塔和不同级别的测试在“约定您用于测试的语言”中进行了讨论。

正如在该部分中讨论的，保持分层策略非常重要，其中有许多快速运行的单元测试和少量的集成和系统测试。最适合的比例会因项目而异，但金字塔形状将保持不变。

尽管在所有这些级别编写测试都很重要，但本节主要关注单元测试，因为这些是我们编写最多且运行最频繁的测试。

# 写规范而不是测试

## 写规范而不是测试

在开始编写测试之前，了解*为什么*这样做很重要。

您想要实现什么？

不幸的是，开发人员倾向于将测试视为必须执行的事情，因为这是“最佳实践”。在真正的工作完成后要执行的一些额外工作。一种苦差事。

编写它们的原因已经迷失。

### 为什么要写测试？

写测试的原因是为了让我们的生活更轻松。

如果我们不编写这样做的测试，我们应该停止编写它们。

一个好的测试应该完成以下所有内容：

+   通过在实现更改时防止回归来促进重构

+   在初始编码期间捕获错误

+   记录代码的行为方式

+   为代码设计提供信息

当测试被视为在编写代码之后完成的一项任务时，只考虑到了这一点。

往往不会实现。

以这种心态编写的测试可能具有负面价值：

+   它们不是在促进重构，而是可能增加其成本。

+   它们不是在记录代码的功能，而是比代码本身更难理解。

+   它们不是帮助开发，而是增加了必须完成的工作量

这个第一个问题引起了最多的痛苦。

如果您有一个与代码实现相关联的测试，要更改代码的实现方式，您必须花费精力更改测试。

如果测试必须在实现更改时更改，那么我们就无法相信测试会阻止回归。我们如何知道我们在更改测试时没有引入错误呢？

### 可执行的规范

那么我们如何确保不编写负值测试？如何确保我们编写的测试能提供列表中的好处？

要做的第一件事是放弃我们正在进行测试的想法。

我们不是在测试，我们是在*规定*。

要测试某样东西，您只需要验证它“做了什么”。要规定，您需要以清晰易懂的方式描述它必须做的重要事情。

一个好的规范只描述*重要的*事情。

它描述了某物*必须*做什么，而不做出关于它将如何做的假设。它允许多种实现。如果规范与一种实现绑定，那么它就是*过度规范化*的，当实现更改时，它将不得不改变。

所以这是我们必须追求的目标 - 我们代码的可执行规范。

不幸的是这很难做到。

### 先有规范

一个简单的技巧可以帮助我们的是在编写代码之前编写规范。即 TDD。

严格的 TDD 循环以非常小的步骤进行。

首先编写一个测试并运行它以确保它失败。

接下来只编写足够的代码使该测试通过（不多不少）。

稍微停顿一下，看看是否有一个合理的重构可以改进代码，然后编写下一个测试并继续循环。

这有几个优点：

+   它保证所有的代码*可以*被测试

+   当编写测试时没有实现时，更难编写与之相关的测试。

+   它保证所有的行为都被测试覆盖

+   它阻止编写多余的代码

TDD 有两个重要方面：

1.  先编写规范

1.  采取非常小的步骤

这些做法各自单独都是一个好主意，即使它们没有结合在一起。

如果我们先编写规范，但采取较大的步骤（可能是因为我们相信我们知道我们的实现应该是什么样的），我们将意识到我们的第一个优势 - 保证我们编写的代码可以测试。

这是什么意思？

如果代码没有考虑测试，那么很难为其编写符合我们对*单元*测试定义的测试。

我们可以通过遵循简单的规则使我们的代码更容易测试，例如：

+   始终注入依赖项

+   避免全局状态（单例，静态变量，ThreadLocals，注册表等）

但是，即使我们遵循这些规则，如果我们没有为此进行设计，我们仍然可能发现很难测试我们的代码。首先编写我们的规范需要我们的设计考虑测试。

尽管我们确保了我们的代码是可测试的，但由于我们采取了带有实现的大步骤，我们可能无法获得其他好处。

如果我们在没有先编写测试的情况下编写代码，我们可能会发现我们已经完成了，但我们的代码很难测试。然而，如果我们采用了第二种技术 - 采取小步骤，编写该代码的过程将更加容易。

如果我们在执行之前只编写了少量代码，并观察每个小的代码更改的结果，我们可能会花费更少的时间进行调试，更不太可能编写我们不需要的代码，并且总体上更快。

TDD 有很多优点，但它并不是魔法。

即使严格应用，也完全有可能编写糟糕的代码和规范。TDD 并不意味着你可以停止思考。

尽管如此，如果您对正在工作的技术和领域有很好的理解，如果您希望优化质量，TDD 通常是最好的方法。

如果您不太了解您的领域或技术，您可能会发现先编写规范很难。

这个问题的经典解决方案是首先通过制作一个临时的试验来获得理解。

### 尖峰

一个"尖峰"只是一些快速而粗糙的代码，用来探索你可能如何解决问题。在尖峰结束时，你会知道这种方法是否有效，或者是否值得寻找其他方法。

通过制作一个尖峰，你会更多地了解你正在处理的领域和技术。即使尖峰结束时的结论是这是一个糟糕的方法，尖峰仍然是有用的，因为它增加了你的理解。

一旦你从尖峰中学到了东西，就应该将其丢弃，并使用你所获得的知识进行最终的代码测试驱动。

### 尖峰和稳定

传统上，尖峰会被丢弃，因为它们本质上质量低下。丢弃尖峰是为了优化代码质量，以换取（可能）更慢的交付速度。

有时这并不是你想要的权衡。

另一种选择是尝试稳定尖峰，使其适用。如果你这样做，通常会得到比重新开始时质量较低的东西。

你最终会在项目的整个生命周期中花费更多的精力在这段代码上，而不是如果你将尖峰丢弃的话。

你为了这种质量损失和努力增加所获得的是更快的*首次*交付。有时这是值得做出的权衡，有时则不是。

# 考虑单位而不是方法

## 考虑单位，而不是方法

单元测试描述的每个行为通常应与整个*单位*相关，而不是个别方法的责任。

### 什么是一个单位？

为了以单位为单位思考，我们首先必须回答一个困难的问题，那就是*单位*到底是什么。

以方法为单位进行测试实际上等同于说一个*单位*就是一个方法。很容易说明为什么这并不总是有效。

如果我们试图为`java.util.Stack`的`push`方法编写一个单元测试，我们可能会得到类似以下的内容：

```
@Test
public void testPush() {
   Stack<String> testee = new Stack<String>();
   testee.push("foo");
   assertThat(testee.pop()).isEqualTo("foo");
}; 
```

现在让我们测试`pop`方法：

```
@Test
public void testPop() {
   Stack<String> testee = new Stack<String>();
   testee.push("foo");
   assertThat(testee.pop()).isEqualTo("foo");
}; 
```

哦。那看起来很熟悉。

我们遇到的问题是我们定义了一个太小的*单位*。我们试图描述的是只有在与同样大小的其他*单位*合作时才有用的东西的行为。

如果我们开始将`java.util.Stack`视为我们的*单位*，那么测试变得更容易编写：

```
@Test
public void shouldRetrieveValuesInOrderTheyAreAdded() {
  Stack<String> testee = new Stack<String>();
  testee.push("a");
  testee.push("b");
  assertThat(testee.pop()).isEqualTo("b");
  assertThat(testee.pop()).isEqualTo("a");
} 
```

我们编写了一个测试，描述的不是一个方法做什么，而是描述整个类的行为。

认为我们的工作是测试方法是新手单元测试开发人员常见的想法，而且不幸的是，一些提供模板为类的每个方法生成测试的 IDE 和工具进一步强化了这种想法。

正如我们所见，对于`Stack`来说，考虑整个类的行为更有意义。

### 类是单位吗？

通常将一个类视为一个*单位*是有道理的，所以这是一个很好的默认定义，但并不总是正确的粒度。

如果我们试图测试`java.util.Collections`类，我们会发现将`sort`、`reverse`、`singleton`等方法视为单独的*单元*是完全合理的。每个方法代表了一个独立的逻辑行为。

有时*单元*的大小就像方法一样小。

有时它们也比一个单一类更大。

如果我们继承了下面的代码而没有任何测试，我们可能会为它编写哪些测试呢？

```
public class ThingaMeBob {

  private final Iterable<MatchingBinaryOperator> actions;

  ThingaMeBob() {
    actions = Arrays.asList(new Addition(), new Subtraction());
  }

  public int process(String s, int a, int b) {
    for (MatchingBinaryOperator each : actions) {
      if (each.match(s)) {
        return each.apply(a,b);
      }
    }

    throw new RuntimeException();
  }

}

class Addition implements MatchingBinaryOperator {
  public boolean match(String s) {
    return "add".equals(s);
  }
  public int apply(int a, int b) {
    return a + b;
  }
}

class Subtraction implements MatchingBinaryOperator {
  public boolean match(String s) {
    return "minus".equals(s);
  }
  public int apply(int a, int b) {
    return a - b;
  }
} 
```

我们可能会为 Addition 和 Subtraction 类编写测试：

```
public class AdditionTest {

  Addition testee = new Addition();

  @Test
  public void shouldMatchWhenStringIsAdd() {
  }

  @Test
  public void shouldNotMatchWhenStringIsNotAdd() {
  }

  @Test
  public void shouldAddTwoNumbers() {
  }

  // etc

} 
```

而对于`ThingaMeBob`类：

```
public class ThingaMeBobTest {

  ThingaMeBob testee = new ThingaMeBob();

  @Test
  public void shouldAddTwoNumbers() {
  }

  @Test
  public void shouldSubtractTwoNumbers() {
  }

  // etc

} 
```

到了某个时候，我们希望质疑为什么这段代码如此过度设计，并考虑重构成更简单的形式。

```
public class ThingaMeBob {

  public int process(String s, int a, int b) {
    if ("add".equals(s)) {
      return a + b;
    }

    if ("minus".equals(s)) {
      return a - b;
    }

    throw new RuntimeException();
  }

} 
```

我们的测试会发生什么变化？

哪些是最有价值的呢？

当然，最有用的测试是通过`ThingaMeBob`的公共接口执行所有三个类的测试。我们根本不需要更改它。当它运行正常时，我们就知道我们的重构是成功的，一切仍然正常运行。

我们删除了`Addition`和`Subtraction`的测试。我们创建的更小单元只是实现细节。

让我们回溯一下，想象事情发生了不同的情况。

如果我们被要求从头开始测试所需的行为，我们会写什么呢？

我们很可能会编写类似于我们的第二个更简单版本的`ThingaMeBob`和类似于`ThingAMeBobTest`的测试。

如果我们被要求添加对其他 10 个操作的支持，我们可能会保持设计基本相同。

如果`ThingAMeBob`的行为需要更加动态，比如在运行时启用和禁用不同的操作，该怎么办呢？

那么将重构为类似于我们之前更复杂版本的东西就会有意义。

我们应该如何处理这些测试？

我们已经编写了以`ThingaMeBob`为基础的测试，描述了所有支持的行为。在将它们提取为类时，我们是否也应该完整描述`Addition`、`Subtraction`和其他 10 个操作的测试呢？

这里没有正确答案，但我希望很明显我们已经确定的最有用的*单元*是`ThingaMeBob`。这些较小的*单元*只是我们需要的功能的一个实现的一部分。

如果我们选择为每个提取出的类编写测试，这些测试将具有一定的价值。

以`ThingaMeBob`为基础编写的测试会很差地描述每个小提取单元的作用。如果一个测试失败了，不会立即明确出错的类。如果我们必须更改一个提取出来的类，不会立即明确要运行哪个测试。

因此，为每个提取出的类编写测试确实有价值。同时，如果我们不这样做，那也是一个合理的决定，它会减少重构的成本。

`ThingaMeBob`测试将是快速和可重复的，并且允许我们轻松地处理代码。如果我们只能在一个级别上进行测试，我们将选择`ThingaMeBob`级别。

因此，作为起点，假设一个*单元*将是一个类，但要认识到这并不是一个硬性规则。

*单元*实际上是一个“单一自包含的逻辑关注点” - 可能有几个类合作以捕获该关注点 - 只要该协作提供了一个单一定义明确的入口点。

使单元太小可能是一种过度规范化的形式。

使单元太大可能导致难以理解和维护成本高昂的测试。

作为一个经验法则，如果您可能合理地将一个或多个类作为不同类的内部类，那么它们可能应该被视为一个单一单元。

# 用规范风格命名测试用例

## 使用规范风格命名测试用例

使用每个测试案例的名称来描述单元测试中的一个（并且**只有一个**）行为。名称应该是一个命题 - 即一个可以是真或假的陈述。

方法名称应该以*应该*开头。

一旦您擅长编写测试名称，这就不再重要了，但是在混合团队中，这是有用的，因为它鼓励以正确的方式思考测试。

其余部分的名称应描述一种行为，可选地，还有一个情景（由单词 When 标识）。

例如，我们可能会开始描述`java.util.Stack`：

+   `创建时应该为空`

+   `应该返回最近添加的项首先`

+   `从空栈中移除项时应该抛出错误`

与一些代码库中发现的常见命名模式相对比：

+   `空栈`

+   `测试空栈`

+   `测试推送`

这些名称本身并没有告诉我们关于`Stack`应该如何行为的任何信息。

如果我们省略*应该*，我们可以创建更简洁的名称

+   `创建时为空`

+   `以添加顺序返回项`

+   `从空栈中移除项时抛出错误`

虽然更冗长的公式化*应该*形式具有优势 - 它提供了一个清晰的遵循模式。

如果开发人员知道测试名称必须以*应该*开头（通常是因为他们在现有测试中看到了这种模式），那么很难让他们返回到不同的风格并编写一个不是命题的测试。

*应该*的冗长通过强迫开发人员以正确的方式思考测试而得到回报。

Kevlin Henney 将*应该*比作自行车上的训练轮 - 一个在学习时帮助的设备。

那么我们什么时候应该摘掉训练轮呢？

这取决于团队的构成以及团队的变动频率。

如果可能在其生命周期内大多数可能参与代码库工作的人习惯于以这种风格编写测试，则增加的冗长不值得。如果有足够大比例的人不这样做，则最好让团队坚持惯例。

### 当规范风格不起作用时，请使用示例风格

有时，不可能遵循规范命名风格，因为描述变得太长和难以控制。如果您觉得您的方法名称变得过长，请问自己两个问题：

1.  我真的只测试了一件事吗？

1.  我的单元是否做得太多了？

如果您对两个问题的答案都很有信心是"否"，那么切换到另一种风格 - 示例风格。

在示例风格中，名称仅描述了"When"部分。它不描述预期行为，例如：

+   `emptyStack`

+   `oneItemAdded`

+   `removalFromEmptyStack`

要理解以示例风格命名的测试，您必须阅读测试中的代码。因此，应尽可能使用此规范样式。

### 在可能的情况下，尽量避免在测试描述中包含方法名称

在可能的情况下，避免在测试名称中包含方法名称。

在实际层面上，这避免了如果方法名称曾经重构过而需要更新测试名称的额外开销。

更微妙的是，包含名称可能会让您以错误的方式思考 - 验证方法实现而不是指定单元行为。

这不是一个硬性规则 - 有时很难或不可能描述有意义的行为而不涉及单元的接口。

领域语言可能与方法名称重叠，因此您可能会发现自己使用与方法名称相同的**单词**。

# 仔细选择示例

## 仔细选择示例

传统测试是通过示例进行的。

通过提供一系列示例输入和输出值或与其他组件的示例交互来解释组件或单元的整体行为。

我们的目标是使用示例来

+   传达一般预期行为

+   传达任何边缘情况下的行为

+   确保我们的代码在更改时仍然正确并保持正确

那么我们应该如何选择这些示例呢？

一种方法是查看要测试组件的可能输入。

如果我们为每个可能的输入提供预期输出，我们可以完全指定我们的代码。通常，这是不切实际的，因为可能的输入范围太大。相反，我们可以查找可能输入范围内的值类别（例如*有效*和*无效*）并从中选择一个示例。

然而，最好的方法通常不是考虑可能的输入和示例，而是首先考虑我们希望我们的代码表现出的行为。

一旦我们确定了行为，我们就可以选择演示它的示例。通常使用的实际值并不重要 - "使测试易于理解"讨论了一些技巧，使不重要的值在测试中不那么突出，并突出重要的值。

基于属性的测试将这一步骤推进了一步。

确定必须对所有输入或满足特定条件的可能输入的子集成立的属性。测试不包含任何示例值 - 只包含它们必须受到约束的描述。用于检查属性的示例是随机生成的，只有在检查失败时才会看到。

基于属性的测试有一些引人注目的优点：

+   测试描述了输入值的重要性。在示例测试中，这必须由读者推断。

+   测试将自动发现程序员所做的边界情况和错误假设

目前，在 Java 社区中对基于属性的测试的经验很少，因此如何最好地使用它仍然存在疑问。

一个明显的问题是它引入了随机性，尽管大多数框架提供了一些机制来控制它和重复测试运行。

## 遵循零、一和多的规则

如果你的组件涉及数字或事物的集合，请确保你使用足够的示例来描述它的行为。

一个很好的经验法则是，覆盖 0（或空）、1 和“多”可能是必要的。还将存在一些重要的边缘情况，例如，处理整数的算法代码可能需要考虑`Integer.MAX`和`Integer.MIN`。

零、一、多规则定义了你可以希望考虑的最小数量的情况。要正确描述代码的行为，可能需要更多的情况。

在测试驱动时，通常最容易从*零*测试案例开始。

### 一次只测试一件事

每个测试案例应该只指定一件事情。

在一个测试中有多个断言可能表明该测试正在测试多个事情。多个断言应该被视为可疑，但不一定是一个问题，例如

```
 @Test
  public void shouldReturnItemsInOrderTheyWereAdded() {
     ArrayDeque<String> testee = new ArrayDeque<String>();

     testee.add("foo");
     testee.add("bar");

     assertEquals("foo",testee.pop());
     assertEquals("bar",testee.pop());
  } 
```

这个测试只测试一个关注点，但使用多个断言来做到这一点。

### 只测试每个东西一次

一旦你测试了一个关注点，就不要让它泄漏到其他测试中 - 如果你这样做了，那么这些测试就不再只测试一件事情了。

这是一个特别容易犯的错误，特别是在基于交互的测试中。如果方法`anImportantSideEffect`的调用非常重要，那么很容易发现自己在每个测试案例中都验证该方法。

如果合同发生变化，以至于这个副作用不再重要，那么所有的测试都需要更新。

这个问题应该由一个单独的测试案例`shouldPerformImportantSideEffect`来解决。

虽然我们不应该让属性泄漏到它不属于的测试案例中，但这并不一定意味着它将被限制在单个测试案例中。可能需要多个示例来充分证明一个属性。

# 使测试易于理解

## 使测试易于理解

写测试的一个目标是记录受测试代码的影响。

我们部分地通过为每个测试案例选择清晰的规范风格名称来实现这一点，但我们还必须确保实现每个测试案例的代码易于理解。

下面讨论了一些有助于实现这一目标的技术。

### 明确测试结构

一个测试可以看作有三个部分：

+   给定 - 创建测试所需的值和对象

+   当 - 执行被测试的代码

+   然后 - 验证输出/行为是否符合预期

有时这些阶段也被一些特别喜欢字母'a'的人称为*arrange*、*act*和*assert*。

尽管这三个阶段的可见性很重要，但试图严格分开它们或用注释标记它们会给测试添加噪音。

**糟糕**

```
 @Test
  public void shouldRetrieveValuesInOrderTheyAreAdded() {

    // given
    Stack<String> testee = new Stack<String>();
    String expectedFirstValue = "a";
    String expectedSecondValue = "b";

    // when
    testee.push(expectedFirstValue);
    testee.push(expectedSecondValue);
    String actualFirstValue = testee.pop();
    String actualSecondValue = testee.pop();

    // then
    assertThat(actualFirstValue).isEqualTo(secondValue);
    assertThat(actualSecondValue).isEqualTo(firstValue);
  } 
```

**更好**

```
 @Test
  public void shouldRetrieveValuesInOrderTheyAreAdded() {
    Stack<String> testee = new Stack<String>();
    testee.push("a");
    testee.push("b");
    assertThat(testee.pop()).isEqualTo("b");
    assertThat(testee.pop()).isEqualTo("a");
  } 
```

### 遵循标准的 TEA 测试变量命名约定

建立简单的约定可以让测试的一些非常基本的内容清晰地呈现给读者。

如果你正在测试的单元是一个类，请通过在测试中始终将其命名为`testee`来明确表示。

如果需要将预期值存储在一个变量中，请将其命名为`expected`（但不要仅仅为了这个目的而将其存储在一个变量中）。

如果需要存储一个结果，以便与预期值进行比较，将其命名为`actual`（但不要仅仅为了这个目的而将其存储在一个变量中）。

如果你已经存根了一个参与者，请考虑将其命名为`stubbedFoo`，如果它充当模拟，请将其命名为`mockedFoo`。这个规则不像其他规则那么严格 - 根据具体情况决定它是否使你的测试更易读。

### 强调重要的内容，隐藏不重要的内容

应该能够一目了然地阅读每个测试用例 - 因此通过突出显示对该测试用例重要的内容并隐藏不重要的内容来使事情清晰。

如果输入的某个方面对测试用例很重要，请通过在测试用例中**明确**设置它来突出显示它 - 不要依赖于在通用设置方法中设置该值。

即使相同的值已经默认设置，最好还是在测试中重新提供它，以便清晰可见。

如果一个特定的值不重要，请通过使用众所周知的中性值（如字符串的`"foo"`）或使用清晰的名称（如`someInt`或`anInt`）来向读者指示这一点，这很重要。

通过方法调用提供值会使它们变得不那么显眼。

下面的测试中重要的是什么？

**糟糕**

```
 @Test
  public void shouldXXX() {
    MyClass testee = new MyClass();
    assertThat(testee.process(0, "", 3))
      .isEqualTo(Status.FAIL);
  } 
```

这个版本怎么样？

**更好**

```
 @Test
  public void shouldXXX() {
    int invalidValue = 3;
    MyClass testee = new MyClass();
    assertThat(testee.process(anInt(), aString(), invalidValue))
      .isEqualTo(Status.FAIL);
  } 
```

虽然我们需要额外的上下文来理解为什么`3`是一个无效值，但应清楚地表明`process`方法的前两个参数对我们正在指定的行为并不重要。

为什么下面的`testee`返回枚举`CONTINUE`很重要？

**糟糕**

```
 @Test
  public void shouldXXX() {
    assertThat(testee.process()).isEqualTo(CONTINUE);
  } 
```

如果我们浏览类的其余部分，我们可能会发现：

```
 @Before
  public void setup() {
     MyClass testee = new MyClass();
     testee.setDefaultProcessState(CONTINUE);
  } 
```

其他测试可能不需要关心默认状态是什么，但这个测试需要，所以我们应该写：

**更好**

```
 @Test
  public void shouldXXX() {
    testee.setDefaultProcessState(CONTINUE);
    assertThat(testee.process()).isEqualTo(CONTINUE);
  } 
```

随着我们开始处理更复杂的领域对象，将重要的值与构造有效对象所需但对我们的测试不是特别重要的值分开变得更加困难。幸运的是，我们可以使用构建器模式来减轻痛苦，减少重复，并保持测试的可读性。

### 有意义地命名值

如果一个值具有重要含义，请明确其含义，例如：

```
 Foo testee = new Foo(PERFORM_VALIDATION); 
```

而不是：

```
 Foo testee = new Foo(true); 
```

### 编写 DAMP 测试代码

正如我们所见，在突出显示一个值对于测试很重要的情况下，我们需要将其保留在使用它的测试方法中。这可能会引入重复，这在正常代码中我们可能不会接受，但测试代码有点不同。

复制粘贴编码在测试中和生产代码中都不好——代码越多，阅读起来就越困难，如果已经在整个测试中重复了，对一个问题的更改将导致霰弹手术。

测试代码中因此应该尽量避免重复。

但是，测试代码与生产代码是不同的。

测试代码必须讲述更多的故事——突出重要的内容，隐藏不重要的内容。测试代码不应该像生产代码一样 DRY（**D**on't **R**epeat **Y**ourself），它应该是 DAMP（包含**D**escriptive **A**nd **M**eaningful **P**hrases）。

如果将少量代码从测试方法中重构为共享方法会隐藏正在发生的事情，请接受重复，并将其保留在原位。如果不影响可读性，那么无情地进行重构。

## 选择正确的断言方法

当测试失败时，一个好的断言会告诉你哪里出了问题。

虽然 JUnit 允许您提供断言消息，但这会为测试添加噪音。像注释一样，这些消息应该保留在那些仅凭代码无法沟通的情况下。

不好的

```
assertTrue("Expected 2 but got " + actual, actual == 2); 
```

好的

```
assertEquals(2, actual); 
```

内置的断言功能相当有限。像 AssertJ 这样的替代断言库提供了更丰富的功能，并且导致了更可读的代码。

# 了解如何使用模拟对象和存根

## 了解如何使用模拟对象和存根

有两种类型的代码，它们需要两种不同类型的测试。

**工作代码**完成工作。我们可以使用**基于状态的测试**来测试工作代码——即断言预期的值是否从方法返回，或者对象是否处于预期状态。

基于状态的测试很容易识别，因为它会使用断言语句。

**管理器代码**通过协调其他人来完成工作。

管理器代码比工作代码更难测试，因为我们需要做出选择——我们是尝试从其输出中推断其行为，使用基于状态的测试，还是使用**基于交互的测试**？

在基于交互的测试中，我们检查对象是否以预期的方式交谈。为了做到这一点，我们需要以某种方式窃听对话。这通过使用模拟真实对象的对象来实现。

通常这些是使用模拟框架创建的。

### 模拟框架

虽然通常将模拟框架创建的所有对象称为模拟对象，但这是不准确的。

这些对象的更正确的通用术语是*测试替身*。

这些可以根据它们的行为方式进行细分：

+   哑对象——需要存在以满足类型签名，但实际上从未被使用

+   存根——必须存在并可能提供*间接输入*

+   模拟对象 - 验证期望的交互是否发生

+   伪造对象 - 像真实对象一样但更轻量化 - 例如内存数据库

+   间谍对象 - 记录其与其他对象的交互的对象

其中只有存根对象、模拟对象和间谍对象可能由模拟框架创建。

我们将在稍后讨论间谍对象，但大多数测试替身都可以在概念上被视为存根对象或模拟对象。

它们之间的重要区别在于，模拟对象有一个期望，如果没有满足就会导致测试失败。即，如果在模拟对象上没有调用预期的方法，测试将失败。

存根对象不关心自己是否被调用 - 其作用仅仅是提供值。

传统的模拟对象提出了一个代码可读性的困境。它们定义了一个预期的结果（*then*），但同时也是测试执行所需的固定部分（*given*）。

例如，使用 JMock 我们会这样写：

```
 Mockery context = new Mockery();

  // given / arrange
  Subscriber subscriber = context.mock(Subscriber.class);
  Publisher publisher = new Publisher();
  publisher.add(subscriber);

  final String message = "message";

  // then / assert . . . but we haven't had a when yet
  context.checking(new Expectations() {{
    oneOf (subscriber).receive(message);
  }});

  // when / act
  publisher.publish(message);

  // then / assert
  context.assertIsSatisfied(); 
```

间谍对象巧妙地解决了这个问题。

### 间谍对象

间谍对象记录与其他对象的交互。

在实践中，这意味着 Spy 默认情况下充当存根对象，但是当我们希望它们充当模拟对象时，它们会作为模拟对象。

given/when/then 的流程变得容易和自然地维护。

例如，使用 Mockito：

```
 // given
  Subscriber subscriber = Mockito.mock(Subscriber.class);
  Publisher publisher = new Publisher();
  publisher.add(subscriber);
  String message = "message";

  // when
  publisher.publish(message);

  // then
  Mockito.verify(subscriber).receive(message); 
```

因此，我们建议使用间谍对象框架。

当间谍对象充当模拟对象并且必须提供间接输入时，最好在提供值时尽可能宽容，在验证时尽可能具体。

这意味着什么呢？

让我们假设，由于某种原因，在我们的示例中，订阅者必须返回一个正整数才能使代码无错误地执行。也许代码中有某种断言语句：

```
public interface Subscriber {
  int receive(String message);
} 
```

我们可以确保我们的测试通过如下所示：

```
 String message = "amessage";
  Subscriber subscriber = Mockito.mock(Subscriber.class);
  // inject indirect value
  Mockito.when(subscriber.receive(message)).thenReturn(1);

  Publisher publisher = new Publisher();
  publisher.add(subscriber);

  publisher.publish(message);

  Mockito.verify(subscriber).receive(message); 
```

我们不会在这里详细讨论 Mockito API，但是这一行代码：

```
 Mockito.when(subscriber.receive(message)).thenReturn(1); 
```

确保当在间谍对象上调用 `receive` 方法时，传入的字符串与 `message` 变量相等时，它将返回 `1`。

如果不存在这行代码，间谍对象将按照 Mockito 默认的方式执行，即返回 `0`。

如果由于错误，`receive` 被调用时传入了不同的字符串，我们的测试会怎么样呢？

答案是，与其由于验证而失败：

```
 Mockito.verify(subscriber).receive(message); 
```

在达到此点之前，它将抛出一个错误，因为我们生产代码中的断言将触发。

我们过于具体了。

如果我们将我们的间谍对象设置如下

```
 Mockito.when(subscriber.receive(anyString())).thenReturn(1); 
```

测试将会干净地失败。

在提供值时宽容，但在验证时具体的这种模式也倾向于导致测试在事物变化时更不脆弱。

### 基于状态的测试中的存根对象

根据定义，基于状态的测试永远不会包括模拟对象（严格意义上的），但是它们可能使用存根对象来提供间接值。

有时使用模拟框架来存根值而不是使用它们的构造函数和修改器方法会很诱人。对于复杂对象，使用存根对象可能比构造真实对象更容易。

不要这样做。

模拟框架只应用于将我们的测试与具有行为的对象隔离开来。如果您有难以构建的值，请考虑使用测试数据生成器模式。

### 在状态和交互测试之间进行选择

有时我们没有选择。例如，仅通过输入和输出就无法有意义地指定缓存应如何行为。其他时候我们必须权衡利弊。

对于管理器代码的基于状态的测试可能不太容易阅读和理解，因为它必须依赖于 SUT 与之交互的对象的行为。测试还将与这些行为耦合，并且如果这些行为发生变化，则需要更改 - 实际上，您已经增加了您正在测试的“单元”的大小，如“思考单元而不是方法”中所讨论的那样。

基于交互的测试要求我们窥视单位的外部接口之外，并深入其实现。这带来的风险是我们可能会过度规定并创建一个特定于实现的测试。

总的来说，倾向于基于状态的测试并在可能的情况下在代码设计中启用它是可取的。然而，有许多情况下您会决定交互式测试更可取。

# 了解代码重用的选项

## 了解代码重用的选项

重用代码是件好事。

当人们第一次开始使用面向对象的编程语言时，他们往往会过度使用继承来达到这个目的，直到发现组合通常是一个更好的主意为止。

不幸的是，在 JUnit 测试中使用组合重用代码并不容易，这可能会导致编写难以维护的测试类层次结构。

少量重复可能比在没有其他选择时引入类层次结构更可取，但某些类型的测试可以在没有继承的情况下重用。

### 断言

与断言相关的代码在类层次结构之外重用是很简单的。这可以通过创建包含静态断言方法的类来轻松实现（就像现在内置的 JUnit 断言一样），或者更优雅地通过为 hamcrest 或 AssertJ 创建自定义匹配器来实现。

### 对象创建

对于小而简单的对象，可以使用 mother 模式，但如果对象随着时间变得更复杂，这可能很快成为一个维护问题。

更好的模式是建造者模式，这样可以额外提供优势，使测试能够清晰地突出重要和不重要的输入。

### 重复行为

如果你正在使用 JUnit，那么测试中重复的代码段可以被打包并重复使用为[自定义规则](https://github.com/junit-team/junit/wiki/Rules)。

# 编写可重复的测试

## 编写可重复的单元测试

单元测试必须是可重复和确定性的 - 必须能够以任何顺序运行数千次并得到相同的结果。这意味着它们不能依赖于任何外部因素。

实际上，这意味着单元测试不能：

+   从数据库中读取或写入

+   执行网络 IO

+   写入磁盘

+   修改静态状态

如果您的测试执行了这些操作之一，那么它就不是一个**单元**测试。这并不是说您的测试没有价值。

# 只有对单元测试代码进行单元测试才有意义

## 只有对单元测试代码进行单元测试才有意义

在大多数情况下，对单元测试的价值不大：

+   自动生成的代码

+   记录

+   **唯一**关注的代码是与另一个系统集成。

具有纯集成关注的典型示例是 DAO。

如果有一个兼容的内存中的虚拟数据库可用，那么可以对其进行有意义的单元测试。如果没有虚拟数据库可用，则没有编写模拟 JDBC 驱动器的测试的价值-第一级测试应该是与真实数据库进行集成测试。

对于非常简单的样板代码（如 get/set 方法）明确指定行为也没有太大价值。在没有测试的情况下，预期的行为是清晰的，而其实际行为应该由使用代码的其他测试验证，同时测试更复杂的逻辑。如果代码覆盖率表明这些方法尚未被其他测试执行，也许您可以删除它们？

没有进行单元测试的代码应始终进行集成测试。

# 测试常见问题解答

## 测试常见问题解答

### 如何测试一个私有方法？

您不测试方法（私有或公共），您测试单元作为整体的行为。

如果您无法通过公共接口执行私有方法的逻辑，则该逻辑是否真的需要？如果它是必需的，并且足够复杂，以至于它给您带来测试上的困扰，那么也许您应该将该关注点提取到一个单独的单元中，该单元可以被隔离测试并通过构造函数注入？

### 如何测试一个空方法？

您不测试方法（void 或不是），您测试单元作为整体的行为。

如果方法是 void，则必须执行某种可以通过状态测试或交互测试进行检查的副作用。

例如，如果您正在尝试“测试集合类的添加方法”，那么您应该考虑编写类似的测试：

```
@Test
public void shouldIncreaseInSizeWhenItemsAdded() {
    Collection testee = new ArrayList();
    assertEquals(0, testee.size());
    testee.add("itemA");
    assertEquals(1, testee.size());
    testee.add("itemB");
    assertEquals(2, testee.size());
} 
```

### 如何测试涉及当前日期/时间的代码？

使用静态方法（例如 joda 时间的`setCurrentMillisFixed`）设置当前日期是一个不好的解决方案。

一个好的解决方案是将检索日期/时间的策略作为依赖项注入到您的类中。

Java 8 提供了`java.time.Clock`类，可用于此目的。

静态工厂方法`fixed`将创建一个代表常量时间的实例。其他方法提供了适合生产使用的实现。

Java 7 没有提供用于此目的的开箱即用类，因此您需要自己编写。

### 我的测试需要实现一个拆卸方法吗？

这曾经是所有 JUnit 3 测试的要求。如果您在拆卸中未将测试类的所有成员置空，则您的测试套件将在增长时开始占用内存。

这对于普通的 JUnit 4 测试不是必需的，但如果您使用自定义运行器，则可能需要这样做。

### 错误和失败之间有什么区别？

当代码在逻辑上错误时，您应该尝试设计您的测试以产生**失败**。只有在发生意外情况时，您的测试才应该产生错误。

### 我应该如何测试预期的异常？

这取决于。

内置：

```
@Test(expected = FooException.class)
public void shouldThrowFooExceptionWhenFeelsLikeIt 
```

对于简单的场景来说，这是简洁且足够的，但有一个陷阱。如果测试方法调用了测试对象的多个方法，期望将适用于整个测试方法，而不是期望与测试对象的特定交互。

如果异常中保存的数据很重要，使用这种方法也无法对其进行断言。

传统的解决方案是使用 try catch 块：

```
@Test
public void shouldThrowFooExceptionWhenFeelsLikeIt() {
  try {
    testee.doStuff();
    fail("Expected an exception");
  } catch (FooException expectedException) {
    assertThat(expectedException.getMessage(), is("felt like it"));
  }
} 
```

这很容易理解，但有点冗长。如果您不是测试驱动您的代码，很容易忘记包含对`fail()`的调用。

JUnit 现在提供了一种替代解决方案，即“ExpectedException”方法规则。这允许进行更精细的异常检查：

```
@Rule
public ExpectedException thrown= ExpectedException.none();

@Test
public void foo() throws IOException {
  thrown.expect(FooException.class);
  thrown.expectMessage("felt like it");

  testee.doStuff();
} 
```

这更加简洁，但打破了测试的通常给定/当/然后流程，将然后部分移到方法的开头。

对于 Java 8，AssertJ 提供了一些自定义断言，可以在不中断此流程的情况下使用。

```
@Test
public void testException() {
  assertThatThrownBy(() -> { testee.doStuff(); })
   .isInstanceOf(Exception.class)
   .hasMessageContaining("felt like it");
} 
```

虽然它保持了流程，但测试对象被调用的 lambda 看起来有点丑陋。

当可以使用时，我们建议坚持简洁的`expected =`格式。对于更复杂的情况，这在很大程度上是一种品味问题。

### 我如何测试抽象类？

抽象类只是其他代码将使用的一个依赖项 - 由于您选择将其设置为抽象类，使得它比通常更难隔离。

首先，如果功能通过组合而不是继承被重用，您的设计会更好吗？

假设您不能通过摆脱抽象类来改进设计，您可以选择：

+   将其视为实现细节，并检查其每个客户端的行为是否符合预期。

+   通过创建一个匿名具体类来隔离地测试它

第一种方法将导致与实现不太相关的测试，但在每个子类的测试之间会有重复。

第二种方法将避免重复，但与实现绑定，可能会很脆弱。

### 我如何测试 Hashcode 和 Equals？

测试哈希码和等式可能会很棘手和耗时，这引发了一个问题，即考虑到代码可能已经是自动生成的，这是否值得花费时间。

Equals 验证器项目提供了一个很好的（部分）解决方案：

[`www.jqno.nl/equalsverifier/`](http://www.jqno.nl/equalsverifier/)

它通过一行测试检查一个类是否满足哈希码-等式合同，这是很容易编写的：

```
 @Test
  public void shouldObeyHashCodeEqualsContract() {
    EqualsVerifier.forClass(MyValue.class).verify();
  } 
```

然而，它确实非常彻底地检查了合同 - 包括它与继承的交互方式。让一个非 final 类符合合同是非平凡的。

尽管 equals verifier 在检查哈希码相等合同方面做得很好，但它不知道你希望方法实际上如何行为。如果你希望相等性（例如）仅由单个 ID 字段定义，你必须编写额外的测试来验证这种行为。

对于一个类在所有字段都应被视为相等的常见情况，可以在单个测试中检查其行为：

```
 @Test
  public void shouldObeyHashCodeEqualsContract() {
    EqualsVerifier.forClass(MyValue.class).allFieldsShouldBeUsed().verify();
  } 
```

这可能会成为 EqualsVerifier 未来版本的默认行为，但必须在 1.7.5 中明确指定。

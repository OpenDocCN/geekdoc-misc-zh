# 17 替代应用语义

很久以前[REF]，我们考虑了在执行应用程序时要替换什么的问题。现在我们准备考虑一些替代方案。当时，我们只提出了一个替代方案；实际上有更多选择。要理解这一点，请看看你是否能回答这个问题：

这两者哪一个是相同的？

> +   (f x (current-seconds))
> +   
> +   (f x (current-seconds))
> +   
> +   (f x (current-seconds))
> +   
> +   (f x (current-seconds))

我们即将发现的是，这个语法片段在运行时行为可能大不相同。例如，我们已经提到的区别是：(current-seconds)何时被求值。它被求值的次数有所不同（因此 f 被运行的次数也不同）。甚至在值是否严格从调用者流向被调用者，或者甚至可以反向流动的情况下，也存在差异！

## 17.1 惰性应用

让我们首先考虑参数何时被简化为值。也就是说，我们是用实际参数的值替换形式参数，还是用实际参数表达式本身替换形式参数？如果我们定义

> | (define sq x) (* x x)) |
> | --- |

并将其作为

> | (sq (+ 2 3)) |
> | --- |

是否简化为

> | (* 5 5) |
> | --- |

还是简化为

> | (* (+ 2 3) (+ 2 3)) |
> | --- |

前者称为急切应用，而后者称为惰性应用。有些人还使用严格一词来表示前者。更深奥的术语是应用顺序评估用于前者，正常顺序评估用于后者。或者，前者称为按值调用，后者称为按名字调用或按需调用。最后两个术语——按名字与按需——实际上代表了我们将在下面看到的技术区别。这结束了我们的术语介绍。当然，我们不想回到通过替换来定义解释器的时代，但将替换视为一种设计原则总是有用的。

### 17.1.1 惰性应用示例

惰性的替代方案有着悠久的历史（例如，这是真正的λ-演算使用的方法），但从考虑某些运算符在应用时不求值而只在需要值时才求值的编程实验中重新回到人们的视野。例如，考虑以下定义

> | (define ones (cons 1 ones)) |
> | --- |

在普通的 Racket 中，这显然是不明确的：当我们尝试评估它时（在右侧），ones 还没有被定义（在左侧），因此会导致错误。然而，如果我们直到实际需要它时才尝试评估它，那时定义就是完整的。因为每个 rest 都获得另一个 ones，这将产生一个无限列表。

我们忽略了很多需要解释的内容。cons 中的 rest 位置的 ones 是对该表达式的副本求值，还是对该表达式本身的结果求值？换句话说，我们是创建了一个无限展开的列表，还是创建了一个实际上是循环的列表？

这在很大程度上取决于我们的语言是否具有变异。如果有的话，那么也许我们可以修改结果列表中的每个单元格，这意味着我们可以观察上述两种实现之间的差异：在展开版本中，先改变一个不会影响另一个，但在循环版本中，改变一个将影响它们全部。因此，在具有变异的语言中，我们可能会认为这应该代表一种惰性展开，而不是实际的循环数据。

牢记这个讨论。我们现在无法解决它；相反，让我们更深入地研究一下惰性求值，然后再回到这个问题[REF]。

### 17.1.2 值是什么？

如果我们回到我们的核心高阶函数解释器[REF]，我们会想起我们有两种值：数字和闭包。如果我们想支持惰性求值，我们需要问的是在函数应用时会发生什么。我们究竟传递了什么？

这似乎很明显：在懒惰的应用语义中，我们需要传递表达式。但稍加思考就会发现这可能会有问题。表达式包含标识符名称，而现在这些确实将是标识符，而不是变量，正如我们将看到的[REF]，我们不希望它们被意外绑定。

例如，假设我们有

> | (define (f x) |
> | --- |
> |   (lambda (y) |
> |     (+ x y))) |

并按如下方式应用它：

> | ((f 3) (+ x 4)) |
> | --- |

立即行动！

> 这应该产生什么结果？

显然，我们应该得到一个报告 x 未绑定的错误。

现在让我们追踪它。第一次应用创建一个闭包，其中 x 绑定为 3。如果我们现在将 y 绑定为(+ x 4)，这将导致在 x 被绑定的环境中表达式(+ x (+ x 4))。结果我们得到答案 10，而不是错误。

立即行动！

> 我们在上面做了一个微妙的假设吗？

是的，我们假设+评估参数并返回数字答案。也许+也会懒惰行事；我们将在一会儿研究这个问题。然而，中心问题仍然存在：如果我们不小心，这个错误的表达式将产生某种有效的答案，而不是错误。

如果你认为这完全是一个错误程序的问题，因此可以特殊处理（例如，首先扫描程序源代码以查找自由标识符），这里是相同 f 的另一个用法：

> | (let ([x 5]) |
> | --- |
> |   ((f 3) x)) |

立即行动！

> 这应该产生什么结果？

我们期望这将产生(+ 3 5)的结果（可能是 8）。然而，如果我们在算术表达式中替换 x，我们将得到(+ 3 3)。

后一个例子揭示了我们解决问题的关键。在后一个例子中，问题显然只在我们使用环境时才会出现；如果我们使用替换，那么在我们遇到 let 时，应用中的 x 就会被替换，结果就是我们所期望的。实际上，请注意，相同的论点在早期也成立：如果我们使用替换，x 的出现将会引发错误。简而言之，我们必须确保我们基于环境的实现与替换的行为相匹配。这听起来很熟悉！

换句话说，解决方案是将参数表达式与其环境捆绑在一起：即创建一个闭包。这个闭包没有参数，因此实际上是一个惰性求值。事实上，这表明函数有两个用途：用值替换名称，以及延迟替换。let 是前者而没有后者；惰性求值是后者而没有前者。我们已经确定前者本身就很有价值；本节显示后者也是如此。我们可以使用现有函数来表示这些惰性求值，但我们的直觉应该告诉我们最好使用不同的数据表示来实现逻辑上的不同目的：用户创建的闭包使用 closV，内部创建的使用其他东西。事实上，正如我们将看到的，将它们分开是明智的，因为有一个地方我们必须能够区分它们。

总结讨论，这是我们的新价值观：

> | (定义类型 Value |
> | --- |
> |   [numV (n : number)] |
> |   [closV (arg : symbol) (body : ExprC) (env : Env)] |
> |   [suspendV (body : ExprC) (env : Env)]) |

前两个变体完全相同；第三个是新的，正如我们讨论的那样，实际上是一个无参数的过程，正如其类型所示。

### 17.1.3 什么导致求值？

现在让我们回到讨论算术表达式。在计算 (+ 1 2) 时，一个惰性应用解释器可以返回任意数量的东西，包括 (suspendV (+ 1 2) mt-env)。在这里写 mt-env 是合法的，因为即使 (+ 1 2) 表达式在非空环境中编写，它也没有自由标识符，因此不需要环境的任何绑定。这样，暂停的计算可以级联进行，极端情况下，每个程序都会立即返回一个“答案”：代表其计算暂停的惰性求值。

显然，必须有某种力量来解除暂停。 （解除暂停意味着当然，在存储的环境中评估其主体。）撤消暂停的表达位置称为严格点。最明显的严格点是交互式环境的打印机，因为用户显然不会使用这样的环境，如果他们不希望看到答案。我们将在过程 strict 中体现解除暂停的行为：

> | (定义 (strict [v : Value]) : Value |
> | --- |
> |   (type-case Value v |
> |     [numV (n) v] |
> |     [closV (a b e) v] |
> |     [suspendV (b e) (strict (interp b e))])) |

其中返回的值保证不是一个 suspendV。我们可以想象打印机将严格包裹在评估程序结果周围，以获得要打印的值。现在做！

> 使用闭包来表示暂停的计算会产生什么影响？

上面的 strict 定义关键取决于能够区分延迟计算（内部构造的闭包）和用户定义的闭包。如果我们混淆了两者，那么我们将不得不猜测如何处理零参数闭包。如果我们未能进一步处理它们，我们可能会错误地得到一个错误（例如，+可能会得到一个惰性计算而不是其中包含的数值）。如果我们进一步处理它，我们可能会意外地过早强制用户定义的惰性计算。简而言之，我们需要一个标志来告诉我们惰性计算是内部的还是用户定义的。为了清晰起见，我们的解释器使用了一个单独的变体。

现在让我们回到严格和解释器之间的交互。不幸的是，正如我们所定义的那样，这将导致一个无限循环。尝试解释加法的行为会创建一个悬挂，而 strict 试图通过强制解释器解释加法来撤消这个悬挂，然后... 因此，显然，我们不能让每个表达式都简单地暂停其计算；相反，我们将限制暂停到应用程序中。这足以给我们提供懒惰的丰富功能，而不使语言变得荒谬。

### 17.1.4 一个解释器

和往常一样，我们将按照情况定义解释器。

<懒惰的 interp>)) ::=

> | (define (interp [expr : ExprC] [env : Env]) : Value |
> | --- |
> |   (type-case ExprC expr |
> |     <懒惰的 numC-case>)) |
> |     <懒惰的 idC-case>)) |
> |     <懒惰的 plusC/multC-case>)) |
> |     <懒惰的 appC-case>)) |
> |     <懒惰的 lamC-case>)))) |

数字很容易：它们已经是值，所以没有必要无谓地悬挂它们：

<懒惰的 numC-case>)) ::=

> [numC (n) (numV n)]

闭包同样保持不变：

<懒惰的 lamC-case>)) ::=

> [lamC (a b) (closV a b env)]

标识符应该返回它们绑定的内容：

<懒惰的 idC-case>)) ::=

> [idC (n) (lookup n env)]

算术表达式的参数通常被定义为严格性点，否则我们将不得不在其他地方实现实际的算术：

<懒惰的 plusC/multC-case>)) ::=

> | [plusC (l r) (num+ (strict (interp l env)) |
> | --- |
> |                    (strict (interp r env)))] |
> | [multC (l r) (num* (strict (interp l env)) |
> |                    (strict (interp r env)))] |

最后，我们有应用。在这里，我们不评估参数位置，而是将其暂停。然而，函数位置必须是一个严格点，否则我们将不知道应用哪个函数，因此也不知道如何继续计算：

<懒惰应用 C-case>)) ::=

> | [appC (f a) (local ([define f-value (strict (interp f env))]) |
> | --- |
> |               (interp (closV-body f-value) |
> |                         (extend-env (bind (closV-arg f-value) |
> |                                           (suspendV a env)) |
> |                                     (closV-env f-value))))] |

就是这样！通过添加一种新的答案类型，插入一些对 strict 的调用，并在应用的参数位置用 suspendV 替换 interp，我们将我们的急切应用解释器转变为具有惰性应用的解释器。然而，这种小改变对我们编写的程序产生了如此巨大的影响！要更彻底地研究这种影响，请研究 Haskell 或 Racket 中的#lang lazy 语言。

练习

> 如果我们用(strict(lookup n env))替换标识符情况（即，在查找标识符的结果周围加上 strict），这对语言会有什么影响？考虑具有数据结构等更丰富的语言。

练习

> 构建产生在惰性评估和急切评估中产生不同结果的程序（即，在两种情况下具有不同答案的相同程序文本）。尝试使差异有趣，即，超出一个返回 suspendV 而另一个不返回的范围。例如，一个是否终止或产生错误，而另一个不会？

练习

> 为两个解释器添加仪器，以计算它们返回答案所需的步骤数。对于在两种评估策略下产生相同答案的程序，是否有一种策略总是比另一种策略需要更多步骤？

### 17.1.5 惰性和变异

惰性评估的优点之一是它推迟执行。通常这是一件好事：它使我们能够构建无限的数据结构，并避免在必要时进行计算。不幸的是，它也改变了计算发生的时间，特别是改变了计算相对于彼此的顺序，具体取决于遇到的严格点。结果，程序员在排序方面失去了很大的可预测性。当表达式执行变异操作时，这当然是一个问题，因为现在非常难以预测程序将计算出什么值（相对于急切版本）。

因此，每个惰性语言的核心都不包含突变。在 Haskell 中，突变和其他状态操作是通过各种机制引入的，例如单子和箭头，最终引入了顺序化代码的能力；这种顺序性对于能够预测执行顺序和因此操作结果至关重要。如果程序结构良好，则这些依赖关系的数量应该很小；此外，Haskell 类型系统试图在类型本身中反映这些操作，因此程序员可以更容易地了解它们的影响。

### 17.1.6 计算缓存

现在我们已经得出了惰性计算不能有突变的结论，我们观察到一个愉快的结果（我们敢说，副作用？）：在固定环境中，表达式总是产生相同的答案。因此，运行时系统可以在首次通过严格性迫使其返回答案时缓存表达式的值，并在后续尝试计算它时返回此缓存的值。当然，这种缓存——<wbr>这是一种记忆化的形式——<wbr>仅在表达式每次返回相同值时才是有效的，这是我们假设的。事实上，编译器和运行时系统可以积极地搜索程序的不同部分中对相同表达式的使用，并且，如果它们的环境的相关部分相同，则合并它们的评估。在需要时每次评估挂起的计算的策略称为名字调用；缓存其结果的策略称为需求调用。

## 17.2 反应性应用

现在考虑一个表达式，如 (当前秒数)。当我们评估它时，它返回一个表示当前时间的单个数字。例如，

| > (当前秒数) |
| --- |
| 1353030630 |

然而，即使我们凝视着这个值，它已经过时了！它代表了函数应用发生的时间，但不会保持最新。

### 17.2.1 激励示例：计时器

假设我们正在尝试实现一个测量经过时间的计时器。理想情况下，我们希望写出这样的程序：

> | (让 ([开始 (当前秒数)]) |
> | --- |
> |   (- (当前秒数) |
> |      开始)) |

在 JavaScript 中，我们可能会这样写：

| d = new Date(); |
| --- |
| 开始 = d.getTime(); |
| 当前 = d.getTime(); |
| 经过时间 = 当前 - 开始; |

在大多数机器上，这个 Racket 表达式，或者 JavaScript 中的 elapsed 的值，将会评估为 0 或者其他非常小的数字。这是因为这些程序代表了经过的时间的一种度量：在获取当前时间的过程的第二次调用时。这给了我们一个瞬时的时间分割，但不是一个实际的计时器。在大多数语言中，要构建一个实际的计时器，我们需要创建某种计时器对象的实例，并安装一个回调。每当时钟滴答作响时，代表操作系统的计时器对象会调用回调。然后回调负责更新系统中的值，并希望全局和一致地这样做。然而，它不能通过返回值来实现，因为它会返回给操作系统，而操作系统对我们的应用程序是无知的，也不关心；因此，回调被迫通过突变来执行其操作。例如，在 JavaScript 中：

| var timerID = null; |
| --- |
| var elapsedTime = 0; |
|  |
| function doEverySecond() { |
|   elapsedTime += 1; |
|   document.getElementById('curTime').innerHTML = elapsedTime; } |
| function startTimer() { |
|   timerId = setInterval(doEverySecond, 1000); } |

假设我们有一个带有 id 为 curTime 的 HTML 页面，并且 onload 或其他回调调用 startTimer。对于这种意大利面条代码的另一种选择是，应用程序程序反复轮询操作系统以获取当前时间。然而：

+   过于频繁地调用会浪费资源，而调用不够频繁会导致错误答案。然而，要以恰到好处的分辨率调用，我们首先需要一个计时器信号！

+   虽然可能可以为定期事件（如计时器）创建这样的轮询循环，但对于无法准确预测的行为（如用户输入，通常无法预测其频率），这是不可能的。

+   除此之外，编写这个循环会污染程序的结构，并迫使开发人员承担这种额外负担。

然而，基于回调的解决方案展示了一种控制的倒置。而不是应用程序调用操作系统，现在操作系统被委托调用（进入）应用程序。应该深度嵌套在显示表达式内部的反应性行为，现在被带到了顶层，并且它的值驱动其他计算。这一根本原因是世界在控制，而不是程序，因此外部刺激决定了程序何时以及如何运行，而不是内在程序表达式。

### 17.2.2 回调类型是四个字母的单词

这种模式的特征签名（可以这么说）体现在类型中。因为操作系统对程序的值是不可知的，回调通常根本没有返回类型，或者是一个通用的状态指示器，而不是特定于应用程序的值。因此，在类型化的语言中，类型通常是一些四个字母的单词。例如，这里是 Java 中 GUI 库的一个片段：

| interface ChangeListener extends EventListener { |
| --- |
|   void stateChanged(ChangeEvent e) { ... } } |
|  |
| interface ActionListener extends EventListener { |
|   void actionPerformed(ActionEvent e) { ... } } |
|  |
| interface MouseListener extends EventListener { |
|   void mouseClicked(MouseEvent e) { ... } |
|   void mouseEntered(MouseEvent e) { ... } } |

这里还有一个 OCaml 的例子：

| mainLoop : unit -> unit |
| --- |
| closeTk : unit -> unit |
|  |
| destroy : 'a Widget.widget -> unit |
| update : unit -> unit |
|  |
| pack : ... -> 'd Widget.widget list -> unit |
| grid : ... -> 'b Widget.widget list -> unit |

在 Haskell 中，这四个字母中间有一个额外的空格：

| select :: Selecting w => Event w (IO ()) |
| --- |
| mouse :: Reactive w => Event w (EventMouse -> IO ()) |
| keyboard :: Reactive w => Event w (EventKey -> IO ()) |
| resize :: Reactive w => Event w (IO ()) |
| focus :: Reactive w => Event w (Bool -> IO ()) |
| activate :: Reactive w => Event w (Bool -> IO ()) |

诸如此类。在所有这些情况下，“void”-like 类型的存在清楚地表明这些函数不返回任何有趣的值，因此它们的唯一目的必须是改变存储或产生其他副作用。这也意味着没有丰富的组合手段���比如表达式的嵌套，是不可能的：void 类型语句的唯一组合运算符是序列化。因此，类型表明我们将被迫无法编写嵌套表达式。

读者当然会对这个问题很熟悉，因为我们之前讨论过 Web 编程时提到过这个问题。这个问题在服务器端由于无状态性 [REF] 而出现，在客户端由于单线程 [REF] 而出现。在服务器端，至少我们能够使用延续来解决这个问题。然而，并非所有语言都支持延续，并且实现它们可能很繁琐。此外，设置恰当的延续作为回调可能会有些棘手。因此，我们将探索另一种解决方案。

### 17.2.3 另一种选择：响应式语言

考虑在 DrRacket 中的 FrTime（发音为“Father Time”）语言。在 DrRacket v5.3 中，您必须从语言菜单中选择语言；写 #lang frtime 不会提供有趣的交互窗口行为。如果我们在交互窗口中运行这个表达式，我们仍然会得到 0 或其他非常小的非负数：

> | (let ([start (current-seconds)]) |
> | --- |
> |   (- (current-seconds) |
> |      start)) |

实际上，我们可以尝试几个其他表达式，发现 FrTime 看起来与传统的 Racket 完全一样。

然而，它还绑定了一些额外的标识符。例如，它提供了一个绑定到秒的值。如果我们在交互提示符中键入这个值，我们会得到非常有趣的东西！首先，我们看到了 1353030630，然后一秒钟后是 1353030631，再一秒后是 1353030632，依此类推。这种值被称为行为：随时间变化的值。除了我们没有写任何回调或其他代码来保持它的当前性。

行为可以用于计算。例如，我们可以写成（- seconds seconds），这总是评估为 0。这里有一些更多的表达式可以在交互提示符下尝试：

> | （加 1 秒） |
> | --- |
> | （取余秒 10） |
> | （build-list（取余秒 10）身份） |
> | （build-list（加 1（取余秒 10））身份） |

如你所见，作为行为是“粘性”的：如果任何子表达式是一个行为，那么它的封闭表达式也是一个行为。

由于这种评估模型，每当秒更新时，整个应用程序都会重新运行：因此，即使我们写了看似简单的表达式，没有任何显式的类似循环的控制，程序仍然会“循环”。换句话说，虽然我们已经探索了一种参数被评估一次的应用程序语义，然后又探索了另一种参数可能被评估零次的语义，现在我们有了一种它们被评估多次直到必要时的语义，以及整个相应的函数。因此，内部的反应性值不再被带到外部；相反，它们可以嵌套在表达式中，给程序员提供了更自然的表达方式。这种评估风格称为数据流或函数式反应性编程。历史上，数据流倾向于指具有一阶函数的语言，而函数式反应性语言也支持高阶函数。

FrTime 实现了我们所说的透明反应性，程序员可以在程序的任何地方注入一个反应性行为，而不需要对其上下文进行任何语法上的更改。这样做的好处是可以很容易地将反应性注入到现有程序中，但对程序员来说，这可能会使评估和成本模型变得更加复杂。在其他语言中，程序员可以通过适当的原语显式地引入行为，从而换取方便以获得更大的可预测性。FrTime 的姊妹语言 Flapjax 是 JavaScript 的扩展，提供了这两种模式。请参阅[Flapjax 网站](http://www.flapjax-lang.org/)。  

### 实现透明反应性

要使现有的语言实现透明的反应性，我们必须（自然地）改变函数应用的语义。我们将分两步完成这个过程。首先，我们将把反应函数应用重写成一个更复杂的形式，然后我们将展示这个更复杂的形式如何启用反应性更新。

### 数据流图构造

通过解释 desugaring 简单说明应用程序变得响应的本质。假设我们已经定义了一个新的构造函数 behavior。构造函数接受一个 thunk，表示每次参数更新时要执行的计算，以及表达式依赖的所有值。它产生的值存储了行为的当前值。然后，像 (f x y) 这样的表达式变成

> | (if (or (behavior? x) (behavior? y)) |
> | --- |
> |     (behavior (λ () (f (current-value x) (current-value y))) x y) |
> |     (f x y)) |

在这里我们假设，给定一个非行为常量，current-value 表现为恒等函数。让我们看两个使用上述定义的例子。考虑一个既不是行为的参数的微不足道的情况，例如，(+ 3 4)。这样展开为

> | (if (or (behavior? 3) (behavior? 4)) |
> | --- |
> |     (behavior (λ () (+ (current-value 3) (current-value 4))) 3 4) |
> |     (+ 3 4)) |

由于 3 和 4 都是数字，而不是行为，这就简化为(+ 3 4)，这正是我们想要的。这反映了一个重要原则：当没有行为存在时，程序的行为与语言的非反应版本完全相同。如果我们计算(+ 1 seconds)，这将扩展为

> | (if (or (behavior? 1) (behavior? seconds)) |
> | --- |
> |     (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds) |
> |     (+ 1 seconds)) |

由于秒是一种行为，这就简化为

> | (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds) |
> | --- |

任何依赖于此的表达式现在也看到其参数成为一种行为，使得我们之前论述的“粘性”属性成为现实。练习

> 上述的展开是否依赖于急切求值？

### 17.2.4.2 数据流图更新

当然，仅仅构造行为值是不够的。关键的附加信息在于行为的额外参数。语言过滤掉那些本身是行为的参数（例如，上面的 seconds）并将这个新行为注册为依赖于那些现有行为的行为之一。这个注册过程创建了一个行为表达式依赖图，称为数据流图（因为它反映了数据需要流动的路径）。

如果程序没有求值为任何行为，则评估简单地产生一个答案，并且不创建图形。然而，如果存在行为依赖关系，则评估不会产生传统的答案，而是一个行为值，其中已经记录了依赖关系。 （实际上，还有必要跟踪哪些原始行为实际上是必要的，以避免不必要地评估程序中没有其他行为引用的原始行为。）简而言之，程序执行生成数据流图。因此，我们不需要为语言编写特殊的新评估器；相反，我们将图构造语义嵌入到传统的评估中。

现在，一个数据流传播算法开始执行。每当一个原始行为发生变化时，算法应用其存储的 thunk，获取其新值，存储它，然后通知每个依赖于它的行为。例如，如果秒更新，它会通知（+ 1 秒）表达式的行为。后者现在评估其 thunk，（λ（）（+（current-value 1）（current-value 秒）））。这将 1 添加到秒的最新值中，使其成为这个行为的新值—<wbr>正如我们所期望的那样。

### 17.2.4.3 评估顺序

上面的讨论呈现了对图更新的过于简单的观点。考虑以下程序：

> | （>（add1 秒） |
> | --- |
> |    秒） |

这个程序有一个原始行为，秒，还构造了两个更多：一个用于（add1 秒），另一个用于整个表达式。

我们期望这个表达式总是成立。然而，当秒更新时，取决于处理更新的顺序，它可能在更新整个表达式之前更新（add1 秒）。假设秒的旧值为 100，所以新值为 101。然而，（add1 秒）的节点仍然存储着它的旧值（因为它还没有被更新），所以它保持（add1 100）或 101。这意味着>将 101 与 1 进行比较，这是错误的，使得这个表达式返回一个从其静态描述中根本不应该发生的值。这种情况被称为故障。

避免故障的一个简单解决方案，正如上面的例子所说明的（并且一个定理可以证明是足够的）。这就是对节点进行拓扑排序。然后，每个节点只有在其依赖项已经被处理后才会被处理，因此不会出现看到过时或不一致的值的危险。

在图中存在循环的情况下，问题变得更加困难。在这些情况下，我们需要特殊的递归运算符，可以为循环行为提供初始值。这使得打破循环依赖成为可能，将评估简化为已经定义的过程。

对于数据流语言的评估还有很多要说的，比如条件语句的处理以及一种对行为的双重概念，即离散和流式的。我希望你能阅读有关反应性语言的文献，以了解更多关于这些主题的内容。

练习

> 早些时候我们批评了一个 Haskell 库。然而，公平地说，我们展示的反应性解决方案是用 Haskell 表达的，其惰性评估使得这种形式的评估相对容易支持。
> 
> 使用惰性实现反应性评估。

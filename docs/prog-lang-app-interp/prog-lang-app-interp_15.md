# 15Checking Program Invariants Statically: Types

|     15.1 Types as Static Disciplines) |
| --- |
|     15.2 A Classical View of Types) |
|       15.2.1 A Simple Type Checker) |
|       15.2.2 Type-Checking Conditionals) |
|       15.2.3 Recursion in Code) |
|         15.2.3.1 A First Attempt at Typing Recursion) |
|         15.2.3.2 Program Termination) |
|         15.2.3.3 Typing Recursion) |
|       15.2.4 Recursion in Data) |
|         15.2.4.1 Recursive Datatype Definitions) |
|         15.2.4.2 Introduced Types) |
|         15.2.4.3 Pattern-Matching and Desugaring) |
|       15.2.5 Types, Time, and Space) |
|       15.2.6 Types and Mutation) |
|       15.2.7 The Central Theorem: Type Soundness) |
|     15.3 Extensions to the Core) |
|       15.3.1 Explicit Parametric Polymorphism) |
|         15.3.1.1 Parameterized Types) |
|         15.3.1.2 Making Parameters Explicit) |
|         15.3.1.3 Rank-1 Polymorphism) |
|         15.3.1.4 Interpreting Rank-1 Polymorphism as Desugaring) |
|         15.3.1.5 Alternate Implementations) |
|         15.3.1.6 Relational Parametricity) |
|       15.3.2 Type Inference) |
|         15.3.2.1 Constraint Generation) |
|         15.3.2.2 Constraint Solving Using Unification) |
|         15.3.2.3 Let-Polymorphism) |
|       15.3.3 Union Types) |
|         15.3.3.1 Structures as Types) |
|         15.3.3.2 Untagged Unions) |
|         15.3.3.3 Discriminating Untagged Unions) |
|         15.3.3.4 Retrofitting Types) |
|         15.3.3.5 Design Choices) |
|       15.3.4 Nominal Versus Structural Systems) |
|       15.3.5 Intersection Types) |
|       15.3.6 Recursive Types) |
|       15.3.7 子类型化) |
|         15.3.7.1 联合) |
|         15.3.7.2 交集) |
|         15.3.7.3 函数) |
|         15.3.7.4 实现子类型化) |
|       15.3.8 对象类型) |

随着程序变得越来越大或更加微妙，开发人员需要工具来帮助他们描述和验证关于程序不变量的陈述。不变量，顾名思义，是关于预期始终保持的程序元素的陈述。例如，当我们在我们的类型语言中编写 x : number 时，我们的意思是 x 将始终持有一个数字，并且程序中依赖于 x 的所有部分都可以依赖于此语句的执行。正如我们将看到的，类型只是我们可能希望陈述的不变量的一个点，而静态类型检查——本身是一组多样的技术——也是我们可以用来强制执行不变量的方法的一个点。

## 15.1 类型作为静态学科

在本章中，我们将特别关注静态类型检查：即，在程序执行之前检查（声明的）类型。通过使用有类型的编程语言，我们已经体验过这种形式的某种程度。我们将探索一些类型及其权衡的设计空间。最后，尽管静态类型是一种特别强大和重要的不变量强制形式，但我们还将研究一些其他可用的技术。

考虑一下我们的类型语言中的这个程序：

> | (define (f [n : number]) : number |
> | --- |
> |   (+ n 3)) |
> |   |
> | (f "x") |

我们在程序开始执行之前就获得了静态类型错误。同样的程序（没有类型注释）在普通的 Racket 中仅在运行时失败：

> | (define (f n) |
> | --- |
> |   (+ n 3)) |
> |   |
> | (f "x") |

练习

> 如何测试这样的断言：一个在程序执行前失败，而另一个在执行期间失败？

现在考虑以下 Racket 程序：

> | (define f n |
> | --- |
> |   (+ n 3)) |

这也在程序执行开始前失败，因为存在解析错误。尽管我们认为解析与类型检查在某种程度上是不同的——通常是因为类型检查器假定它有一个已解析的程序来开始——但将解析视为简单的类型检查的最简单形式可能是有用的：通常确定程序是否遵循上下文无关语法。然后，类型检查询问它是否遵循上下文相关（或更丰富的）语法。简而言之，类型检查是对解析的一种泛化，因为两者都涉及对程序强制执行规则的语法方法。

## 15.2A 类型的经典观点

我们将首先介绍传统类型的核心语言。稍后，我们将探索扩展[参考]和变体[参考]。

### 15.2.1A 简单类型检查器

在我们可以定义类型检查器之前，我们必须解决两件事：我们类型化核心语言的语法以及与此同时，类型本身的语法。

首先，我们将回到我们的语言，其中函数作为值[REF]，但在添加变异和其他复杂性之前（其中一些我们稍后会回到）。对于这种语言，我们必须添加类型注释。通常，我们不会对常量或加法等原始操作强加类型注释；相反，我们将它们强加在函数或方法的边界上。在这项研究过程中，我们将探讨为什么这是一个很好的注释位置。

经过这个决定，我们的类型化核心语言变为：

> | (define-type TyExprC |
> | --- |
> |   [numC (n : number)] |
> |   [idC (s : symbol)] |
> |   [appC (fun : TyExprC) (arg : TyExprC)] |
> |   [plusC (l : TyExprC) (r : TyExprC)] |
> |   [multC (l : TyExprC) (r : TyExprC)] |
> |   [lamC (arg : symbol) (argT : Type) (retT : Type) (body : TyExprC)]) |

换句话说，每个过程都带有它期望的参数类型和它声称要产生的参数类型的注释。现在我们必须决定一种类型的语言。为此，我们遵循类型抽象化值集合的传统。在我们的语言中，我们有两种值：

> | (define-type Value |
> | --- |
> |   [numV (n : number)] |
> |   [closV (arg : symbol) (body : TyExprC) (env : Env)]) |

由此可见，我们应该有两种类型：一种用于数字，另一种用于函数。

即使数字类型也可能不是直截了当的：数字类型需要记录什么信息？在大多数语言中，实际上有许多数字类型，事实上甚至可能没有一个代表“数字”的类型。然而，我们忽略了这些数字之间的渐变[REF]，所以对我们来说只有一个就足够了。决定了这一点后，我们是否记录有关哪个数字的其他信息？原则上我们可以，但很快就会遇到可决定性问题。

至于函数，我们有更多信息：期望参数的类型和声称结果的类型。我们可能会记录这些信息，直到它被证明是没有用的。结合这些，我们得到以下抽象类型语言： 

> | (define-type Type |
> | --- |
> |   [numT] |
> |   [funT (arg : Type) (ret : Type)]) |

现在我们已经固定了语言的术语和类型结构，让我们确保我们对于在我们的语言中构成类型错误的事物达成一致（并且，通过法令，一切不是类型错误的事物必须通过类型检查器）。有三种明显的类型错误形式：

+   + 的一个或两个参数不是数字，即不是 numT。

+   * 的一个或两个参数不是数字。

+   应用程序中函数位置的表达式不是函数，即不是 funT。

现在就做！

> 还有吗？

实际上我们还缺少一个：

+   应用的函数位置的表达式是一个函数，但实际参数的类型与函数预期的形式参数的类型不匹配。

看起来很明显，我们语言中的所有其他程序都应该经过类型检查。

类型检查器的一个自然起始签名将是一个过程，它消耗一个表达式并返回一个布尔值，指示表达式是否通过了类型检查。因为我们知道表达式包含标识符，很快就会清楚我们需要一个类型环境，它将名称映射到类型，类似于我们到目前为止所见到的值环境。

练习

> 定义与类型环境相关联的类型和函数。

因此，我们可能会将我们的程序开始如下：

<tc-take-1>)) ::=

> | (define (tc [expr : TyExprC] [tenv : TyEnv]) : boolean |
> | --- |
> |   (type-case TyExprC expr |
> |     <tc-take-1-numC-case>)) |
> |     <tc-take-1-idC-case>)) |
> |     <tc-take-1-appC-case>)))) |

正如上面简化的案例集所示，这种方法将行不通。我们很快就会看到原因。

让我们从简单的情况开始：数字。数字类型是否经过检查？当然，在其自身上，它当然是的；周围的上下文可能不期望一个数字，但这个错误将在其他地方被发出。因此：

<tc-take-1-numC-case>)) ::=

> [numC (n) true]

现在让我们处理标识符。标识符是否是良好类型的？同样，就其本身而言，它似乎是的，前提是它实际上是一个绑定的标识符；它可能不是上下文所期望的，但希望这也将在其他地方处理。因此，我们可以写成

<tc-take-1-idC-case>)) ::=

> | [idC (n) (if (lookup n tenv) |
> | --- |
> |              true |
> |              (error 'tc "not a bound identifier"))] |

这应该让你有点不舒服：如果标识符没有绑定，查找已经发出错误信号，因此没有必要重复它（事实上，我们永远不会到达这个错误调用）。但让我们继续下去。

现在我们来处理应用。我们应该对函数部分进行类型检查，以确保它是一个函数，然后确保实际参数的类型与函数声明的形式参数的类型一致。例如，函数可以是一个数字，应用本身可以是一个函数，反之亦然，在任何一种情况下，我们都希望阻止这种错误的应用。

代码看起来怎么样？

<tc-take-1-appC-case>)) ::=

> | [appC (f a) (let ([ft (tc f tenv)]) |
> | --- |
> |               ...)] |

对 tc 的递归调用只能告诉我们函数表达式是否经过类型检查。如果是，我们怎么知道它有什么类型？如果我们有一个立即函数，我们可以进入其语法并提取参数（和返回）类型。但是，如果我们有一个复杂的表达式，我们需要一些过程来计算该表达式的结果类型。当然，只有表达式被正确类型化时，这样的过程才能提供类型；否则它将无法提供一个连贯的答案。换句话说，我们的类型“计算器”将类型“检查”作为一个特殊情况！因此，我们应该加强对 tc 的归纳不变量：它不仅告诉我们一个表达式是否被类型化，还告诉我们它的类型是什么。确实，通过给出任何类型，它都确认了表达式的类型，否则它会发出错误信号。

现在让我们定义一个更丰富的类型“检查器”。

<tc>)) ::= 

> | (define (tc [expr : TyExprC] [tenv : TyEnv]) : Type |
> | --- |
> |   (type-case TyExprC expr |
> |     <tc-numC-case>)) |
> |     <tc-idC-case>)) |
> |     <tc-plusC-case>)) |
> |     <tc-multC-case>)) |
> |     <tc-appC-case>)) |
> |     <tc-lamC-case>)))) |

现在让我们填入这些部分。数字很容易：它们具有数字类型。

<tc-numC-case>)) ::= 

> [numC (n) (numT)]

同样地，标识符具有环境中规定的任何类型（如果它们没有绑定，则会发出错误信号）。

<tc-idC-case>)) ::= 

> [idC (n) (lookup n tenv)]

观察到，到目前为止，与解释相似之处及不同之处：在标识符案例中，我们基本上做了相同的事情（除了我们返回了一个类型而不是一个实际值），而在数字案例中，我们返回了抽象的“数字”，而不是指示它是哪个特定的数字。

现在让我们来看看加法。我们必须确保两个子表达式都具有数值类型；只有这样，整体表达式才会评估为一个数字本身。

<tc-plusC-case>)) ::= 

> | [plusC (l r) (let ([lt (tc l tenv)] |
> | --- |
> |                    [rt (tc r tenv)]) |
> |                (if (and (equal? lt (numT)) |
> |                         (equal? rt (numT))) |
> |                    (numT) |
> |                    (error 'tc "+ not both numbers")))] |

我们通常在考虑加法后会忽略乘法，但现在明确处理它将是有益的：

<tc-multC-case>)) ::= 

> | [multC (l r) (let ([lt (tc l tenv)] |
> | --- |
> |                    [rt (tc r tenv)]) |
> |                (if (and (equal? lt (numT)) |
> |                         (equal? rt (numT))) |
> |                    (numT) |
> |                    (error 'tc "* 不是两个数字")))] |

现在开始！

> 你看到了什么不同之处吗？

没错：实际上几乎没有什么区别！（类型案例中的 multC 而不是 plusC，以及稍微不同的错误消息除外。）这是因为，从类型检查的角度来看（在此类型语言中），加法和乘法之间没有区别，实际上也没有区别两个消耗两个数字并返回一个数字的任何两个函数之间。

再观察一下解释和类型检查之间的另一个区别。两者都要求参数为数字。然后解释器返回一个精确的和或积，但类型检查器对它们之间的差异漠不关心：因此，计算返回值的表达式((numT))是一个常量，在两种情况下都是相同的常量。

最后，两个困难的情况：应用和函数。我们已经讨论了应用必须做什么：计算函数和参数表达式的值；确保函数表达式具有函数类型；检查参数表达式的类型是否兼容。如果所有这些都成立，那么整个应用的类型就是函数体将返回的任何类型（因为最终在运行时返回的值是评估函数体的结果）。

<tc-appC-case>)) ::=

> | [appC (f a) (let ([ft (tc f tenv)] |
> | --- |
> |                   [at (tc a tenv)]) |
> |               (cond |
> |                 [(not (funT? ft)) |
> |                  (error 'tc "不是一个函数")] |
> |                 [(not (equal? (funT-arg ft) at)) |
> |                  (error 'tc "应用参数不匹配")] |
> |                 [else (funT-ret ft)]))] |

这留下了函数定义。该函数有一个形式参数，据推测在函数体中使用；除非此参数在环境中绑定，否则函数体很可能无法正确进行类型检查。因此，我们必须使用形式名称扩展类型环境，该名称绑定到其类型，并在该扩展环境中对函数体进行类型检查。无论此计算得到的值是什么，都必须与函数体的声明类型相同。如果是这样，那么函数本身就具有从参数类型到函数体类型的函数类型。

练习

> 为什么我在上面说“很可能”？

<tc-lamC-case>)) ::=

> | [lamC (a argT retT b) |
> | --- |
> |       (if (equal? (tc b (extend-ty-env (bind a argT) tenv)) retT) |
> |           (funT argT retT) |
> |           (error 'tc "lam 类型不匹配"))] |

注意解释器和类型检查器之间的另一个奇怪差异。在解释器中，应用负责评估参数表达式、扩展环境和评估主体。在这里，应用案例确实检查了参数表达式，但是保持环境不变，只是简单地返回主体的类型而不对其进行遍历。相反，当检查函数定义时，实际上是检查器遍历主体的时候，因此这是环境实际扩展的时候。

### 15.2.2 类型检查条件

假设我们用条件扩展了上述语言。即使是谦虚的 if 也会引入几个设计决策。我们将在这里讨论其中两个，并且稍后回到其中一个 [REF]。

1.  测试表达式的类型应该是什么？在一些语言中，它必须求值为布尔值，这种情况下我们必须丰富类型语言以包括布尔值（这可能是个好主意）。在其他语言中，它可以是任何值，并且一些值被认为是“真值”，而另一些被认为是“假值”。

1.  then- 和 else- 分支之间应该是什么关系？在一些语言中，它们必须具有相同的类型，以便整个表达式有一个单一、明确的类型（即那个类型）。在其他语言中，这两个分支可以有不同的类型，这极大地改变了类型语言和类型检查器的设计，也改变了编程语言本身的性质。

练习

> 将布尔值添加到类型语言中。这至少需要什么，并且在典型语言中可能还期望有什么？

练习

> 为条件添加一个类型规则，其中测试表达式预计将求值为布尔值，并且 then- 和 else- 分支必须具有相同的类型，即整个表达式的类型。

### 15.2.3 代码中的递归

现在我们已经获得了一个基本的编程语言，让我们为其添加递归。我们先前看到 [REF]，这可以通过展开轻松完成。但在这里将会是一个更复杂的情况。

### 15.2.3.1 尝试类型递归的第一个尝试

现在让我们尝试表达一个简单的递归函数。最简单的当然是一个永远循环的函数。我们能用函数写一个无限循环吗？我们已经可以通过这个程序简单地完成了—<wbr>

> | ((lambda (x) (x x)) |
> | --- |
> |  (lambda (x) (x x))) |

—<wbr>我们知道我们可以用函数作为值在我们的语言中表示。练习

> 这为什么构成了一个无限循环？它对函数调用的本质做了什么微妙的依赖？

现在我们有了一个有类型的语言，并且一个强制我们对所有函数进行注释的语言，让我们对其进行注释。为简单起见，从现在开始，我们假设我们在一个有类型的表面语法中编写程序，并且展开操作负责构造核心语言术语。

首先要注意，我们有两个相同的术语被应用于彼此。从历史上看，整个术语被称为Ω（希腊大写的 omega），每个相同的子术语被称为ω（希腊小写的 omega）。相同的术语必须具有完全相同的类型并不是必然的，因为它取决于我们想要在使用环境中断言的不变量是什么。然而，在这种情况下，请注意 x 绑定到ω，因此第二个ω进入第一和第二个位置。因此，输入一个有效地相当于同时输入两个。

因此，让我们尝试为ω编写类型；我们将这个类型称为γ。这显然是一个函数类型，并且这个函数接受一个参数，所以它必须是形式为φ -> ψ的。现在这个参数是什么？它是ω本身。也就是说，进入φ的值的类型本身就是γ。因此，ω的类型是γ，它是φ -> ψ，它展开为 (φ -> ψ) -> ψ，进一步展开为 ((φ -> ψ) -> ψ) -> ψ，以此类推。换句话说，这个类型无法被写成任何有限字符串！

现在做！

> 你注意到我们刚刚做了微妙但重要的飞跃了吗？

### 15.2.3.2 程序终止

我们注意到Ω的明显类型化似乎会遇到严重问题。然而，从那里，我们跳到了这种类型无法被写成任何有限字符串的结论，对此我们只是给出了直觉，而不是证明。事实上，更奇怪的是：在我们迄今为止定义的类型系统中，我们根本无法为Ω类型化！

这是一个强有力的陈述，但实际上我们可以说得更加强烈。到目前为止，我们所拥有的带类型的语言具有一个称为强归约的属性：每个具有类型的表达式在有限步骤后将终止计算。换句话说，这个特殊（而古怪）的无限循环程序并不是我们无法类型化的唯一程序；我们无法类型化任何无限循环（甚至是潜在的无限循环）。一个可能有所帮助的粗略直觉是，任何类型——必须是一个有限的字符串——只能有有限数量的 ->，每次应用都会释放一个，所以我们只能执行有限数量的应用。

如果我们的语言只允许直线程序，那么这并不奇怪。然而，我们有条件语句，甚至可以将函数作为值传递，而且我们可以用它们来编码任何我们想要的数据类型。然而，我们仍然得到了这个保证！这使得这个结果有点令人惊讶。

练习

> 尝试使用未类型化的函数和已类型化的语言来编码列表。你看到了什么？这对编码的影响告诉了你什么？

这个结果还说明了更深层次的东西。它表明，与您可能相信的相反——<wbr>即类型系统只能防止一些有 bug 的程序运行——<wbr>类型系统可以改变语言的语义。以前我们可以用一两行写一个无限循环，现在我们根本不能写了。它还表明，类型系统不仅可以建立关于特定程序的不变量，还可以建立关于语言本身的不变量。如果我们想绝对确保一个程序会终止，我们只需要用这种语言编写它并通过类型检查器，保证就是我们的！

一个所有程序都会终止的语言有什么可能的用处呢？对于通用编程来说，当然没有。但在许多专业领域中，拥有这样的保证是非常有用的。例如，假设您正在实现一个复杂的调度算法；您希望知道您的调度程序有保证地终止，以便正在调度的任务实际上能运行。还有许多其他领域，我们也会从这样的保证中受益：路由器中的包过滤器；实时事件处理器；设备初始化程序；配置文件；单线程 JavaScript 中的回调函数；甚至编译器或链接器。在每种情况下，我们几乎都有这样一个默默的期望，即这些程序总是会终止。现在我们有一种语言可以提供这样的保证——<wbr>这是不可能测试的东西，更何况！这些不是假设性的例子。在标准 ML 语言中，用于链接模块的语言基本上使用了这种带类型的语言来编写模块链接规范。这意味着开发人员可以编写相当复杂的抽象——<wbr>毕竟他们有函数作为值！——<wbr>同时仍然保证链接总是会终止，生成一个程序。

### 15.2.3.3 递归的类型

这意味着，尽管以前我们能够完全通过解糖化来处理 rec，但现在我们必须将其作为类型语言的一个显式部分。为了简单起见，我们将考虑 rec 的一个特殊情况——<wbr>尽管这涵盖了常见的用法——<wbr>其中递归标识符绑定到一个函数。因此，在表面语法中，一个人可能会写

> | (rec (Σ num (n num) |
> | --- |
> |         (if0 n |
> |              0 |
> |              (n + (Σ (n + -1))))) |
> |   (Σ 10)) |

用于求和函数，其中Σ是函数的名称，n 是其参数，num 是函数消耗和返回的类型。表达式(Σ 10)表示使用该函数从 10 加到 0 的数字。

我们如何为这样的表达式编写类型？显然，我们必须在函数的主体中绑定 n，当我们为其编写类型时（但当然，不在函数的使用中）；这一点我们从编写函数中知道。但Σ呢？显然，在检查使用时（（Σ 10）），它必须在类型环境中绑定，并且其类型必须是 num -> num。但在检查函数主体时，它也必须绑定到相同的类型。（还要注意，主体返回的类型必须与其声明的返回类型匹配。）

现在我们可以看到如何打破类型的有限性的枷锁。当然，我们在程序源代码中只能写入有限数量的->。然而，这种递归类型的规则会在引用自身的主体中复制->，从而确保有不尽的应用。这是我们无限的箭头图。

实现此规则的代码如下。假设 f 绑定到函数的名称，aT 是函数的参数类型，rT 是其返回类型，b 是函数的主体，u 是函数的用途：

<tc-lamC-case>)) ::=

> | [recC (f a aT rT b u) |
> | --- |
> |       (让 ([扩展环境 |
> |              (扩展类型环境 (绑定 f (funT aT rT)) tenv)]) |
> |         (条件 |
> |           [(not (equal? rT (tc b |
> |                                (扩展类型环境 |
> |                                 (绑定 a aT) |
> |                                 扩展环境)))) |
> |            (错误 'tc "主体返回类型不正确")] |
> |           [else (tc u 扩展环境)]))] |

### 15.2.4 数据中的递归

我们已经看到如何为递归程序编写类型，但这还不足以使我们能够创建递归数据。我们已经有一种递归数据—<wbr>函数类型—<wbr>但这是内置的。我们还没有看到开发人员如何可以创建自己的递归数据类型。

### 15.2.4.1 递归数据类型定义

当���们说允许程序员创建递归数据时，实际上我们在谈论三种不同的功能：

+   创建一个新类型。

+   让新类型的实例具有一个或多个字段。

+   让一些这些字段引用相同类型的实例。

实际上，一旦我们允许第三个，我们必须再允许一个：

+   允许类型具有非递归基本情况。

这些设计标准的融合导致了通常称为代数数据类型的东西，例如我们的类型化语言支持的类型。例如，考虑以下对数字的二叉树的定义：稍后[REF]，我们将讨论类型如何可以被参数化。

> | (定义类型 BTnum |
> | --- |
> |   [BTmt] |
> |   [BTnd (n : number) (l : BTnum) (r : BTnum)]) |

注意到，如果没有新数据类型 BTnum 的名称，我们将无法在 BTnd 中引用它。同样，如果没有能力有多种类型的 BTnum，我们将无法定义 BTmt，因此也无法终止递归。最后，当然，我们需要多个字段（如 BTnd 中所示）来构造有用且有趣的数据。换句话说，这三种机制一起打包，因为它们在结合使用时最有用。 （然而，一些语言确实允许定义独立的结构。我们稍后会回到这个设计决策对类型系统的影响 [REF]。）

这结束了我们对递归类型的初始介绍，但它存在一个致命问题。我们实际上并没有解释新类型 BTnum 是从哪里来的。这是因为我们不得不假装它是内置在我们的类型检查器中的。然而，每次定义一个新的递归类型时都改变我们的类型检查器是不现实的——这就像每次程序包含递归函数时都修改我们的解释器一样！相反，我们需要找到一种使这样的定义固有于类型语言的方法。我们稍后会回到这个问题 [REF]。

这种数据定义风格有时也称为总和乘积。 “乘积” 指的是一种变体中字段组合的方式：例如，BTnd 的合法值是供应给 BTnd 构造器的每个字段中的合法值的交叉乘积。 “总和” 是所有这些变体的总和：任何给定的 BTnum 值只是其中的一个。 （将 “乘积” 视为 “和”，将 “总和” 视为 “或”）。

### 15.2.4.2 引入的类型

现在，数据类型定义有什么影响呢？首先，它引入了一个新类型；然后，它使用这个类型来定义几个构造器、谓词和选择器。例如，在上面的例子中，它首先引入 BTnum，然后用它来描述以下类型：

> | BTmt : -> BTnum |
> | --- |
> | BTnd : number * BTnum * BTnum -> BTnum |
> | BTmt? : BTnum -> boolean |
> | BTnd? : BTnum -> boolean |
> | BTnd-n : BTnum -> number |
> | BTnd-l : BTnum -> BTnum |
> | BTnd-r : BTnum -> BTnum |

观察到一些显著的事实：

+   这两个构造器创建的是 BTnum 的实例，而不是更精细的东西。我们稍后会讨论这个设计上的权衡 [REF]。

+   这两个谓词消耗的是 BTnum 类型的值，而不是“任何”类型的值。这是因为类型系统已经可以告诉我们一个值是什么类型。因此，我们只需要区分该类型的各个变体。

+   选择器实际上只能在相关变体的实例上工作——例如，BTnd-n 只能在 BTnd 的实例上工作，而不能在 BTmt 的实例上工作——但我们没有办法在静态类型系统中表达这一点，因为缺乏合适的静态类型。因此，应用这些选择器只会导致动态错误，而不是类型系统捕获的静态错误。

关于递归类型还有更多要说的，我们马上会回来 [REF]。

### 15.2.4.3 模式匹配和语法糖

一旦我们观察到这些是类型，唯一剩下的就是提供模式匹配的说明。例如，我们可以编写表达式

> | (type-case BTnum t |
> | --- |
> |   [BTmt () e1] |
> |   [BTnd (nv lt rt) e2]) |

我们已经看到[REF]，这可以根据上面定义的函数来编写。我们可以使用 let 模拟此模式匹配器所做的绑定：

> | (cond |
> | --- |
> |   [(BTmt? t) e1] |
> |   [(BTnd? t) (let ([nv (BTnd-n t)] |
> |                    [lt (BTnd-l t)] |
> |                    [rt (BTnd-r t)]) |
> |                e2)]) |

简而言之，这可以通过宏来实现，因此模式匹配不需要在核心语言中，而可以委托给解糖。这反过来意味着一种语言可以有许多不同的模式匹配机制。

但是，这并不完全正确。一些生成上述代码的宏需要知道 BTnd 的三个位置选择器分别是 BTnd-n、BTnd-l 和 BTnd-r。这些信息在类型定义中是显式的，但在模式匹配器的使用中只是隐含的（这确实是重点）。因此，这些信息必须以某种方式从定义传达到使用。因此，宏展开器需要类似于类型环境的东西来完成其任务。

此外，请注意，诸如 e1 和 e2 这样的表达式无法进行类型检查，甚至无法可靠地识别为表达式，直到宏展开扩展了 type-case 的使用。因此，扩展取决于类型环境，而类型检查取决于扩展的结果。换句话说，这两者是共生的，需要发生，不完全是“并行”的，而是步调一致。因此，为具有类型的语言构建解糖，其中语法糖对类型做出假设，比为无类型的语言构建解糖要复杂一些。

### 15.2.5 类型、时间和空间

显而易见，类型在安全语言中已经带来了性能优势。这是因为原本在运行时会执行的检查，比如检查其参数是否确实为数字，现在在静态环境下执行。在类型化的语言中，像 : number 这样的注解已经回答了某物是否属于特定类型的问题；在运行时不需要再进行任何询问。因此，这些类型级别的断言可以（并且需要）完全消失，以及在程序中使用它们的任何需求。

对于开发人员来说，这会带来一些成本，他们必须说服静态类型系统他们的程序不会引发类型错误；由于可决定性的限制，即使可能无错误地运行的程序也可能违反类型系统。然而，对于符合此要求的程序，类型提供了显著的执行时间节省。

现在让我们讨论空间问题。直到现在，语言运行时系统需要存储附加到每个值的信息，指示其类型是什么。这是它如何实现诸如 number? 这样的类型级谓词的方式，这些谓词可能被开发人员和原语同时使用。如果这些谓词消失，用于实现它们的空间也会消失。因此，类型标签不再是必要的。但是，垃圾收集器仍然需要它们，尽管其他表示形式如 BIBOP 可以大大减少它们的空间影响。

仍然留下的类型谓词是变异的：BTmt? 和 BTnd?，如上例所示。这些确实必须在运行时应用。例如，正如我们所注意到的，像 BTnd-n 这样的选择器必须执行此检查。当然，还有一些更多的优化是可能的。考虑通过解糖模式匹配器生成的代码：这里没有必要为这三个选择器实现这个检查，因为控制只能在 BTnd? 返回 true 值后才会到达它们。因此，运行时系统可以仅为解糖级别提供访问特殊不执行检查的不安全原语，从而生成类似以下的代码：

> | (cond |
> | --- |
> |   [(BTmt? t) e1] |
> |   [(BTnd? t) (let ([nv (BTnd-n/no-check t)] |
> |                    [lt (BTnd-l/no-check t)] |
> |                    [rt (BTnd-r/no-check t)]) |
> |                e2)]) |

然而，最终结果是，运行时表示仍然必须存储足够的信息来准确回答这些问题。然而，以前它需要使用足够的位来记录每种可能的类型（和变体）。现在，由于类型已经静态分离，对于没有变体的类型（例如，只有一种字符串），根本不需要存储任何变体信息；这意味着运行时系统可以使用所有可用的位来存储实际动态值。

相反，当存在变体时，运行时系统必须牺牲位来区分这些变体，但是一个类型内的变体数量明显远小于所有类型的变体和类型的数量。在上面的 BTnum 示例中，只有两种变体，因此运行时系统只需使用一位来记录值表示的 BTnum 的哪种变体。

特别要注意的是，类型系统的分离可以防止混淆。如果存在两种不同的数据类型，每种类型都有两个变体，在未类型化的世界中，所有这些四个变体都需要不同的表示。相比之下，在类型化的世界中，这些表示可以跨越类型重叠，因为静态类型系统将确保一个类型的变体永远不会被误认为是另一个类型的变体。因此，对于程序来说，类型确实具有真正的空间（节省表示）和时间（消除运行时检查）性能优势。

### 15.2.6 类型与变异

我们现在已经介绍了我们核心语言的大部分基本特性，除了突变。在某种程度上，类型与突变有着简单的交互，这是因为在传统设置中，它们根本不互动。例如，考虑以下未经类型化的程序：

> | (let ([x 10]) |
> | --- |
> |   (begin |
> |     (set! x 5) |
> |     (set! x "something"))) |

x 的“类型”是什么？它实际上没有一个固定的类型：有一段时间它是一个数字，稍后（注意时间词）它是一个字符串。我们根本无法给它一个类型。一般来说，类型检查是一种非时间性的活动：它在程序运行之前只进行一次，并且因此必须独立于程序执行的具体顺序。因此，跟踪存储中的精确值是超出类型检查器的能力范围的。上面的例子当然很容易静态理解，但我们不应该被简单的例子误导。假设我们有一个像下面这样的程序

> | (let ([x 10]) |
> | --- |
> |   (if (even? (read-number "输入一个数字")) |
> |     (set! x 5) |
> |     (set! x "something"))) |

现在在条件结束后，关于 x 的类型达到任何静态结论都是不可能的，因为只有在运行时我们才能知道用户可能输入了什么。

为了避免这种困境，传统类型检查器采用了一个简单的策略：类型必须在突变过程中保持不变。也就是说，突变操作——无论是变量突变还是结构突变——都不能改变突变体的类型。因此，上面的例子在我们的类型语言中到目前为止都无法通过类型检查。然而，程序员能够获得多少灵活性取决于类型语言。例如，如果我们允许一个更灵活的类型，代表“数字或字符串”，那么上面的例子就能通过类型检查，但是 x 将始终具有这种不太精确的类型，并且所有对 x 的使用都必须处理其降低的特定性，这是我们稍后将回到的问题[REF]。

简而言之，在传统类型系统中，突变很容易解释，因为其规则仅仅是，虽然值可以以类型系统的特定级别以下的方式改变，但类型不能改变。对于像 set!（或我们核心语言的 setC）这样的操作，这意味着分配值的类型必须与变量的类型匹配。对于结构突变，比如盒子，这意味着分配的值必须与盒子的包含类型匹配。

### 15.2.7 中心定理：类型完整性

我们之前已经见过[REF]，某些类型语言可以为它们的程序提供非常强大的定理：例如，语言中的所有程序都终止。当然，总的来说，我们不能获得这样的保证（事实上，我们添加了一般递归，正是为了让自己编写无限循环）。然而，一个有意义的类型系统——确实，任何值得我们赋予“类型系统”这一尊贵称的东西我们已经多次使用了“类型系统”这个术语。一个类型系统通常是三个组成部分的组合：类型语言、类型规则集合和将这些规则应用于程序的算法。通过在一个函数中主要呈现我们的类型规则，我们已经模糊了这两者之间的区别，但仍然可以被视为在智力上是不同的。——应该提供某种有意义的保证，即所有带类型的程序都享有。这是程序员的回报：通过为这个程序编写类型，她可以确信某些不好的事情肯定不会发生。除此之外，我们只是一个错误查找器；虽然它可能有用，但它不足以构建任何高级工具的基础（例如，用于获得安全性、隐私或健壮性保证）。

我们可能希望类型系统有哪些定理？请记住，类型检查器在执行之前运行在静态程序上。在这样做时，它实际上在对程序的行为进行预测：例如，当它声明一个特定的复杂项具有类型 num 时，它实际上在预测当运行时，该项将产生一个数字值。我们怎么知道这个预测是正确的，即类型检查器从不撒谎？每个类型系统都应该伴随着一个定理来证明这一点。

对于一个类型系统，怀疑是有道理的，除了一般的怀疑之外。类型检查器和程序求值器之间有许多差异：

+   类型检查器只看到程序文本，而求值器则运行在实际存储上。

+   类型环境将标识符绑定到类型，而求值器的环境将标识符绑定到值或位置。

+   类型检查器将（甚至无限的）值集合压缩成类型，而求值器将它们区别对待。

+   类型检查器总是终止的，而求值器可能不会。

+   类型检查器仅对每个表达式的主体经过一次，而求值器可能对每个主体经过零次到无限次。

因此，我们不应该假设这些总是对应的！

对于给定类型系统，我们希望获得的中心结果称为声音性。它是这样说的。假设我们有一个表达式（或程序）e。我们对其进行类型检查，并得出其类型为 t。当我们运行 e 时，假设我们得到值 v。那么 v 也将具有类型 t。

证明这个定理的标准方法是分两部分证明，即进展和保持。进展指的是，如果一个术语通过了类型检查，它将能够进行一步评估（除非它已经是一个值）；保持指的是，这一步的结果将与原始类型相同。如果我们交错进行这些步骤（首先进展，然后保持；重复），我们可以得出最终答案确实与原始类型相同的结论，因此类型系统确实是正确的。

例如，考虑这个表达式：(+ 5 (* 2 3))。它的类型是 num。在一个正确的类型系统中，进展提供了一个证明，因为这个术语有类型，并且不是一个值，它可以执行一步—显然可以。经过一步后，程序简化为(+ 5 6)。果然，保持证明，这与原始类型相同：num。进展再次表示这可以进行一步，产生 11。保持再次显示，这与先前（中间）表达式的类型相同：num。现在进展发现我们得到了一个答案，因此没有剩余的步骤可执行，我们的答案与原始表达式给出的类型相同。

然而，这并不是整个故事。有两个警告：

1.  程序可能根本不会产生答案；它可能永远循环。在这种情况下，严格来说定理并不适用。然而，我们仍然可以观察到每个中间术语仍然具有相同的类型，因此即使程序不产生值，它仍然在有意义地计算。

1.  任何足够丰富的语言都具有无法静态决定的属性（以及其他可能可以静态决定的属性，但语言设计者选择推迟到运行时）。当这些属性之一失败时—例如，数组索引超出范围—程序就没有有意义的类型。因此，每个类型正确性定理中都隐含着一些已发布的、允许的异常或错误条件集合，可能会发生。使用类型系统的开发人员隐含地同意接受这一集合。

作为后一种集合的例子，典型类型化语言的用户承认，向量解引用、列表索引等都可能产生异常。

后一种警告看起来像是在推诿责任。事实上，很容易忘记这实际上是关于运行时不可能发生的一个声明：任何不在这个集合中的异常都将不会被触发。当然，在首先设计静态类型的语言中，不清楚（除了通过宽泛的类比）这些异常可能是什么，因为不需要定义它们。但是当我们在现有编程语言上添加类型系统—尤其是只有动态强制执行的语言，例如 Racket 或 Python—时，已经有一个明确定义的异常集合，并且类型检查器明确声明了其中一些异常集（例如“在应用位置找不到非函数”或“找不到方法”）将永远不会发生。因此，这就是程序员接受类型系统的语法限制所得到的回报。

## 15.3 核心的扩展

现在我们有了一个基本的类型化语言，让我们探讨如何扩展它以获得一个更有用的编程语言。

### 15.3.1 显式参数化多态

这些中哪一个是相同的？

> +   List<String>
> +   
> +   List<String>
> +   
> +   (字符串列表)

实际上，这些都不太相同。但是第一个和第三个非常相似，因为第一个是在 Java 中，第三个是在我们的类型化语言中，而第二个在 C++ 中是不同的。清楚了吗？没有？好的，继续读下去！

### 15.3.1.1 参数化类型

我们已经编程的语言已经展示了参数化多态的价值。例如，map 的类型是这样给出的

> | (('a -> 'b) (’a 列表) -> (’b 列表)) |
> | --- |

它表示对于所有类型 ’a 和 ’b，map 消耗一个从 ’a 值生成 ’b 值的函数，以及 ’a 值的列表，并生成相应的 ’b 值列表。这里，’a 和 ’b 不是具体类型；而是类型变量（在我们的术语中，这些应该适当地称为“类型标识符”，因为它们在实例化过程中不会改变；然而，我们将坚持传统的术语）。理解这一点的另一种方法是，实际上有一个无限的 map 函数家族。例如，有一个 map 具有这种类型：

> | ((数 -> 字符串) (字符串列表) -> (字符串列表)) |
> | --- |

还有另一个属于这种类型的（没有说类型必须是基本类型）：

> | ((数 -> (数 -> 数)) (数列表) -> ((数 -> 数)列表)) |
> | --- |

还有另一个属于这种类型的（没有说 ’a 和 ’b 不能相同）：

> | ((字符串 -> 字符串) (字符串列表) -> (字符串列表)) |
> | --- |

等等。因为它们有不同的类型，它们需要不同的名称：map_num_str、map_num_num->num、map_str_str 等。但那将使它们成为不同的函数，所以我们必须总是引用一个特定的 map 而不是每一个通用的 map。

显然，将所有这些函数加载到我们的标准库中是不可能的：这些函数有无限多个！我们宁愿有一种方法能够按需获取每个这些函数。我们的命名约定提供了一个提示：就像 map 接受两个参数，它们是类型。给定一对类型作为参数，然后我们可以获得一个根据特定类型定制的 map。这种类型上的参数化称为参数多态性。不要与对象的“多态性”混淆，我们将在下面讨论。

### 15.3.1.2 明确参数

换句话说，我们实际上是在说 map 实际上是一个函数，可能有四个参数，其中两个是类型，另外两个是实际值（一个函数和一个列表）。在一个具有显式类型的语言中，我们可能会尝试编写

> | (define (map [a : ???] [b : ???] [f : (a -> b)] [l : (listof a)]) : (listof b) |
> | --- |
> |   ...) |

但是这引发了一些问题。首先，???? 应该填什么？这些是 a 和 b 的类型。但如果 a 和 b 本身将被类型替换，那么类型的类型是什么呢？其次，我们真的想在每次实例化时都使用四个参数来调用 map 吗？第三，我们真的想在任何实际值之前先取类型参数吗？这些问题的答案实际上导致了一个非常丰富的多态类型系统空间，我们大部分不会在这里探讨。我建议阅读皮尔斯的《类型与编程语言》以获得现代、易于理解的介绍。

请注意，一旦我们开始参数化，比我们预期的代码更多地被参数化了。例如，考虑简单的 cons 的类型。它的类型确实是针对列表中值的类型进行参数化的（即使它实际上并不依赖于这些值！——稍后会详细说明）。因此，对 cons 的每次使用都必须以适当的类型进行实例化。同样，即使是空的也必须被实例化以创建正确类型的空列表！当然，Java 和 C++ 程序员都熟悉这种痛苦。

### 15.3.1.3 排名-1 多态性

相反，我们将限制自己在这个空间中的一个特别有用且易处理的点，即本书的类型化语言的类型系统、较早版本的 Haskell 的类型系统、Java 和 C# 的泛型以及在 C++ 中使用模板大致相同。这种语言定义了所谓的谓词、排名-1 或前置多态性。它对上述问题的答案如下：没有、不、是的。让我们在下面探讨一下。

我们首先将类型世界分成两组。第一组包括我们一直使用的类型语言，但扩展为包括类型变量；这些称为单态。第二组，称为多态，包括参数化类型；这些通常以∀前缀、类型变量列表，然后是可能使用这些变量的类型表达式来书写。因此，map 的类型将是：

> | ∀ a, b : (('a -> 'b) (listof 'a) -> (listof 'b)) |
> | --- |

“∀”是逻辑符号“对于所有”的符号，你可以这样阅读：“对于所有类型’a 和’b，map 的类型是…”。

在秩-1 多态中，类型变量只能用单类型替换。（此外，这些只能是具体类型，因为不会剩下任何类型变量可替换。）因此，我们获得了类型变量参数和常规参数之间的明确分离。我们不需要为类型变量提供“类型注释”，因为我们确切地知道它们可以是什么类型。这产生了一种相对清洁的语言，仍然提供了相当大的表达能力。非预测性语言抹去了单类型和多类型之间的区别，因此类型变量可以用另一个多态类型实例化。

注意，由于类型变量只能被单类型替换，它们彼此独立。因此，所有类型参数都可以被带到参数列表的前面。这就使我们能够以∀ tv，…：t 的形式编写类型，其中 tv 是类型变量，t 是单类型（可能引用这些变量）。这不仅证明了语法，还证明了“前言”的名称。这也将在实现中证明是有用的。

### 15.3.1.4 将秩-1 多态解释为解糖

这一特性的最简单实现是将其视为一种解糖形式：这基本上是 C++所采用的解释方式。（换句话说，因为 C++具有模板形式的宏系统，由于一个幸运的巧合，它通过使用模板获得了一种秩-1 多态形式。）例如，想象一下我们有一个新���语法形式 define-poly，它接受一个名称、一个类型变量和一个主体。在为名称提供类型时，它会在主体中用给定的类型替换类型变量。因此：

> | (define-poly (id t) (lambda ([x : t]) : t x)) |
> | --- |

首先通过将 id 定义为多态来定义一个恒等函数：给定 t 的具体类型，它产生一个类型为（t -> t）的一个参数过程（其中 t 被适当替换）。因此，我们可以在许多不同类型上实例化 id—<wbr>

> | (define id_num (id number)) |
> | --- |
> | (define id_str (id string)) |

—<wbr>从而在每种类型上获得恒等函数：（test（id_num 5）5）（test（id_str“x”）“x”）相比之下，表达式（id_num“x”）（id_str 5）将无法通过类型检查（而不是在运行时失败）。如果你感兴趣，这是实现。为简单起见，我们假设只有一个类型参数；这很容易推广使用….我们不仅将为 define-poly 定义一个宏，它将反过来定义一个宏：

> | (define-syntax define-poly |
> | --- |
> |   (syntax-rules () |
> |     [(_ (name tyvar) body) |
> |      (define-syntax (name stx) |
> |        (syntax-case stx () |
> |          [(_ type) |
> |           (with-syntax ([tyvar #'type]) |
> |             #'body)]))])) |

因此，考虑到这样的定义

> | (define-poly (id t) (lambda ([x : t]) : t x)) |
> | --- |

语言创建了一个名为 id 的宏：从（define-syntax（name ...）...）开始的部分（在这个例子中，name 是 id）。id 的实例化，比如（id number），用给定的类型替换类型变量 tyvar。为了规避卫生问题，我们使用 with-syntax 强制所有类型变量（tyvar）的使用实际上被给定的类型替换。因此，实际上，

> | (define id_num (id number)) |
> | --- |

变成

> | (define id_num (lambda ([x : number]) : number x)) |
> | --- |

然而，这种方法有两个重要的限制。

1.  让我们尝试定义一个递归的多态函数，比如 filter。之前我们说过，我们应该为每个多态值（如 even cons 和 empty）实例化类型，但为了保持代码简洁，我们将依赖底层类型化语言已经做到这一点，并只关注 filter 的类型参数。以下是代码：

    > | (define-poly (filter t) |
    > | --- |
    > |   (lambda ([f : (t -> boolean)] [l : (listof t)]) : (listof t) |
    > |     (cond |
    > |       [(empty? l) empty] |
    > |       [(cons? l) (if (f (first l)) |
    > |                      (cons (first l) |
    > |                            ((filter t) f (rest l))) |
    > |                      ((filter t) f (rest l)))]))) |

    在 filter 的递归使用中，我们必须用适当的类型实例化它。这是一个非常好的定义。只有一个问题。当我们尝试使用它时，例如，

    > | (define filter_num (filter number)) |
    > | --- |

    DrRacket 不会终止。具体来说，宏展开不会终止，因为它一直在尝试制作 filter 代码的新副本。相反，如果我们将函数写成以下形式，展开就会终止，

    > | (define-poly (filter2 t) |
    > | --- |
    > |   (letrec ([fltr |
    > |             (lambda ([f : (t -> boolean)] [l : (listof t)]) : (listof t) |
    > |               (cond |
    > |                 [(empty? l) empty] |
    > |                 [(cons? l) (if (f (first l)) |
    > |                                (cons (first l) (fltr f (rest l))) |
    > |                                (fltr f (rest l)))]))]) |
    > |     fltr)) |

    但这只是把痛苦推给了用户。事实上，一些模板扩展器将缓存先前的扩展值，并在给定相同参数时避免重新生成代码。（Racket 不能这样做，因为一般来说，宏的主体可能依赖于可变变量和值，甚至执行输入输出，因此 Racket 不能保证给定的输入总是生成相同的输出。）

1.  考虑两个 identity 函数的实例化。我们无法比较 id_num 和 id_str，因为它们是不同类型的，但即使它们是相同类型，它们也不是 eq?：

    > | (test (eq? (id number) (id number)) #f) |
    > | --- |

    这是因为每次使用 id 都会创建一个新的函数体副本。即使我们上面提到的优化应用了，所以对于相同类型只有一个代码体，对于不同类型仍然会有不同的代码体。实际上，C++模板因创建代码膨胀而臭名昭著；这是其中一个原因。——但即使如此也是不必要的！例如，id 函数体中实际上没有任何依赖于参数类型的内容。事实上，整个无限系列的 id 函数可以共享一个实现。简单的解糖策略无法做到这一点。

换句话说，基于解糖的策略，本质上是一种替换实现，与替换作为参数实例化的实现相比，基本上存在与之前相同的问题。然而，在其他情况下，替换还为我们提供了对程序行为的期望的真实性。与多态性相同，我们很快将会看到 [REF]。

请注意，解糖策略的一个优点是它不需要我们的类型检查器“了解”多态性。相反，核心类型语言可以继续是单态的，而所有（第一级）多态性完全通过扩展处理。这为向语言添加多态性提供了一种廉价的策略，尽管——如 C++所示——它也引入了显着的开销。

最后，尽管我们只关注函数，但前面的讨论同样适用于数据结构。

### 15.3.1.5 替代实现

有其他实施策略不会受到这些问题的影响。我们不会在这里详细介绍它们，但至少其中一些的本质是我们上面概述的“缓存”方法。因为我们可以确定，对于给定的类型参数集，我们总是会得到相同类型的函数体，我们永远不需要在相同类型上两次实例化多态函数。这避免了无限循环。如果我们一次对实例化的函数体进行类型检查，我们就可以避免在相同类型的其他实例化上进行检查（因为函数体不会改变）。此外，我们也不需要保留实例化的源代码：一旦我们检查了扩展程序，我们就可以丢弃扩展术语，只保留运行时的一个副本。这避免了上面纯解糖策略中讨论的所有问题，同时保留了好处。

其实，我们有点太轻率了。静态类型的一个好处是，它们使我们能够选择更精确的运行时表示。例如，静态类型可以告诉我们是 32 位还是 64 位的数字，或者是 32 位值还是 1 位值（实际上，是一个布尔值）。编译器然后可以为每个表示生成专门的代码，利用位的布局方式（例如，32 个布尔值可以打包到一个 32 位的字中）。因此，在每个使用的类型进行类型检查后，多态实例化器可以跟踪函数或数据结构使用的所有特殊类型，并将此信息提供给编译器进行代码生成。然后，这将导致函数的多个副本，它们彼此不等同，但有很好的原因，并且因为它们的操作确实不同，所以是正确的。

### 15.3.1.6 关系参数化

关于多态性，还有一个细节我们必须解决。

我们之前说过像 cons 这样的函数不依赖于其参数的具体值。这也适用于 map、filter 等函数。当 map 和 filter 想要操作单个元素时，它们接受另一个函数作为参数，而这个函数则负责决定如何处理元素；map 和 filter 本身只是遵循其参数函数的规则。

一种“测试”这个命题是否正确的方法是替换参数列表中的一些不同值，以及相应不同的参数函数。也就是说，想象我们有两组值之间的关系；我们根据这个关系转换列表元素，以及参数函数。问题是，map 和 filter 的输出是否也可以通过这个关系来预测？如果对于某些输入，map 的输出不符合这个关系，那么必然是因为 map 检查了实际的值，并根据这些信息执行了某些操作。但实际上，这种情况不会发生在 map 上，或者说是大多数标准的多态函数上。

遵循这种关系规则的函数被称为关系参数化。这是类型给我们带来的另一个非常强大的属性，因为它告诉我们这些多态函数能执行的操作有很强的限制：基本上，它们可以丢弃、复制和重新排列元素，但不能直接检查和做出决策。

起初这听起来非常令人印象深刻（而且确实如此！），但仔细检查后，您可能会意识到这与您的经验不符。例如，在 Java 中，一个多态方法仍然可以使用 instanceof 来检查在运行时获得的特定类型的值，并相应地更改其行为。这样的方法确实不是关系参数化的！在网络上，您经常会发现这种属性被描述为函数无法检查参数的能力—<wbr>这并不完全正确。事实上，关系参数化同样可以被视为语言弱点的陈述：它只允许一组非常有限的操作。（您仍然可以检查类型—<wbr>但不能根据所学到的内容采取行动，这使得检查毫无意义。因此，一个想要模拟关系参数化的运行时系统必须删除诸如 instanceof 以及各种代理的操作：例如，将值加 1 并捕获异常将会显示该值是否为数字。）尽管如此，这是一个非常优雅和令人惊讶的结果，展示了具有丰富类型系统可能实现的程序推理能力。

### 15.3.2 类型推断

在程序中到处写多态类型实例化可能是一个非常令人沮丧的过程，许多 Java 和 C++的用户可以证明这一点。想象一下，如果在我们的程序中，每次我们写 first 或 rest 时，还必须为其实例化一个类型！我们能够避免这种命运的原因是因为我们的语言实现了类型推断。这就是使我们能够编写定义

> | （定义（mapper f l） |
> | --- |
> |   （条件 |
> |     [（l 为空？）空] |
> |     [（cons？ l）（cons （f （first l）） （mapper f （rest l））]）） |

并让编程环境自动声明

| > 映射器 |
| --- |
| - （'a -> 'b）（'a 的列表）->（'b 的列表） |

这不仅是正确的类型，而且是一个非常通用的类型！能够仅通过程序结构推导出这样通用类型的过程几乎感觉像是魔术。现在让我们看看幕后。

首先，让我们了解类型推断在做什么。有些人错误地认为具有推断的语言没有类型声明，推断取代了它们。这在多个层面上是混淆的。首先，即使在具有推断的语言中，程序员也可以自由地（并且出于文档目的，通常被鼓励—<wbr>就像您一直在做的那样）有时，推断也是不可判定的，程序员别无选择，只能声明一些类型。最后，编写显式注释可以大大减少难以理解的错误消息。声明类型。此外，在没有这些声明的情况下，推断实际意味着什么并不太清楚。

相反，更好的想法是将底层语言视为完全、明确标注类型的—<wbr>就像我们刚刚学习的多态语言[REF]一样。我们只需说我们可以将冒号后面的类型注释留空，并假设某个编程环境特性会为我们填充它们。（如果我们可以做到这一点，我们也可以去掉冒号和额外的修饰，让它们都自动插入。因此，推断只是一个方便用户减轻写类型注释负担的功能，但底层语言是明确标注类型的。

我们如何思考推断的作用？假设我们有一个表达式（或程序）e，写在一个明确标注类型的语言中：即，e 在需要的地方都有类型注释。现在假设我们擦除 e 中的所有注释，并使用一个推断过程来推断它们。

现在就做！

> 我们期望推断具有什么属性？

我们可以要求它做很多事情。其中之一可能是它产生准确那些我们最初拥有的注释。这在很多方面都是有问题的，最重要的是，e 可能甚至无法通过类型检查，那么推断怎么可能知道它们是什么（因此应该是什么）？这可能让你觉得这是一个琐碎的小事：毕竟，如果 e 没有通过类型检查，擦除其注释并重新填写它们能让它通过吗？既然两个程序都无法通过类型检查，谁在乎呢？

现在就做！

> 这种推理正确吗？

假设 e 是

> | (lambda ([x : number]) : string x) |
> | --- |

这个过程显然无法通过类型检查。但如果我们擦除类型注释——<wbr>获得

> | (lambda (x) x) |
> | --- |

—<wbr>我们同样显然得到一个可类型化的函数！因此，一个更合理的要求可能是，如果原始的 e 通过了类型检查，那么用推断类型替换注释的版本也必须通过。这种单向蕴含在两个方面都很有用：

1.  它并没有说明如果 e 无法通过类型检查会发生什么，即，它并没有排除我们目前拥有的使上面错误类型的身份函数可类型化的类型推断算法。

1.  更重要的是，它向我们保证我们通过使用类型推断不会损失任何东西：以前可类型化的程序现在不会停止可类型化。这意味着我们可以专注于在我们想要的地方使用明确的注释，但不会被迫这样做。当然，这仅在推断是可判定的情况下成立。

我们可能也期望这两个版本的类型相同，但这并不是一定的：函数

> | (lambda ([x : number]) : number x) |
> | --- |

类型为(number -> number)，而在擦除类型后应用推断后，得到一个更一般的类型。因此，关联这些类型并给出类型相等的精确定义并不是简单的，尽管我们稍后将简要回到这个问题[REF]。

有了这些准备工作，我们现在准备深入探讨类型推断的机制。最重要的一点是，我们简单的递归下降类型检查算法[REF]将不再适用。这是可能的，因为我们已经在所有函数边界上有了注释，所以我们可以降入函数体时携带关于这些注释的信息在类型环境中。没有这些注释，如何下降并不清楚。

实际上，并不清楚有什么特定的方向比其他方向更有意义。在上面的 mapper 定义中，每段代码都会影响其他部分。例如，将 empty?、cons?、first 和 rest 应用于 l 都指向它是一个列表。但是一个什么样的列表？我们无法从这些操作中得知。然而，我们对每个（或者说，任何）第一个元素应用 f 的事实意味着列表成员必须是可以传递给 f 的类型。同样，我们知道输出必须是一个列表，因为有 cons 和 empty。但它的元素是什么？它们必须是 f 的返回类型。最后，注意到一些非常微妙的东西：当参数列表为空时，我们返回 empty，而不是 l（我们知道此时 l 绑定到 empty）。使用前者使得返回的类型可以是任何类型的列表（仅受 f 返回的限制）；使用后者将强制它与参数列表的类型相同。

所有这些信息都在函数中。但我们如何系统地提取它，并在一个终止且具有我们上面所述属性的算法中提取它呢？我们分两步来做。首先，我们基于程序术语生成约束，确定类型必须是什么。然后，我们解决约束，识别不一致性，并将散布在函数体中的约束合并在一起。每一步都相对简单，但组合起来就会产生魔力。

### 15.3.2.1 约束生成

我们的最终目标是找到一个类型填充到每个类型注释位置。找到每个表达式的类型同样重要。稍加思考就会发现，这可能是必要的：例如，我们如何确定在不知道其主体类型的情况下在函数上放置类型？这也足够了，因为如果每个表达式的类型都已计算出来，那么这将包括那些需要注释的表达式。

首先，我们必须生成约束条件以便（稍后）解决。约束生成会遍历程序源代码，在每个表达式上发出适当的约束，并返回这组约束。它主要通过递归下降来实现简单性；实际上它确实计算出一组约束，因此在原则上遍历和生成的顺序并不重要—<wbr>所以我们可能会选择递归下降，这很容易—<wbr>尽管为了简单起见，我们将使用列表来表示这组约束。

约束是什么？它们只是关于表达式类型的陈述。此外，尽管变量的绑定实例不是表达式，但我们也必须计算它们的类型（因为函数需要参数和返回类型）。一般来说，我们能对表达式的类型说些什么？

1.  它与某个标识符的类型相关。

1.  它与其他表达式的类型相关。

1.  它是一个数字。

1.  它是一个函数，其定义域和值域类型可能受到进一步限制。

因此，我们定义以下两种数据类型：

> | (define-type Constraints |
> | --- |
> |   [eqCon (lhs : Term) (rhs : Term)]) |
> |   |
> | (define-type Term |
> |   [tExp (e : ExprC)] |
> |   [tVar (s : symbol)] |
> |   [tNum] |
> |   [tArrow (dom : Term) (rng : Term)]) |

现在我们可以定义生成约束的过程：

<constr-gen>)) ::=

> | (define (cg [e : ExprC]) : (listof Constraints) |
> | --- |
> |   (type-case ExprC e |
> |     <constr-gen-numC-case>)) |
> |     <constr-gen-idC-case>)) |
> |     <constr-gen-plusC/multC-case>)) |
> |     <constr-gen-appC-case>)) |
> |     <constr-gen-lamC-case>)))) |

当表达式是一个数字时，我们唯一能说的是我们期望表达式的类型是数字：

<constr-gen-numC-case>)) ::=

> [numC (_) (list (eqCon (tExp e) (tNum)))]

这听起来可能微不足道，但我们不知道的是，包含它的外部表达式对该表达式还有什么其他期望。因此，存在着一种可能性，即一些外部表达式将与该表达式的类型必须是数字的断言相矛盾，从而导致类型错误。

对于一个标识符，我们只是说表达式的类型是我们期望的标识符类型：

<constr-gen-idC-case>)) ::=

> [idC (s) (list (eqCon (tExp e) (tVar s)))]

如果上下文限制了其类型，那么这个表达式的类型将自动受到限制，并且必须与其上下文对其期望的一致。

加法让我们首次看到上下文约束。对于加法表达式，我们必须首先确保在两个子表达式中生成（和返回）约束，这可能是复杂的。完成后，我们期望什么？我们期望每个子表达式都是数字类型。（如果一个子表达式的形式要求的类型不是数字，这将导致类型错误。）最后，我们断言整个表达式的类型本身是数字。append3 只是 append 的三参数版本。

<constr-gen-plusC/multC-case>)) ::=

> | [plusC (l r) (append3 (cg l) |
> | --- |
> |                       (cg r) |
> |                       (list (eqCon (tExp l) (tNum)) |
> |                             (eqCon (tExp r) (tNum)) |
> |                             (eqCon (tExp e) (tNum))))] |

多元 C 的情况与变种名称除外是相同的。

现在我们来看看另外两种有趣的情况，即函数声明和应用。在这两种情况下，我们都必须记得生成并返回子表达式的约束。

在函数定义中，函数的类型是函数（“箭头”）类型，其参数类型是形式参数的类型，返回类型是主体的类型：

<constr-gen-lamC-case>)) ::=

> | [lamC (a b) (append (cg b) |
> | --- |
> |                     (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))] |

最后，我们有应用程序。我们不能直接陈述应用程序类型的约束。相反，我们可以说，应用程序位置的函数必须消耗实际参数表达式类型的参数，并返回应用程序表达式类型的类型：

<constr-gen-appC-case>)) ::=

> | [appC (f a) (append3 (cg f) |
> | --- |
> |                      (cg a) |
> |                      (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))] |

就这样！我们已经完成了生成约束的过程；现在我们只需要解决它们。

### 15.3.2.2 使用统一解决约束

用于解决约束的过程称为统一。一个统一器被赋予一组方程。每个方程将一个变量映射到一个项，其数据类型如上所示。请注意一个微妙的问题：我们实际上有两种类型的变量。 tvar 和 tExp 都是“变量”，前者显然如此，但后者同样如此，因为我们需要解决这些表达式的类型。（另一种形式将为每个表达式引入新的类型变量，但我们仍然需要一种方法来标识哪些变量对应于哪些表达式，这样，已经在表达式上 eq 的将自动执行。此外，这将生成更大的约束集合，使视觉检查令人生畏。）

对于我们的目的，统一的目标是生成一个替换，或者从不包含任何变量的项到变量的映射。这应该听起来很熟悉：我们有一组同时方程，其中每个变量都被线性使用；这样的方程使用高斯消元法解决。在这种情况下，我们知道我们可能会得到既不完全受限也不完全受限的系统。同样的情况也可能发生在这里，我们很快就会看到。

统一算法在约束集合上迭代工作。因为每个约束方程有两个项，每个项可以是四种中的一种，因此基本上有十六种情况要考虑。幸运的是，我们可以用更少的实际代码案例来涵盖所有十六种情况。

算法从所有约束集合和空替换开始。每个约束只考虑一次并从集合中移除，因此原则上终止参数应该非常简单，但实际上会稍微棘手一些。随着约束的消失，替换集合倾向于增长。当所有约束都被处理完毕时，统一返回最终的替换集合。

对于给定的约束条件，统一器检查方程的左侧。如果它是一个变量，那么现在它已经准备好被消除了。统一器将变量的右侧加入到替换中，并且为了真正消除它，用该右侧替换替换中的变量的所有出现。在实践中，这需要高效地实现；例如，使用这些变量的可变表示可以避免不得不搜索和替换所有出现。然而，在我们可能需要回溯的情况下（正如我们将在统一存在的情况下所做的那样[REF]），可变实现有它自己的缺点。

现在做！

> 你注意到上面微妙的错误了吗？

这个微妙的错误就在这里。我们说统一器通过替换替换中的所有实例来消除变量。然而，这假设右侧不包含相同变量的任何实例。否则我们就有了循环定义，并且执行这个特定的替换变得不可能。因此，统一器包括一个出现检查：检查是否在两边都出现相同的变量，如果是，则拒绝统一。

现在做！

> 构造一个触发发生检查的约束的项。

你还记得 ω 吗？

现在让我们考虑统一的实现。传统上用希腊字母 Θ 表示替换。

> | (定义类型别名 替换 (替换列表)) |
> | --- |
> | (定义类型 替换 |
> |   [sub [var : 项] [是 : 项]]) |
> |   |
> | (定义 (统一 [cs : (约束列表)]) : 替换 |
> |   (统一/Θ cs empty)) |

让我们先把简单的部分处理掉：

<统一/Θ>)) ::=

> | (定义 (unify/Θ [cs : (约束列表)] [Θ : 替换]) : 替换 |
> | --- |
> |   (条件 |
> |     [(空? cs) Θ] |
> |     [(cons? cs) |
> |      (让 ([l (eqCon-lhs (第一个 cs))] |
> |            [r (eqCon-rhs (第一个 cs))]) |
> |        (类型-情况 项 l |
> |          <统一/Θ-tVar-case>)) |
> |          <统一/Θ-tExp-case>)) |
> |          <统一/Θ-tNum-case>)) |
> |          <统一/Θ-tArrow-case>))))])) |

现在我们准备进行统一的核心部分。我们将依赖一个带有这个签名的函数，extend+replace：(Term Term Subst -> Subst)。我们期望它执行出现测试，如果失败（即没有循环），则扩展替换并在替换中替换第一个术语的所有现有实例为第二个术语。类似地，我们将假设 lookup 的存在：(Term subst -> (optionof Term))

练习

> 定义 extend+replace 和 lookup。

如果约束方程的左侧是一个变量，我们首先在替换中查找它。如果存在，则用新约束替换当前约束；否则，我们扩展替换：

<统一/Θ-tVar-case>)) ::=

> | [tVar (s) (type-case (optionof Term) (lookup l Θ) |
> | --- |
> |             [some (bound) |
> |                   (统一/Θ (cons (eqCon bound r) |
> |                                  (rest cs)) |
> |                            Θ)] |
> |             [无 () |
> |                   (统一/Θ (rest cs) |
> |                            (extend+replace l r Θ))])] |

当表达式标识符时，逻辑相同：

<统一/Θ-tExp-case>)) ::=

> | [tExp (e) (type-case (optionof Term) (lookup l Θ) |
> | --- |
> |             [some (bound) |
> |                   (统一/Θ (cons (eqCon bound r) |
> |                                  (rest cs)) |
> |                            Θ)] |
> |             [无 () |
> |                   (统一/Θ (rest cs) |
> |                            (extend+replace l r Θ))])] |

如果是基本类型，比如数字，那么我们检查右侧。有四种可能性，对应四种不同类型的术语：

+   如果是一个数字，那么我们有一个方程声称类型 num 与类型 num 相同，这显然是真实的。因此，我们可以忽略这个约束—<wbr>因为它没有告诉我们任何新信息—<wbr>并继续处理其余部分。

    当然，你应该质疑为什么这样一个约束会首次出现。显然，我们的约束生成器没有生成这样的约束。然而，当前替换的先前扩展可能导致这种情况。实际上，在实践中我们会遇到几种这样的情况。

+   如果是函数类型，则显然存在类型错误，因为数字类型和函数类型是不相交的。再次强调，我们永远不会直接生成这样的约束，但它必定是由先前的替换导致的。

+   它可能是两种变量种类之一。然而，我们已经仔细安排我们的约束生成器，永远不会将这些放在右侧。此外，替换也不会在右侧引入它们。因此，这两种情况不会发生。

这导致以下代码：<统一/Θ-tNum-case>)) ::=

> | [tNum () (type-case Term r |
> | --- |
> |            [tNum () (统一/Θ (rest cs) Θ)] |
> |            [else (error 'unify "数字和其他内容")])] |

最后，我们留下了函数类型。在这里，论证几乎与数值类型完全相同。

<unify/Θ-tArrow-case>)) ::=

> | [tArrow (d r) (type-case Term r |
> | --- |
> |                 [tArrow (d2 r2) |
> |                         (unify/Θ (cons (eqCon d d2) |
> |                                        (cons (eqCon r r2) |
> |                                              cs)) |
> |                                  Θ)] |
> |                 [else (error 'unify "箭头和其他内容")])] |

请注意，我们并不总是缩小约束集的大小，因此简单的论证并不足以证明终止性。相反，我们必须基于约束集的大小以及替换的大小（包括其中的变量数量）进行论证。

上述算法非常通用，适用于各种类型术语，不仅仅是数字和函数。我们已经将数字用作所有基本类型的替代品；同样，函数代表所有构造类型，例如 listof 和 vectorof。

至此，我们完成了。统一化产生了一个替换。我们现在可以遍历替换并找到程序中所有表达式的类型，然后相应地插入类型注释。一个定理，我们在这里不会证明，规定了上述过程的成功意味着程序将会通过类型检查，因此我们不需要在此程序上显式运行类型检查器。

然而，请注意，类型错误的性质现在发生了显著变化。以前，我们有一个递归下降算法，使用类型环境遍历表达式。类型环境中的绑定是程序员声明的类型，因此可以被视为（预期的）权威类型规范。因此，任何不匹配都归咎于表达式，并报告类型错误是简单的（易于理解）。然而，在这里，类型错误是一种未通知的失败。统一失败基于两个智能算法——约束生成和统一——发生的事件，因此不一定可以被程序员理解。特别是，这些约束的等式性质意味着报告错误的位置和“真正”错误的位置可能相距甚远。因此，生成更好的错误消息仍然是一个活跃的研究领域。在实践中，该算法将维护有关涉及的程序源项以及可能的统一历史的元数据，以便能够将错误追溯到源程序。

最后，请记住，约束可能不会准确地规定所有变量的类型。如果方程组过于约束，那么我们就会得到冲突，从而导致类型错误。如果相反，系统过于约束，那么意味着我们没有足够的信息来对所有表达式做出明确的陈述。例如，在表达式(lambda (x) x)中，我们没有足够的约束来指示 x 的类型，因此也无法确定整个表达式的类型。这不是一个错误；它只是意味着 x 可以是任何类型。换句话说，它的类型是“x 的类型 -> x 的类型”，没有其他约束。这些欠约束标识符的类型被表示为类型变量，因此上述表达式的类型可能被报告为（'a -> 'a）。

统一算法实际上具有一种奇妙的属性：它自动计算出表达式的最一般类型，也称为主类型。也就是说，表达式可以具有的任何实际类型都可以通过用实际类型实例化推断出的类型变量来获得。这是一个了不起的结果：在计算机战胜人类的另一个例子中，它表明没有人可以生成比上述算法更一般的类型！

### 15.3.2.3Let-多态

不幸的是，尽管这些类型变量在表面上与我们之前拥有的多态性相似[REF]，但它们并不相同。考虑以下程序：

> | (let ([id (lambda (x) x)]) |
> | --- |
> |   (if (id true) |
> |       (id 5) |
> |       (id 6))) |

如果我们使用显式类型注释来写，它会通过类型检查：

> | (if ((id boolean) true) |
> | --- |
> |     ((id number) 5) |
> |     ((id number) 6)) |

但是，如果我们使用类型推断，情况就不一样了！这是因为类型 id 中的'a 会与布尔值或数字统一，这取决于约束处理的顺序。在那一点上，id 实际上会成为一个布尔值->布尔值函数或数字->数字函数。在使用另一种类型的 id 时，我们会得到一个类型错误！

这是因为我们通过统一推断的类型实际上并不是多态的。这一点很重要：仅仅因为你有类型变量，并不意味着你已经见识过多态性！类型变量可能在下次使用时被统一，而你最终得到的只是一个单纯的单态函数。相反，真正的多态性只有在类型变量真正实例化时才会产生。

在具有真正多态性的语言中，约束生成和统一不足以满足需求。相反，像 ML、Haskell 甚至我们的类型编程语言这样的语言，实现了俗称的 let-多态。在这种策略中，当一个带有类型变量的项在词法上下文中被绑定时，类型会自动提升为量化类型。在每次使用时，该项实际上会自动实例化。

有许多实现策略可以完成这个任务。最简单（也是最不令人满意的）的方法是仅仅复制绑定标识符的代码；因此，以上每个 id 的使用都会得到自己的 (lambda (x) x) 的副本，因此每个都会有自己的类型变量。第一个可能得到类型 (’a -> ’a)，第二个 (’b -> ’b)，第三个 (’c -> ’c)，依此类推。这些类型变量都不会冲突，因此我们获得了多态的效果。显然，这不仅增加了程序的大小，而且在存在递归的情况下也无法工作。然而，这为我们提供了更好解决方案的见解：与其复制代码，为什么不只复制类型呢？因此，在每个使用处，我们都会创建推断类型的重命名副本：id 的 (’a -> ’a) 在第一次使用时变为 (’b -> ’b)，依此类推，从而实现与复制代码相同的效果，但没有它的负担。然而，由于所有这些策略实际上都模拟了复制代码的行为，它们只在词法上下文中起作用。

### 15.3.3 联合类型

假设我们想构造一个动物园动物的列表，其中有许多种类：犰狳、蟒蛇等。目前，我们被迫创建一个新的数据类型：“在德克萨斯州，路中间什么也没有，只有一条黄线和死去的犰狳。”—<wbr>Jim Hightower

> | (定义类型 Animal |
> | --- |
> |    [犰狳 (alive? : boolean)] |
> |    [蟒蛇 (length : number)]) |

并制作这些的列表：(动物的列表)。因此，类型 Animal 表示了犰狳和蟒蛇的“联合”，除非唯一的构造这种联合的方式是每次都创建一个新类型：如果我们想表示动物和植物的联合，我们需要

> | (定义类型 LivingThings |
> | --- |
> |    [动物 (a : Animal)] |
> |    [植物 (p : Plant)]) |

因此，一个实际的动物现在多了一个额外的“级别”。这些数据类型被称为带标签的联合或可辨识联合，因为我们必须引入显式标签（或辨别符），如动物和植物，来将它们区分开来。反过来，一个结构体只能存在于数据类型声明内部；我们不得不创建只有一个变体的数据类型，比如

> | (定义类型 Constraints |
> | --- |
> |    [eqCon (lhs : Term) (rhs : Term)]) |

来保存数据类型，而我们到处都必须使用类型 Constraints，因为 eqCon 本身不是一种类型，它只是一个在运行时可以区分的变体。

无论哪种方式，联合类型的目的是表示一个析取，或“或”。一个值的类型是联合中的一个类型。一个值通常只属于联合中的一个类型，尽管这取决于联合类型的定义方式，是否有规则来对其进行归一化，等等。

### 15.3.3.1 结构体作为类型

对此的自然反应可能是，为什么不取消这个限制？为什么不允许每个结构独立存在，并定义一个类型为一些结构集合的联合？毕竟，在从 C 到 Racket 的各种语言中，程序员可以定义独立的结构，而无需将它们包装在带有标签构造函数的其他类型中！例如，在原始的 Racket 中，我们可以写

> | (struct armadillo (alive?)) |
> | --- |
> | (struct boa (length)) |

并附上一条注释

> | ;; 一个动物要么是 |
> | --- |
> | ;; - (armadillo <boolean>) |
> | ;; - (boa <number>) |

但是没有强制的静态类型，比较会变得混乱。然而，我们可以更直接地与 Typed Racket 进行比较，这是 Racket 的一种带类型的形式，内置于 DrRacket 中。以下是相同的带类型代码：

> | #lang [typed/racket](http://docs.racket-lang.org/ts-reference/index.html) |
> | --- |
> |   |
> | (struct: armadillo ([alive? : Boolean])) |
> | (struct: boa ([length : Real])) ;; feet |

现在我们可以定义消耗蟒蛇类型值的函数，而无需提及犰狳：

> | ;; http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight |
> | --- |
> | (define: (big-one? [b : boa]) : Boolean |
> |   (> (boa-length b) 8)) |

实际上，如果我们将这个函数应用于任何其他类型，包括犰狳—<wbr>(big-one? (armadillo true))—<wbr>我们会得到一个静态错误。这是因为犰狳与蟒蛇或数字或字符串一样没有关联。当然，我们仍然可以定义这些类型的联合：

> | (define-type Animal (U armadillo boa)) |
> | --- |

并对其进行函数操作：

> | (define: (safe-to-transport? [a : Animal]) : Boolean |
> | --- |
> |   (cond |
> |     [(boa? a) (not (big-one? a))] |
> |     [(armadillo? a) (armadillo-alive? a)])) |

以前我们有一个具有两个变体的类型，现在我们有三种类型。碰巧两种类型形成了一个便利的联合来定义第三种类型。

### 15.3.3.2 未标记联合

看起来我们仍然需要有区分性的标签，但实际上不需要。在具有联合类型的语言中，选项类型构造函数的效果通常通过将预期的返回类型与表示失败或无效的不同类型结合来实现。例如，这是（number 的选项）的道德等价物：

> | (define-type MaybeNumber (U Number Boolean)) |
> | --- |

实际上，布尔值本身可能是 True 和 False 的联合，就像在 Typed Racket 中一样，因此选项类型的更准确的模拟可能是：

> | (define-type MaybeNumber (U Number False)) |
> | --- |

更一般地，我们可以定义

> | (struct: none ()) |
> | --- |
> | (define-type (Maybeof T) (U T none)) |

这对所有类型都适用，因为 none 是一个新的、独特的类型，��会与任何其他类型混淆。这给我们带来了与选项类型相同的好处，只是我们想要的值不是埋在某个结构的一级深处，而是立即可用。例如，考虑 member，它具有以下 Typed Racket 类型：

> | (All (a) (a (Listof a) -> (U False (Listof a)))) |
> | --- |

如果未找到元素，member 返回 false。否则，它将返回从该元素开始的列表（即，列表的第一个元素将是所需的元素）：

| > (member 2 (list 1 2 3)) |
| --- |
| '(2 3) |

要将其转换为使用 Maybeof，我们可以编写

> | (define: (t) (in-list? [e : t] [l : (Listof t)]) : (Maybeof (Listof t)) |
> | --- |
> |   (let ([v (member e l)]) |
> |     (if v |
> |         v |
> |         (none)))) |

如果未找到元素，则返回值(none)，但如果找到，则仍然返回一个列表

| > (in-list? 2 (list 1 2 3)) |
| --- |
| '(2 3) |

因此，无需从某个包装器中删除列表。

### 15.3.3.3 区分未标记的联合

将值放入联合是一回事；我们还必须考虑如何以良好类型的方式取出它们。在我们的类似 ML 的类型系统中，我们使用一种风格化的符号—<wbr>在我们的语言中是 type-case，在 ML 中是模式匹配—<wbr>来识别和分解这些部分。特别是，当我们写

> | (define (safe-to-transport? [a : Animal]) : boolean |
> | --- |
> |   (type-case Animal a |
> |     [armadillo (a?) a?] |
> |     [boa (l) (not (big-one? l))])) |

a 的类型在整个表达式中保持不变。标识符 a?和 l 分别绑定到布尔值和数值，big-one?现在必须编写以消耗这些类型，而不是 armadillo 和 boa。换句话说，我们不能有一个消耗 boas 的函数 big-one?，因为没有这种类型。相反，对于联合类型，我们确实有 boa 类型。因此，我们遵循这样一个原则，即向值询问谓词会缩小类型。例如，在 cond 情况中

> | [(boa? a) (not (big-one? a))] |
> | --- |

虽然 a 最初是 Animal 类型，但在通过 boa?测试后，类型检查器应将其类型缩小为仅 boa 分支，以便 big-one?的应用是良好类型的。反过来，在条件的其余部分中，它的类型不是 boa—<wbr>在这种情况下，只剩下一种可能性，即 armadillo。这对类型检查器测试和识别某些模式的能力施加了更大的压力—<wbr>称为 if-splitting—<wbr>没有这些模式，使用联合类型将是不可能的；但它总是可以默认识别仅那些类似 ML 系统将识别的模式，例如模式匹配或 type-case。

### 15.3.3.4 类型改造

并不奇怪 Typed Racket 使用联合类型。它们在为现有编程语言添加类型时特别有用，这些编程语言的程序并没有考虑到类似 ML 的类型纪律，比如脚本语言。这种后续添加类型的常见原则是尽可能静态地捕获尽量多的动态异常。当然，类型检查器最终必须拒绝一些程序，除非它实现了一个有趣的称为软类型的想法，它不会拒绝任何程序，但会提供有关程序无法被类型化的点的信息。如果它拒绝了太多本来可以正常运行的程序，开发者就不太可能采用它。因为这些程序是在没有考虑类型检查的情况下编写的，所以类型检查器可能需要采取英雄式的措施来接受在语言中被认为是合理习惯的东西。

考虑下面的 JavaScript 函数：

| var slice = function (arr, start, stop) { |
| --- |
|   var result = []; |
|   for (var i = 0; i <= stop - start; i++) { |
|     result[i] = arr[start + i]; |
|   } |
|   return result; |
| } |

它接受一个数组和两个索引，并生成这些索引之间的子数组。例如，slice([5, 7, 11, 13], 0, 2) 产生 [5, 7, 11]。然而在 JavaScript 中，开发者可以自由地忽略函数的任意尾随参数。每个省略的参数都被赋予一个特殊值，undefined，并且由函数来处理这种情况。例如，splice 的典型实现会让用户省略第三个参数；下面是定义

| var slice = function (arr, start, stop) { |
| --- |
|   if (typeof stop == "undefined") |
|     stop = arr.length - 1; |
|   var result = []; |
|   for (var i = 0; i <= stop - start; i++) { |
|     result[i] = arr[start + i]; |
|   } |
|   return result; |
| } |

自动返回数组直到末尾的子数组：因此，slice([5, 7, 11, 13], 2) 返回 [11, 13]。在 Typed JavaScript 中，在 Brown 大学由 Arjun Guha 和其他人构建。请参见 [我们的网站](http://www.jswebtools.org/)。程序员可以通过给参数赋予类型 U Undefined 来显式指示函数接受更少的参数，从而将其类型定义为

> | ∀ t : (Array[t] * Int * (Int U Undefined) -> Array[t]) |
> | --- |

从原理上讲，这意味着表达式 stop - start 可能存在潜在的类型错误，因为 stop 可能不是一个数字。然而，对 stop 的赋值在用户省略时将其设置为数值类型。换句话说，在所有控制路径中，在减法发生之前，stop 最终都会具有数值类型，因此此函数是类型正确的。当然，这要求类型检查器能够推理控制流（通过条件语句）和状态（通过赋值语句），以确保此函数是类型正确的；但是 Typed JavaScript 可以做到这一点，因此可以为此类函数提供保证。

### 15.3.3.5 设计选择

使用联合类型的语言，通常会有

+   独立的结构类型（通常使用类表示），而不是具有变体的数据类型。

+   临时收集结构以表示特定类型。

+   使用哨兵值表示失败。

将按照这种风格编写的程序转换为类似 ML 的类型规则将是非常繁重的。因此，许多后期添加的类型系统采用联合类型来简化类型化过程。在上述三个属性中，第一个属性似乎是道德上中立的，但其他两个值得更多讨论。我们将逆序讨论它们。

+   让我们先来解决哨兵问题。在许多情况下，哨兵应该被异常替代，但在许多语言中，异常可能非常昂贵。因此，开发人员更喜欢区分真正异常的情况——这种情况不应该发生——和在正常操作过程中预期到的情况。检查一个元素是否在列表中，并且找不到它显然属于后一种情况（如果我们已经知道元素是否存在，那么就不需要运行此谓词）。在后一种情况下，使用哨兵是合理的。

    然而，我们必须将这一观察结果与未检查异常哨兵值的事实相协调，这是 C 程序中错误的常见源头，甚至是安全漏洞。这很容易协调。在 C 中，哨兵与常规返回值的类型相同（或至少在效果上相同），而且没有运行时检查。因此，哨兵可以作为合法值使用，而不会产生类型错误。因此，哨兵的值为 0 可以被视为一个地址，用于分配数据，从而可能导致系统崩溃。相比之下，我们的哨兵是一个全新类型，不能用于任何计算中。我们可以通过观察到我们的语言中不存在消耗 none 类型值的现有函数来轻松地理解这一点。

+   暂时搁置“临时”的使用，这是带有贬义的，不同的结构集合是一个好主意吗？实际上，即使在使用类似 ML 的学科的程序中，当程序员想要划分一个较大集合的不同子宇宙时，这种分组也会发生。例如，ML 程序员使用类似于

    > | (define-type SExp |
    > | --- |
    > |   [numSexp (n : number)] |
    > |   [strSexp (s : string)] |
    > |   [listSexp (l : (listof SExp))]) |

    用于表示 s 表达式。如果一个函数现在只对这些术语的某个子集进行操作——比如只对数字和数字列表进行操作——他们必须创建一个新类型，并在这两种类型之间转换值，即使它们的底层表示基本上是相同的。另一个例子是考虑 CPS 表达式集。这显然是所有可能表达式的一个子集，但如果我们为它创建一个新的数据类型，我们将无法使用任何处理表达式的现有程序——比如解释器。

换句话说，联合类型似乎是我们之前见过的 ML 风格类型系统的一个合理变体。然而，即使在联合类型中也存在设计变化，这些变化会产生后果。例如，类型系统能否创建新的联合，或者是否允许用户定义（并命名）联合？也就是说，像这样的表达式是否允许

> | (if (phase-of-the-moon) |
> | --- |
> |     10 |
> |     true) |

允许类型（到（U Number Boolean）），还是引入以前未命名和显式标识的联合是类型错误？Typed Racket 提供了前者：它将构造真正的特设联合。这对于将现有代码导入到类型设置中可能更灵活，因为它更加灵活。然而，是否这是编写新代码的良好设计并不清楚，因为程序员不打算的联合可能会发生，而且没有办法阻止它们。这为编程语言设计空间中的一个未探索的角落提供了可能性。

### 15.3.4 命名型与结构型系统

在我们最初的类型检查器中，如果两种类型具有相同的结构，则认为它们是等价的。实际上，我们根本没有提供命名类型的机制，因此不清楚我们还有什么其他选择。

现在考虑 Typed Racket。一个开发者可以编写

> | (define-type NB1 (U Number Boolean)) |
> | --- |
> | (define-type NB2 (U Number Boolean)) |

随后

> | (define: v : NB1 5) |
> | --- |

假设开发者还定义了函数

> | (define: (f [x : NB2]) : NB2 x) |
> | --- |

并尝试将 f 应用于 v，即 (f v)：此应用是否应该进行类型检查？

有两种完全合理的解释。一种是说 v 被声明为 NB1 类型，这是一个不同于 NB2 的名称，因此应该被视为不同的类型，因此上述应用应该导致错误。这样的系统被称为命名型，因为类型的名称对于确定类型相等性至关重要。

相反，另一种解释是因为 NB1 和 NB2 的结构相同，所以开发者无法编写在这两种类型的值上行为不同的程序，因此这两种类型应该被视为相同。如果你想特别小心，你会注意到被认为相同和实际上相同之间存在区别。我们不会在这里讨论这个问题，但考虑一下对于编译器编写者选择值的表示方式的影响，尤其是在一种允许运行时检查值的静态类型的语言中。这样的类型系统被称为结构化的，并且会成功地为上述表达式提供类型。（Typed Racket 遵循结构化原则，再次减轻了导入现有的非类型代码的负担，这些代码——<wbr>在 Racket 中——<wbr>通常是以结构化解释为前提编写的。实际上，Typed Racket 不仅为 (f v) 提供了类型，它还将结果打印为具有类型 NB1，尽管在 f 上有返回类型的注释！）

名义类型和结构类型之间的区别在面向对象的语言中最常见的是有争议的，我们稍后会简要回到这个问题上[REF]。然而，本节的重点是说明这些问题并不本质上是关于“对象”的。任何允许类型被命名的语言——<wbr>正如所有的语言都必须，为了程序员的理智——<wbr>都必须处理这个问题：命名只是一种便利，还是选择的名称打算具有意义？选择前者的答案导致结构类型，而选择后者则走上了名义路径。

### 15.3.5 交集类型

既然我们刚刚探讨了联合类型，你自然会想知道是否也有交集类型。的确有。

如果联合类型意味着一个值（该类型的值）属于联合中的一个类型，则交集类型明确意味着该值属于交集中所有类型：一个连接词，或者“与”。这可能看起来很奇怪：一个值如何属于多个类型？

作为一个具体的答案，考虑重载函数。例如，在某些语言中，+可同时作用于数字和字符串；给定两个数字，它会产生一个数字，给定两个字符串，它会产生一个字符串。在这样的语言中，+的适当类型是什么？它不仅仅是（number number -> number），因为这将拒绝其在字符串上的使用。按照同样的推理，它也不是（string string -> string）单独的。甚至不是

> | （U （number number -> number） |
> | --- |
> |    （string string -> string）） |

因为 + 不仅仅是这些函数中的一个：它确实是它们两个。我们可以指定类型

> | ((number U string) (number U string) -> (number U string)) |
> | --- |

反映了每个参数和结果只能是这些类型中的一个，而不是两者兼而有之。然而，这样做会导致精度损失。现在做！

> 这种类型在哪些方面失去了精度？

请注意，对于此类型，在所有调用中返回类型都是（number U string）。因此，每次返回时，我们必须区分数值和字符串返回，否则将出现类型错误。因此，即使我们知道如果给定两个数字参数，我们将得到一个数字结果，这些信息也会丢失到类型系统中。

更微妙的是，这种类型允许每个参数的类型独立选择。因此，根据这种类型，调用（+ 3 "x"）是完全有效的（并产生类型为（number U string）的值）。但当然，我们指定的加法运算对这些输入根本没有定义！

因此，适当的类型来描述这种加法形式是

> | (∧ （number number -> number） |
> | --- |
> |    （string string -> string）） |

其中∧应该让人联想到逻辑中的合取运算符。这允许使用两个数字或两个字符串进行调用，但不能使用其他类型。使用两个数字进行调用会得到一个数字结果类型；使用两个字符串进行调用会得到一个字符串结果类型；其他情况则不行。这与我们对重载（有时也称为特定多态）的预期行为完全一致。请注意，这只处理有限数量的重载情况。

### 15.3.6 递归类型

现在我们已经看到了联合类型，回到我们最初的递归数据类型的制定。如果我们接受变体作为类型构造函数，我们能否将递归类型写成对这些变体的联合？例如，回到 BTnum，我们不应该能够将其描述为等价于

> | ((BTmt) U (BTnd number BTnum BTnum)) |
> | --- |

从而表明 BTmt 是一个零元构造函数，BTnd 需要三个参数？但是，这三个参数的类型是什么？在我们上面写的类型中，BTnum 要么是内置于类型语言中（这是不令人满意的），要么是未绑定的。也许我们的意思是

> | BTnum = ((BTmt) U (BTnd number BTnum BTnum)) |
> | --- |

但是现在我们有一个没有明显解决方案的等式（记得ω吗？）。这种情况应该是递归值中熟悉的。然后，我们发明了一个递归函数构造函数（并展示了其实现）来规避这个问题。我们同样需要一个递归类型构造函数。这通常被称为μ（希腊字母“mu”）。有了它，我们可以将上面的类型写成

> | μ BTnum : ((BTmt) U (BTnd number BTnum BTnum)) |
> | --- |

μ是一个绑定构造；它将 BTnum 绑定到其后的整个类型，包括 BTnum 本身的递归绑定。实际上，这整个递归类型就是我们希望称为 BTnum 的类型：

> | BTnum = μ BTnum : ((BTmt) U (BTnd number BTnum BTnum)) |
> | --- |

虽然这看起来像是一个循环定义，但请注意等式右侧的 BTnum 名称不依赖于左侧的名称：也就是说，我们可以将其重写为

> | BTnum = μ T : ((BTmt) U (BTnd number T��T)) |
> | --- |

换句话说，BTnum 的这个定义确实可以被视为语法糖，并且可以在程序中随处替换而不必担心无限回归。在语义层面上，通常有两种非常不同的方式来思考被μ绑定的类型的含义：它们可以被解释为等价递归或同构递归。然而，这两者之间的区别是微妙的，超出了本章的范围。这方面的材料在皮尔斯的书中特别详细地介绍。值得注意的是，递归类型可以被视为等价于其展开。例如，如果我们将一个数字列表类型定义为

> | NumL = μ T : ((MtL) U (ConsL number T)) |
> | --- |

然后

> |   μ T : ((MtL) U (ConsL number T)) |
> | --- |
> | = (MtL) U (ConsL number (μ T : ((MtL) U (ConsL number T)))) |
> | = (MtL) U (ConsL number (MtL)) |
> |         U (ConsL number (ConsL number (μ T : ((MtL) U (ConsL number T))))) |

等等（iso- 和 equi- 递归在何时认为相等的概念上有所不同：定义相等或同构）。在每一步中，我们只需用整个类型替换 T 参数。与值递归一样，这意味着我们可以根据需要“再获得”一个 ConsL 构造函数。换句话说，列表的类型可以写成零个或任意多个元素的并集；这与由零个、一个或任意多个元素组成的类型相同；等等。任何数字列表都符合所有（且准确地）这些类型。

注意，即使对 μ 的这种非正式理解，我们现在也可以为 ω 提供一个类型，从而为 Ω 提供一个类型。

练习

> 为 ω 和 Ω 赋予类型。

### 15.3.7 子类型化

想象我们有一个典型的二叉树定义；为简单起见，我们假设所有值都是数字。我们将在 Typed Racket 中编写这个示例以阐明一个观点：

> | #lang [typed/racket](http://docs.racket-lang.org/ts-reference/index.html) |
> | --- |
> |   |
> | (define-struct: mt ()) |
> | (define-struct: nd ([v : Number] [l : BT] [r : BT])) |
> | (define-type BT (U mt nd)) |

现在考虑一些具体的树值：

| > (mt) |
| --- |
| - : mt |
| #<mt> |
| > (nd 5 (mt) (mt)) |
| - : nd |
| #<nd> |

注意，每个结构构造函数都生成其自己类型的值，而不是 BT 类型的值。但考虑表达式 (nd 5 (mt) (mt))：nd 的定义声明子树必须是 BT 类型，然而我们成功地给它赋予了 mt 类型的值。

显然，我们将 BT 定义为 mt 和 nd 的组合并非巧合。然而，这表明在类型检查时，我们不能简单地检查函数相等性，至少不是我们迄今为止所做的那样。相反，我们必须检查一个类型是否“适合”另一个类型。这种适合的概念称为子类型化（以及适合的行为，包容性）。

子类型的本质是定义一个关系，通常用 <: 表示，它将类型对联系起来。我们说 S <: T 如果类型为 S 的值可以在期望类型为 T 的地方给出：换句话说，子类型化形式化了可替代性的概念（即，在期望类型为 T 的地方，可以用类型为 S 的值替换）。当这种情况成立时，S 被称为子类型，T 被称为超类型。采用子集解释是有用的（通常也是准确的）：如果 S 的值是 T 的一个子集，那么期望 T 值的表达式将不会因为只接收到 S 值而感到不愉快。

子类型对类型系统具有普遍影响。我们必须重新审视每种类型，并了解它与子类型的相互作用。对于基本类型，这通常是很明显的：像 number、string 等不相交的类型彼此无关。（在某些脚本语言中，一个基本类型用于表示另一个基本类型—<wbr>例如，在一些脚本语言中，数字只是用特殊语法编写的字符串，而在其他语言中，布尔值只是数字—<wbr>这种情况下，甚至可能存在基本类型之间的子类型关系，但这些情况并不常见。）然而，我们必须考虑子类型与每个复合类型构造器的相互作用。

实际上，甚至我们关于类型的措辞也必须改变。假设我们有一个类型为 T 的表达式。通常来说，我们会说它生成类型为 T 的值。现在，我们应该小心地说它生成最多或至多类型为 T 的值，因为它可能只生成 T 的子类型的值。因此，对类型的每个引用都应隐含地涉及到子类型的潜在性。为了避免打扰你，我将避免这样做，但请注意不考虑这种隐含解释可能会导致推理错误。

### 15.3.7.1 联合

让我们看看联合如何与子类型相互作用。显然，每个子联合都是整个联合的子类型。在我们的运行示例中，显然每个 mt 值也是一个 BT；nd 也是如此。因此，

> | mt <: BT |
> | --- |
> | nd <: BT |

因此，(mt) 也具有类型 BT，从而使表达式 (nd 5 (mt) (mt)) 自身具有类型，并且具有类型 nd—<wbr>因此，也具有类型 BT。一般来说，

> | S <: (S U T) |
> | --- |
> | T <: (S U T) |

(我们写了似乎是相同规则两次，只是为了明确它不管子类型在联合的“哪一边”。) 这意味着 S 的值可以被认为是 S U T 的值，因为任何类型为 S U T 的表达式确实可以包含类型为 S 的值。

### 15.3.7.2 交集

顺便提一下，我们还应该简要讨论交集。正如你可能想象的那样，交集的行为是对偶的：

> | (S ∧ T) <: S |
> | --- |
> | (S ∧ T) <: T |

为了让自己相信这一点，采用子集解释：如果一个值既是 S 又是 T，那么显然它是其中的一个。现在就做吧！

> 为什么以下两个不是有效的子摄取？
> 
> 1.  (S U T) <: S
> 1.  
> 1.  T <: (S ∧ T)

第一个不是有效的，因为类型为 T 的值是类型为 (S U T) 的元素的完全有效成员。例如，数字是 (string U number) 类型的成员。然而，数字不能被提供给期望类型为 string 的值的位置。

至于第二个，一般来说，类型为 T 的值不是类型为 S 的值。任何 (S ∧ T) 值的使用者都期望能够将其视为 T 和 S，但后者是不合理的。例如，给定我们之前重载的 +，如果 T 是 (number number -> number)，那么这种类型的函数将不知道如何操作字符串。

### 15.3.7.3 函数

我们还看到了另一个构造器：函数。我们还看到了参数化数据类型。在本版本中，探索它们的子类型化被留作读者的练习。因此，我们必须确定当任一类型都可以是函数时的子类型化规则。由于我们通常假设函数与所有其他类型不相交，因此我们只需要考虑一个函数类型何时是另一个函数类型的子类型：即，

> | (S1 -> T1) <: (S2 -> T2) |
> | --- |

为方便起见，让我们将类型 (S1 -> T1) 称为 f1，(S2 -> T2) 称为 f2。那么问题就是，如果一个表达式期望 f2 类型的函数，我们何时可以安全地给它 f1 类型的函数？使用子集解释最容易思考这个问题。

考虑一下 f2 类型的使用。它返回类型为 T2 的值。因此，函数应用周围的上下文会使用类型为 T2 的值。显然，如果 T1 和 T2 相同，那么使用 f2 会继续类型；同样，如果 T1 包含 T2 值的子集，那也没问题。唯一的问题是如果 T1 的值比 T2 多，因为上下文会遇到意外的值，导致未定义的行为。换句话说，我们需要 T1 <: T2。注意“包含”的“方向”与整个函数类型的方向相同；这被称为协变（两者在相同方向上变化）。这或许正是你期望的。

凭借同样的道理，你可能也期望参数位置的协变：即 S1 <: S2。这是可预测的，但是错误的。让我们看看为什么。

应用 f2 类型的函数是提供类型为 S2 的参数值。假设我们用 f1 类型的函数替换它。如果 S1 <: S2，那么意味着新函数只接受类型为 S1 的值——一个严格较小的集合。这意味着可能会有一些输入——特别是那些在 S2 中但不在 S1 中的输入——应用可以提供但替换函数未定义的输入，再次导致未定义的行为。为了避免这种情况，我们必须让包含关系反过来：替换函数应该接受至少与其替换的函数相同数量的输入。因此我们需要 S2 <: S1，并且说函数位置是反变的：它与子类型化的方向相反。

将这两个观察结果综合起来，我们得到了函数（因此也包括方法）的子类型规则：

> | (S2 <: S1) and (T1 <: T2) => (S1 -> T1) <: (S2 -> T2) |
> | --- |

### 15.3.7.4 实现子类型化

当然，这些规则假设我们已经修改了类型检查器以遵守子类型化。子类型化的本质是一条规则，它说，如果表达式 e 的类型是 S，并且 S <: T，则 e 也具有类型 T。尽管听起来很直观，但由于两个原因，它也立即存在问题：

+   到目前为止，我们所有的类型规则都是基于语法的，这就是我们能够编写递归下降类型检查器的原因。然而，现在，我们有一个适用于所有表达式的规则，所以我们无法确定何时应用它。

+   可能存在许多级别的子类型。因此，不再明显何时“停止”子类型化。特别是，以前在类型检查中能够计算表达式的类型，现在我们对于每个表达式可能有许多可能的类型；如果我们返回了“错误”的类型，那么可能会得到类型错误（因为那不是上下文所期望的类型），即使存在一些其他类型，它是上下文所期望的类型。

这两个问题指出的是，我们在这里给出的子类型描述基本上是声明性的：我们说了什么是真的，但没有展示如何将其转化为算法。对于每种实际类型语言，将这一点转化为算法子类型化存在一个更或者更少有趣的问题：一个实际的算法实现了一个类型检查器（理想情况下，它可以对在声明性制度下也会有类型的程序进行类型化，即，一个既是完备又是完全的）。

### 15.3.8 对象类型

正如我们之前提到的，对象的类型通常被分为两派：名义和结构。名义类型对大多数程序员来说是熟悉的，通过 Java，所以我在这里不会多说。对象的结构类型规定对象的类型本身是一个结构化对象，由字段的名称和它们的类型组成。例如，一个具有两个方法 add1 和 sub1 [REF] 的对象将具有类型

> | {add1 : (number -> number), sub1 : (number -> number)} |
> | --- |

（供以后参考，让我们将这种类型称为 addsub。）类型检查然后将沿着可预测的线路进行：对于字段访问，我们只需确保字段存在，并使用其声明的类型进行解引用表达式；对于方法调用，我们不仅要确保成员存在，还要确保它具有函数类型。到目前为止，一切都很简单明了。对象类型因许多原因变得复杂：因此有很多书籍专门讨论这个主题。阿巴迪和卡雷利的《对象理论》是重要的，但现在有些过时了。布鲁斯的《面向对象语言的基础：类型和语义》更现代化，也提供了更温和的阐述。皮尔斯很好地涵盖了所有必要的理论。

+   自引用。self 的类型是什么？它必须与对象本身的类型相同，因为任何从“外部”可以应用于对象的操作也可以使用 self 从“内部”应用于它。这意味着对象类型是递归类型。

+   访问控制：私有、公共和其他限制。这导致对象的类型在“外部”和“内部”有所区别。

+   继承。我们不仅需要为父对象（们）赋予类型，沿着继承路径可见的内容可能与从“外部”可见的内容再次不同。

+   多重继承与子类型之间的相互作用。

+   类与接口之间的关系，例如像 Java 这样的语言，它具有运行时成本。

+   突变。

+   强制类型转换。

+   飞机上的蛇。

等等。在名义类型存在时，其中一些问题变得简化了，因为给定类型的名称，我们可以确定关于它的行为的一切（类型声明有效地成为了一个字典，通过它可以根据需要查找对象的描述），这是支持名义类型的一个论点。请注意，Java 的方法不是构建名义类型系统的唯一方法。我们已经证明了 Java 的类系统无谓地限制了程序员的表达能力[参考文献]；反过来，Java 的名义类型系统无谓地混淆了类型（这些是接口描述）和实现。因此，可能存在比 Java 更好的名义类型系统。例如，Scala 在这个方向上迈出了重要的步伐。

对这些问题的全面阐述将占用比我们这里拥有的空间更多。目前，我们将限制自己只讨论一个有趣的问题。记得我们说过子类型强迫我们考虑每个类型构造函数吗？对象的结构化类型引入了一个额外的构造函数：对象类型构造函数。因此，我们必须理解它与子类型之间的相互作用。

在我们开始之前，让我们确保我们理解什么是对象类型。考虑上面的 addsub 类型，它列出了两个方法。哪些对象可以具有这种类型？显然，只具有这两种方法的对象，精确地具有这两种类型的对象是合格的。同样明显的是，只具有这两种方法中的一种而不具有另一种的对象，无论它还具有什么，都是不合格的。但短语“不管它还有什么其他内容”是带有引导意味的。如果一个对象代表一个算术包，除了上面的两个方法之外，还包含 + 和 * 方法，那么我们当然有一个可以提供这两个方法的对象，因此这个算术包当然具有 addsub 类型。使用 addsub 类型时，其它方法只是无法访问的。

让我们完整地写出这个包的类型，并称这个类型为 as+*：

> | {add1  : (number -> number), |
> | --- |
> |  sub1  : (number -> number), |
> |  +     : (number number -> number), |
> |  *     : (number number -> number)} |

我们刚刚讨论的是类型为 as+* 的对象也应该允许声明类型 addsub，这意味着它可以替换为期望类型 addsub 的任何上下文中的值。换句话说，我们刚刚说过我们希望 as+* <: addsub：

> | {add1  : (number -> number),           {add1 : (number -> number), |
> | --- |
> |  sub1  : (number -> number),        <:  sub1 : (number -> number)} |
> |  +     : (number number -> number), |
> |  *     : (number number -> number)} |

这可能看起来令人困惑：我们说子类型遵循集合包含，因此我们期望左侧有较小的集合，右侧有较大的集合。然而，看起来我们左侧有一个“较大的类型”（从字符数来看确实如此），右侧有一个“较小的类型”。

要理解这为什么是正确的，有助于发展这样的直觉：类型越“大”，它可以具有的值就越少。每个具有左侧四个方法的对象显然也具有右侧的两个方法。然而，有许多对象具有右侧的两个方法，但却不具有左侧的所有四个方法。如果我们将类型视为对可接受值形状的约束，则“较大”的类型会施加更多约束，因此接受的值会更少。因此，尽管类型可能看起来大小不对，但一切都很好，因为它们订阅的值集合的大小是符合预期的。

更一般地说，这意味着通过从对象类型中删除字段，我们得到一个超类型。这被称为宽度子类型，因为子类型更“宽”，我们通过调整对象的“宽度”向上移动子类型层次结构。即使在 Java 的命名世界中也能看到这一点：当我们沿着继承链向上移动时，一个类的方法和字段越来越少，直到我们到达 Object，所有类的超类型，它具有最少的方法和字段。因此，对于 Java 中的所有类类型 C，C <: Object。有些令人困惑的是，有时候会使用缩小和扩大这些术语，但有些人可能认为含义相反。扩大是指从子类型到超类型，因为它从“较窄”（较小）的集合到“较宽”（较大）的集合。这些术语发展独立地，但不幸的是不一致地。

你可能会预料到，还有另一种重要的子类型形式，即在给定成员内部的子类型。这只是说任何特定的成员都可以被其对应位置的超类型包含。出于明显的原因，这种形式被称为深度子类型。

练习

> 构建两个深度子类型的示例。在一个示例中，给字段本身一个对象类型，并使用宽度子类型来对该字段进行子类型化。在另一个示例中，给字段一个函数类型。

Java 具有有限的深度子类型，倾向于使类型在对象层次结构下不变，因为这是常规突变的安全选择。

宽度子类型和深度子类型的组合涵盖了对象子类型的最有趣的情况。然而，只实现这两种类型的类型系统将不必要地使程序员感到恼火。其他方便的（也是数学上必要的）规则包括能够对名称进行置换，自反性（每种类型都是其自身的子类型，因为将子类型关系解释为 ⊆ 更方便），以及传递性。像 Typed JavaScript 这样的语言利用所有这些特性为程序员提供最大的灵活性。

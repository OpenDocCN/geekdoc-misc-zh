# 13 解糖作为一种语言特性

到目前为止，我们已经广泛讨论并依赖解糖，但我们当前的解糖机制很弱。我们实际上以两种不同的方式使用了解糖。一种是我们用它来缩小语言：将一个大语言提炼到其核心[REF]。但我们还用它来扩展语言：将现有语言并添加新功能[REF]。这只是表明解糖是一个非常有用的功能。事实上，它是如此有用，以至于我们可能会提出两个问题：

+   因为我们创建语言是为了简化常见任务的创建，那么一个旨在支持解糖的语言会是什么样子呢？请注意，通过“外观”我们不仅指语法，还指其关键行为特性。

+   鉴于通用语言通常被用作解糖的目标，为什么它们自身不提供解糖功能呢？例如，这可能意味着用前一问题的响应作为附加语言扩展基础语言。

我们将通过研究 Racket 提供的这些功能来同时探讨这两个问题的答案。

## 13.1 第一个例子

DrRacket 有一个非常有用的工具称为宏步进器，它显示程序的逐步展开。您应该尝试使用宏步进器运行本章中的所有示例。但是，目前，您应该在#lang plai 而不是#lang plai-typed 中运行它们。

请记住，在[REF]中，我们将 let 作为 lambda 的语法糖添加。我们遵循的模式是这样的：

> | (let (var val) body) |
> | --- |

被转换为

> | ((lambda (var) body) val) |
> | --- |

现在就动手！

> 如果这听起来不熟悉，现在是恢复对为什么这样工作的记忆的好时机。

描述这种转换的最简单方法是直接陈述：以某种方式写出，

> | (let (var val) body) |
> | --- |
> | -> |
> | ((lambda (var) body) val) |

实际上，这几乎正是 Racket 让您能够做的事情。我们将使用 my-let 而不是 let 的名称，因为后者已经在 Racket 中定义了。

> | (define-syntax my-let-1 |
> | --- |
> |   (syntax-rules () |
> |     [(my-let-1 (var val) body) |
> |      ((lambda (var) body) val)])) |

syntax-rules 告诉 Racket，每当它看到一个表达式，紧跟在开括号后面的是 my-let-1，它应该检查它是否符合模式 (my-let-1 (var val) body)。var、val 和 body 是语法变量：它们是代表代码主体的变量。特别地，它们匹配该位置上的任何 s-表达式。如果表达式符合模式，那么语法变量将绑定到表达式的相应部分，并可用于右侧。你可能已经注意到了一些额外的语法，比如 ()。我们稍后会解释这个。右侧—<wbr>在这种情况下，((lambda (var) body) val)—<wbr>是生成的输出。每个语法变量都会使用我们的老朋友，替换，替换为输入的相应部分。这种替换非常简单：它不会尝试。因此，如果我们尝试使用它

> | (my-let-1 (3 4) 5) |
> | --- |

Racket 最初不会抱怨 3 被提供在标识符位置；相反，它会让标识符渗透，将其解糖为

> | ((lambda (3) 5) 4) |
> | --- |

这反过来产生了一个错误：

| lambda: 预期是 <id> 或 `[<id> : <type>]' |
| --- |
|   for function argument in: 3 |

这立即告诉我们，解糖过程在功能上是直接的：它不会试图猜测或聪明，而是简单地重写并替换。输出是一个再次经过解糖的表达式。

术语上，这种简单的表达式重写形式通常被称为宏，正如我们之前在 [REF] 中提到的。传统上，这种解糖形式被称为宏展开，尽管这个术语有误导性，因为解糖的输出可能比输入更小（尽管通常更大）。

当然，在 Racket 中，let 可以绑定多个标识符，而不仅仅是一个。如果我们非正式地写下这个，比如在白板上，我们可能会写出类似 (let ([var val] ...) body) -> ((lambda (var ...) body) val ...) 的东西，其中 ... 的意思是“零个或多个”，意图是输出中的 var ... 应该对应于输入中的 var 序列。再次，这几乎是 Racket 语法：

> | (define-syntax my-let-2 |
> | --- |
> |   (syntax-rules () |
> |     [(my-let-2 ([var val] ...) body) |
> |      ((lambda (var ...) body) val ...)])) |

观察 ... 符号的威力：输入序列中的“对”被转换为输出序列的一对；换句话说，Racket “解压缩”了输入序列。反过来，这个符号也可以用来将序列合并在一起。

## 13.2 语法变换器作为函数

早些时候我们看到 my-let-1 甚至不尝试确保标识符位置的语法是否真正（即，语法上）是标识符。我们无法用语法规则机制来纠正这一点，但是我们可以用一个更强大的机制——语法情况来纠正。因为语法情况还展示了许多其他有用的功能，所以我们将介绍它，然后逐渐增加它。

首先要理解的是宏实际上是一个函数。然而，它不是从常规运行时值到其他运行时值的函数，而是从语法到语法的函数。这些函数在一个旨在创建要执行的程序的世界中执行。请注意，我们谈论的是要执行的程序：实际执行程序可能要晚得多（或根本不执行）。当我们检查解糖化时，这一点实际上非常清楚，解糖化非常明确地是从一种语法到另一种语法的函数。这在上面可能以两种方式被掩盖：

+   无参数名或其他“函数头”的语法规则符号的表示形式可能并不清楚它是一个函数变换（尽管重写规则格式确实暗示了这一事实）。

+   在解糖化中，我们为整个过程指定了一个原子函数。在这里，我们实际上编写了几个小函数，每个新的语法构造（如 my-let-1）一个，这些部分由一个控制整体重写过程的隐式函数编织在一起。（作为一个具体的例子，不明显的是宏的输出是否进一步扩展——虽然一个简单的例子立即证明了这确实是这样的。）

练习

> 写一个或多个宏来确认宏的输出是否进一步扩展。

还有一个细微之处。因为宏的形式看起来很像 Racket 代码，所以不会立即清楚它“存在于另一个世界”中。在抽象层面上，想象宏定义实际上是用一种完全不同的语言编写的，该语言仅处理语法。然而，这种简单性是误导性的。在实践中，程序转换器——也称为编译器——也是完整的程序，并且需要所有普通程序的功能。这将不得不创建一个纯粹用于处理程序的平行语言。这是浪费和无意义的；因此，Racket 取而代之地赋予语法转换程序与 Racket 本身的全部功能。

有了这个前提，现在让我们介绍一下语法情况。我们将从简单地使用这种新符号重写 my-let-1（以 my-let-3 的名称）开始。首先，我们必须为定义写一个头部；请注意已经存在的显式参数：

<sc-macro-eg>)) ::=

> | (define-syntax (my-let-3 x) |
> | --- |
> |   <sc-macro-eg-body>))) |

这将 x 绑定到整个（my-let-3 ...）表达式。

正如你所想象的那样，define-syntax 只是告诉 Racket 你要定义一个新的宏。它不会精确地挑选你想要实现它的方式，让你可以自由地使用任何方便的机制。之前我们使用了语法规则；现在我们要使用语法案例。特别是，语法案例需要显式地获得对表达式进行模式匹配的权限：

<sc-macro-eg-body>)) ::=

> | (syntax-case x () |
> | --- |
> |   <sc-macro-eg-rule>))) |

现在我们准备表达我们想要的重写。先前的重写规则有两个部分：输入的结构和相应的输出。这里也是一样。第一个（匹配输入）与以前相同，但第二个（输出）有一点不同：

<sc-macro-eg-rule>)) ::=

> | [(my-let-3 (var val) body) |
> | --- |
> |  #'((lambda (var) body) val)] |

观察关键的额外字符：#’。让我们来看看这意味着什么。

在语法规则中，整个输出部分仅仅指定了输出的结构。相比之下，因为语法案例暴露了转换的功能性质，输出部分实际上是一个任意表达式，可以执行任何它想要的计算。它只需要求值为一段语法。

语法实际上是一个独立的数据类型。与任何独立数据类型一样，它有自己的构造规则。具体来说，我们通过编写 #’ 来构造语法值；以下的 s 表达式被视为语法值。（如果你在想，上面宏定义中的 x 也是这种数据类型。）

语法构造器，#’，具有特殊的属性。在宏的输出部分内，所有输入中的语法变量都会自动绑定，并在出现时替换。因此，当扩展器遇到输出中的变量时，比如说，它会用输入表达式的对应部分替换变量。

现在开始！

> 去掉 #’ 然后尝试使用上述宏定义。会发生什么？

到目前为止，语法案例似乎只是语法规则的一个更复杂的形式：也许在更清晰地界定扩展的功能性质和输出类型方面稍微更好一些，但其他方面仅仅更加笨重。然而，正如我们将看到的，它也提供了显著的功能。

练习

> 实际上，语法规则可以表达为对语法案例的宏。定义它。

## 13.3 卫兵

现在我们可以回到最初引入 syntax-case 的问题：确保 my-let-3 的绑定位置在语法上是一个标识符。为此，你需要了解 syntax-case 的一个新特性：每个重写规则可以有两部分（如上所示），或三部分。如果有三部分存在，中间的部分被视为保护条件：一个必须评估为真才能继续扩展而不是发出语法错误信号的谓词。在这种情况下特别有用的是谓词 identifier?，它确定一个语法对象在语法上是否是标识符（或变量）。

现在！

> 编写保护条件并重写规则以包含它。

希望你碰巧发现了一个微妙之处：identifier? 的参数是语法类型。它需要引用绑定到 var 的实际语法片段。回想一下，var 在语法空间中被绑定，#’ 用于替换那里绑定的标识符。因此，编写保护条件的正确方式是：

> | (identifier? #'var) |
> | --- |

有了这些信息，我们现在可以编写整个规则：<sc-macro-eg-guarded-rule>)) ::=

> | [(my-let-3 (var val) body) |
> | --- |
> |  (identifier? #'var) |
> |  #'((lambda (var) body) val)] |

现在！

> 现在你有了一个受保护的规则定义，尝试在绑定位置使用一个非标识符的宏，看看会发生什么。

## 13.4Or：一个具有许多特性的简单宏

考虑 or，它实现了析取。自然地，使用前缀语法，允许 or 有任意数量的子项。我们将 or 展开为嵌套的条件语句，以确定表达式的真值。

### 13.4.1 第一次尝试

让我们尝试 or 的第一个版本：

> | (define-syntax (my-or-1 x) |
> | --- |
> |   (syntax-case x () |
> |     [(my-or-1 e0 e1 ...) |
> |      #'(if e0 |
> |            e0 |
> |            (my-or-1 e1 ...))])) |

它说我们可以提供任意数量的子项（稍后会详细介绍）。扩展将其重写为一个条件语句，测试第一个子项；如果这是一个真值，则返回该值（稍后会详细介绍！），否则是剩余项的析取。让我们在一个简单的例子上尝试一下。我们期望这将评估为真，但实际上：

| > (my-or-1 #f #t) |
| --- |
| my-or-1: bad syntax in: (my-or-1) |

发生了什么？这个表达式变成了

> | (if #f |
> | --- |
> |     #f |
> |     (my-or-1 #t)) |

这反过来又扩展为

> | (if #f |
> | --- |
> |     #f |
> |     (if #t |
> |         #t |
> |         (my-or-1))) |

对于没有定义的情况。这是因为模式 e0 e1 ... 意味着一个或多个子项，但我们忽略了当子项为零时的情况。当没有子项时会发生什么？析取的恒等式是 falsehood。练习

> 为什么 #f 是正确的默认值？

通过下面的填充，我们演示了一个具有多个规则的宏。宏规则是按顺序匹配的，因此我们应该确保首先放置最具体的规则，以免它们被更一般的规则覆盖（尽管在这种特殊情况下，这两个规则是不重叠的）。这产生了我们改进的宏：

> | (define-syntax (my-or-2 x) |
> | --- |
> |   (syntax-case x () |
> |     [(my-or-2) |
> |      #'#f] |
> |     [(my-or-2 e0 e1 ...) |
> |      #'(if e0 |
> |            e0 |
> |            (my-or-2 e1 ...))])) |

现在展开如我们所期望的那样。在接下来的内容中，当只有一个子项时，我们会发现有一个特殊情况是很有用的：

> | (define-syntax (my-or-3 x) |
> | --- |
> |   (syntax-case x () |
> |     [(my-or-3) |
> |      #'#f] |
> |     [(my-or-3 e) |
> |      #'e] |
> |     [(my-or-3 e0 e1 ...) |
> |      #'(if e0 |
> |            e0 |
> |            (my-or-3 e1 ...))])) |

这使得展开的输出更加简洁，这在下面会发现很有用。请注意，在这个版本的宏中，模式不是不相交的：第三个（一个或多个子项）包含第二个（一个子项）。因此，第二个规则不要与第三个规则交换是至关重要的。

### 13.4.2Guarding Evaluation

我们上面说过，这展开如我们所期望的。但是真的吗？让我们尝试以下示例：

> | (let ([init #f]) |
> | --- |
> |   (my-or-3 (begin (set! init (not init)) |
> |                   init) |
> |            #f)) |

注意到 or 返回第一个“真值”值的实际值，因此开发人员可以在进一步的计算中使用它。因此，这返回 init 的值。我们期望它是什么？自然地，因为我们对 init 的值取反了一次，我们期望它是 #t。但是评估它产生了 #f！这个问题不是 set! 的产物。如果我们没有内部变异，而是打印输出，那么打印将发生两次。要理解为什么，我们必须检查展开的代码。就是这个：

> | (let ([init #f]) |
> | --- |
> |   (if (begin (set! init (not init)) |
> |              init) |
> |       (begin (set! init (not init)) |
> |              init) |
> |       #f)) |

啊哈！因为我们将输出模式写成

> | #'(if e0 |
> | --- |
> |       e0 |
> |       ...) |

当我们第一次编写时，这看起来完全无害，但它展示了在编写宏（或者任何其他程序转换系统）时一个非常重要的原则：不要复制代码！在我们的设置中，一个语法变量永远不应该被重复；如果你需要以可能导致该代码多次执行的方式重复它，请确保你已经考虑了这样做的后果。或者，如果你打算使用表达式的值，那么绑定一次并随后使用绑定的标识符名称。这很容易演示：

> | (define-syntax (my-or-4 x) |
> | --- |
> |   (syntax-case x () |
> |     [(my-or-4) |
> |      #'#f] |
> |     [(my-or-4 e) |
> |      #'e] |
> |     [(my-or-4 e0 e1 ...) |
> |      #'(let ([v e0]) |
> |          (if v |
> |              v |
> |              (my-or-4 e1 ...)))])) |

引入绑定的这种模式会产生一个新的潜在问题：你可能会评估不必要的表达式。实际上，它会产生一个更加微妙的问题：即使它要被评估，你也可能在错误的上下文中评估它！因此，你必须仔细考虑一个表达式是否会被评估，如果是的话，就在恰当的地方评估一次，然后将该值存储供后续使用。

当我们重复包含 set! 的先前示例，使用 my-or-4，我们看到结果是 #t，正如我们所希望的那样。

### 13.4.3 卫生

希望现在你对另一件事感到紧张。

现在做！

> 什么？

考虑一下宏 (let ([v #t]) (my-or-4 #f v))。我们期望这会计算什么？当然是 #t：第一个分支是 #f，但第二个是 v，而 v 绑定到 #t。但是让我们来看一下展开：

> | (let ([v #t]) |
> | --- |
> |   (let ([v #f]) |
> |     (if v |
> |         v |
> |         v))) |

这个表达式，当直接运行时，会评估为 #f。然而，(let ([v #t]) (my-or-4 #f v)) 会评估为 #t。换句话说，这个宏似乎神奇地产生了正确的值：宏中选择的标识符名称似乎与宏引入的名称无关！当它发生在函数中时，这并不奇怪；宏展开器具有称为卫生的属性，使其具有相同的属性。关于卫生的一种思考方式是，它有效地自动重命名了所有绑定的标识符。也就是说，程序的展开如下所示：

> | (let ([v #t]) |
> | --- |
> |   (or #f v)) |

转变成了

> | (let ([v1 #t]) |
> | --- |
> |   (or #f v1)) |

（请注意 v 的一致重命名为 v1），变成了

> | (let ([v1 #t]) |
> | --- |
> |   (let ([v #f]) |
> |        v |
> |        v1)) |

然后，经过重命名，变成了

> | (let ([v1 #t]) |
> | --- |
> |   (let ([v2 #f]) |
> |        v2 |
> |        v1)) |

当扩展终止时。请注意，上述每个程序，如果直接运行，都将产生正确的答案。

## 13.5 标识符捕获

卫生宏解决了创建语法糖的创作者面临的一个常规而重要的问题。但在极少数情况下，开发人员希望有意地打破卫生习惯。回到对象，考虑以下输入程序：

> | (define os-1 |
> | --- |
> |   (object/self-1 |
> |    [first (x) (msg self 'second (+ x 1))] |
> |    [second (x) (+ x 1)])) |

这个宏是什么样子？这是一个明显的候选人：

> | (define-syntax object/self-1 |
> | --- |
> |   (syntax-rules () |
> |     [(对象 [mtd-name (var) val] ...) |
> |      (let ([self (lambda (msg-name) |
> |                    (lambda (v) (error 'object "nothing here")))]) |
> |        (begin |
> |          (set! self |
> |                (lambda (msg) |
> |                  (case msg |
> |                    [(mtd-name) (lambda (var) val)] |
> |                  ...))) |
> |          self))])) |

不幸的是，这个宏产生了以下错误：

| self: unbound identifier in module in: self |
| --- |

这是指向绑定到 first 方法体内的 self。练习

> 通过卫生扩展过程来理解为什么错误是预期结果。

在我们跳转到更丰富的宏之前，让我们考虑一个使绑定明确的输入项的变体：

> | (define os-2 |
> | --- |
> |   (object/self-2 self |
> |    [first (x) (msg self 'second (+ x 1))] |
> |    [second (x) (+ x 1)])) |

相应的宏是我们之前所说的一个小变化：

> | (define-syntax object/self-2 |
> | --- |
> |   (syntax-rules () |
> |     [(object self [mtd-name (var) val] ...) |
> |      (let ([self (lambda (msg-name) |
> |                    (lambda (v) (error 'object "nothing here")))]) |
> |        (begin |
> |          (set! self |
> |                (lambda (msg) |
> |                  (case msg |
> |                    [(mtd-name) (lambda (var) val)] |
> |                  ...))) |
> |          self))])) |

这个宏扩展没有困难。练习

> 通过扩展这个版本，看看有什么不同。

这提供了一个关键的见解：如果在绑定位置写入的标识符是��宏用户编写的，那么就不会有问题。因此，我们希望能够假装引入的标识符是由用户编写的。函数 datum->syntax 将第二个参数中的 s 表达式转换；它的第一个参数是要假装它是哪个语法的一部分（在我们的情况下，原始宏使用，它绑定到 x）。为了将结果引入用于扩展的环境中，我们使用 with-syntax 将其绑定在该环境中：

> | (define-syntax (object/self-3 x) |
> | --- |
> |   (syntax-case x () |
> |     [(object [mtd-name (var) val] ...) |
> |      (with-syntax ([self (datum->syntax x 'self)]) |
> |        #'(let ([self (lambda (msg-name) |
> |                        (lambda (v) (error 'object "nothing here")))]) |
> |            (begin |
> |              (set! self |
> |                    (lambda (msg-name) |
> |                      (case msg-name |
> |                        [(mtd-name) (lambda (var) val)] |
> |                        ...))) |
> |              self)))])) |

有了这个，我们可以重新让 self 成为隐式的：

> | (define os-3 |
> | --- |
> |   (object/self-3 |
> |    [first (x) (msg self 'second (+ x 1))] |
> |    [second (x) (+ x 1)])) |

## 13.6 对编译器设计的影响

在语言定义中使用宏对所有工具，特别是编译器产生影响。作为一个工作示例，考虑 let。let 的优点在于它可以通过简单地扩展当前环境来高效地编译。相比之下，将 let 扩展为函数应用会导致一个更昂贵的操作：创建一个闭包并将其应用于参数，实际上实现了相同的结果，但以更多的时间（通常还有空间）为代价。

这似乎是反对使用宏的一个论点。然而，一个聪明的编译器会意识到这种模式经常出现，并且内部有效地将左-左-λ [REF]转换为等效的 let。这有两个优点。首先，这意味着语言设计者可以自由地使用宏来获得一个更小的核心语言，而不必将其与执行成本相抵消。

它还有第二个更微妙的优势。因为编译器识别了这种模式，其他宏也可以利用它并获得相同的优化；它们不需要扭曲其输出以插入 let 项，如果左-左-λ模式自然发生，它们就不需要这样做。例如，当编写某些类型的模式匹配器时，左-左-λ模式会自然发生，但将其转换为扩展中的 let 需要额外的步骤—<wbr>这不再是必要的。

## 13.7 其他语言中的解糖

许多现代语言通过解糖来定义操作，不仅仅是 Racket。例如，在 Python 中，使用 for 进行迭代只是一种语法模式。编写 for x in o 的开发人员是

+   引入一个新的标识符（称之为 i—<wbr>但一定不要捕获程序员已经定义的任何其他 i，即要卫生地绑定 i！），

+   将其绑定到从 o 获得的迭代器，并

+   创建一个（可能）无限的 while 循环，重复调用 i 的.next 方法，直到迭代器引发 StopIteration 异常。

现代编程语言中有许多这样的模式。

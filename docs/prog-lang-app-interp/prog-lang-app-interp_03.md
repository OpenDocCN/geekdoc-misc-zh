# 3A 对解释的第一次观察

现在我们有了程序的表示，有很多我们可能想要操作它们的方式。我们可能想要以一种吸引人的方式显示程序（“漂亮打印”），转换成其他格式的代码（“编译”），询问它是否遵循某些属性（“验证”），等等。现在，我们将专注于询问它对应什么值（“求值”—<wbr>将程序缩减为值）。

让我们编写一个求值器，以解释器的形式，为我们的算术语言。我们选择算术首先有三个原因：(a) 你已经知道它如何工作，所以我们可以专注于编写求值器的机制；(b) 它包含在我们后面会遇到的每种语言中，所以我们可以从中向上和向外构建；(c) 它既小又大，足以说明我们想要传达的许多观点。

## 3.1 表示算术

让我们首先就我们将如何表示算术表达式达成一致。假设我们只想支持两种操作——<wbr>加法和乘法——<wbr>除了原始数字。我们需要表示算术表达式。规定了嵌套算术表达式的规则是什么？实际上，我们可以在另一个表达式内嵌套任何表达式。

现在做！

> 为什么我们没有包括除法？它对上述评论有什么影响？

我们忽略了除法，因为它迫使我们讨论哪些表达式我们可能认为是合法的：显然表示 1/2 应该是合法的；表示 1/0 则更具有争议；而 1/(1-1)的表示似乎更加有争议。我们希望暂时避开这种争议并稍后返回 [REF]。因此，我们想要一个数字的表示以及任意嵌套的加法和乘法。这是我们可以使用的一个：

> | (定义类型 ArithC |
> | --- |
> |   [numC (n : number)] |
> |   [plusC (l : ArithC) (r : ArithC)] |
> |   [multC (l : ArithC) (r : ArithC)]) |

## 3.2 编写一个解释器

现在让我们为这个算术语言编写一个解释器。首先，我们应该考虑它的类型是什么。它显然消耗了一个 ArithC 值。它会产生什么？嗯，一个解释器会进行求值——<wbr>算术表达式可能会缩减为什么样的值？当然是数字。所以解释器将是一个从算术表达式到数字的函数。

练习

> 为解释器编写你的测试案例。

因为我们有一个递归数据类型，所以将解释器构造为对其的递归函数是很自然的。这是一个初步的模板：

> > > 模板在《如何设计程序》中有详细解释。
> > > 
> | (定义 (interp [a : ArithC]) : number |
> | --- |
> |   (类型-案例 ArithC a |
> |     [numC (n) n] |
> |     [plusC (l r) ...] |
> |     [multC (l r) ...])) |

你可能会想直接跳到代码，这样你就可以了：

> | (定义 (interp [a : ArithC]) : number |
> | --- |
> |   (类型-案例 ArithC a |
> |     [numC (n) n] |
> |     [plusC (l r) (+ l r)] |
> |     [multC (l r) (* l r)])) |

现在做！

> 你发现错误了吗？

相反，让我们将模板展开一步：

> | (define (interp [a : ArithC]) : number |
> | --- |
> |   (type-case ArithC a |
> |     [numC (n) n] |
> |     [plusC (l r) ... (interp l) ... (interp r) ...] |
> |     [multC (l r) ... (interp l) ... (interp r) ...])) |

现在我们可以填写空白处：

> | (define (interp [a : ArithC]) : number |
> | --- |
> |   (type-case ArithC a |
> |     [numC (n) n] |
> |     [plusC (l r) (+ (interp l) (interp r))] |
> |     [multC (l r) (* (interp l) (interp r))])) |

后面 [REF]，我们会希望我们返回的不仅仅是数字这样的简单数据类型。但是现在，这样就够了。

恭喜：你已经写出了你的第一个解释器！我知道，这几乎是一个反高潮。但它们会变得更难—<wbr>更难—<wbr>很快，我保证。

## 3.3 你有没有注意到？

我刚刚在你身边溜了一下：

现在就做！

> 在这种新语言中，加法和乘法的“含义”是什么？

这是一个非常抽象的问题，不是吗。让我们具体化一下。在计算机科学中有许多种类的加法：

+   首先，有许多不同类型的数字：固定宽度（例如，32 位）整数，带符号的固定宽度（例如，31 位加上一个符号位）整数，任意精度整数；在一些语言中，有理数；各种格式的定点和浮点数；在一些语言中，复数；等等。在选择了数字之后，加法可能仅支持其中的一些组合。

+   此外，一些语言允许添加诸如矩阵之类的数据类型。

+   此外，许多语言支持字符串的“加法”（我们用引号是因为我们并不真正指的是数学概念上的加法，而是由具有语法 + 的运算符执行的操作）。在一些语言中，这总是意味着连接；在另一些语言中，它可能导致数字结果（或存储在字符串中的数字）。

这些都是加法的不同含义。语义是将语法（例如，+）映射到含义（例如，上述某些或全部）的过程。

这带我们来到我们的第一个游戏：

这些中哪些是相同的？

> +   1 + 2
> +   
> +   1 + 2
> +   
> +   ’1’ + ’2’
> +   
> +   ’1’ + ’2’

现在回到上面的问题。我们有什么样的语义？我们采用了 Racket 提供的任何语义，因为我们将 + 映射到 Racket 的 +。事实上，这甚至不完全正确：Racket 可能也允许 + 适用于字符串，所以我们选择了 Racket 语义对数字的限制（尽管事实上 Racket 的 + 不容忍字符串）。

如果我们想要不同的语义，我们必须显式实现它。

练习

> 为了使数字具有带符号的 32 位算术，你需要改变什么？

一般来说，我们必须谨慎地从���主语言中借鉴。我们稍后会回到这个话题 [REF]。

## 3.4 扩展语言

我们选择了一种非常受限制的首选语言，所以我们可以通过许多方式来扩展它。有些方式，比如表示数据结构和函数，显然会迫使我们向解释器本身添加新功能（假设我们不想使用哥德尔编号）。另一些方式，比如增加更多的算术本身，可以在不干扰核心语言及其解释器的情况下完成。我们将在接下来进行审查（第一次深化的味道）。

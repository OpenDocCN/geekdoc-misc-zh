# 14 控制操作

控制一词指的是任何导致评估继续进行的编程语言指令，因为它“控制”了机器的程序计数器。在这个意义上，即使是一个简单的算术表达式也应该被视为“控制”，而像顺序程序执行、函数调用和返回等操作则肯定是。然而，在实践中，我们使用这个术语主要是指那些导致非局部控制转移的操作，尤其是超出了仅仅函数和过程的范围，以及更高级别的异常。我们将在本章中研究这些操作。

当我们学习以下控制操作符时，值得记住，即使没有它们，我们仍然拥有图灵完备的语言，因此没有更多的“权力”。因此，控制操作符的作用是改变并潜在地改善我们表达意图的方式，从而增强程序的结构。因此，我们开始学习时应该专注于程序结构。

## 14.1 网络控制

让我们通过检查 Web 程序的结构来开始我们的学习。考虑以下程序：从现在开始，我们将称之为我们的“加法服务器”。当然，你应该把这看作更复杂应用程序的替身。例如，这两个提示可能要求输入旅行的起点和终点，而在加法的位置上，我们可能计算路线或计算机票价格。甚至可能在两个步骤之间进行计算：例如，在输入第一个城市后，航空公司可能会提示我们选择从那里飞往哪里。

> | (display |
> | --- |
> |   (+ (read-number "第一个数字") |
> |      (read-number "第二个数字"))) |

为了测试这些想法，这里是一个 read-number 的实现：

> | (define (read-number [prompt : string]) : number |
> | --- |
> |   (begin |
> |     (display prompt) |
> |     (let ([v (read)]) |
> |       (if (s-exp-number? v) |
> |           (s-exp->number v) |
> |           (read-number prompt))))) |

当在控制台或 DrRacket 中运行时，此程序会提示我们输入一个数字，然后另一个数字，然后显示它们的和。

现在假设我们想在 Web 服务器上运行这个程序。我们立即遇到一个困难：服务器端 Web 程序的结构是这样的，它们生成一个单一的网页—<wbr>比如要求输入第一个数字的网页—<wbr>然后停止。因此，程序的其余部分—<wbr>在这种情况下提示输入第二个数字，然后相加，然后打印结果—<wbr>会丢失。

现在做！

> 为什么 Web 服务器表现得如此奇怪？

这种行为至少有两个原因：一个可能是历史原因，另一个是技术原因。历史原因是，Web 服务器最初是设计用来提供页面，即静态内容。任何运行的程序都必须将其输出生成到一个文件中，服务器可以从中提供。自然地，开发人员想知道为什么同样的程序不能按需运行。这使得 Web 内容变得动态起来。在生成单个输出后终止程序是朝向 Web 上的程序而不是页面的最简单的渐进式步骤。

更重要的原因——并且一直存在着的原因——是技术性的。想象一下，我们的加法服务器已经生成了第一个提示符。回想一下，有相当多的待处理计算：第二个提示符，加法，以及结果的显示。这个计算必须暂停等待用户的输入。如果有数百万的用户，那么数百万的计算必须被暂停，这会产生巨大的性能问题。此外，假设用户实际上没有完成计算——类似于在在线书店或航空公司网站搜索，但没有完成购买。服务器如何知道何时甚至是否终止计算？在它这样做之前，与该计算相关联的资源仍在使用中。

因此，从概念上讲，Web 协议被设计为无状态的：它不会在服务器上存储与中间计算相关的状态。相反，Web 程序开发人员将被迫在其他地方维护所有必要的状态，并且每个请求都需要能够完整地恢复计算。实际上，Web 并没有被证明是无状态的，但它仍然在很大程度上朝着这个方向发展，研究这种程序的结构非常有启发性。

现在考虑客户端 Web 程序：那些在浏览器内运行的程序，编写或编译成 JavaScript。假设这样的计算需要与服务器通信。这个通信的原语称为 XMLHttpRequest。用户创建这个原语的实例，并调用它的 send 方法将消息发送到服务器。然而，与服务器通信并不是瞬时的（实际上可能永远不会完成，这取决于网络的状态）。这将导致发送过程被挂起。

JavaScript 的设计者决定使语言单线程化：即一次只有一个执行线程。由于这导致的结构问题，现在有各种提案，实际上是向 JavaScript 添加“安全”线程。本章描述的思想可以看作是提供类似结构性好处的替代方案。然而，这样一来，JavaScript 进程会因为等待响应而锁定，其他任何事情都无法发生：例如，页面上的其他处理程序不再响应。

为了避免这个问题，XMLHttpRequest 的设计要求开发人员提供一个在请求到达时响应的过程。这个回调过程已在系统中注册。它需要体现该请求的其余处理。因此，出于完全不同的原因——不是性能，而是避免同步、非原子性和死锁的问题——客户端 Web 已经发展到要求开发人员采用相同的模式。现在让我们更好地理解这种模式。

### 14.1.1 程序分解为现在和以后

让我们考虑如何使我们上面的程序在无状态设置中运行，比如在 Web 服务器上。首先，我们必须确定第一个交互。这是第一个数字的提示，因为 Racket 从左到右评估参数。将程序分为两部分是有益的：生成第一个交互的操作（现在全部可以运行），以及之后需要发生的操作（必须以某种方式“记住”）。前者很容易：

> | (read-number "First number") |
> | --- |

我们已经用散文解释了剩下的内容，但现在是时候将其写成程序了。它似乎是这样的：现在我们有意忽略 read-number，但我们会回到它。现在，让我们假装它是内置的。

> | (display |
> | --- |
> |   (+ <the result from the first interaction> |
> |      (read-number "Second number"))) |

但是，Web 服务器无法执行上述操作，因为显然它不是一个程序。相反，我们需要以某种方式将其编写为程序。让我们观察一下这个计算的几个特点：

+   它需要是一个合法的程序。

+   它需要保持挂起，直到请求到达。

+   它需要一种方式——比如一个参数——来引用第一个交互的值。

将这些特征放在一起，我们有了一个明确的表示——一个函数：

> | (lambda (v1) |
> | --- |
> |   (display |
> |     (+ v1 |
> |        (read-number "Second number")))) |

### 14.1.2 一个部分解决方案

在 Web 上，还有一个额外的问题：每个带有输入元素的 Web 页面都需要引用存储在 Web 上的程序，该程序将接收来自表单的数据并进行处理。该程序在表单的 action 字段中命名。因此，想象一下，服务器生成一个新的标签，将上述函数存储在与该标签关联的表中，并在 action 字段中引用该表。如果客户端实际提交表单，则服务器提取关联的函数，为其提供表单的值，从而恢复执行。

现在动手！

> 上面的解决方案是无状态的吗？

让我们假设我们有一个维护上述表的定制 Web 服务器。在这样的服务器上，我们可能有一个特殊版本的 read-number——称之为 read-number/suspend——记录程序的其余部分：

> | (read-number/suspend "First number" |
> | --- |
> |                      (lambda (v1) |
> |                        (display |
> |                         (+ v1 |
> |                            (read-number "Second number"))))) |

为了测试这一点，让我们实现这样一个过程。首先，我们需要一个标签的表示；数字是一个简单的替代品：

> | (define-type-alias label number) |
> | --- |

假设 new-label 在每次调用时生成一个新标签。练习

> 定义 new-label。你可以借鉴 new-loc 的方法。

我们需要一个表来存储表示程序其余部分的过程。

> | (define table (make-hash empty)) |
> | --- |

现在我们可以存储这些过程：

> | (define (read-number/suspend [prompt : string] rest) |
> | --- |
> |   (let ([g (new-label)]) |
> |     (begin |
> |       (hash-set! table g rest) |
> |       (display prompt) |
> |       (display " To enter it, use the action field label ") |
> |       (display g)))) |

如果我们现在运行上述对 read-number/suspend 的调用，系统将打印

| First number 要输入它，请使用动作字段标签 1 |
| --- |

这相当于在 Web 页面中打印提示，并在动作字段中放置标签 1。因为我们正在模拟它，所以我们需要一些来代表浏览器的提交过程。这需要标签（来自动作字段）和表单中输入的值。在拥有这两个值后，该过程需要从表中提取相关过程，并将其应用于表单值。

> | (define (resume [g : label] [n : number]) |
> | --- |
> |   ((some-v (hash-ref table g)) n)) |

有了这个，我们现在可以通过运行来模拟输入 3 并点击“提交”按钮的行为：

| > (resume 1 3) |
| --- |

其中 1 是标签，3 是用户的输入。不幸的是，这只会产生另一个提示，因为我们还没有完全转换程序。如果我们删除 read-number，我们就不得不转换整个程序：

> | (read-number/suspend "First number" |
> | --- |
> |                      (lambda (v1) |
> |                        (read-number/suspend "Second number" |
> |                                             (lambda (v2) |
> |                                               (display |
> |                                                (+ v1 v2)))))) |

为了安全起见，我们还可以确保每次输出后计算都会终止，方法是在 read-number/suspend 的末尾添加一个错误调用（以确保“悬挂”的最极端形式）。当我们执行这个程序时，我们必须使用 resume 两次：

| First number 要输入它，请使用动作字段标签 1 |
| --- |
| halting: 程序关闭 |
| > (resume 1 3) |
| Second number 要输入它，请使用动作字段标签 2 |
| halting: 程序关闭 |
| > (resume 2 10) |
| 13 |

两个用户输入分别是 3 和 10，总计 13，

| halting |
| --- |

由我们插入的错误命令生成消息。

我们故意对程序中有趣部分的类型有点含糊。让我们来看看这些类型应该是什么。read-number/suspend 的第二个参数必须是一个消耗数字并返回最终产生的计算结果的过程：（数字 -> 'a）。类似地，resume 的返回类型是相同的'a。这些'a 如何相互通信？这是通过表格完成的，它将标签映射到（数字 -> 'a）。也就是说，每一步计算都朝着相同的结果取得进展。read-number/suspend 写入这个表格，而 resume 从中读取。

### 14.1.3 实现无状态性

实际上我们还没有实现无状态性，因为我们在服务器上有这个大表，没有明确的方法来删除其中的条目。最好的方法是完全避免服务器状态。这意味着我们必须将相关状态移动到客户端。

服务器实际上有两种保持状态的方式。一种是我们保留了在哈希表中创建任意数量的条目的权利，而不是一个常数（即，与程序本身大小成线性关系）。另一种是我们在表中存储的内容：真正的闭包，可能持有任意数量的状态。我们很快会更清楚地看到这一点。

让我们首先消除闭包。相反，让我们使每个函数参数都有命名，成为顶层函数（这立即迫使我们只能有固定数量的函数，因为程序的大小不能无限制增长）：

> | (read-number/stateless "第一个数字" prog1) |
> | --- |
> |   |
> | (定义 (prog1 v1) |
> |   (read-number/stateless "第二个数字" prog2)) |
> |   |
> | (定义 (prog2 v2) |
> |   (显示 (+ v1 v2))) |

注意每个代���块只引用下一个的名称，而不是一个真正的闭包。参数的值来自表单。只有一个问题：prog2 中的 v1 是一个自由标识符！

解决这个问题的方法是，在一步之后不创建闭包，而是将 v1 发送到客户端存储在那里。我们在哪里存储这个？浏览器提供了两种机制来做到这一点：cookies 和隐藏字段。我们使用哪一个？

### 14.1.4 与状态的交互

饼干和隐藏字段之间的根本区别在于所有页面共享同一个 cookie，但每个页面都有自己的隐藏字段。

首先，让我们考虑一系列与现有程序交互的交互，该程序在两个交互点都使用 read-number/suspend。它看起来像这样：

| 输入第一个数字，使用动作字段标签 1 |
| --- |
| > (恢复 1 3) |
| 输入第二个数字，使用动作字段标签 2 |
| > (恢复 2 10) |
| 13 |

因此，使用标签 2 恢复似乎表示将 3 添加到给定参数（即，表单字段值）。为了确保，

| > (恢复 2 15) |
| --- |
| 18 |

到目前为止，一切顺利。现在假设我们再次使用标签 1：

| > (恢复 1 5) |
| --- |
| 输入第二个数字，使用动作字段标签 3 |

请观察这个新的程序执行需要使用标签 3 来恢复，而不是 1。确实，

| > (恢复 3 10) |
| --- |
| 15 |

但是我们应该问，如果我们重复使用标签 2 会发生什么？现在做！

> 尝试 (恢复 2 10)。

这样做等同于恢复旧的计算。因此，我们期望它产生与之前相同的答案：

| > (恢复 2 10) |
| --- |
| 13 |

现在让我们创建一个有状态的实现。我们可以通过观察到每个闭包都有自己的环境，但所有闭包共享相同的可变状态来模拟这一点。我们可以通过确保我们不依赖于 lambda 的闭包行为来模拟这一点，即，通过不在主体中具有任何自由标识符。

> | (define cookie '-100) |
> | --- |
> |   |
> | (read-number/suspend "第一个数字" |
> |                      (lambda (v1) |
> |                        (begin |
> |                          (set! cookie v1) |
> |                          (read-number/suspend "第二个数字" |
> |                                             (lambda (v2) |
> |                                               (display |
> |                                                (+ cookie v2))))))) |

练习

> 我们对相同的序列有什么期望？

现在做！

> 发生了什么？

最初，似乎没有什么不同：

| 第一个数字 要输入它，请使用动作字段标签 1 |
| --- |
| > (恢复 1 3) |
| 第二个数字 要输入它，请使用动作字段标签 2 |
| > (恢复 2 10) |
| 13 |

当我们重用初始计算时，我们确实得到一个新的恢复标签：

| > (恢复 1 5) |
| --- |
| 第二个数字 要输入它，请使用动作字段标签 3 |

使用时计算我们预期的内容：

| > (恢复 3 10) |
| --- |
| 15 |

现在我们来到关键步骤：

| > (恢复 2 10) |
| --- |
| 15 |

鉴于它们依赖于可变状态，标签 2 的两次恢复产生不同的答案并不奇怪。问题所在是当我们将相同的行为转换为 Web 时会发生什么。

想象一下访问酒店预订网站并搜索城市中的酒店。作为回报，您将看到酒店列表和标签 1。您在新的标签页或窗口中探索其中一个酒店；这将产生有关该酒店的信息，并提供标签 2 以进行预订。但是，您决定返回酒店列表，并在新的标签页或窗口中探索另一个酒店。这将产生第二家酒店的信息，带有标签 3 以在该酒店预订。但是，您决定选择第一家酒店，返回第一家酒店的页面，并选择其预订按钮——即，提交标签 2。您希望预订哪家酒店？尽管您期望在第一家酒店预订，但在大多数旅行网站上，这将预订第二家酒店——即，您最后查看的那家，而不是您单击其预订按钮的页面上的酒店——或者产生错误。这是因为网站普遍使用 Cookie，这是大多数 Web API 鼓励的做法。

## 14.2 过程传递样式

我们编写的函数有一个名字。虽然我们以 Web 为基础呈现了这些思想，但我们依赖的是一个更古老的想法：这些函数被称为 continuations，并且这种程序的风格被称为 continuation-passing style（CPS）。我们将自由地将 CPS 用作名词和动词：一种特定的代码结构和将代码转换为它的过程。这值得单独研究，因为它是研究各种其他非平凡控制操作的基础，比如生成器。

早先，我们将程序转换成这样一个形式，其中没有 Web 输入操作嵌套在另一个内部。动机很简单：当程序终止时，所有嵌套的计算都会丢失。类似的论点在 XMLHttpRequest 的情况下也适用，从更局部的角度来看，任何依赖于从 Web 服务器的响应中获得的结果的计算都需要驻留在与向服务器发出请求相关联的回调中。

实际上，我们不需要转换每一个表达式。我们只关心涉及实际 Web 交互的表达式。例如，如果我们计算的是比简单的加法更复杂的数学表达式，我们就不需要转换它。但是，如果我们有一个函数调用，我们要么必须确信该函数内部没有任何 Web 调用，要么在它调用的函数中，或者它们调用的函数中也没有，否则，为了防御性，我们应该将它们全部转换。因此，我们必须转换每一个我们不能确定不执行 Web 交互的表达式。

因此，我们转换的核心是将每个单参数函数 f 转换为一个带有额外参数的函数。这个额外参数是 continuation，它代表了剩余的计算过程。continuation 本身是一个带有一个参数的函数。这个参数取决于 f 将返回的值，并将其传递给剩余的计算过程。f 不是返回一个值，而是将它将要返回的值传递给它的 continuation。

CPS 是一种通用的转换，我们可以将其应用到任何程序中。因为它是一个程序转换，我们可以将其看作是一种特殊的 desugaring：特别是，它不是将程序从一个更大的语言转换为一个更小的语言（如宏所做的），也不是从一种语言转换为另一种完全不同的语言（如编译器所做的），而是将程序转换到同一种语言中：从完整的语言转换为一个更受限制的版本，它遵循我们一直在讨论的模式。因此，我们可以重用用于完整语言的评估器来评估 CPS 子集中的程序。

### 14.2.1 通过 desugaring 实现

因为我们已经很好地支持了解糖，让我们使用它来定义 CPS 转换。具体来说，我们将实现一个 CPS 宏[REF]。为了更清晰地将源语言与目标语言分开，我们将为大多数语言构造使用略有不同的名称：一个臂状的 with 和 rec 代替 let 和 letrec；lam 代替 lambda；cnd 代替 if；seq 代替 begin；set 代替 set!。我们还将给自己一个足够丰富的语言来编写一些有趣的程序！接下来的演示按照我认为从简单到困难的宏案例排序。然而，宏中的代码必须避免不重叠的模式，因此遵循不同的顺序。

<cps-macro>)) ::=

> | (define-syntax (cps e) |
> | --- |
> |   (syntax-case e (with rec lam cnd seq set quote display read-number) |
> |     <cps-macro-with-case>)) |
> |     <cps-macro-rec-case>)) |
> |     <cps-macro-lam-case>)) |
> |     <cps-macro-cnd-case>)) |
> |     <cps-macro-display-case>)) |
> |     <cps-macro-read-number-case>)) |
> |     <cps-macro-seq-case>)) |
> |     <cps-macro-set-case>)) |
> |     <cps-macro-quote-case>)) |
> |     <cps-macro-app-1-case>)) |
> |     <cps-macro-app-2-case>)) |
> |     <cps-macro-atomic-case>)))) |

我们在 CPS 中的表示将是将每个表达式转换为一个带有一个参数（续集）的过程。转换后的表达式最终将向续集提供一个值，或者将续集传递给将会——通过保持这个不变性的归纳——向其提供一个值的其他表达式。因此，CPS 的所有输出看起来都像 (lambda (k) ...)（我们将依赖卫生性[REF]来防止所有这些引入的 k 互相冲突）。

首先，让我们处理最简单的情况，即原子值。尽管在概念上最简单，但我们将其放在最后编写，否则此模式将掩盖所有其他情况。（理想情况下，我们应该首先编写它，并提供一个精确定义我们要将其视为原子的语法情况的保护表达式。我们在这里玩得很随意，因为我们的重点是更有趣的情况。）在原子情况下，我们已经有一个值，所以我们只需将其提供给续集：

<cps-macro-atomic-case>)) ::=

> | [(_ atomic) |
> | --- |
> |  #'(lambda (k) |
> |      (k atomic))] |

类似地，对于引用的常量：

<cps-macro-quote-case>)) ::=

> | [(_ 'e) |
> | --- |
> |  #'(lambda (k) (k 'e))] |

此外，我们已经知道，从 [REF] 和 [REF]，我们可以分别将 with 和 rec 视为宏：

<cps-macro-with-case>)) ::=

> | [(_ (with (v e) b)) |
> | --- |
> |  #'(cps ((lam (v) b) e))] |

<cps-macro-rec-case>)) ::=

> | [(_ (rec (v f) b)) |
> | --- |
> |  #'(cps (with (v (lam (arg) (error 'dummy "nothing"))) |
> |               (seq |
> |                (set v f) |
> |                b)))] |

变异很容易：我们必须评估新值，然后执行实际的更新：

<cps-macro-set-case>)) ::=

> | [(_ (set v e)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps e) (lambda (ev) |
> |                 (k (set! v ev)))))] |

顺序也很简单：我们依次执行每个操作。注意，这样保留了顺序语义：它不仅遵循操作顺序，而且第一个子项（e1）的值在第二个子项（e2）的正文中没有提到，因此保存其值的标识符的名称是无关紧要的。

<cps-macro-seq-case>)) ::=

> | [(_ (seq e1 e2)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps e1) (lambda (_) |
> |                  ((cps e2) k))))] |

处理条件时，我们需要创建一个新的延续来记住我们正在等待测试表达式的评估。然而，一旦我们有了它的值，我们就可以根据结果进行分派并返回到现有的延续：

<cps-macro-cnd-case>)) ::=

> | [(_ (cnd tst thn els)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps tst) (lambda (tstv) |
> |                   (if tstv |
> |                       ((cps thn) k) |
> |                       ((cps els) k)))))] |

处理应用程序时，我们有两种情况需要考虑。我们绝对需要处理语言中创建的过程的处理：带有一个参数的过程。然而，为了编写示例程序，能够使用诸如 + 和 * 之类的基本操作是很有用的。因此，我们将简单地假设用户编写了带一个参数的过程，因此需要将其转换为 CPS，而带有两个参数的过程是不会执行任何 Web 或其他控制操作的原语，因此可以直接调用；我们还将假设原语将内联编写（即，应用位置不会是一个可以执行 Web 交互的复杂表达式）。

对于应用程序，我们必须评估函数和参数表达式。一旦我们获得了这些，我们就可以准备应用函数了。因此，很容易写成

<cps-macro-app-1-case-take-1>)) ::=

> | [(_ (f a)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps f) (lambda (fv) |
> |                 ((cps a) (lambda (av) |
> |                            (k (fv av)))))))] |

现在就做！

> 你明白这为什么是错误的吗？

问题在于，尽管函数现在是一个值，但该值是一个具有潜在复杂体的闭包：评估体可能导致进一步的 Web 交互，此时函数的其余部分体，以及待处理的 (k ...)（即程序的其余部分）都将丢失。为了避免这种情况，我们必须向函数的值提供 k，并让归纳不变量确保 k 最终将被调用，其值为将 fv 应用于 av 的结果：

<cps-macro-app-1-case>)) ::=

> | [(_ (f a)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps f) (lambda (fv) |
> |                 ((cps a) (lambda (av) |
> |                            (fv av k))))))] |

处理内置二元操作的特殊情况更容易：

<cps-macro-app-2-case>)) ::=

> | [(_ (f a b)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps a) (lambda (av) |
> |                 ((cps b) (lambda (bv) |
> |                            (k (f av bv)))))))] |

我们在这里使用了我们无法用于用户定义���程的模式，因为我们假设 f 的应用总是会在没有任何异常控制转移的情况下返回。

函数本身是一个值，因此应该返回给待处理的计算。然而，上面的应用情况显示，我们必须将函数转换为接受额外参数的形式，即在调用点处的延续。这让我们陷入了困境：我们应该向体提供哪个延续？

<cps-macro-lam-case-take-1>)) ::=

> | [(_ (lam (a) b)) |
> | --- |
> |  (identifier? #'a) |
> |  #'(lambda (k) |
> |      (k (lambda (a dyn-k) |
> |           ((cps b) ...))))] |

也就是说，在...的位置，我们应该提供哪个延续：k 还是 dyn-k？

现在就做！

> 我们应该提供哪个延续？

前者是在闭包创建时的延续。后者是在闭包调用时的延续。换句话说，前者是“静态的”，后者是“动态的”。在这种情况下，我们需要使用动态延续，否则会发生非常奇怪的事情：程序会返回到创建闭包的地方，而不是使用它的地方！这将导致看似非常奇怪的程序行为，所以我们希望避免这种情况。请注意，我们在这里有意选择动态延续，就像在处理作用域时选择静态环境一样。

<cps-macro-lam-case>)) ::=

> | [(_ (lam (a) b)) |
> | --- |
> |  (identifier? #'a) |
> |  #'(lambda (k) |
> |      (k (lambda (a dyn-k) |
> |           ((cps b) dyn-k))))] |

最后，为了模拟 Web 编程，我们可以添加我们的输入和输出过程。输出遵循我们已经看到的应用模式：

<cps-macro-display-case>)) ::=

> | [(_ (display output)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps output) (lambda (ov) |
> |                      (k (display ov)))))] |

最后，对于输入，我们可以使用预先存在的 read-number/suspend，但这次生成其用途而不是强制程序员构建它们：

<cps-macro-read-number-case>)) ::=

> | [(_ (read-number prompt)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps prompt) (lambda (pv) |
> |                      (read-number/suspend pv k))))] |

注意，绑定到 k 的延续恰好是我们需要在 Web 交互点存储的延续。

对于测试转换为 CPS 的任何代码都稍微麻烦，因为所有 CPS 术语都期望延续。初始延续是一个简单地（a）消耗一个值并返回它，或者（b）消耗一个值并打印它，或者（c）消耗一个值，打印它，并准备好另一个计算（如 DrRacket 交互窗口中的提示）。这三者实际上都只是不同形式的恒等函数。因此，以下定义对于测试非常有帮助：

> | (define (run c) (c identity)) |
> | --- |

例如，

> | (test (run (cps 3))                           3) |
> | --- |
> | (test (run (cps ((lam ()    5)       )))      5) |
> | (test (run (cps ((lam (x)   (* x x)) 5)))     25) |
> | (test (run (cps (+ 5 ((lam (x) (* x x)) 5)))) 30) |

我们也可以测试我们的旧网络程序：

> | (run (cps (display (+ (read-number "First") |
> | --- |
> |                       (read-number "Second"))))) |

以免您在代码的海洋中迷失，让我强调这里的重要教训：我们恢复了我们的代码结构。也就是说，我们可以用直接的方式编写程序，使用正确的嵌套表达式，并且编译器——在这种情况下，CPS 转换器——负责使其与合适的底层 API 配合工作。这才是良好的编程语言应该做的！

### 14.2.2 转换示例

让我们考虑上面的例子并看看它转换成了什么。您可以手工进行此操作，也可以采用 DrRacket 的宏调试器的简便方法。目前，您需要将代码放在#lang racket 中，以充分利用宏调试器的功能。假设我们包含在 run 中包含的对 identity 的应用，我们得到：

> | (lambda (k) |
> | --- |
> |   ((lambda (k) |
> |      ((lambda (k) |
> |         ((lambda (k) |
> |            (k "First")) (lambda (pv) |
> |                           (read-number/suspend pv k)))) |
> |       (lambda (lv) |
> |         ((lambda (k) |
> |            ((lambda (k) |
> |               (k "Second")) (lambda (pv) |
> |                               (read-number/suspend pv k)))) |
> |          (lambda (rv) |
> |            (k (+ lv rv))))))) |
> |    (lambda (ov) |
> |      (k (display ov))))) |

什么！这根本不是我们手工编写的版本！

实际上，这个程序充满了所谓的管理 lambda，这些 lambda 是由我们使用的特定 CPS 算法引入的。设计更好的 CPS 算法，消除不必要的管理 lambda，因此是一个持续且开放的研究问题。不用担心！如果我们逐步应用这些 lambda 并替换，然而—<wbr>

现在就做！

> 去做吧！

—<wbr>程序会简化为

> | (read-number/suspend "First" |
> | --- |
> |                      (lambda (lv) |
> |                        (read-number/suspend "Second" |
> |                                             (lambda (rv) |
> |                                               (identity |
> |                                                (display (+ lv rv))))))) |

这正是我们想要的。

### 14.2.3 核心实现

现在我们已经看到 CPS 如何通过 desguaring 实现，���们应该问问它是否可以放在核心中。

记住，我们曾说过 CPS 适用于所有程序。我们对一个程序特别感兴趣：解释器。果不其然，我们可以对其应用 CPS 转换，从而提供实际上是相同的延续。

首先，我们会发现使用过程式闭包表示会更方便[REF]。我们将让解释器接受一个额外的参数，该参数消耗值（传递给延续的值）并最终返回它们：

<cps-interp>)) ::=

> | (define (interp/k [expr : ExprC] [env : Env] [k : (Value -> Value)]) : Value |
> | --- |
> |   <cps-interp-body>))) |

在简单情况下，我们不需要返回一个值，而只需将其传递给延续参数：

<cps-interp-body>)) ::=

> | (type-case ExprC expr |
> | --- |
> |   [numC (n) (k (numV n))] |
> |   [idC (n) (k (lookup n env))] |
> |   <cps-interp-plusC-case>)) |
> |   <cps-interp-appC-case>)) |
> |   <cps-interp-lamC-case>))) |

（请注意，multC 的处理方式与 plusC 完全类似。）

让我们从简单情况开始，即 plusC。首先解释左子表达式。这个评估的延续解释右子表达式。为此添加结果的延续。加法的结果应该怎么处理？在 interp 中，它被返回给导致 plusC 被解释的任何计算。现在，请记住，我们不再返回值；而是将它们传递给延续：

<cps-interp-plusC-case>)) ::=

> | [plusC (l r) (interp/k l env |
> | --- |
> |                        (lambda (lv) |
> |                          (interp/k r env |
> |                                    (lambda (rv) |
> |                                      (k (num+ lv rv))))))] |

练习

> 实现 multC 的代码。

这留下了两个困难且相关的部分。

在一个应用程序中，我们再次需要解释两个子表达式，然后将得到的闭包应用于参数。但我们已经同意每个应用程序都需要一个续体参数。因此，我们必须更新对值的定义：

> | (define-type Value |
> | --- |
> |   [numV (n : number)] |
> |   [closV (f : (Value (Value -> Value) -> Value))]) |

现在我们必须决定传递什么样的续体。在一个应用程序中，这是传递给解释器的续体：

<cps-interp-appC-case>)) ::=

> | [appC (f a) (interp/k f env |
> | --- |
> |                       (lambda (fv) |
> |                         (interp/k a env |
> |                                   (lambda (av) |
> |                                     ((closV-f fv) av k)))))] |

最后是 lamC 情况。我们必须像以前一样使用 lambda 创建 closV。然而，这个过程需要接受两个参数：参数的实际值，以及应用的续体。关键问题是，后一个值是什么？

我们基本上有两种选择。k 表示静态续体：在闭包构造点处活动的续体。然而，我们想要的是闭包调用点的续体：动态续体。

<cps-interp-lamC-case>)) ::=

> | [lamC (a b) (k (closV (lambda (arg-val dyn-k) |
> | --- |
> |                         (interp/k b |
> |                                   (extend-env (bind a arg-val) |
> |                                               env) |
> |                                   dyn-k))))] |

要测试这个修改后的解释器，我们需要用某种初始续体值调用 interp/k。这需要是一个代表计算中没有任何东西剩余的过程。这的一个自然表示是恒等函数：

> | (define (interp [expr : ExprC]) : Value |
> | --- |
> |   (interp/k expr mt-env |
> |             (lambda (ans) |
> |               ans))) |

为了表示这严格是对 interp/k 的顶层接口，我们已经删除了环境参数并自动传递了空环境。如果我们特别确定没有意外地递归使用这个过程，我们可以在其末尾插入一个调用错误的调用，以防止它返回并且其返回值被使用。

## 14.3 生成器

许多编程语言现在都有生成器的概念。生成器类似于一个过程，因为可以在应用程序中调用它。而正常过程总是从开头开始执行，生成器则从上次停止的地方继续执行。当然，这意味着生成器需要一种“在完成之前退出”的概念。这被称为产出，即将控制权返回给调用它的内容。

### 14.3.1 设计变体

生成器之间存在许多变化。可以预见的变化点与如何进入和退出生成器有关：

+   在某些语言中，生成器是实例化的对象，像任何其他对象一样，并且通过调用方法（例如 Python 中的 next）恢复其执行。在其他语言中，它就像一个过程一样，并且实际上是通过像函数一样应用它而重新进入的。在除了常规过程之外还可以在应用程序中使用值的语言中，所有这些值都被称为可应用的。

+   在某些语言中，yielding 操作——比如 Python 的 yield——只能在生成器的句法主体内部使用。在其他语言中，如 Racket，yield 是在主体中绑定的可应用值，但由于是值，它可以传递给抽象，存储在数据结构中等等。

Python 的设计在于生成器只是任何包含关键字 yield 的函数。此外，Python 的 yield 不能作为参数传递给另一个代表生成器执行 yield 的函数。还有一个小问题是命名。在许多具有生成器的语言中，yielder 自动称为 yield 单词：作为关键字（如 Python 中）或作为绑定到适用值的标识符（如 Racket 中）。另一种可能性是生成器的使用者必须在生成器表达式中指示要给 yielder 什么名称。有趣的是，Python 期望用户确定在对象中调用 self 或 this 的名称，但它不提供 yield 相同的灵活性，因为它没有其他方法来确定哪些函数是生成器！即，使用可能看起来像

> | (generator (yield) (from) |
> | --- |
> |            (rec (f (lam (n) |
> |                      (seq |
> |                        (yield n) |
> |                        (f (+ n 1))))) |
> |              (f from))) |

但它等价于

> | (generator (y) (from) |
> | --- |
> |            (rec (f (lam (n) |
> |                      (seq |
> |                        (y n) |
> |                        (f (+ n 1))))) |
> |              (f from))) |

如果 yielder 是一个实际值，用户还可以抽象出 yield：

> | (generator (y) (from) |
> | --- |
> |            (rec (f (lam (n) |
> |                      (seq |
> |                        ((yield-helper y) n) |
> |                        (f (+ n 1))))) |
> |              (f from))) |

其中 yield-helper 可能会执行实际的 yield。实际上还有两个设计决策：

1.  yield 是语句还是表达式？在许多语言中，它实际上是一个表达式，意味着它有一个值：在恢复生成器时提供的值。这使得生成器更加灵活，因为生成器的使用者可以使用参数来改变生成器的行为，而不是被迫使用状态来传达所需的变化。

1.  生成器执行结束时会发生什么？在许多语言中，生成器会引发异常来表示其完成。

### 14.3.2 实现生成器

要实现生成器，使用我们的 CPS 宏语言将会特别有用。首先让我们确定我们对上述设计决策的立场。我们将使用生成器的适用表示：也就是说，从生成器请求下一个值是通过将其应用于任何必要的参数来完成的。同样，产出者也将是一个可应用的值，并且将依次是一个表达式。虽然我们已经看到宏如何可以自动捕获一个名称[REF]，但为了使宏更简单，让我们明确地指定产出者的名称。最后，当生成器执行完毕时，我们将引发错误。

生成器是如何工作的？要产出，生成器必须

+   记住它在执行中的当前位置，并且

+   知道它在其调用者中应该返回到哪里。

当被调用时，它应该

+   记住它在执行中的调用者当前所在位置，并且

+   知道它在其主体中应该返回到哪里。

观察调用和产出之间的双重性。

正如你可能猜到的那样，“where”对应于继续。

让我们逐步建立 cps 宏的生成规则。首先是一个头部模式：

<cps-macro-generator-case>)) ::=

> | （_ (generator (yield) (v) b)) |
> | --- |
> | （和 (identifier? #'v) (identifier? #'yield)） |
> | [（<generator-body>))）] |

主体的开始很简单：CPS 中的所有代码都需要消耗一个继续，因为生成器是一个值，所以应该将此值提供给继续：

<generator-body>)) ::=

> | #'（lambda (k) |
> | --- |
> | （k <generator-value>))）） |

现在我们准备着手处理生成器的核心。

回想一下，生成器是一个可应用的值。这意味着它可以出现在一个应用位置，并且因此必须与过程具有相同的“接口”：一个带有两个参数的过程，第一个是值，第二个是应用点的继续。这个过程应该做什么？我们上面描述了这一点。首先，生成器必须记住调用者在其执行中的位置，这正是应用点的继续；这里的“记住”最简单地意味着“必须存储在状态中”。然后，生成器应该返回到它先前的位置，即它自己的继续，这显然必须已经存储了。因此，可应用值的核心是：

<generator-core>)) ::=

> | （lambda (v dyn-k) |
> | --- |
> | （开始 |
> | （set! where-to-go dyn-k） |
> | （resumer v）） |

在这里，where-to-go 记录了调用者的继续，以便在产出时恢复它；resumer 是生成器的本地继续。让我们考虑一下它们的初始值必须是什么：

+   where-to-go 没有初始值（因为生成器尚未被调用），所以如果被使用，它需要抛出一个错误。幸运的是，这个错误永远不会发生，因为 where-to-go 在第一次进入生成器时被修改，所以错误只是针对实现中的错误的保护措施。

+   最初，生成器的剩余部分是整个生成器，因此 resumer 应该绑定到（CPS of）b。它的 continuation 是什么？这是整个生成器的 continuation，即生成器完成时要执行的操作。我们已经同意，这也应该发出一个错误信号（除非在这种情况下错误确实可能发生，即生成器被要求产生的值超出了其装备的值）。

我们仍然需要绑定 yield。正如我们指出的，它对生成器的恢复是对称的：将本地 continuation 保存在 resumer 中，并通过应用 where-to-go 进行返回。

将这些片段组合起来，我们得到：

<生成器值>)) ::=

> | (let ([where-to-go (lambda (v) (error 'where-to-go "nothing"))]) |
> | --- |
> |   (letrec([resumer (lambda (v) |
> |                      ((cps b) (lambda (k) |
> |                                 (error 'generator "fell through"))))] |
> |           [yield (lambda (v gen-k) |
> |                    (begin |
> |                      (set! resumer gen-k) |
> |                      (where-to-go v)))]) |
> |     <生成器核心>)))) |

现在做！

> 为什么要使用 let 和 letrec 的这种模式，而不是 let？

观察这些代码片段之间的依赖关系。where-to-go 不依赖于 resumer 或 yield 中的任何一个。yield 明显依赖于 where-to-go 和 resumer。但是为什么 resumer 和 yield 互相引用？

现在做！

> 尝试替代方案！

你可能会忽视的微妙依赖关系是，resumer 包含了 b，生成器的主体，它可能包含对 yield 的引用。因此，它需要对 yielder 的绑定进行闭包。

练习

> 生成器与协程和线程有何不同？使用类似的策略实现协程和线程。

## 14.4 续集与栈

尽管可能令人惊讶，但 CPS 转换实际上为程序执行栈的性质提供了巨大的见解。要理解的第一件事是，每个 continuation 实际上都是栈本身。这可能看起来有些奇怪，因为栈是低级别的机器原语，而 continuation 看起来是复杂的过程。但是栈真的是什么？

+   这是计算中剩下的工作的记录。继续也是如此。

+   -   传统上它被认为是堆栈帧的列表。也就是说，每个框架都引用在其完成后剩余的框架。同样，每个继续是一个小过程，引用-<wbr>并因此闭合-<wbr>它自己的继续。如果我们选择了不同的程序指令表示法，将其与闭包的数据结构表示法结合，我们将获得一种基本与机器堆栈相同的继续表示。

+   -   每个堆栈帧还存储过程参数。这是通过继续的程序表示隐式管理的，而在数据结构表示中，这是通过明确使用 bind 来完成的。

+   -   每个框架还有“局部变量”的空间。原则上，继续也有，尽管通过使用局部绑定的宏实现，我们已经将一切有效地减少到了过程参数。然而，在概念上，其中一些是“真正”的过程参数，而其他一些是通过宏转换为过程参数的局部绑定。

+   -   堆栈引用堆，但不闭合。因此，堆上的更改在堆栈帧之间可见。以完全相同的方式，闭包引用存储，但不关闭，因此对存储的更改在闭包之间可见。

-   因此，传统上堆栈负责维护词法作用域，这是自动获得的，因为我们在静态作用域语言中使用闭包。现在我们可以研究各种术语的转换以理解到堆栈的映射。例如，考虑函数应用的转换[REF]：

> | [(_ (f a)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps f) (lambda (fv) |
> |                 ((cps a) (lambda (av) |
> |                            (fv av k))))))] |

-   我们如何“读取”这个？如下所示：

+   -   让我们使用 k 来引用函数应用程序开始评估之前存在的堆栈。

+   -   当我们开始评估函数位置（f）时，创建一个新的堆栈帧((lambda (fv) ...))。该帧有一个自由标识符：k。因此，它的闭包需要记录环境的一个元素，即堆栈的其余部分。

+   -   堆栈帧的代码部分表示我们获得函数值后剩下的工作：评估参数，并执行应用程序，并将结果返回给期望应用程序的堆栈：k。

+   -   当 f 的评估完成时，我们开始评估 a，这也创建一个堆栈帧：(lambda (av) ...)。该帧有两个自由标识符：k 和 fv。这告诉我们：

    +   -   我们不再需要用于评估函数位置的堆栈帧，但是

    +   -   现在我们需要一个临时记录值-<wbr>希望是函数值-<wbr>评估函数位置的值。

+   -   此第二帧的代码部分也表示剩下的工作：在期望应用程序的值的堆栈中使用参数调用函数值。

-   让我们对条件应用类似的推理：

> | [(_ (cnd tst thn els)) |
> | --- |
> |  #'(lambda (k) |
> |      ((cps tst) (lambda (tstv) |
> |                   (if tstv |
> |                       ((cps thn) k) |
> |                       ((cps els) k)))))] |

它说，要评估条件表达式，我们必须创建一个新的栈帧。该帧封闭了期望整个条件值的栈。这个帧根据条件表达式的值做出决定，并调用其他表达式之一。一旦我们检查了这个值，用于评估条件表达式的帧就不再需要了，所以评估可以在 k 中进行。

通过这个视角，我们可以更容易地为生成器提供一个操作性的解释。每个生成器都有自己的私有栈，当执行尝试返回到其结束时，我们的实现会引发错误。在调用时，生成器将“程序的其余部分”的栈的引用存储在 where-to-go 中，并恢复其自己的栈，该栈由 resumer 引用。在产生中，系统交换栈的引用。协程、线程和生成器都是概念上相似的：它们都是创建“许多小栈”而不是拥有单个全局栈的机制。

## 14.5 尾调用

注意上述栈模式会向当前栈添加一个帧，执行一些评估，最终总是返回到当前栈。特别要注意，在应用中，我们需要栈空间来评估函数位置和参数，但一旦所有这些都被评估了，我们就会使用在应用之前开始的栈来恢复计算。换句话说，函数调用本身并不需要消耗栈空间：我们只需要空间来计算参数。

然而，并非所有的语言都遵守或尊重这个属性。在遵循这个属性的语言中，程序员可以使用递归来获得迭代行为：即，一系列函数调用的堆栈空间消耗不会比根本没有函数调用更多。这消除了创建特殊循环结构的需要；事实上，循环可以简单地表示为一种语法糖。

当然，这个属性通常并不适用。如果调用 f 来计算调用 g 的参数，那么调用 f 仍然相对于 g 周围的上下文消耗空间。因此，我们真正需要谈论的是表达式之间的关系：一个表达式相对于另一个表达式的尾部位置，如果它的评估不需要比另一个表达式更多的栈空间。在我们的 CPS 宏中，每个使用 k 作为其延续的表达式——比如在所有子表达式被评估后的函数应用，或者条件语句的 then 分支和 else 分支——都相对于封闭应用的尾部位置（也许是递归地更高位置）。相反，每个必须创建新栈帧的表达式都不在尾部位置。

一些语言对尾递归有特殊支持：当一个过程在相对于其主体的尾位置调用自身时。这显然很有用，因为它使递归能够高效地实现循环。然而，它会影响那些无法被压缩成单个递归函数的“循环”。例如，当实现扫描器或其他状态机时，最方便的方法是有一组函数，每个函数代表一个状态，并通过进行（尾）函数调用来转换到其他状态。将这些转换为单个递归函数是繁琐的（并且失去了意义）。然而，如果一种语言将尾调用识别为这样的话，它可以像内部函数一样优化这些跨函数调用。

特别是 Racket 承诺在不分配额外堆栈空间的情况下实现尾调用。尽管有些人将其称为“尾调用优化”，但这个术语是误导性的：优化是可选的，而语言是否承诺正确实现尾调用是一个语义特性。开发人员需要知道语言的行为方式，因为这影响他们的编程方式。

由于这个特性，在 CPS 转换后观察程序的一个有趣之处：所有的函数应用本身都是尾调用！你可以从本章开始的 read-number/suspend 示例中看到这一点：任何待处理的计算都被放入延续参数中。假设程序可能在任何调用时终止等同于根本不使用任何堆栈空间（因为堆栈会被清除）。

练习

> 在没有堆栈的情况下，程序是如何能够运行的？

## 14.6 延续作为一种语言特性

通过对延续和堆栈之间连接的洞察，我们现在可以回到处理过程的问题：我们在闭包创建时忽略了延续，而是只在闭包调用时使用了延续。这当然对应于正常的过程行为。但现在我们可以问，如果我们使用创建时的延续呢？这将对应于在“过程”创建时保持对（堆栈的副本）的引用，并且在应用过程时，忽略动态评估并返回到过程创建点。

原则上，我们试图保持 lambda 不变，而是给自己一个与此行为相对应的语言构造：cc = “当前延续”

<cps-macro-let/cc-case>)) ::=

> | [(_ (let/cc kont b)) |
> | --- |
> |  (标识符？ #'kont) |
> |  #'(lambda (k) |
> |      (let ([kont (lambda (v dyn-k) |
> |                    (k v))]) |
> |        ((cps b) k)))] |

这句话的意思是，无论如何，控制都将返回到紧邻 let/cc 的表达式：要么通过继续（因为 body 的延续 b 是 k），要么—<wbr>更有趣的是—<wbr>通过调用延续，通过简单地忽略动态延续 dyn/k 并返回到 k 来丢弃它。

这是最简单的测试：

> | (test (run (cps (let/cc esc 3))) |
> | --- |
> |       3) |

这证实了如果我们从未使用延续，那么对 body 的评估将继续进行，就好像 let/cc 根本不存在（因为 ((cps b) k)）。如果我们使用它，那么给定给延续的值将返回到创建点：

> | (test (run (cps (let/cc esc (esc 3)))) |
> | --- |
> |       3) |

当然，这个例子并不具有启示性，但考虑这个例子：

> | (test (run (cps (+ 1 ( let/cc esc (esc 3)))) |
> | --- |
> |       4) |

这证实了实际发生了加法。但动态继续呢？

> | (test (run (cps (let/cc esc (+ 2 (esc 3))))) |
> | --- |
> |       3) |

这表明加法 2 从未发生，即动态继续确实被忽略了。为了确保在创建点处尊重继续，观察：

> | (test (run (cps (+ 1 ( let/cc esc (+ 2 (esc 3)))))) |
> | --- |
> |       4) |

从这些例子中，你可能已经注意到了一个熟悉的模式：这里的 esc 就像一个异常。也就是说，如果你不抛出异常（在这种情况下，调用一个延续），就好像它不存在一样，但如果你抛出它，所有待处理的中间计算都会被忽略，计算会返回到异常创建点。

练习

> 使用 let/cc 和宏，创建一个 throw/catch 机制。

然而，这些例子只是揭示了可用力量的冰山一角，因为在调用点处的延续总是在创建点的延续的扩展：即，后者只是在堆栈中比前者更早。然而，实际上没有任何要求 k 和 dyn-k 必须相关。这意味着它们实际上可以是无关的，这意味着每个都可以是一个不同的堆栈，因此我们实际上可以很容易地使用它们实现堆栈切换过程。

练习

> 为了与 lambda 适当类比，我们应该引入一个称为 cont-lambda 的构造，其扩展如下：
> 
> > | [(_ (cont-lambda (a) b)) |
> > | --- |
> > |  (identifier? #'a) |
> > |  #'(lambda (k) |
> > |      (k (lambda (a dyn-k) |
> > |           ((cps b) k))))] |
> > 
> 为什么我们没有？考虑静态类型的影响，以及我们如何使用这个构造来构建类似异常的行为。

### 14.6.1 语言中的呈现

在我们的小玩具语言中编写程序很快就会变得令人沮丧。幸运的是，Racket 已经提供了一个叫做 call/cc 的构造，它实现了延续。call/cc 是一个带有一个参数的过程，该参数本身是一个带有一个参数的过程，Racket 将其应用于当前延续——<wbr>这是一个带有一个参数的过程。明白了吗？

幸运的是，我们可以很容易地将 let/cc 写成一个宏，覆盖 call/cc 并用它来编程。这里是它的实现：

> | (define-syntax let/cc |
> | --- |
> |   (syntax-rules () |
> |     [(let/cc k b) |
> |      (call/cc (lambda (k) b))])) |

确保，我们所有的旧测试仍然通过：

> | (test (let/cc esc 3) 3) |
> | --- |
> | (test (let/cc esc (esc 3)) 3) |
> | (test (+ 1 (let/cc esc (esc 3))) 4) |
> | (test (let/cc esc (+ 2 (esc 3))) 3) |
> | (test (+ 1 (let/cc esc (+ 2 (esc 3)))) 4) |

### 14.6.2 定义生成器

现在我们可以开始创建有趣的抽象。例如，让我们构建生成器。以前我们需要同时使用 CPS 表达式并传递延续，现在这些都会自动由 call/cc 完成。因此，每当我们需要当前延续时，我们只需简单地召唤它，而无需转换程序。因此，额外的...-k 参数可以在相同位置的 let/cc 中消失，以捕获相同的延续：

> | (define-syntax (generator e) |
> | --- |
> |   (syntax-case e () |
> |     [(generator (yield) (v) b) |
> |      #'(let ([where-to-go (lambda (v) (error 'where-to-go "nothing"))]) |
> |          (letrec ([resumer (lambda (v) |
> |                              (begin b |
> |                                     (error 'generator "fell through")))] |
> |                   [yield (lambda (v) |
> |                            (let/cc gen-k |
> |                              (begin |
> |                                (set! resumer gen-k) |
> |                                (where-to-go v))))]) |
> |            (lambda (v) |
> |              (let/cc dyn-k |
> |                (begin |
> |                  (set! where-to-go dyn-k) |
> |                  (resumer v))))))])) |

观察这段代码与通过将代码解糖为 CPS 代码来实现生成器之间的密切相似性。具体来说，我们可以去掉额外的延续参数，并用 let/cc 的调用来精确捕获相同的延续。代码的其余部分基本上没有改变。

练习

> 如果我们将 let/cc 和变异移到 begins 中的第一个语句，会发生什么？

例如，我们可以编写一个从初始值开始向上迭代的生成器：

> | (define g1 (generator (yield) (v) |
> | --- |
> |                       (letrec ([loop (lambda (n) |
> |                                        (begin |
> |                                          (yield n) |
> |                                          (loop (+ n 1))))]) |
> |                         (loop v)))) |

其行为是：

| > (g1 10) |
| --- |
| 10 |
| > (g1 10) |
| 11 |
| > (g1 0) |
| 12 |
| > |

因为主体只引用��始值，忽略通过调用 yield 返回的值，我们在后续调用中传递的值是无关紧要的。相比之下，考虑这个生成器：

> | (define g2 (generator (yield) (v) |
> | --- |
> |                       (letrec ([loop (lambda (n) |
> |                                        (loop (+ (yield n) n)))]) |
> |                         (loop v)))) |

在第一次调用时，它返回提供的任何值。在后续调用中，该值会累加到重新进入生成器时提供的值上。换句话说，该生成器会累加所有给定的值：

| > (g2 10) |
| --- |
| 10 |
| > (g2 15) |
| 25 |
| > (g2 5) |
| 30 |

练习

> 现在您已经看到如何使用 call/cc 和 let/cc 实现生成器，请同时实现协程和线程。

### 14.6.3 定义线程

在完成了生成器之后，让我们再做另一个类似的基本操作：线程。也就是说，假设我们想要编写这样一个程序：

> | (define d display) ;; 在接下来的内容中，这是一个有用的缩写 |
> | --- |
> |   |
> | (scheduler-loop-0 |
> |  (list |
> |   (thread-0 (y) (d "t1-1  ") (y) (d "t1-2  ") (y) (d "t1-3 ")) |
> |   (thread-0 (y) (d "t2-1  ") (y) (d "t2-2  ") (y) (d "t2-3 ")) |
> |   (thread-0 (y) (d "t3-1  ") (y) (d "t3-2  ") (y) (d "t3-3 ")))) |

并期望输出

| t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3 |
| --- |

我们将构建实现此目标所需的所有组件。

让我们从定义线程调度程序开始。它会消耗一个“线程”列表，我们假设其接口将是一个消耗延续的过程，最终将控制权交给它。每次调度程序重新激活线程时，它都会提供一个延续给它。调度程序可以简单地循环选择线程，也可以使用一些更复杂的算法；我们在这里不关心它的选择细节。

与生成器一样，我们假设让出控制权是通过调用用户命名的过程来完成的：上面的 y。我们可以使用名称捕获 [REF] 自动绑定类似 yield 的名称。

更重要的是，请注意线程系统的用户手动放弃了控制权。这被称为协作式多任务处理。相反，我们也可以选择有一个定时器或其他固有机制在没有用户许可的情况下自动放弃控制权；这被称为抢占式多任务处理（因为系统“抢占”—即，从线程中夺取控制权）。虽然这种区别对于构建系统很重要，但从设置延续的角度来看，这并不重要。

练习

> 在完成构建协作式多任务处理之后，实现抢占式多任务处理。会有什么变化？

在我们确定的约束条件下，我们可以编写一个第一个调度程序。它会消耗一个线程列表，并在仍有剩余线程时继续执行。每次，它都会将线程过程应用于表示返回到调度程序并继续到下一个线程的延续：

> | (define (scheduler-loop-0 threads) |
> | --- |
> |   (cond |
> |     [(empty? threads) 'done] |
> |     [(cons? threads) |
> |      (begin |
> |        (let/cc after-thread ((first threads) after-thread)) |
> |        (scheduler-loop-0 (append (rest threads) |
> |                                  (list (first threads)))))])) |

当接收线程调用绑定到 after-thread 的延续时，控制返回到 begin 序列中第一条语句的末尾。因此，传递给延续的值被忽略了（因此可以是任意虚拟值；我们将选择'dummy，这样如果它出现在不希望出现的地方，我们就可以很容易地发现它）。然后，控制继续进行，将最近调用的线程追加到线程列表的末尾（即，将列表视为循环队列）。现在让我们定义一个线程。正如我们所说，它将是一个带有一个参数（调度程序的延续）的过程。因为线程需要恢复，即继续上次的位置，所以它可能必须存储上次的位置：我们将其称为线程恢复器。最初，这是整个线程体，但在后续实例中，它将是一个延续：具体来说，是调用 yield 的延续。因此，我们得到以下骨架：

> | (定义语法 线程-0 |
> | --- |
> |   (语法规则 () |
> |     [(线程（生成器）b ...） |
> |      (letrec ([线程恢复器 (lambda (_) |
> |                                 (begin b ...))]) |
> |        (lambda (sched-k) |
> |          (线程恢复器 'dummy)))])) |

这仍然留下了生成器。它需要是一个没有参数的过程，它将线程的延续存储在线程恢复器中，然后用'dummy 调用调度程序延续。但是，它需要调用哪个调度程序延续？不是在线程初始化时提供的那个，而是最近的一个。因此，我们必须以某种方式“线程化”sched-k 的值传递给生成器。有许多方法可以实现它，但最简单、也许最残酷的方法是在每次线程恢复时简单地重建生成器，始终封闭在 sched-k 的最新值之上：

> | (定义语法 线程-0 |
> | --- |
> |   (语法规则 () |
> |     [(线程（生成器）b ...） |
> |      (letrec ([线程恢复器 (lambda (_) |
> |                                 (begin b ...))] |
> |               [生成器（lambda () (error '生成器 "这里什么都没有"))]) |
> |        (lambda (sched-k) |
> |          (begin |
> |            (set! 生成器 |
> |                  (lambda () |
> |                    (let/cc thread-k |
> |                      (begin |
> |                        (set! 线程恢复器 thread-k) |
> |                        (sched-k 'dummy))))) |
> |            (线程恢复器 'tres))))])) |

当我们运行这个集合时，我们得到：

| t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3 |
| --- |

嘿，这正是我们想要的！但它继续说：

| t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 |
| --- |

嗯。

发生了什么？好吧，我们一直对线程到达其结束时需要发生的事情保持沉默。事实上，控制权只是返回给线程调度程序，后者将线程追加到队列的末尾，当线程再次来到队列的头部时，控制权从以前存储的同一个续体恢复：对应于打印第三个值的续体。这打印了，控制返回，线程被追加...无限。 |

显然，当线程终止时，我们需要通知线程调度程序，以便调度程序可以将其从线程队列中删除。我们将创建一个简单的数据类型来表示此信号：

> | （定义类型 ThreadStatus |
> | --- |
> | [Tsuspended] |
> | （Tdone）） |

（在真实系统中，当然，这些状态消息也可能携带来自计算的信息价值。）我们现在必须修改我们的调度程序以实际检查和使用这些值：

> | （定义（scheduler-loop-1 threads） |
> | --- |
> | （病情 |
> | [(empty？ threads）'done] |
> | [(cons？ threads） |
> | （type-case ThreadStatus（让/cc after-thread（（第一线程） after-thread））） |
> | [Tsuspended （）（scheduler-loop-1 （append （rest threads） |
> | （列表（第一线程））] |
> | [Tdone （）（scheduler-loop-1 （rest threads））））））） |

现在我们必须以两种方式修改我们的线程表示：它必须在中间返回时向调度程序的续体提供 Tsuspended，并在终止时提供 Tdone。它在哪里终止？在执行主体中的代码之后，b...请注意，最后，终止过程必须确保使用最新的调度程序续体，就像 yielding 一样。因此：

> | （define-syntax thread-1 |
> | --- |
> | （语法规则（） |
> | （线程（yielder）b ...） |
> | （letrec（[thread-resumer（λ（_） |
> | （开始 b ... |
> | [（完成者）））] |
> | [完成者（λ（）（错误'finisher“这里没有什么”））] |
> | [yielder（λ（）（错误'yielder“这里没有什么”））] |
> | （λ（sched-k） |
> | （开始 |
> | （set！ finisher |
> | （λ（） |
> | （让/cc thread-k |
> | （sched-k （Tdone））））） |
> | （set！ yielder |
> | （λ（） |
> | （让/cc thread-k |
> | （开始 |
> | （set！ thread-resumer thread-k） |
> | （sched-k （Tsuspended））））） |
> | （thread-resumer 'tres））））））））））））） |

如果我们现在用 scheduler-loop-1 替换 scheduler-loop-0，用 thread-1 替换 thread-0，并重新运行上面的示例程序，我们将得到我们想要的输出。

### 14.6.4 更好的网络编程原语 |

最后，为了将结论与我们开始的地方联系起来，让我们回到读数：观察到，如果运行服务器程序的语言具有 call/cc，那么我们可以简单地捕获当前的延续并将其保存在哈希表中，而不是必须将整个程序 CPS 化，从而再次保持程序结构完整。

# 11 内存管理

## 11.1 垃圾

我们使用术语垃圾来指代不再需要的分配内存。典型编程语言运行时系统执行的分配有两种不同类型。一种是为环境分配的；这遵循了与静态作用域性质一致的推入和弹出规则。从过程返回会释放该过程分配的环境空间以供后续使用，看似没有成本。这并不是免费的！机器必须执行显式的“弹出”指令来回收该空间。因此，这并不一定比其他内存管理策略更便宜。相比之下，存储器上的分配必须遵循值的生命周期，这可能超出了创建它的作用域的生命周期—实际上，它可能永远存在。因此，我们需要一种不同的策略来回收存储器分配的垃圾所占用的空间。

有许多方法可以回收这些空间，但它们主要分为两大阵营：手动和自动。手动收集取决于开发人员能够知道并正确丢弃不需要的内存。传统上，人类在这方面并不表现出色（尽管在某些情况下，他们可能拥有机器不具备的知识[REF]）。因此，几十年来，自动化方法几乎无处不在。

## 11.2 什么是“正确”的垃圾回收？

垃圾回收既不应该过早回收空间（完整性），也不应该过晚回收（完备性）。虽然两者都可以被视为缺陷，但它们在影响上并不对称：可以说，过早回收要糟糕得多。这是因为如果我们过早回收一个存储位置，计算将继续使用它，并有可能向其中写入其他数据，从而使用无意义的数据。这至少会导致程序不正确，但在更极端的情况下会导致更糟糕的现象，如安全违规。相比之下，持有内存太久会降低性能，并最终导致程序终止，即使在柏拉图意义上，它仍有可用内存。这种性能下降和过早终止总是令人讨厌的，在某些关键任务系统中可能会带来严重问题，但至少程序不会计算无意义的内容。

理想情况下，我们希望三者兼顾：自动化、正确性和完整性。然而，我们面临一个经典的“选其二”抉择。理想的人类能够同时达到正确性和完整性，但在实践中很少做到任何一者。你，当然，是完美的，但你的同伴呢？顺便提一句，经济学界一直在寻找你。计算机可以提供自动化和正确性或完整性中的一个，但可计算性论证表明自动化不能伴随其他两者。因此，在实践中，自动化技术提供正确性，理由如下：（a）它造成的伤害最小，（b）相对容易实现，（c）经过一些人工干预，它可以更接近完整性。

## 11.3 手动回收

最手动的方法是把所有的解除分配都交给人类。例如，在 C 语言中，有两个基本原语：分配用的 `malloc` 和回收用的 `free`。`malloc` 消耗一个大小并返回一个分配的值的引用；`free` 消耗引用并回收其关联的内存。

> > > “`摩洛`（Moloch）在英国文学中的比喻用法从约翰·弥尔顿（John Milton）的《失乐园》（1667 年）到艾伦·金斯伯格（Allen Ginsberg）的 `嚎叫`（1955 年）都有，用来指代一个需要或要求非常昂贵牺牲的人或事物。” —<wbr>[摩洛 - 维基百科](http://en.wikipedia.org/wiki/Moloch)
> > > 
> > > “我认为这个名字听起来像是 `malloc` 并非巧合。” —<wbr>Ian Barland

### 11.3.1 全手动回收的成本

让我们首先问问这些操作的成本是多少。我们可以先假设 `malloc` 有一个指向存储器的寄存器（类似于 `new-loc [REF]`），并且在每次分配时它只是获取下一个空闲位置。这个模型非常简单——<wbr>事实上，是误导性的。问题出现在我们释放这些值时。如果第一个释放的是最后一个分配的，我们就不会遇到问题；但是存储数据通常不遵循堆栈规则。当我们释放除最近分配的值之外的任何值时，我们会在存储器中留下空洞。这些空洞导致碎片化，而在最坏的情况下，即使存储器中有足够的空间——<wbr>只是分散在许多碎片中，但每个碎片都不够大，我们也无法分配任何对象。

练习

> 原则上，我们可以通过使所有的空闲空间连续来消除碎片化。做到这一点需要什么？仔细思考所有后果，并草拟是否实际上可以手动完成此操作。

虽然在大多数手动内存管理方案中碎片化仍然是一个无法克服的问题，但即使在这个看似简单的学科中，还有更多需要考虑的事情。当我们释放一个值时会发生什么？运行时系统必须以某种方式记录它现在可供将来分配使用。它通过维护一个空闲列表来实现：一个空闲空间的链表。稍加思考就会立即提出一个问题：空闲列表本身存储在哪里，谁管理它的内存？答案是空闲列表引用存储在释放的单元中，这立即意味着每个分配的最小大小。

原则上，每个 malloc 现在都必须遍历空闲列表，以找到一个合适的空闲位置。我说“合适”，是因为分配器必须做出一个复杂的决定。它应该采用与之匹配的第一个插槽还是后面的插槽？无论哪种方式，什么是“匹配”？它应该只取准确的大小的插槽，还是取较大的插槽并将其分成较小的插槽（从而增加创建不可用的小孔的可能性）？等等。

开发人员希望分配是廉价的。使分配不廉价会导致开发人员尝试基于重复使用值的技巧，从而降低清晰度，很可能也降低正确性。因此，在实践中，分配系统往往只使用一组固定的大小，通常是 2 的幂次方。这使得可以维护不止一个，而是许多空闲列表，每个列表都是相同大小的空洞（即 2 的幂次方）。一个表引用到这些列表中的每一个，并且通过使用位移进行表索引是廉价的。作为回报，开发人员牺牲了空间，因为不是 2 的幂次方大小的对象最终将被不必要地填充。 （这是一个经典的计算机科学权衡：以时间换空间。）此外，free 必须将释放的内存放入正确的插槽中，并且甚至可能将较大的块分成多个较小的块以准备将来的分配。这个模型中没有任何东西从本质上来说都是廉价的。特别是，free 不是免费的。

当然，所有这些都假设开发人员可以以甚至是完整的方式工作。但是他们不会。

### 11.3.2 引用计数

因为完全手动回收给开发人员带来了不合理的负担，一些半自动化技术长期以来一直在使用，最显著的是引用计数。

在引用计数中，每个值都有一个关联的计数，表示它有多少个引用。开发人员负责增加和减少这些计数。当计数达到零时，该值的空间可以安全地恢复以供将来重用。

立即注意到，在这个简单的定义下隐藏着两个重要的假设。

1.  开发人员可以追踪每个引用。请记住，每个别名也是一个引用。因此，写下这样的代码的开发人员

    > | (let ([x <some value>]) |
    > | --- |
    > |   (let ([y x]) |
    > |     ...)) |

    必须记住 y 是对 x 引用的同一个值的第二个引用，并相应地增加计数。

1.  每个值只有有限数量的引用。当一个值存在循环时，这个假设就失败了。

由于需要手动增加和减少引用，这种技术在完整性和完备性方面存在缺陷。事实上，上述第二个假设自然导致了完备性的缺失，而第一个假设指向了破坏完整性的最简单方法。

手动内存管理的危险是微妙且更深层次的。因为开发人员负责释放内存（或者等效地管理引用计数），内存管理策略必须成为每个库接口的一部分：实际上，“谁将释放此库分配的值，此库是否会释放传递给它的值？”遗憾的是，精确记录和遵循这些策略很困难，更糟糕的是，它会使库的描述受到低级细节的污染，这些细节通常与其预期行为无关。

一个有趣的想法是自动化插入引用增减。另一个是在实现中添加循环检测。两者结合解决了上述许多问题，但引用计数也存在其他问题：

+   引用计数增加了每个对象的大小。它必须足够大以避免溢出，但又必须足够小以不显著增加程序的内存占用。

+   增加和减少这些计数所花费的时间可能变得显著。

+   如果一个对象的引用计数变为零，则它所引用的一切也必须减少它们的引用计数—<wbr>可能是递归的。这意味着单个释放操作可能会产生很大的时间影响，除非使用巧妙的“懒惰”技术（这会增加程序的内存占用）。

+   要减少引用计数，我们必须遍历垃圾对象。这似乎非常低效：遍历我们不再感兴趣的对象。这带来了实际后果：我们不感兴趣的对象可能已经有一段时间没有被访问，这意味着它们可能已经被分页出去。引用计数器必须将它们重新分页回来，只是为了告诉它们不再需要。

出于这些原因，引用计数应该谨慎使用。你不应该将其视为默认选项，而应该问问自己为什么拒绝通常更好的自动化技术。

练习

> 如果引用计数溢出，哪些正确性属性会受到影响？考虑权衡。

## 11.4 自动回收，或垃圾回收

有些人将引用计数称为“垃圾回收”技术。我更喜欢使用后一种术语仅指全自动技术。但在浏览网络时要注意这种潜在的混淆。

现在让我们简要地考虑一下让语言的运行时系统自动化回收垃圾的想法。我们将使用缩写 GC（垃圾收集）来指代算法和过程，让上下文消除歧义。

### 11.4.1 概述

所有 GC 算法背后的关键思想是通过跟随值之间的引用来遍历内存。遍历从根集开始，根集是程序可能引用存储中值的所有位置。通常，根集包括环境中的每个绑定变量和任何全局变量。在实际的工作实现中，实现者必须小心地注意到诸如寄存器中的引用等短暂值。从这个根集开始，算法使用各种通常是深度优先搜索变体的算法遍历所有可访问的值。深度优先搜索通常是首选，因为它与基于栈的实现很好地配合。当然，你可能（也应该）想知道 GC 自己的栈存储在哪里！以识别一切活跃的内容（即，通过一系列程序操作可用）。其他一切，根据定义，都是垃圾。不同的算法以不同的方式处理这些空间的回收。

### 11.4.2 真理与可证性

如果你仔细阅读，你会注意到我在上述描述中插入了一个算法。这是一个实现细节，不是规范的一部分！事实上，垃圾收集的规范是以真理为基础的：我们希望精确地收集所有垃圾值，不多不少。但是对于任何图灵完备的编程语言，我们无法获得真理，所以我们必须满足于可证性。上面描述的算法风格给我们提供了一个高效的“证明”活跃性的方法，使得补充垃圾值。当然，还有一些变体的方案使我们能够收集更多或更少的垃圾，这对应于值的“垃圾性”不同强度的证明。

最后一句话突显了严格规范的一个弱点，它没有提及应该收集多少垃圾。实际上，思考极端情况是很有用的。

现在就做！

> 定义一个稳健的垃圾收集策略是微不足道的。同样，定义一个完整的垃圾收集策略也是微不足道的。你看到了吗？

要保证稳健，我们只需确保不会意外地移除任何活跃的内容。绝对确定的一种方法是根本不收集任何垃圾。双重地，微不足道的完全 GC 会收集一切。显然，这两者都不是有用的（后者肯定是非常危险的）。但这突显了实践中，我们希望一个既稳健又尽可能完整，同时又高效的 GC。

### 11.4.3 中心假设

能够稳健地执行 GC 取决于两个关键假设。第一个是关于语言实现的，另一个是关于语言语义的。

1.  当 GC 面对一个值时，它需要知道这是什么类型的值，以及它的内存表示是如何布局的。例如，当遍历到一个 cons 单元格时，它必须知道：

    1.  这是一个 cons 单元格；因此，

    1.  第一个位于，比如说，四个字节的偏移量处，

    1.  其余的位于，比如说，八个字节的偏移量处。

    显然，这个属性必须递归地保持，从而使遍历算法能够正确地映射内存中的值。

1.  程序不能以两种方式制造引用：

    1.  对象引用不能驻留在实现预定义的根集之外。

    1.  对象引用只能指向对象中的明确定义的点。

    当第二个属性被违反时，GC 可能会有效地失控，误解数据。第一个属性听起来很明显：当它被违反时，似乎运行时系统显然未能遵守语言的语义。然而，这个属性的后果是微妙的，正如我们下面讨论的那样[REF]。

## 11.5 保守垃圾回收

我们已经解释了典型根集由环境、全局变量和一些选择性的临时变量组成。引用可能还驻留在哪里？

在大多数语言中，没有其他地方。但是一些语言（我指的是你，C 和 C++）允许将引用转换为任意数字，并将任意数字转换回引用。因此，原则上，程序中的任何数值（由于 C 和 C++类型的性质，几乎程序中的任何值）都可能被视为引用。

这对两个原因都是有问题的。首先，它意味着 GC 不能再将注意力限制在小的根集上；相反，整个存储现在可能是根集。其次，如果 GC 尝试以任何方式修改对象——例如，在遍历过程中记录“已访问”位——那么它可能会改变非引用值：例如，它实际上可能会改变程序中的一个无辜的数值常量。因此，像 C 和 C++这样的语言中特定特性的结合使得实现稳健、高效的 GC 变得极其困难。

但这并非不可能。一条刺激人的研究路线称为保守 GC 已成功为这类语言创建了相当有效的 GC 系统。保守 GC 背后的原则指出，虽然原则上每个存储位置都可能是根，但实际上很多存储位置都不是。然后，它通过一系列越来越聪明的观察来推断哪些不可能是引用（传统 GC 的相反），因此可以安全地忽略：例如，在字对齐的架构上，没有奇数可能是引用。通过跳过大部分存储，通过对程序行为做出一些基本假设（例如，它不会制造某些类型的引用），并且小心地不修改存储——例如，改变值中的位，或者移动数据——它实际上可以产生一个相当有效的 GC 策略。然而，这有点像一只后腿行走的狗。

保守 GC 在编程语言实现中通常受到欢迎，这些实现是用 C 或 C++编写的，或者依赖于 C 或 C++代码库。例如，早期的 Racket 版本完全依赖于它。这有很多很好的理由：

1.  它提供了一种快速的引导技术，因此语言实现者可以专注于其他更具创新性的特性。

1.  控制所有引用的语言（如 Racket 所做）可以轻松地创建特别有利于增加 GC 效果的内存表示（例如，在最不显著位中为所有真实数字填充一个 1）。

1.  它使得与 C 和 C++中编写的有用库轻松地进行交互操作成为可能（前提是它们也符合该技术的期望）。

对词汇表需要一些解释。正如我们所主张的[REF]，所有实用的 GC 技术都是“保守的”，因为它们用可达性来近似真实性。然而，“保守”的词汇已经成为一个专业术语，用来指代在一个不合作（但希望不是敌对的）运行时系统中运行的 GC 技术。

## 11.6 精确垃圾回收

在传统 GC 术语中，“保守”的相反是精确。这也是一个误称，因为 GC 不能精确，即既正确又完整。而“精确”在这里是关于识别引用的能力的陈述：当面对一个值时，精确的 GC 确切地知道什么是引用，什么不是引用，以及引用在哪里。这消除了保守 GC 必须猜测非引用（并希望通过这个过程尽可能消除尽可能多的潜在引用）的巨大努力。

在精确 GC（Garbage Collection）的空间内，这是大多数现代语言运行时系统使用的技术，有许多实现技术。我建议你阅读保罗·威尔逊（Paul Wilson）的调查报告（尽管在这个快速发展的领域，它相对较老，但仍然是一份优秀的资源），以及[理查德·琼斯（Richard Jones）](http://www.cs.kent.ac.uk/people/staff/rej/gc.html)的书籍和其他资料。特别是，要快速并且易读地了解分代垃圾收集器，请阅读[简单的分代垃圾收集与快速分配](http://www.cs.princeton.edu/~appel/papers/143.ps)。

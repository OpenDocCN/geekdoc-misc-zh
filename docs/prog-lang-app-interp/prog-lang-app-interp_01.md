# 1 介绍

## 1.1 我们的哲学

请观看[YouTube 上的视频](http://www.youtube.com/watch?v=3N__tvmZrzc)。将来这里可能会有文字描述。

## 1.2 本书的结构

与其他一些教科书不同，这本书不遵循自上而下的叙述。相反，它具有对话的流程，带有回溯。我们经常会逐步构建程序，就像一对程序员会做的那样。我们会包含错误，不是因为我不知道答案，而是因为这是你学习的最佳方式。包含错误使你无法被动阅读：你必须与材料互动，因为你永远不能确定你所阅读的内容的真实性。

最终，你总会得到正确的答案。然而，这种非线性的路径在短期内更加令人沮丧（你经常会忍不住说，“告诉我答案吧！”），并且使这本书成为一个糟糕的参考指南（你不能随意翻开一页就确定其正确性）。然而，这种沮丧的感觉就是学习的感觉。我不知道有什么方法可以避免它。

在各个地方你会遇到这样的情况：

练习

> 这是一个练习。请尝试一下。

这是一个传统的教科书练习。这是你需要自己完成的任务。如果你将这本书作为课程的一部分，这很可能已经被指定为作业。相比之下，你还会发现���似练习的问题，看起来像这样：

现在就做！

> 这里有一个活动！你看到了吗？

当你遇到这些情况时，请停下来。阅读，思考，并在继续之前制定一个答案。你必须这样做，因为这实际上是一个练习，但答案已经在书中了——<wbr>通常在紧随其后的文本中（即，你正在阅读的部分）——<wbr>或者是你可以通过运行程序自己确定的东西。如果你继续阅读，你会看到答案而没有思考过它（或者根本看不到，如果指令是运行程序），所以你既不能（a）测试你的知识，也不能（b）提高你的直觉。换句话说，这些是鼓励主动学习的额外明确尝试。然而，最终，我只能鼓励它；练习的责任在于你。

## 1.3 本书的语言

本书中主要使用的编程语言是[Racket](http://www.racket-lang.org/)。然而，与所有操作系统一样，Racket 实际上支持一系列编程语言，因此你必须告诉 Racket 你正在使用哪种语言进行编程。你可以通过写一行像这样的代码来通知 Unix shell

| #!/bin/sh |
| --- |

在脚本的顶部；你可以通过写入，比如说，

| <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" ...> |
| --- |

类似地，Racket 要求您声明将要使用的语言。Racket 语言可以具有与 Racket 相同的括号语法，但语义不同；具有相同的语义但语法不同；或者语法和语义都不同。因此，每个 Racket 程序都以 `#lang` 开头，后跟某种语言的名称：默认情况下是 Racket（写作 racket）。在 DrRacket v. 5.3 中，转到“语言”，然后选择“选择语言”，并选择“使用源代码中声明的语言”。在本书中，我们几乎总是使用的语言

> | plai-typed |
> | --- |

当我们偏离时，我们会明确说明，因此除非另有说明，否则将

| #lang plai-typed |
| --- |

在每个文件的顶部（并假设我已经做了同样的事情）。Typed PLAI 语言与传统的 Racket 最重要的区别是它是静态类型的。它还为您提供了一些有用的新构造：define-type、type-case 和 test。例如，还有用于控制测试输出的其他命令。务必阅读语言的文档在 DrRacket v. 5.3 中，转到帮助，然后转到帮助台，在帮助台搜索栏中，键入“plai-typed”。以下是每个用法的示例。我们可以引入新的数据类型：

> | （define-type MisspelledAnimal |
> | --- |
> |   [caml (humps : number)] |
> |   [yacc (height : number)]) |

您可以粗略地将此视为 Java 中的以下内容：一个抽象类 MisspelledAnimal 和两个具体的子类 caml 和 yacc，每个类都有一个名为 humps 和 height 的数值构造函数参数。在此语言中，我们构造实例如下：

> | （caml 2） |
> | --- |
> | （yacc 1.9） |

如其名称所示，define-type 创建给定名称的类型。例如，当绑定上述实例到名称时，我们可以使用这个：

> | （define ma1：MisspelledAnimal（caml 2）） |
> | --- |
> | （define ma2：MisspelledAnimal（yacc 1.9）） |

实际上，您不需要这些特定的类型声明，因为 Typed PLAI 将在此处和许多其他情况下为您推断类型。因此，您可以写成

> | （define ma1（caml 2）） |
> | --- |
> | （define ma2（yacc 1.9）） |

但我们更喜欢在以后返回程序时写明确的类型声明，这既是纪律问题，也是可理解性问题。

类型名称甚至可以递归使用，正如我们在本书中反复看到的那样（例如，完成解析器)）。

该语言为编写表达式（例如函数的主体）提供了模式匹配器：

> | （define（good？[ma：MisspelledAnimal]）：boolean |
> | --- |
> |   （type-case MisspelledAnimal ma |
> |     [caml (humps) (>= humps 2)] |
> |     [yacc (height) (> height 2.1)])) |

在表达式（>= humps 2）中，例如，humps 是分配给构造函数 caml 的任何值的名称。最后，你应该编写测试用例，最好在定义函数之前，但也可以在之后以防意外更改：

> | （测试（好吗？ma1）#t） |
> | --- |
> | （测试（好吗？ma2）#f） |

当您运行上面的程序时，语言将提供详细的输出，告诉您两个测试都通过了。阅读文档以了解如何抑制大部分这些消息。上面隐藏了一个重要的东西。我们在数据类型定义和模式匹配字段中都使用了相同的名称 humps（和 height）。这是完全不必要的，因为两者是按位置而不是名称相关的。因此，我们完全可以将函数写成以下形式： 

> | (define (good? [ma : 拼写错误的动物]) : boolean |
> | --- |
> |   (type-case 拼写错误的动物 ma |
> |     [caml (h) (>= h 2)] |
> |     [yacc (h) (> h 2.1)])) |

因为每个 h 只在引入它的分支中可见，所以这两个 h 实际上并不冲突。因此，您可以使用约定和可读性来决定您的选择。一般来说，当定义数据类型时提供一个长且描述性的名称是有意义的（因为您可能不会再次使用该名称），但在类型案例中使用较短的名称是有意义的，因为您可能会使用这些名称一次或多次。我刚刚说过，您不太可能使用在数据类型定义中引入的字段描述符，但您可以。语言提供了选择器来提取字段，而无需进行模式匹配：例如，caml-humps。有时，直接使用选择器比经过模式匹配要容易得多。通常不是这样，就像上面定义的 good? 一样，但为了明确起见，让我们写成没有模式匹配的形式：

> | (define (good? [ma : 拼写错误的动物]) : boolean |
> | --- |
> |   (cond |
> |     [(caml? ma) (>= (caml-humps ma) 2)] |
> |     [(yacc? ma) (> (yacc-height ma) 2.1)])) |

现在做！

> 如果您将函数错误地应用于错误类型的值会发生什么？例如，如果您给 caml 构造函数一个字符串会发生什么？如果您将一个数字发送到上述每个版本的 good? 会发生什么？

# 7 函数随处可见

Scheme 编程语言定义的介绍建立了这个设计原则：

> 编程语言的设计不应该是在功能上堆砌功能，而应该是通过消除使额外功能显得必要的弱点和限制来设计。[REF]

就设计原则而言，这个原则很难辩驳。（当然，有些限制确实有充分的理由存在，但这个原则迫使我们为它们辩护，而不是默认承认它们。）现在让我们把它应用到函数上。

当我们介绍函数时，有一件事情我们保持了含糊不清（将函数添加到语言中），那就是函数应该放在哪里。我们可能暗示我们正在遵循理想化的 DrRacket 模型，其中定义和使用被分开。但是，受 Scheme 设计原则的启发，让我们看看这是否必要。

为什么函数定义不能是表达式？在我们当前以算术为中心的语言中，我们面临一个令人不舒服的问题“函数定义代表什么值？”，对此我们并没有一个好的答案。但是一个真正的编程语言显然计算的不仅仅是数字，所以我们不再需要以这种形式面对这个问题；事实上，上面的答案同样可以是“一个函数值”。让我们看看这可能会怎样。

函数作为值我们能做什么？显然，函数是一种与数字不同的值，所以我们不能像添加数字那样，将它们相加。但有一件明显的事情我们可以做：将它们应用于参数！因此，我们可以允许函数值出现在应用的函数位置上。行为自然是应用函数。因此，我们提出的语言中以下内容将是一个有效的程序（我使用括号是为了方便我们识别函数）

> | (+ 2 ([define (f x) (* x 3)] 4)) |
> | --- |

并将计算结果为 (+ 2 (* 4 3))，或 14。 （你看到我刚刚使用了替换吗？）

## 7.1 函数作为表达式和值

让我们首先定义核心语言，包括函数定义：

<expr-type>)) ::=

> | (define-type ExprC |
> | --- |
> |   [numC (n : number)] |
> |   [idC (s : symbol)] |
> |   <app-type>)) |
> |   [plusC (l : ExprC) (r : ExprC)] |
> |   [multC (l : ExprC) (r : ExprC)] |
> |   <fun-type>))) |

目前，我们将简单地将函数定义复制到表达式语言中。如果需要的话，我们可以随时更改这个，但现在至少可以让我们重用我们现有的测试用例。

<fun-type-take-1>)) ::=

> [fdC (name : symbol) (arg : symbol) (body : ExprC)]

我们还需要确定应用是什么样子的。应用的函数位置放什么？我们想允许整个函数定义，而不仅仅是它的名称。因为我们把函数定义与所有其他表达式混合在一起，所以让我们在这里允许任意表达式，但要理解我们只想要函数定义表达式：

> > > 我们可能会考虑更精细的数据类型，将函数定义与其他类型的表达式分开。这就相当于试图对不同类型的表达式进行分类，这是我们在研究类型时将返回的内容。[REF]

<app-type>)) ::= 

> [appC (fun : ExprC) (arg : ExprC)]

使用这个应用的定义，我们不再需要通过名称查找函数，所以解释器可以摆脱函数定义的列表。如果需要，我们可以稍后恢复它，但现在让我们来探讨一下在应用点写入函数定义时会发生什么：所谓的即时函数。

现在让我们来解决 interp。我们需要为解释器添加一个函数定义的情况，这是一个不错的选择：

> | [fdC (n a b) expr] |
> | --- |

现在开始吧！

> 当你添加这个时会发生什么？

立即，我们发现了一个问题：解释器不再总是返回数字，所以我们有一个类型错误。

我们周期性地提到解释器计算的答案，但从未打算给这些答案赋予自己的类型。现在是时候这样做了。

<answer-type-take-1>)) ::= 

> | (定义-type Value |
> | --- |
> |   [numV (n : number)] |
> |   [funV (name : symbol) (arg : symbol) (body : ExprC)]) |

我们使用 V 的后缀代表值，即求值的结果。funV 的部分将与 fdC 的部分完全相同：前者是输入，后者是输出。通过保持它们的区别，我们允许每个部分根据需要独立发展。

现在我们必须重写解释器。让我们从它的类型开始：

<interp-hof>)) ::= 

> | (定义 (interp [expr : ExprC] [env : Env]) : Value |
> | --- |
> |   (type-case ExprC expr |
> |     <interp-body-hof>)))) |

这个改变自然地导致 Binding 数据类型和 lookup 的相应类型更改。

练习

> 适当地修改 Binding 和 lookup。

<interp-body-hof>)) ::= 

> | [numC (n) (numV n)] |
> | --- |
> | [idC (n) (lookup n env)] |
> | <app-case>)) |
> | <plus/mult-case>)) |
> | <fun-case>)) |

显然，数值答案需要用适当的数值答案构造函数包装起来。标识符查找没有变化。我们必须稍微修改加法和乘法以处理解释器返回的是值而不是数字这一事实：

<plus/mult-case>)) ::= 

> | [plusC (l r) (num+ (interp l env) (interp r env))] |
> | --- |
> | [multC (l r) (num* (interp l env) (interp r env))] |

值得检查其中一个辅助函数的定义：

> | (define (num+ [l : Value] [r : Value]) : Value |
> | --- |
> |   (cond |
> |     [(and (numV? l) (numV? r)) |
> |      (numV (+ (numV-n l) (numV-n r)))] |
> |     [else |
> |      (error 'num+ "一个参数不是数字")])) |

请注意，在执行加法之前，它检查两个参数是否都是数字。这是一个安全的运行时系统的一个例子。当我们讨论类型时，我们将更多地讨论这个主题。[REF]

还有两种情况要涵盖。一种是函数定义。我们已经同意这些将是它们自己的一种值：

<fun-case-take-1>)) ::=

> [fdC (n a b) (funV n a b)]

这留下了一个情况，应用。虽然我们不再需要查找函数定义，但我们将尽可能保持代码结构相似：

<app-case-take-1>)) ::=

> | [appC (f a) (local ([define fd f]) |
> | --- |
> |               (interp (fdC-body fd) |
> |                       (extend-env (bind (fdC-arg fd) |
> |                                         (interp a env)) |
> |                                   mt-env)))] |

在查找的位置，我们引用了函数定义 f，就在那里。请注意，因为任何表达式都可以在函数定义位置，我们确实应该加强代码以检查它确实是一个函数。

现在动手！

> 这是什么意思？也就是说，我们想要检查函数定义位置在语法上是否是函数定义（fdC），还是仅仅它是否评估为一个（funV）？有区别吗，也就是说，你能写一个满足一个条件但不满足另一个条件的程序吗？

我们有两个选择：

1.  我们可以检查它在语法上是否是一个 fdC，并且如果不是，则拒绝它作为错误。

1.  我们可以评估它，并检查结果值是否是一个函数（否则会发出错误信号）。

我们将采取后一种方法，因为这给了我们一个更加灵活的语言。特别是，即使我们无法立即想象出我们作为人类可能需要这种情况，但当程序需要生成代码时，这可能会派上用场。而我们正在编写正是这样的程序，即解糖器！（参见 Sugaring Over Anonymity）。）因此，我们将修改应用案例以评估函数位置：<app-case-take-2>)) ::=

> | [appC (f a) (local ([define fd (interp f env)]) |
> | --- |
> |               (interp (funV-body fd) |
> |                       (extend-env (bind (funV-arg fd) |
> |                                         (interp a env)) |
> |                                   mt-env)))] |

练习

> 修改代码以执行此检查的两个版本。

有了这个，我们完成了。我们有一个完整的解释器！例如，这里是我们的一些旧测试：

> | (test (interp (plusC (numC 10) (appC (fdC 'const5 '_ (numC 5)) (numC 10))) |
> | --- |
> |               mt-env) |
> |       (numV 15)) |
> |   |
> | (test/exn (interp (appC (fdC 'f1 'x (appC (fdC 'f2 'y (plusC (idC 'x) (idC 'y))) |
> |                                           (numC 4))) |
> |                         (numC 3)) |
> |                   mt-env) |
> |           "name not found") |

## 7.2Nested What?

函数定义的主体是一个任意表达式。函数定义本身就是一个表达式。这意味着函数定义可以包含一个...函数定义。例如：

<嵌套-fdC>)) ::=

> | (fdC 'f1 'x |
> | --- |
> |      (fdC 'f2 'x |
> |           (plusC (idC 'x) (idC 'x)))) |

对此进行评估并不是很有趣：

> | (funV 'f1 'x (fdC 'f2 'x (plusC (idC 'x) (idC 'x)))) |
> | --- |

但假设我们将上述函数应用到某些内容上：<应用嵌套-fdC>)) ::=

> | (appC <嵌套-fdC>)) |
> | --- |
> |       (numC 4)) |

现在答案变得更有趣了：

> | (funV 'f2 'x (plusC (idC 'x) (idC 'x))) |
> | --- |

看起来好像应用外部函数对内部函数没有任何影响。嗯，为什么会这样呢？外部函数引入了一个标识符，而内部函数引入了相同名称的标识符，因此按照静态作用域的规定（我们应该这样做！），它们会掩盖外部定义。但这暗示了一个不同的程序：

> | (appC (fdC 'f1 'x |
> | --- |
> |            (fdC 'f2 'y |
> |                 (plusC (idC 'x) (idC 'y)))) |
> |       (numC 4)) |

这评估为：

> | (funV 'f2 'y (plusC (idC 'x) (idC 'y))) |
> | --- |

嗯，这很有趣。现在做！

> 什么是有趣的？

要看看有趣的地方，让我们再应用一次：

> | (appC (appC (fdC 'f1 'x |
> | --- |
> |                  (fdC 'f2 'y |
> |                       (plusC (idC 'x) (idC 'y)))) |
> |             (numC 4)) |
> |       (numC 5)) |

这会产生一个错误，指示表示 x 的标识符未绑定！但是它被名为 f1 的函数绑定了，不是吗？为了清楚起见，让我们将其表示为我们假设的 Racket 语法：

> | ((define (f1 x) |
> | --- |
> |    ((define (f2 y) |
> |       (+ x y)) |
> |     4)) |
> |  5) |

在应用外部函数时，我们期望 x 被替换为 5，结果为

> | ((define (f2 y) |
> | --- |
> |    (+ 5 y)) |
> |  4) |

进一步应用和替换后，得到 (+ 5 4) 或 9，而不是错误。

换句话说，我们再次没有忠实地捕捉到替换会做什么。另一方面，请注意，按照我们定义的替换方式，我们将用 (numV 4) 替换 x，导致函数体为 (plusC (numV 5) (idC ’y))，这是无法类型化的。也就是说，替换的前提是答案的类型是一种形式的语法。实际上，甚至在这种假设下也可以进行非常高级的编程构造的研究，但我们不会选择这条路。函数值需要记住已应用到它的替换。因为我们正在使用环境来表示替换，所以函数值因此需要与环境一起捆绑。这个结果数据结构称为闭包。

此时请注意上面的 appC 情况使用了 funV-arg 和 funV-body，但没有使用 funV-name。想想看，为什么函数需要名称？为了我们能找到它。但是如果我们使用解释器来找到函数，那么就没有东西可以找到和获取了。因此，名称仅仅是描述性的，可以理解为注释。换句话说，函数不需要名称，就像其他任何即时常量一样：例如，我们不会给每个 3 的使用命名，那么为什么我们要给每个函数的使用命名呢？函数本质上是匿名的，我们应该将其定义与命名分开。

（但是，你可能会说，如果函数总是在原地编写，这个论点才有意义。如果我们想把它们放在其他地方怎么办？那么它们不需要名称吗？它们需要，我们将在此返回（Sugaring Over Anonymity)）。）

## 7.3Implementing Closures

我们需要改变我们对值的表示方式，记录闭包而不是原始函数文本：

<answer-type>)) ::=

> | (define-type Value |
> | --- |
> |   [numV (n : number)] |
> |   [closV (arg : symbol) (body : ExprC) (env : Env)]) |

在此期间，我们也可以修改我们定义函数的语法，以删除无用的名称。这个结构在历史上被称为 lambda：

<fun-type>)) ::=

> [lamC (arg : symbol) (body : ExprC)]

在遇到函数定义时，解释器现在必须记住保存到目前为止已应用的替换：“保存环境！今天创建一个闭包！” ——<wbr>Cormac Flanagan

<fun-case>)) ::=

> [lamC (a b) (closV a b env)]

在应用函数时，必须使用这个保存的集合，而不是空环境：

<app-case>)) ::=

> | [appC (f a) (local ([define f-value (interp f env)]) |
> | --- |
> |               (interp (closV-body f-value) |
> |                       (extend-env (bind (closV-arg f-value) |
> |                                         (interp a env)) |
> |                                   (closV-env f-value))))] |

实际上还有另一种可能性：我们可以使用应用点处的环境：

> | [appC (f a) (local ([define f-value (interp f env)]) |
> | --- |
> |               (interp (closV-body f-value) |
> |                       (extend-env (bind (closV-arg f-value) |
> |                                         (interp a env)) |
> |                                   env)))] |

练习

> 如果我们扩展动态环境会发生什么？

回顾起来，解释为什么我们在空环境中解释函数体变得更加清晰。当一个函数在顶层定义时，它并未“封闭”任何标识符。因此，我们先前的函数应用是这种形式应用的特例。

## 7.4 替换，再次

我们已经看到替换对于思考如何实现 lambda 函数是有指导意义的。但是，我们必须小心替换本身！假设我们有以下表达式（为了给 lambda 函数其正确的 Racket 语法）：

> | (lambda (f) |
> | --- |
> |   (lambda (x) |
> |     (f 10))) |

现在假设我们替换 f 为以下表达式：(lambda (y) (+ x y))。请注意，它有一个自由标识符 (x)，因此如果它被评估，我们期望会得到一个未绑定的标识符错误。替换似乎会给出：

> | (lambda (x) |
> | --- |
> |   ((lambda (y) (+ x y)) 10)) |

但是请注意，后一个程序没有自由标识符！这是因为我们对替换有太过简单化的版本。为了防止出现这种意外行为（这是一种动态绑定的形式），我们需要定义无捕获替换。它大致工作如下：我们首先一致地将所有绑定标识符重命名为先前完全未使用的名称（称为新鲜名称）。想象一下，我们给每个标识符一个数值后缀来获得新鲜度。然后原始表达式变为

> | (lambda (f1) |
> | --- |
> |   (lambda (x1) |
> |     (f1 10))) |

（请注意，我们在绑定位置和绑定位置均将 f 重命名为 f1。）现在让我们对我们要替换的表达式执行相同的操作：

> | (lambda (y1) (+ x y1)) |
> | --- |

为什么我们没有重命名 x？因为 x 可能是对顶层绑定的引用，那么也应该重命名它。这只是一种一致重命名原则的应用。在当前的设置中，这种区别是不相关的。现在让我们替换 f1：

> | (lambda (x1) |
> | --- |
> |   ((lambda (y1) (+ x y1)) 10)) |

...而且 x 仍然是自由的！这是一种很好的替换形式。

但是稍等一下。如果我们在基于环境的解释器中尝试相同的示例会发生什么？

现在做！

> 试一下。 

请注意，它可以正确运行：它报告一个未绑定的标识符错误。环境自动实现无捕获替换！

练习

> 使用环境的方式如何避免替换的捕获问题？

## 7.5 覆盖匿名性

现在让我们回到给函数命名的想法，这对于程序理解具有明显的价值。请注意，我们确实有一种命名事物的方法：通过将它们传递给函数，在那里它们获得一个本地名称（即形式参数的名称）。在该函数的任何地方，我们都可以使用形式参数名称引用该实体。

因此，我们可以将一组函数定义收集起来，并使用其他...函数来命名它们。例如，Racket 代码

> | (定义 (双倍 x) (+ x x)) |
> | --- |
> | (双倍 10) |

首先可以重写为等价形式

> | (定义 双倍 (lambda (x) (+ x x))) |
> | --- |
> | (双倍 10) |

当然，我们可以直接内联双倍的定义，但为了保留名称，我们可以这样写：

> | ((lambda (双倍) |
> | --- |
> |    (双倍 10)) |
> |  (lambda (x) (+ x x))) |

实际上，这种模式——我们将其发音为“左-左-λ”——是一种本地命名机制。在 Racket 中，它非常有用，因此有自己的特殊语法：

> | (让 ([双倍 (lambda (x) (+ x x))]) |
> | --- |
> |   (双倍 10)) |

其中 let 可以通过上面显示的展开来定义。这里有一个更复杂的例子：

> | (定义 (双倍 x) (+ x x)) |
> | --- |
> | (定义 (四倍 x) (双倍 (双倍 x))) |
> | (四倍 10) |

这可以重写为

> | (让 ([双倍 (lambda (x) (+ x x))]) |
> | --- |
> |   (让 ([四倍 (lambda (x) (双倍 (双倍 x)))]) |
> |     (四倍 10))) |

这将按我们的预期工作；但如果我们改变顺序，它就不再起作用——

> | (让 ([四倍 (lambda (x) (双倍 (双倍 x)))]) |
> | --- |
> |   (让 ([双倍 (lambda (x) (+ x x))]) |
> |     (四倍 10))) |

—因为四倍无法“看到”双倍。所以我们看到顶层绑定与本地绑定不同：本质上，顶层具有“无限范围”。这是其强大和问题的根源。还有另一个更微妙的问题：与递归有关。考虑最简单的无限循环：

> | (定义 (永远循环 x) (永远循环 x)) |
> | --- |
> | (永远循环 10) |

让我们将其转换为 let：

> | (让 ([永远循环 (lambda (x) (永远循环 x))]) |
> | --- |
> |   (永远循环 10)) |

看起来不错，对吧？用 lambda 重写：

> | ((lambda (永远循环) |
> | --- |
> |    (永远循环 10)) |
> |  (lambda (x) (永远循环 x))) |

显然，最后一行的永远循环没有绑定！

这是我们从顶层“免费”获得的另一个功能。为了消除这种神奇的力量，我们需要明确理解递归，我们很快会做到[REF]。

# 10 对象

当一种语言允许函数作为值时，它为开发人员提供了最自然的表示计算单元的方式。假设开发人员想要参数化某个函数 f。任何语言都可以让 f 被被动数据参数化，比如数字和字符串。但通常更吸引人的是将其参数化为活跃数据：一个可以根据一些信息计算答案的数据。此外，传递给 f 的函数可以（假设具有词法作用域的函数）引用来自调用者的数据，而无需将这些数据透露给 f，从而为安全性和隐私性提供了基础。因此，具有词法作用域的函数对于许多安全编程技术的设计至关重要。

虽然函数是一种绝妙的东西，但它过于简洁。有时，我们可能希望多个函数都封闭到相同的共享数据中；如果其中一些函数对其进行了变异并且期望其他函数看到这些变异的结果，则分享尤为重要。在这种情况下，仅发送一个函数作为参数变得不便；将一组函数发送更有用。接收者然后需要一种方法来在组中选择不同的函数。函数的这种分组，以及从组中选择一个的方法，是对象的本质。因此，我们在涵盖了函数（函数随处可用）和变异（变异：结构和变量）之后已经完美地准备好研究对象——并且，它将会发展为递归（递归和循环：过程和数据）。

我无法涵盖对象系统的巨大空间。请阅读 Éric Tanter 的 [面向对象的编程语言：应用与解释](http://users.dcc.uchile.cl/~etanter/ooplai/)，这本书详细介绍了并涵盖了本文所忽略的主题。让我们将这个对象的概念添加到我们的语言中。然后我们将充实它并发展它，并探索对象设计空间中的许多维度。我们首先将展示如何将对象添加到核心语言中，但因为我们希望快速原型化许多不同的想法，所以很快我们将转向基于 desguaring 的策略。你使用哪种取决于你是否认为理解它们对于理解你的语言的本质至关重要。衡量这一点的方法之一是你的 desguaring 策略变得多么复杂，以及通过添加一些关键的核心语言增强，你是否可以大大减少 desugaring 的复杂性。

## 10.1 没有继承的对象

对象的最简单概念——几乎每个谈论对象的人都同意的唯一事情——是对象是

+   一个值，即

+   将名称映射到

+   物品：可以是其他值或“方法”。

从极简主义的角度看，方法似乎只是函数，而由于我们已经在语言中拥有了这些函数，我们可以把这种区别放在一边。我们将发现，“方法”与函数非常接近，但在它们被调用的方式和/或绑定在其中的内容上有重要区别。

### 10.1.1 核心中的对象

因此，从具有头等函数的语言开始，让我们通过将其添加到核心语言中来定义对象的这个非常简单的概念。我们显然必须扩展我们对值的概念：

> | (定义类型 Value |
> | --- |
> |   [numV (n : number)] |
> |   [closV (arg : symbol) (body : ExprC) (env : Env)] |
> |   [objV (ns : (listof symbol)) (vs : (listof Value))]) |

我们将扩展表达式语法以支持字面对象构造表达式：请注意，这已经是一个设计决策。在某些语言中，比如 JavaScript，开发人员可以编写字面对象：这个概念在 JavaScript 中是如此流行，以至于其一部分语法已成为 Web 标准，即 JSON。在其他语言中，比如 Java，对象只能通过在类上调用构造函数来创建。我们可以通过假设模拟后一种语言来模拟前一种语言，只能在遵循一种风格化约定的特殊位置写入对象文字，就像我们在下面展开时所做的那样。

> | [objC (ns : (listof symbol)) (es : (listof ExprC))] |
> | --- |

对这样的对象表达式进行评估很容易：我们只需评估其每个表达式位置：

> | [objC (ns es) (objV ns (map (lambda (e) |
> | --- |
> |                               (interp e env)) |
> |                             es))] |

不幸的是，我们实际上无法使用对象，因为我们无法获得其内容。出于这个原因，我们可以添加一个操作来提取成员：

> | [msgC (o : ExprC) (n : symbol)] |
> | --- |

其行为是直观的：

> | [msgC (o n) (lookup-msg n (interp o env))] |
> | --- |

练习

> 实现
> 
> > | ; lookup-msg : symbol * Value -> Value |
> > | --- |
> > 
> 第二个参数预期是一个 objV。

原则上，msgC 可以用于获取任何类型的成员，但为了简单起见，我们只需要假设我们有函数。要使用它们，我们必须将它们应用于值。这在具体语法中写起来很麻烦，因此让我们假设展开已经为我们解决了这个问题：消息调用的具体语法包括要提取的消息名称及其参数表达式，

> | [msgS (o : ExprS) (n : symbol) (a : ExprS)] |
> | --- |

这可以看作是 msgC 与应用程序组合的展开：

> | [msgS (o n a) (appC (msgC (desugar o) n) (desugar a))] |
> | --- |

有了这个，我们就有了一个完整的具有对象的第一语言。例如，这里是一个对象定义和调用：

> | (letS 'o (objS (list 'add1 'sub1) |
> | --- |
> |                (list (lamS 'x (plusS (idS 'x) (numS 1))) |
> |                      (lamS 'x (plusS (idS 'x) (numS -1))))) |
> |       (msgS (idS 'o) 'add1 (numS 3))) |

并且这将求值为(numV 4)。

### 10.1.2 通过展开实现的对象

在核心语言中定义对象可能是值得的，但这是一种繁琐的学习方法。相反，我们将使用 Racket 来表示对象，坚持使用我们已经知道如何在解释器中实现的语言部分。也就是说，我们假设我们正在查看解糖的输出。（因此，我们也将坚持使用风格化的代码，可能会写一些不必要的表达式，因为这是一个简单程序生成器会产生的。）

警告：接下来的所有代码将使用 #lang plai，而不是类型化语言。

练习

> 为什么选择 #lang plai？当您尝试输入以下代码时遇到了什么问题？有些问题是否容易修复，比如引入一个新的数据类型并一致应用它？如果我们为了建模目的进行简化，比如假设方法只有一个参数，那么有些问题是否较难解决？

### 10.1.3 对象作为命名集合

让我们从复制上面的对象语言开始。对象只是一个根据给定名称分派的值。为简单起见，我们将使用 lambda 来表示对象，并使用 case 来实现分派。请注意，基本对象是 lambda 的一种泛化，具有多个“入口点”。相反，lambda 是只有一个入口点的对象，因此不需要“方法名称”来消除歧义。

> | (define o-1 |
> | --- |
> |   (lambda (m) |
> |     (case m |
> |       [(add1) (lambda (x) (+ x 1))] |
> |       [(sub1) (lambda (x) (- x 1))]))) |

这是我们之前定义的同一个对象，并且我们以相同的方式使用它的方法：

> | (test ((o-1 'add1) 5) 6)  ;; 测试成功 |
> | --- |

当然，使用这些嵌套函数调用编写方法调用是不便的（而且即将变得更加不便），因此最好装备自己方便地调用方法的语法 —— 与之前看到的相同（msgS），但在这里我们可以简单地将其定义为一个函数：我们利用了 Racket 的可变参数语法：. a 表示“将所有剩余的 —— 零个或多个 —— 参数绑定到名为 a 的列表中”。apply 会“展开”这些参数列表以调用函数。

> | (define (msg o m . a) |
> | --- |
> |   (apply (o m) a)) |

这使我们能够重写我们的测试：

> | (test (msg o-1 'add1 5) 6) |
> | --- |

现在开始！

> 当我们切换到解糖策略时，有一些非常重要的变化。你看到了吗？

回想一下我们之前的语法定义：

> | [msgC (o : ExprC) (n : symbol)] |
> | --- |

消息的“名称”位置非常明确是一个符号。也就是说，开发人员必须在那里写入符号的文字名称。在我们的��糖版本中，名称位置只是一个必须求值为符号的表达式；例如，可以写成

> | (test ((o-1 (string->symbol "add1")) 5) 6)  ;; 这也成功了 |
> | --- |

这是解糖的一个普遍问题：目标语言可能允许表达式，而源语言中没有对应的表达式，因此无法映射回源语言。幸运的是，我们通常不需要执行这种逆映射，尽管在一些调试和程序理解工具中会出现。然而更微妙的是，我们必须确保目标语言不会产生在源语言中没有对应等价物的值。

现在我们有了基本对象，让我们开始添加大多数对象系统中期望的功能。

### 10.1.4 构造函数

构造函数只是在对象构造时调用的函数。我们目前缺少这样一个函数。通过将对象从文字转换为接受构造函数参数的函数，我们实现了这种效果：

> | (define (o-constr-1 x) |
> | --- |
> |   (lambda (m) |
> |     (case m |
> |       [(addX) (lambda (y) (+ x y))]))) |
> |   |
> | (test (msg (o-constr-1 5) 'addX 3) 8) |
> | (test (msg (o-constr-1 2) 'addX 3) 5) |

在第一个示例中，我们将 5 作为构造函数的参数传递，因此添加 3 得到 8。第二个类似，并显示构造函数的两次调用不会相互干扰。

### 10.1.5 状态

许多人认为对象主要存在于封装状态。阿兰·凯（Alan Kay）为发明 Smalltalk 和现代对象技术而获得图灵奖的人持不同意见。在[Smalltalk 的早期历史](http://www.smalltalk.org/smalltalk/TheEarlyHistoryOfSmalltalk_Abstract.html)中，他说，“[OOP 的小规模动机]是为了找到一个更灵活的赋值版本，然后尝试完全消除它”。他补充说，“不幸的是，今天被称为`面向对象编程’的许多东西只是带有更复杂结构的旧式编程。许多程序现在充斥着更昂贵的附加过程所做的`赋值式’操作。”我们当然没有失去这种能力。如果我们解糖到一个带有变量的语言（我们可以等效地使用盒子，以换取轻微的解糖开销），我们可以轻松地让多个方法改变共同状态，比如构造函数参数：

> | (define (o-state-1 count) |
> | --- |
> |   (lambda (m) |
> |     (case m |
> |       [(inc) (lambda () (set! count (+ count 1)))] |
> |       [(dec) (lambda () (set! count (- count 1)))] |
> |       [(get) (lambda () count)]))) |

例如，我们可以测试一系列操作：

> | (test (let ([o (o-state-1 5)]) |
> | --- |
> |         (begin (msg o 'inc) |
> |                (msg o 'dec) |
> |                (msg o 'get))) |
> |       5) |

还要注意的是，改变一个对象不会影响另一个：

> | (test (let ([o1 (o-state-1 3)] |
> | --- |
> |             [o2 (o-state-1 3)]) |
> |         (begin (msg o1 'inc) |
> |                (msg o1 'inc) |
> |                (+ (msg o1 'get) |
> |                   (msg o2 'get)))) |
> |       (+ 5 3)) |

### 10.1.6 私有成员

另一个常见的对象语言特性是私有成员：仅在对象内部可见，而在外部不可见。除了在 Java 中，相同类型的其他类的实例可以访问“私有”成员。否则，你根本无法实现抽象数据类型。这些看起来可能是我们需要实现的额外特性，但我们已经有了必要的机制，即以局部作用域、词法绑定变量的形式存在：

> | (define (o-state-2 init) |
> | --- |
> |   (let ([count init]) |
> |     (lambda (m) |
> |       (case m |
> |         [(inc) (lambda () (set! count (+ count 1)))] |
> |         [(dec) (lambda () (set! count (- count 1)))] |
> |         [(get) (lambda () count)])))) |

上面的展开没有提供访问 count 的方式，并且词法作用域确保它对世界保持隐藏。

### 10.1.7 静态成员

对象用户通常很有价值的另一个特性是静态成员：它们是所有“相同”类型对象实例的共同成员。我们使用引号是因为对象的相同性有许多概念。还有更多。然而，这仅仅是一个词法作用域的标识符（使其私有），它存在于构造函数之外（使其成为构造函数的所有用法的共同部分）：

> | (define o-static-1 |
> | --- |
> |   (let ([counter 0]) |
> |     (lambda (amount) |
> |       (begin |
> |         (set! counter (+ 1 counter)) |
> |         (lambda (m) |
> |           (case m |
> |             [(inc) (lambda (n) (set! amount (+ amount n)))] |
> |             [(dec) (lambda (n) (set! amount (- amount n)))] |
> |             [(get) (lambda () amount)] |
> |             [(count) (lambda () counter)])))))) |

我们已经在这个对象的“构造函数”位置写了计数器的增量，尽管它同样可以在方法内部被操作。为了测试它，我们应该创建多个对象，并确保它们每一个都影响全局计数：

> | (test (let ([o (o-static-1 1000)]) |
> | --- |
> |         (msg o 'count)) |
> |       1) |
> |   |
> | (test (let ([o (o-static-1 0)]) |
> |         (msg o 'count)) |
> |       2) |

### 10.1.8 具有自引用的对象

直到现在，我们的对象只是命名函数的包装：可以理解为具有多个命名入口点的函数。我们已经看到，许多被认为在对象系统中很重要的特性实际上只是函数和作用域上的简单模式，并且的确已经被程序员使用了几十年，尽管没有给它们分配名字。

实际上区分对象系统的一个特征是，每个对象都自动配备有指向同一对象的引用，通常称为 self 或 this。我更喜欢这种稍微干燥的表达方式，而不是对象倡导者经常采用的具有人工智能的“了解自己”的术语。确实，值得注意的是，我们已经在对象系统属性中深入到如此程度，而不需要借助人工智能。我们能够轻松实现这一点吗？

### 10.1.8.1 使用变异进行自引用

是的，我们可以，因为我们刚刚在实现递归时看到了这个模式；现在我们将其概括为不仅仅是引用相同的框或函数，而是引用相同的对象。

> | (define o-self! |
> | --- |
> |   (let ([self 'dummy]) |
> |     (begin |
> |       (set! self |
> |             (lambda (m) |
> |               (case m |
> |                 [(first) (lambda (x) (msg self 'second (+ x 1)))] |
> |                 [(second) (lambda (x) (+ x 1))]))) |
> |       self))) |

请注意，这恰好是递归模式（递归函数）），稍作修改。我们已经测试过了，首先将一个方法发送到其自己的第二个。不出所料，这产生了预期的答案：

> | (test (msg o-self! 'first 5) 7) |
> | --- |

### 10.1.8.2 无突变的自引用

如果你学过如何在没有突变的情况下实现递归，你会注意到同样的解决方案在这里也适用。观察：

> | (define o-self-no! |
> | --- |
> |   (lambda (m) |
> |     (case m |
> |       [(first) (lambda (self x) (msg/self self 'second (+ x 1)))] |
> |       [(second) (lambda (self x) (+ x 1))]))) |

每个方法现在都将 self 作为参数。这意味着方法调用必须修改以遵循这种新模式：

> | (define (msg/self o m . a) |
> | --- |
> |   (apply (o m) o a)) |

换句话说，当在 o 上调用方法时，我们必须将 o 作为参数传递给方法。显然，这种方法是危险的，因为我们可能会传递一个不同的对象作为“self”。因此，将这一点暴露给开发人员可能是一个坏主意；如果使用这种实现技术，应该只在解糖时进行。尽管如此，Python 在其表面语法中公开了这一点。虽然这是对 Y 组合子的致敬，但也许结果的脆弱性是不必要的。

### 10.1.9 动态分派

最后，我们应该确保我们的对象能够处理对象系统的一个特征属性，即能够调用方法而不需要调用者知道或决定哪个对象将处理调用。假设我们有一个二叉树数据结构，其中树由空节点或保存值的叶子组成。在传统的函数中，我们被迫实现等效的一种形式的条件语句，比如 cond 或 type-case 或 pattern-match 或其他道德等价物，这些条件语句穷尽地列出并选择不同种类的树。如果树的定义增加了新的树种类，那么每个这样的代码片段都必须修改。动态分派通过使这个条件分支消失在用户程序中，并通过语言内置的方法选择代码来处理，从而解决了这个问题。这提供的关键特性是可扩展的条件。这是对象提供的可扩展性的一个方面。这个特性——似乎使系统更具黑盒可扩展性，因为系统的一部分可以增长而不需要修改另一部分来适应这些变化——通常被赞誉为面向对象的关键优势。虽然这确实是对象比函数更有优势的一个方面，但函数对对象也有一个双重优势，事实上，许多对象程序员最终会扭曲他们的代码——使用 Visitor 模式——使其看起来更像是基于函数的组织。阅读 [Synthesizing Object-Oriented and Functional Design to Promote Re-Use](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/) 了解一个详细的示例，它将全面展示问题。尝试在你喜欢的语言中解决它，然后看看 [Racket solution](http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml)。

现在让我们定义两种树对象：

> | (define (mt) |
> | --- |
> |   (let ([self 'dummy]) |
> |     (begin |
> |       (set! self |
> |             (lambda (m) |
> |               (case m |
> |                 [(add) (lambda () 0)]))) |
> |       self))) |
> |   |
> | (define (node v l r) |
> |   (let ([self 'dummy]) |
> |     (begin |
> |       (set! self |
> |             (lambda (m) |
> |               (case m |
> |                 [(add) (lambda () (+ v |
> |                                      (msg l 'add) |
> |                                      (msg r 'add)))]))) |
> |       self))) |

有了这些，我们可以创建一个具体的树：

> | (define a-tree |
> | --- |
> |   (node 10 |
> |         (node 5 (mt) (mt)) |
> |         (node 15 (node 6 (mt) (mt)) (mt)))) |

最后，测试一下：

> | (test (msg a-tree 'add) (+ 10 5 15 6)) |
> | --- |

请注意，在测试用例和节点的添加方法中都有一个引用指向‘add’，而不检查接收者是空节点还是节点。相反，运行时系统会提取接收者的添加方法并调用它。用户程序中缺少的这个条件是动态分派的本质。

## 10.2 成员访问设计空间

当涉及成员名称的处理时，我们已经有了两个正交维度。一个维度是名称是静态提供还是计算的，另一个维度是名称集是固定的还是可变的：

|  | 名称是静态的 | 名称是计算的 |
| --- | --- | --- |
| 固定成员集 | 与基本 Java 相同。 | 与使用反射来计算名称的 Java 相同。 |
| 可变成员集 | 难以设想（有什么用呢？）。 | 大多数脚本语言。 |

唯一一个案例有点不合理：如果我们强制开发人员在源文件中明确指定成员名称，那么就无法访问新成员（而且对先前存在但已删除的成员的某些访问将失败）。然而，此设计空间中的所有其他点都已被语言所探索。

右下角与使用哈希表表示对象的语言密切对应。然后名称只是哈希表的索引。一些语言将此视为极端情况，并且即使对于数值索引，也使用相同的表示，从而（例如）将对象与字典甚至数组混为一谈。即使对象只处理“成员名称”，这种对象风格也会为类型检查[REF]带来重大困难，因此并不自动可取。

因此，在本节的其余部分，我们将坚持使用具有固定名称集甚至静态成员名称引用的“传统”对象（左上角）。即使如此，我们将发现还有很多很多要研究的东西。

## 10.3 其他是什么？

到目前为止，我们的案例语句都没有 else 子句。加入 else 子句的一个原因是如果对象中有一个可变的成员集，尽管这可能更好地通过不同的表示来处理：例如，像我们之前讨论过的那样，使用哈希表。相比之下，如果一个对象的成员集是固定的，将其解糖为条件对于说明目的很有效（因为它强调了成员名称集的固定性，而哈希表则开放了解释——<wbr>并且也会出错）。然而，有另一个 else 子句的原因，那就是将控制“链接”到另一个、父对象。这被称为继承。

让我们回到上面解糖对象的模型。为了实现继承，必须为对象提供一个“东西”，它可以将不认识的方法调用委托给它。很大程度上将取决于那个“东西”是什么。

一个答案可能是它只是另一个对象。

> | (case m |
> | --- |
> |   ... |
> |   [else (父对象 m)]) |

由于我们对象的表示方式，这个应用程序实际上在父对象中搜索方法（并且，可能递归地在其父对象中搜索）。如果找到与名称匹配的方法，则通过这个链返回到最初在 msg 中寻找方法的原始调用。如果找不到，则最终对象可能会发出“未找到消息”错误。练习

> 观察到应用程序(parent-object m)就像“半个消息”，就像 l 值是“半个值查找”[REF]。这两者之间有任何联系吗？

让我们通过扩展我们的树来实现另一个方法 size。我们将为每个节点和 mt 编写一个“扩展”（你可能会说“子类”，但现在先别急！）来实现 size 方法。我们打算扩展现有的节点和 mt 的定义，因此我们将使用上面描述的扩展模式。我们不编辑现有的定义，因为这应该是对象继承的全部意义：以黑盒方式重用代码。这也意味着不相互了解的不同方可以扩展相同的基础代码。如果他们必须编辑基础，首先他们必须了解彼此，而且，其中一个可能不喜欢另一个的编辑。继承的目的是完全规避这些问题。

### 10.3.1 类

立即我们看到一个困难。这是构造函数模式吗？

> | (define (node/size parent-object v l r) |
> | --- |
> |   ...) |

这表明父对象与对象的构造函数字段处于“同一级别”。这似乎是合理的，因为一旦给定所有这些参数，对象就“完全定义”了。然而，我们还有

> | (define (node v l r) |
> | --- |
> |   ...) |

我们要两次写所有参数吗？（每当我们写两次某事时，我们应该担心可能无法一致地这样做，从而引发微妙的错误。）这里有一个替代方案：node/size 可以构造其父节点的实例。也就是说，node/size 的父参数不是父对象，而是父对象的对象制造者。

> | (define (node/size parent-maker v l r) |
> | --- |
> |   (let ([parent-object (parent-maker v l r)] |
> |         [self 'dummy]) |
> |     (begin |
> |       (set! self |
> |             (lambda (m) |
> |               (case m |
> |                 [(size) (lambda () (+ 1 |
> |                                      (msg l 'size) |
> |                                      (msg r 'size)))] |
> |                 [else (parent-object m)]))) |
> |       self))) |
> |   |
> | (define (mt/size parent-maker) |
> |   (let ([parent-object (parent-maker)] |
> |         [self 'dummy]) |
> |     (begin |
> |       (set! self |
> |             (lambda (m) |
> |               (case m |
> |                 [(size) (lambda () 0)] |
> |                 [else (parent-object m)]))) |
> |       self))) |

然后对象构造函数必须记住在每次调用时传递 parent-object maker：

> | (define a-tree/size |
> | --- |
> |   (node/size node |
> |              10 |
> |              (node/size node 5 (mt/size mt) (mt/size mt)) |
> |              (node/size node 15 |
> |                         (node/size node 6 (mt/size mt) (mt/size mt)) |
> |                         (mt/size mt)))) |

显然，我们可以通过适当的语法糖来简化这个过程。我们可以确认旧测试和新测试仍然有效：

> | (test (msg a-tree/size 'add) (+ 10 5 15 6)) |
> | --- |
> | (test (msg a-tree/size 'size) 4) |

练习

> 用自我应用而不是变异来重写这个代码块。

我们所做的是捕捉类的本质。每个参数化父类的函数...嗯，这有点棘手，实际上。现在让我们暂时称之为 blob。blob 对应于 Java 程序员在编写类时定义的内容：

> | class NodeSize extends Node { ... } |
> | --- |

现在开始！

> 那么为什么我们要绕过不称其为“类”呢？

当开发人员调用 Java 类的构造函数时，实际上会构造整个继承链上的对象（实际上，编译器可能会优化这一点，只需要一个构造函数调用和一个对象分配）。这些是对应于父类的对象的私有副本（私有，即直到静态成员的存在）。然而，有一个问题是这些对象的多少是可见的。Java 选择了—<wbr>与我们上面的实现不同—<wbr>只有一个给定名称（和签名）的方法保留下来，无论继承链上可能有多少个，而每个字段都保留在结果中，并且可以通过转换访问。后者是有道理的，因为每个字段可能都有规定其内容的不变量，因此保持它们分开（因此全部存在）是明智的。相比之下，很容易想象一种实现方式，即使在继承层次结构中最低（即最精细）的方法也使所有方法都可用。许���脚本语言采用后一种方法。

练习

> 上面的代码基本上是错误的。自我引用是指向相同的语法对象，而它需要引用最精细的对象：这被称为开放递归。这展示了我们从传统对象中获得的另一种可扩展性形式：可扩展递归。修改对象表示，使得 self 始终指向对象的最精细版本。提示：你会发现自我应用方法(无变异的自我引用))对递归很有用。

### 10.3.2 原型

在我们上面的描述中，我们为每个类提供了其父类的描述。然后对象构造会使每个实例沿着继承链向上走。还有另一种方式来考虑父类：不是作为一个要实例化的类，而是直接作为一个对象本身。然后所有具有相同父类的子类将观察到完全相同的对象，这意味着一个子对象对其进行的更改将对另一个子对象可见。共享的父对象被称为原型。

原型为基础的典型语言是[Self](http://selflanguage.org/)。尽管你可能已经读到过像 JavaScript 这样的语言是“基于”Self 的，但从源头研究这个想法仍然有价值，特别是因为 Self 以其最纯粹的形式呈现了这些想法。一些语言设计者认为原型比类更加原始，因为借助其他基本机制，比如函数，可以从原型中恢复类，但反之则不行。这基本上就是我们上面所做的：每个“类”函数内部都包含一个对象描述，因此一个类就是一个返回对象的函数。如果我们暴露了这两个不同的操作，并选择直接继承一个对象，我们将得到类似原型的东西。

练习

> 修改上述继承模式以实现类似 Self 的基于原型的语言，而不是基于类的语言。因为类为每个对象提供了其父对象的独立副本，一个原型语言可能会提供一个克隆操作，以简化在原型之上模拟类的操作的创建。

### 10.3.3 多重继承

现在你可能会问，为什么只有一个 fall-through 选项呢？将这个概念推广到有多个选项很容易，这自然地导致了多重继承。实际上，我们有多个对象可以进行查找链，这当然引发了一个问题，我们应该以什么顺序进行查找。如果祖先按照树的方式排列，那就已经够糟糕了，因为即使树也没有一个规范的遍历顺序：比如广度优先和深度优先遍历（每种都有强大的用途）。更糟糕的是，假设一个 blob A 继承了 B 和 C；但现在假设 B 和 C 各自又继承了 D。这个臭名昭著的情况被称为钻石继承。如果你选择在你的语言中包含多重继承，你将在这方面的设计决策中迷失数日。因为你极有可能找不到一个规范的答案，你的痛苦只会刚刚开始。现在我们必须面对这个问题：在 A 的实例中会有一个还是两个 D 对象？只有一个可以节省空间，并且可能与我们的期望更好地交互，但是，我们会访问这个对象一次还是两次呢？访问两次应该没有任何区别，所以这似乎是不必要的。但是访问一次意味着 B 或 C 中的一个的行为可能会改变。依此类推。结果，几乎每一种支持多重继承的语言都伴随着一个微妙的算法，仅仅是为了定义查找顺序。

多重继承只有在你仔细思考之后才会变得有吸引力。

### 10.3.4 超级继承！

许多语言都有超级调用的概念，即能够在继承链中更高层次地调用方法或访问字段的能力。请注意，我说的是“the”和“chain”。当我们转换为多重继承时，这些概念被更复杂的东西所取代。这包括在对象构造时进行这样的操作，通常要求调用所有构造函数，以确保对象被正确定义。

我们已经习惯了将这些调用视为“上行”链条，以至于我们可能已经忘记了问这是否是最自然的方向。请记住，构造函数和方法应该强制执行不变量。我们应该更信任谁：超类还是子类？一个论点会说子类最精细，因此它对对象有最全局的视角。相反，每个超类都有一个既得利益，要保护其不变量免受无知子类的侵犯。

这是两种根本相反的对继承含义的看法。沿着链条上行意味着我们将扩展视为替换父类。沿着链条下行意味着我们将扩展视为对父类的完善。因为我们通常将子类化与完善联系起来，为什么我们的语言选择了“错误”的调用顺序？因此，一些语言默认探索向下方向的调用。[gbeta](http://www.daimi.au.dk/~eernst/gbeta/) 是一种支持内部以及许多其他有趣功能的现代编程语言。考虑 [结合两个方向](http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf) 也很有趣。

### 10.3.5 混合和特质

让我们回到我们的“blob”。

当我们在 Java 中编写一个类时，在大括号之间我们到底在定义什么？这不是整个类：这取决于它继承的父类，以此类推。相反，在大括号内我们定义的是一个类扩展。它只有在我们在同一个位置也标识出父类时才变成一个完整的类。

自然地，我们应该问：为什么？为什么不将定义扩展与将扩展应用于基类分开？也就是说，假设不是

> | 类 C extends B { ... } |
> | --- |

我们改为写：

> | 类扩展 E { ... } |
> | --- |

分开来说

> | 类 C = E(B) |
> | --- |

其中 B 是某个已经定义的类。到目前为止，看起来我们只是为了得到以前的东西而大费周章。然而，函数应用程序样式的语法旨在提出建议：我们可以将这个扩展“应用”到几个不同的基类上。因此：

> | 类 C1 = E(B1); |
> | --- |
> | 类 C2 = E(B2); |

等等。通过将 E 的定义与它所扩展的类的定义分开，我们解放了类扩展，使其摆脱了固定基类的限制。我们有一个对这些扩展的名称：它们被称为 mixins。术语“mixin”起源于 Common Lisp，那里它是使用多重继承的一种特定模式。猪上的口红。

Mixin 使类的定义更具有组合性。它们提供了多重继承的许多好处（重用多个功能片段），但在单一继承语言的保护下进行（即，没有关于查找顺序的复杂规则）。观察到，当解糖时，向语言添加 mixin 实际上是非常容易的。mixin 主要是一个“类的函数”；因为我们已经确定了如何解糖类，而且我们解糖的目标语言也有函数，并且类解糖为可以嵌套在函数内部的表达式，所以实现一个简单的 mixin 模型几乎是微不足道的。这是一种情况，解糖的目标语言更普遍，可以导致我们更好的构建，如果我们将其反映回源语言。

在一个类型化的语言中，一个好的 mixin 设计实际上可以改善面向对象的编程实践。假设我们正在定义一个基于 mixin 的 Java 版本。如果一个 mixin 实际上是一个类到类的函数，那么这个“函数”的“类型”是什么呢？显然，mixin 应该使用接口来描述它期望和提供的内容。Java 已经可以实现（但不要求）后者，但它不支持前者：一个类（扩展）扩展另一个类——<wbr>所有成员都对扩展可见——<wbr>而不是它的接口。这意味着它获取了父类的所有行为，而不是行为的规范。反过来，如果父类发生了变化，类可能会出现问题。

在一个 mixin 语言中，我们可以改写为

> | mixin M extends I { ... } |
> | --- |

其中 I 是一个接口。然后 M 只能应用于满足接口 I 的类，反之，语言可以确保只有在 I 中指定的成员在 M 中可见。这遵循了良好软件设计的重要原则。“基于接口而非实现进行编程。” —<wbr>《设计模式》

一个好的 mixin 设计甚至可以走得更远。按定义，类在继承链中只能使用一次（如果一个类最终引用自身，那么在继承链中将会形成一个循环，导致潜在的无限循环）。相比之下，当我们组合函数时，我们对于多次使用同一个函数并不犹豫（例如：（map ... (filter ... (map ...))））。使用 mixin 两次有价值吗？当然有！参见 [Classes and Mixins](http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/) 的第 3 和第 4 节。

混入解决了在库设计中出现的一个重要问题。假设我们有一打不同的特性，可以以不同的方式组合。我们应该提供多少个类？此外，并非所有这些都可以彼此组合。很明显，生成整个组合爆炸的类是不切实际的。如果开发人员可以挑选并选择他们关心的特性，并具有一些机制来防止不合理的组合，那就更好了。这正是混入解决的问题：它们提供了类的扩展，开发人员可以以保持接口的方式组合，以创建他们需要的类。混入在 Racket GUI 库中被广泛使用。例如，color:text-mixin 使用基本文本编辑器接口并实现了彩色文本编辑器接口。后者本身就是一个基本文本编辑器接口，因此可以将其他基本文本混入应用于结果。

练习

> 你最喜欢的面向对象库是如何解决这个问题的？

混入确实有一个限制：它们强制实现了组合的线性性。这种严格有时是不合适的，因为它给程序员带来了可能是不必要的负担。一种称为特质的混入的泛化说，我们可以扩展一组混入，而不是单一混入。当然，一旦我们扩展超过一个，我们必须再次处理潜在的名称冲突。因此，特质必须配备解决名称冲突的机制，通常以某种名称组合代数的形式出现。因此，特质为混入提供了很好的补充，使程序员能够选择最适合他们需求的机制。因此，Racket 提供了混入和特质两种机制。

# 5 将函数添加到语言中

让我们开始将这些转换为一个真正的编程语言。我们可以添加诸如条件语句之类的中间特性，但要做任何有趣的事情，我们都需要函数或它们的道德等价物，所以让我们开始吧。

练习

> 向你的语言中添加条件语句。你可以添加布尔数据类型，或者，如果想快速完成，可以添加一个将 0 视为 false 而其他一切视为 true 的条件语句。
> 
> 你应该编写哪些重要的测试用例？

因此，想象我们正在模拟一个像 DrRacket 这样的系统。开发者在定义窗口中定义函数，并在交互窗口中使用它们。现在，让我们假设所有的定义都只在定义窗口中（我们很快会放宽这一限制 [REF]），而所有的表达式都只在交互窗口中。因此，运行程序只是加载定义。因为我们的解释器对应于交互窗口提示符，所以我们假设它提供了一组定义。

> > > 一组定义暗示着没有顺序，这意味着，据推测，任何定义都可以引用任何其他定义。这是我在这里的意图，但当你设计自己的语言时，一定要考虑这一点。

## 5.1 定义数据表示

为了保持简单，让我们只考虑一个参数的函数。下面是一些 Racket 示例：

> | (define (double x) (+ x x)) |
> | --- |
> |   |
> | (define (quadruple x) (double (double x))) |
> |   |
> | (define (const5 _) 5) |

练习

> 当一个函数有多个参数时，什么简单但重要的标准决定了这些参数的名称？

函数定义的各部分是什么？它有一个名称（如上所示，double、quadruple 和 const5），我们将其表示为一个符号（'double 等）；它的形式参数或参数有一个名称（例如，x），我们也可以将其建模为一个符号（'x）；它有一个主体。我们将逐步确定主体的表示方法，但让我们开始制定函数定义的数据类型：

<fundef>)) ::=

> | (define-type FunDefC |
> | --- |
> |   [fdC (name : symbol) (arg : symbol) (body : ExprC)]) |

主体是什么？显然，它具有算术表达式的形式，有时甚至可以使用现有的 ArithC 语言来表示：例如，const5 的主体可以表示为 (numC 5)。但表示 double 的主体需要更多的东西：不仅仅是加法（我们已经有了），还有“x”。你可能习惯称其为变量，但我们现在不会使用这个术语。相反，我们将其称为标识符。我保证我们以后会回到这个命名问题上 [REF]。

立即行动！

> 还有其他吗？

最后，让我们看看 quadruple 的主体。它有一个全新的构造：函数应用。非常小心地区分函数定义（描述函数是什么）和应用（使用函数）。这些是用途。double 的内部应用的参数（或实际参数）是 x；外部应用的参数是(double x)。因此，参数可以是任何复杂的表达式。

让我们将所有这些都提交到一个清晰的数据类型中。显然，我们正在扩展之前的内容（因为我们仍然希望拥有所有的算术）。我们将为我们的数据类型取一个新名字，以表明它正在成长：

<exprC>)) ::=

> | (define-type ExprC |
> | --- |
> |   [numC (n : number)] |
> |   <idC-def>)) |
> |   <app-def>)) |
> |   [plusC (l : ExprC) (r : ExprC)] |
> |   [multC (l : ExprC) (r : ExprC)]) |

标识符与形式参数密切相关。当我们通过为其参数提供一个值来应用一个函数时，实际上我们正在要求它替换体中所有该形式参数的实例——即，与形式参数同名的标识符——为该值。请注意，我们对一些问题保持了含糊不清：是什么样的“值” [REF]，以及何时替换 [REF]。为了简化这个搜索和替换的过程，我们可能会使用同一种数据类型来表示两者。我们已经选择了符号来表示形式参数，所以：

<idC-def>)) ::=

> [idC (s : symbol)]

最后，应用。它们有两部分：函数的名称和其参数。我们已经同意参数可以是任何完整的表达式（包括标识符和其他应用）。至于函数名称，再次使用与我们在函数定义中给函数命名时使用的相同的数据类型是合理的。因此：

<app-def>)) ::=

> [appC (fun : symbol) (arg : ExprC)]

确定要应用哪个函数，并提供其参数。

使用这些定义，写出我们上面定义的示例的表示是很有启发性的：

+   (fdC ’double ’x (plusC (idC ’x) (idC ’x)))

+   (fdC ’quadruple ’x (appC ’double (appC ’double (idC ’x))))

+   (fdC ’const5 ’_ (numC 5))

我们还需要选择一种表示一组函数定义的表示方法。用列表表示这些是方便的。

> > > 注意！你是否注意到我们谈到了一组函数定义，但选择了列表表示？这意味着我们使用有序数据集表示无序实体。至少，在测试时，我们应该使用所有的排列组合来确保我们没有微妙地构建了对顺序的依赖。

## 5.2 扩展解释器

现在我们准备好处理解释器了。首先，让我们回顾一下它需要消耗什么。之前，它仅消耗要评估的表达式。现在，它还需要接受一个函数定义的列表：

<interp>)) ::= 

> | (定义 (interp [e : ExprC] [fds : (listof FunDefC)]) : 数字 |
> | --- |
> |   <interp-body>))) |

让我们重新审视一下我们的旧解释器（首次看解释）。对于数字的情况，显然我们仍然将数字作为答案返回。在加法和乘法情况下，我们仍然需要递归（因为子表达式可能很复杂），但我们使用哪一组函数定义？因为评估表达式的行为既不添加也不删除函数定义，因此定义集合保持不变，并且在递归调用中应该保持不变。

<interp-body>)) ::= 

> | (类型分支 ExprC e |
> | --- |
> |   [numC (n) n] |
> |   <idC-interp-case>)) |
> |   <appC-interp-case>)) |
> |   [plusC (l r) (+ (interp l fds) (interp r fds))] |
> |   [multC (l r) (* (interp l fds) (interp r fds))]) |

现在让我们来处理应用。首先我们必须查找函数定义，对此我们假设我们有一个此类型的辅助函数可用：

> | ; get-fundef : symbol * (listof FunDefC) -> FunDefC |
> | --- |

假设我们找到了给定名称的函数，我们需要评估它的主体。然而，记得我们关于标识符和参数所说的吗？我们必须进行“搜索和替换”，这是一个你在学校代数中见过的过程，称为替换。这是非常重要的，我们应该先谈论替换，然后再回到解释器（恢复的解释器)）。

## 5.3 替换

替换是用另一个表达式（在本例中为实际参数）替换表达式中的名称（在本例中为形式参数）的行为。让我们定义它的类型：

> | ; subst : ExprC * symbol * ExprC -> ExprC |
> | --- |

还给它的参数起一个有意义的名字是很有帮助的：

<subst>)) ::= 

> | (定义 (subst [what : ExprC] [for : symbol] [in : ExprC]) : ExprC |
> | --- |
> |   <subst-body>))) |

第一个参数是我们想要替换的名称；第二个是我们想要执行替换的名称；第三个是我们想要在其中执行替换的表达式。

现在就做吧！

> 假设我们想要在上述三个示例函数的主体中将 3 替换为标识符 x。它应该产生什么？

在双中，这应该产生(+ 3 3)；在四倍中，它应该产生(double (double 3))；在 const5 中，它应该产生 5（即，不发生替换，因为主体中没有 x 的实例）。

> > > 一个常见的错误是假设在 double 中替换 x 为 3 的结果是（define (double x) (+ 3 3)）。这是不正确的。我们只在应用函数时进行替换，在那时函数的调用被其主体替换。标头使我们能够找到函数并确定其参数的名称；但只有其主体保留用于评估。检查替换如何用于注意到返回函数定义会导致类型错误。

这些示例已经告诉我们在几乎所有情况下该怎么做。给定一个数字，没有什么需要替换的。如果它是一个标识符，我们还没有看到一个不同标识符的示例，但你已经猜到应该发生什么：它保持不变。在其他情况下，进入子表达式，执行替换。

在我们将这转化为代码之前，有一个重要的情况需要考虑。假设我们要替换的名称恰好是一个函数的名称。那么应该发生什么？

现在动起来！

> 究竟应该发生什么？

有许多方法来解决这个问题。其中一种是从设计的角度来看：函数名存在于它们自己的“世界”中，与普通程序标识符不同。一些语言（如 C 和 Common Lisp，稍有不同）采取这种观点，并根据它们的使用方式将标识符划分为不同的命名空间。在其他语言中，没有这样的区别；事实上，我们很快将研究这样的语言[REF]。

现在，我们将采取一种实用的观点。因为表达式会被计算为数字，这意味着函数名可能会变成一个数字。然而，数字不能命名函数，只有符号可以。因此，在那个位置进行替换是没有意义的，无论它与被替换的变量的关系如何，我们都应该保持函数名不变。（因此，一个函数可以有一个名为 x 的参数，也可以引用另一个名为 x 的函数，这两者应该保持不同。）

现在我们已经做出了所有决定，我们可以提供主体代码：

<subst-body>)) ::=

> | (type-case ExprC in |
> | --- |
> |   [numC (n) in] |
> |   [idC (s) (cond |
> |              [(symbol=? s for) what] |
> |              [else in])] |
> |   [appC (f a) (appC f (subst what for a))] |
> |   [plusC (l r) (plusC (subst what for l) |
> |                       (subst what for r))] |
> |   [multC (l r) (multC (subst what for l) |
> |                       (subst what for r))]) |

练习

> 注意，与 numC 情况不同，解释器在 numC 情况下返回 n，而替换返回 in（即，原始表达式，在那一点上等同于写（numC n）。为什么？

## 5.4 解释器，继续

哦！现在我们已经完成了替换的定义（或者我们认为完成了），让我们完成解释器。替换是一个繁重的步骤，但它也完成了应用函数所涉及的大部分工作。很容易写成

<appC-interp-case-take-1>)) ::=

> | [appC (f a) (local ([define fd (get-fundef f fds)]) |
> | --- |
> |               (subst a |
> |                      (fdC-arg fd) |
> |                      (fdC-body fd)))] |

诱人，但是错了。

现在就做！

> 你明白为什么了吗？

从类型推理。解释器返回什么？数字。替换返回什么？哦，对了，表达式！例如，当我们在 double 的主体中进行替换时，我们得到了表示 (+ 5 5) 的表示形式。这对解释器来说不是一个有效的答案。相反，它必须被归约为一个答案。当然，这正是解释器所做的：

<appC-interp-case>)) ::=

> | [appC (f a) (local ([define fd (get-fundef f fds)]) |
> | --- |
> |               (interp (subst a |
> |                              (fdC-arg fd) |
> |                              (fdC-body fd)) |
> |                       fds))] |

好的，只剩下一个情况了：标识符。它们可能会有什么复杂的地方？它们应该和数字一样简单！但是我们把它们推到最后，暗示着有什么微妙或复杂的事情正在发生。

现在就做！

> 通过一些例子来理解解释器在标识符情况下应该做什么。

让我们假设我们将 double 定义如下：

> | (define (double x) (+ x y)) |
> | --- |

当我们将 5 代入 x 时，这产生了表达式 (+ 5 y)。到目前为止一切顺利，但是还剩下什么要替代 y 呢？事实上，从一开始就应该清楚，这个 double 的定义是错误的。说标识符 y 是自由的，这个形容词在这种情境中有负面含义。

换句话说，解释器永远不应该遇到一个标识符。所有的标识符都应该是在解释器看到它们之前就已经被替换（称为绑定标识符——这里是一个积极的内涵）的参数。因此，对于一个标识符只有一种可能的响应：

<idC-interp-case>)) ::=

> [idC (_) (error 'interp "shouldn't get here")]

就是这样！

最后，为了完成我们的解释器，我们应该定义 get-fundef：

> | (define (get-fundef [n : symbol] [fds : (listof FunDefC)]) : FunDefC |
> | --- |
> |   (cond |
> |     [(empty? fds) (error 'get-fundef "reference to undefined function")] |
> |     [(cons? fds) (cond |
> |                    [(equal? n (fdC-name (first fds))) (first fds)] |
> |                    [else (get-fundef n (rest fds))])])) |

## 5.5 噢，等等，还有更多！

之前，我们给 subst 分配了以下类型：

> | ; subst : ExprC * symbol * ExprC -> ExprC |
> | --- |

为了简洁起见，我们坚持使用表面语法，假设我们将 double 应用于 (+ 1 2)。这将为每个 x 替换为 (+ 1 2)，导致以下表达式—(+ (+ 1 2) (+ 1 2))—供解释。这一定是我们想要的吗？

当你在学校学习代数时，可能被教导以不同的方式进行：首先将参数简化为一个答案（在这种情况下为 3），然后用答案替换参数。这种替换概念可能会有以下类型：

> | ; subst : number * symbol * ExprC -> ExprC |
> | --- |

注意：我们不能在表达式中放入原始数字，因此我们必须不断地将数字包装在 numC 的调用中。因此，subst 应该在包装第一个参数后调用一个辅助函数。 （实际上，我们现有的 subst 将是一个非常好的候选者：因为它接受第一个参数中的任何 ExprC，所以它肯定可以很好地与 numC 一起使用。）

> > > 实际上，我们甚至没有完全正确的替换！我们目前的替换版本由于一个被称为“名称捕获”的微妙问题而无法扩展到这种语言之外。修复替换是一个复杂、微妙且令人兴奋的智力努力，但这不是我想在这里探讨的方向。在本书中，我们将绕过这个问题。然而，如果你感兴趣，可以阅读关于λ演算的内容，它提供了正确定义替换的工具。

练习

> 修改你的解释器，用答案而不是表达式替换名称。

实际上，我们已经发现了编程语言中的一个深刻区别。在将参数替换到函数中之前评估参数的行为称为急切应用，而推迟评估的行为称为惰性<wbr>应用，并且有一些变体。目前，我们实际上更喜欢急切语义，因为这是大多数主流语言采用的方式。稍后[REF]，我们将回到讨论惰性应用语义及其影响。

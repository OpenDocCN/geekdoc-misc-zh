# 2 关于解析的一切（我们将说）

解析是将输入字符流转换为更结构化的内部表示的行为。一个常见的内部表示是树，程序可以递归处理。例如，给定流

| 23 + 5 - 6 |
| --- |

我们可能想要一个代表加法的树，其左节点代表数字 23，右节点代表从 5 减去 6。解析器负责执行这个转换。

解析是一个庞大而复杂的问题，由于歧义的困难，远未解决。例如，对于上述输入表达式，一个替代的解析树可能将减法放在顶部，加法放在其下方。我们还可能考虑这个加法操作是否可交换，因此参数的顺序是否可以交换。当我们涉及到完整的编程语言时（更不用说自然语言了），一切都变得更加糟糕。

## 2.1 一个轻量级、内置的解析器的前半部分

这些问题使得解析成为一个值得研究的主题，整本书、工具和课程都致力于此。然而，从我们的角度来看，解析大多数时候只是一个干扰，因为我们想要研究的是编程语言中不是解析的部分。因此，我们将利用 Racket 的一个方便功能来管理将输入流转换为树的过程：read。read 与语言的括号形式相关联，它完全解析（因此无歧义地）括号化的术语为内置的树形式。例如，在上述输入的括号形式上运行（read）—

| (+ 23 (- 5 6)) |
| --- |

—将产生一个列表，其第一个元素是符号'+', 第二个元素是数字 23，第三个元素是一个列表；这个列表的第一个元素是符号'-', 第二个元素是数字 5，第三个元素是数字 6。

## 2.2 一个方便的快捷方式

正如你所知，你需要充分测试你的程序，但当你必须一遍又一遍地手动输入术语时，这是很困难的。幸运的是，正如你所期望的那样，括号语法通过引用机制深度集成到了 Racket 中。也就是说，'<expr>—你在上面的例子中刚刚看到的—就好像你在提示符下运行（read）并键入了<expr>（当然，评估为（read）将会产生的值）。

## 2.3 解析的类型

实际上，我有点撒谎。我说（read）—或者等效地，使用引用—将产生一个列表，等等。在常规的 Racket 中是正确的，但在 Typed PLAI 中，它返回一个称为 s-表达式的不同类型，Typed PLAI 中写为 s-表达式：

| > (read) |
| --- |
| - s 表达式 |
| [在 (+ 23 (- 5 6) 中的类型] |
| '(+ 23 (- 5 6)) |

Racket 有一个非常丰富的 s-表达式语言（甚至有表示循环结构的符号），但我们只会使用其中的简单片段。

在有类型的语言中，s-表达式与其他类型（如数字和列表）有所不同对待。在底层，s-表达式是一个大型的递归数据类型，包含所有基本可打印值——<wbr>数字、字符串、符号等等——<wbr>以及 s-表达式的可打印集合（列表、向量等等）。因此，像数字、符号和字符串这样的基本类型既是它们自己的类型，也是 s-表达式的实例。对这样的数据进行类型化可能会相当棘手，我们稍后会讨论[REF]。

Typed PLAI 采用了简单的方法。当单独写出时，像数字这样的值属于各自的类型。但当写在复杂的 s-表达式中——<wbr>特别是由 read 或引用创建的——<wbr>它们的类型是 s-表达式。然后你必须将它们强制转换为其本机类型。例如：

| > '+ |
| --- |
| - 符号 |
| '+ |
| > (define l '(+ 1 2)) |
| > l |
| - s-表达式 |
| '(+ 1 2) |
| > (first l) |
| . 类型检查失败：(listof '_a) vs s-表达式： |
|   first |
|   (quote (+ 1 2)) |
|   l |
|   first |
| > (define f (first (s-exp->list l))) |
| > f |
| - s-表达式 |
| '+ |

这类似于 Java 程序员需要插入的强制转换。我们稍后将学习强制转换本身[REF]。请注意，列表的第一个元素仍然不被类型检查器视为符号：一个类似列表形状的 s-表达式是 s-表达式的列表。因此，

| > (symbol->string f) |
| --- |
| . 类型检查失败：符号与 s-表达式不匹配： |
|   symbol->string |
|   f |
|   symbol->string |
|   f |
|   first |
|   (first (s-exp->list l)) |
|   s-exp->list |

而强制转换可以解决这个问题：

| > (symbol->string (s-exp->symbol f)) |
| --- |
| - string |
| "+" |

需要对 s-表达式进行强制转换有点麻烦，但由于我们试图实现的目标，一些复杂性是不可避免的：通过强类型的方式将无类型的输入流转换为有类型的输出流。我们必须明确表达我们对输入流的假设。

幸运的是，我们只会在解析器中使用 s-表达式，我们的目标是尽快摆脱解析！实际上，如果有什么的话，这应该是更快摆脱的诱因。

## 2.4 完成解析器

原则上，我们可以将 read 视为一个完整的解析器。然而，它的输出是通用的：它代表了令牌结构，而没有提供任何关于其意图的评论。相反，我们更希望有一个表示，告诉我们关于语言中术语的预期含义的表示，就像我们在一开始写的那样：“表示加法”，“表示一个数字”等等。

为了做到这一点，我们必须首先引入一个捕捉这种表示���数据类型。我们将单独讨论（表示算术）我们如何以及为什么获得这种数据类型，但现在让我们假设它已经给出：

> | (define-type ArithC |
> | --- |
> |   [numC (n : number)] |
> |   [plusC (l : ArithC) (r : ArithC)] |
> |   [multC (l : ArithC) (r : ArithC)]) |

现在我们需要一个函数，将 s 表达式转换为此数据类型的实例。这是我们解析器的另一半：

> | (define (parse [s : s-expression]) : ArithC |
> | --- |
> |   (cond |
> |     [(s-exp-number? s) (numC (s-exp->number s))] |
> |     [(s-exp-list? s) |
> |      (let ([sl (s-exp->list s)]) |
> |        (case (s-exp->symbol (first sl)) |
> |          [(+) (plusC (parse (second sl)) (parse (third sl)))] |
> |          [(*) (multC (parse (second sl)) (parse (third sl)))] |
> |          [else (error 'parse "invalid list input")]))] |
> |     [else (error 'parse "invalid input")])) |

因此：

| > (parse '(+ (* 1 2) (+ 2 3))) |
| --- |
| - ArithC |
| (plusC |
|  (multC (numC 1) (numC 2)) |
|  (plusC (numC 2) (numC 3))) |

恭喜！您刚刚完成了对程序的第一个表示。从现在开始，我们可以完全专注于以递归树表示的程序，忽略表面语法的变化以及如何将其转换为树形式。我们终于准备好开始学习编程语言了！

练习

> 如果您忘记引用解析器的参数会发生什么？为什么？

## 2.5Coda

Racket 的语法，它继承自 Scheme 和 Lisp，是有争议的。然而，请注意，我们从中获得的一些非常有价值的东西。虽然解析传统语言可能非常复杂，但解析这种语法几乎是微不足道的。给定与输入对应的标记序列，将括号序列转换为 s 表达式绝对是直截了当的；同样直截了当（如上所示）将 s 表达式转换为正确的语法树。我喜欢将这种两级语言称为双室制，与政府立法机构的松散类比：下层进行基本的格式检查，而上层进行更深层次的有效性检查。（我们还没有做任何后者，但我们将在[REF]中做。）

因此，这种语法的优点是多方面的。它所需的代码量很小，可以轻松嵌入许多上下文中。通过将语法集成到语言中，程序可以轻松地操作程序的表示（正如我们将在[REF]中看到的）。因此，即使许多基于 Lisp 的语法具有完全不同的语义，它们都共享这种语法遗产。

当然，我们也可以使用 XML。那会更好。或者 JSON。因为那根本不像 s 表达式。

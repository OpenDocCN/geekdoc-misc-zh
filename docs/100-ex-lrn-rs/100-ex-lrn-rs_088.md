# 设计回顾

> 原文：[`rust-exercises.com/100-exercises/07_threads/13_without_channels.html`](https://rust-exercises.com/100-exercises/07_threads/13_without_channels.html)

让我们花点时间回顾一下我们所走过的路。

## 无锁的通道序列化

我们对多线程票据存储的第一个实现使用了：

+   一个单一的长生命线程（服务器），以持有共享状态

+   多个客户端通过它们自己的线程中的通道向其发送请求。

无需锁定状态，因为服务器是唯一修改状态的实体。这是因为“收件箱”通道自然**序列化**了传入的请求：服务器会逐个处理它们。

我们已经讨论了这种方法在修补行为方面的局限性，但我们没有讨论原始设计的性能影响：服务器一次只能处理一个请求，包括读取。

## 细粒度锁定

然后，我们转向了一个更复杂的设计，其中每个票据都由其自己的锁保护，并且客户端可以独立决定是否想要读取或原子性地修改一个票据，获取适当的锁。

这种设计允许更好的并行性（即多个客户端可以同时读取票据），但它仍然是根本上的**序列化**：服务器逐个处理命令。特别是，它逐个向客户端发放锁。

我们能否完全移除通道，并允许客户端直接访问`TicketStore`，完全依赖锁来同步访问？

## 移除通道

我们有两个问题需要解决：

+   在线程间共享`TicketStore`

+   同步对存储的访问

### 在线程间共享`TicketStore`

我们希望所有线程都引用同一个状态，否则我们实际上并没有一个多线程系统——我们只是在并行运行多个单线程系统。

当我们尝试在多个线程间共享一个锁时，我们已经遇到了这个问题：我们可以使用`Arc`。

### 同步对存储的访问

由于通道提供的序列化，有一个交互仍然是无锁的：从存储中插入（或删除）一个票据。

如果我们移除通道，我们需要引入（另一个）锁来同步对`TicketStore`本身的访问。

如果我们使用`Mutex`，那么为每个票据使用额外的`RwLock`就没有意义了：`Mutex`将已经序列化对整个存储的访问，所以我们无论如何都无法并行读取票据。

如果我们使用`RwLock`，那么我们可以并行读取票据。我们只需要在插入或删除票据时暂停所有读取。

让我们沿着这条路径走下去，看看它将带我们走向何方。

## 练习

本节练习位于[`07_threads/13_without_channels`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/13_without_channels)

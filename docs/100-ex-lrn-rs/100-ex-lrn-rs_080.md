# 通道

> 原文：[`rust-exercises.com/100-exercises/07_threads/05_channels.html`](https://rust-exercises.com/100-exercises/07_threads/05_channels.html)

到目前为止，我们生成的所有线程都相对较短命。

获取一些输入，运行计算，返回结果，然后关闭。

对于我们的票据管理系统，我们想要做些不同的事情：一个客户端-服务器架构。

我们将有一个**长时间运行的服务器线程**，负责管理我们的状态，即存储的票据。

然后，我们将有**多个客户端线程**。

每个客户端都将能够向状态线程发送**命令**和**查询**，以改变其状态（例如，添加新的票据）或检索信息（例如，获取票据的状态）。

客户端线程将并发运行。

## 通信

到目前为止，我们只有非常有限的父子通信：

+   生成的线程从父上下文中借用/消费了数据。

+   当生成的线程连接时，它将数据返回给父线程。

这对于客户端-服务器设计来说还不够。

客户端需要在启动后能够从服务器线程发送和接收数据。

我们可以使用**通道**来解决这个问题。

## 通道

Rust 的标准库在其 `std::sync::mpsc` 模块中提供了**多生产者，单消费者**（mpsc）通道。

有两种通道类型：有界和无界。我们现在将坚持使用无界版本，但稍后我们将讨论其优缺点。

通道创建看起来是这样的：

```rs
use std::sync::mpsc::channel;

let (sender, receiver) = channel();
```

你得到一个发送者和一个接收者。

你在发送者上调用 `send` 来将数据推入通道。

你在接收者上调用 `recv` 来从通道中拉取数据。

### 多个发送者

`Sender` 是可克隆的：我们可以创建多个发送者（例如，每个客户端线程一个），它们将数据推入同一个通道。

相反，`Receiver` 不可克隆：对于给定的通道，只能有一个接收者。

这就是 **mpsc**（多生产者单消费者）的含义！

### 消息类型

`Sender` 和 `Receiver` 都是对类型参数 `T` 的泛型。

这是我们通道上可以传输的消息类型。

它可以是 `u64`、结构体、枚举等。

### 错误

`send` 和 `recv` 都可能失败。

如果接收者已断开连接，`send` 返回错误。

如果所有发送者都已断开连接且通道为空，`recv` 返回错误。

换句话说，当通道实际上关闭时，`send` 和 `recv` 会返回错误。

## 练习

本节练习位于[`07_threads/05_channels`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/05_channels)。

# 复制值，第二部分

> 原文：[`rust-exercises.com/100-exercises/04_traits/12_copy.html`](https://rust-exercises.com/100-exercises/04_traits/12_copy.html)

让我们考虑与之前相同的例子，但稍作修改：使用`u32`而不是`String`作为类型。

```rs
fn consumer(s: u32) { /* */ }

fn example() {
     let s: u32 = 5;
     consumer(s);
     let t = s + 1;
}
```

它会编译无误！这里发生了什么？`String`和`u32`之间的区别是什么，使得后者在没有`.clone()`的情况下也能工作？

## `Copy`

`Copy`是 Rust 标准库中定义的另一个特质：

```rs
pub trait Copy: Clone { }
```

它是一个标记特质，就像`Sized`一样。

如果一个类型实现了`Copy`，则不需要调用`.clone()`来创建该类型的新实例：Rust 会为你**隐式地**完成这项工作。

`u32`是实现`Copy`的类型的例子，这就是为什么上面的例子可以编译无误：当调用`consumer(s)`时，Rust 通过执行`s`的位复制来创建一个新的`u32`实例，然后将这个新实例传递给`consumer`。这一切都是在幕后发生的，你不需要做任何事情。

## 什么可以是`Copy`？

`Copy`不等同于“自动克隆”，尽管它暗示了这一点。

类型必须满足一些要求才能允许实现`Copy`。

首先，它必须实现`Clone`，因为`Copy`是`Clone`的子特质。这很有道理：如果 Rust 可以隐式地创建一个类型的新实例，那么它也应该能够通过调用`.clone()`来显式地创建一个新实例。

然而，还有更多条件必须满足：

1.  该类型不管理任何**额外**资源（例如堆内存、文件句柄等），除了它占用的内存中的`std::mem::size_of`字节。

1.  该类型不是可变引用（`&mut T`）。

如果满足这两个条件，那么 Rust 可以通过执行原始实例的**位复制**来安全地创建该类型的新实例——这通常被称为`memcpy`操作，这个名字来源于执行位复制的 C 标准库函数。

### 案例研究 1：`String`

`String`是一个没有实现`Copy`的类型。

为什么？因为它管理了一个额外的资源：存储字符串数据的堆分配内存缓冲区。

让我们假设 Rust 允许`String`实现`Copy`。

然后，当通过执行原始实例的位复制来创建新的`String`实例时，原始实例和新实例都会指向同一个内存缓冲区：

```rs
 s                                 copied_s
+---------+--------+----------+      +---------+--------+----------+
| pointer | length | capacity |      | pointer | length | capacity |
|  |      |   5    |    5     |      |  |      |   5    |    5     |
+--|------+--------+----------+      +--|------+--------+----------+
   |                                    |
   |                                    |
   v                                    |
 +---+---+---+---+---+                  |
 | H | e | l | l | o |                  |
 +---+---+---+---+---+                  |
   ^                                    |
   |                                    |
   +------------------------------------+ 
```

这很糟糕！当这两个`String`实例超出作用域时，它们都会尝试释放内存缓冲区，导致双重释放错误。你也可以创建两个指向同一内存缓冲区的不同`&mut String`引用，违反 Rust 的借用规则。

### 案例研究 2：`u32`

`u32`实现了`Copy`。实际上，所有整数类型都实现了。

整数“只是”内存中表示数字的字节。没有更多！如果你复制这些字节，你会得到另一个完全有效的整数实例。不会发生任何坏事，所以 Rust 允许这样做。

### 案例研究 3: `&mut u32`

当我们介绍所有权和可变借用时，我们明确地提出了一条规则：在任何给定时间，一个值只能有一个可变借用。

正因如此，`&mut u32`不实现`Copy`，尽管`u32`实现了。

如果`&mut u32`实现了`Copy`，你就可以创建多个对同一值的可变引用，并在多个地方同时修改它。这将违反 Rust 的借用规则！因此，无论`T`是什么，`&mut T`永远不会实现`Copy`。

## 实现`Copy`

在大多数情况下，你不需要手动实现`Copy`。你可以直接推导它，如下所示：

```rs
#[derive(Copy, Clone)]
struct MyStruct {
    field: u32,
}
```

## 练习

本节练习位于[`04_traits/12_copy`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy)

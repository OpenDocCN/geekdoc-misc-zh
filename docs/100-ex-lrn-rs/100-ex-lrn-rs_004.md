# 类型，第一部分

> 原文：[`rust-exercises.com/100-exercises/02_basic_calculator/01_integers.html`](https://rust-exercises.com/100-exercises/02_basic_calculator/01_integers.html)

在"语法"部分中，`compute`的输入参数类型为 `u32`。

让我们来解释一下这*意味着什么*。

## 原始类型

`u32` 是 Rust 的**原始类型**之一。原始类型是语言的最基本构建块。它们是语言本身构建的——即它们不是基于其他类型定义的。

你可以将这些原始类型组合起来创建更复杂的类型。我们很快就会看到。

## 整数

`u32` 特别是一个**无符号 32 位整数**。

整数是可以不带小数部分的数字。例如，`1` 是一个整数，而 `1.2` 不是。

### 有符号与无符号

整数可以是**有符号**或**无符号**。

无符号整数只能表示非负数（即 `0` 或更大）。有符号整数可以表示正数和负数（例如 `-1`、`12` 等）。

`u32` 中的 `u` 代表**无符号**。

有符号整数的等效类型是 `i32`，其中 `i` 代表整数（即任何整数，正数或负数）。

### 位宽

`u32` 中的 `32` 指的是在内存中表示数字所使用的**比特数^(1)**。

比特数越多，可以表示的数字范围就越大。

Rust 支持多种整数位宽：`8`、`16`、`32`、`64`、`128`。

使用 32 位，`u32` 可以表示从 `0` 到 `2³² - 1`（即[`u32::MAX`](https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX)）的数字。

在相同的比特数下，有符号整数（`i32`）可以表示从 `-2³¹` 到 `2³¹ - 1`（即[`i32::MIN`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN) 到[`i32::MAX`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX)）的数字。

`i32` 的最大值小于 `u32` 的最大值，因为有一个比特用于表示数字的符号。有关有符号整数在内存中表示的更多详细信息，请查看[二进制补码](https://en.wikipedia.org/wiki/Two%27s_complement)表示。

### 总结

结合这两个变量（有符号/无符号和位宽），我们得到以下整数类型：

| 位宽 | 有符号 | 无符号 |
| --- | --- | --- |
| 8 位 | `i8` | `u8` |
| 16 位 | `i16` | `u16` |
| 32 位 | `i32` | `u32` |
| 64 位 | `i64` | `u64` |
| 128 位 | `i128` | `u128` |

## 字面量

**字面量**是表示源代码中固定值的记法。

例如，`42` 是 Rust 中表示数字四十二的字面量。

### 字面量的类型注解

但在 Rust 中，所有值都有类型，所以... `42` 的类型是什么？

Rust 编译器会根据字面量的使用方式尝试推断其类型。

如果您不提供任何上下文，编译器将默认为`i32`为整数字面量。

如果您想使用不同的类型，您可以在所需整数类型后添加后缀——例如，`2u64`是一个显式类型为`u64`的 2。

### 字面量中的下划线

您可以使用下划线 `_` 来提高大数字的可读性。

例如，`1_000_000` 与 `1000000` 相同。

## 算术运算符

Rust 支持以下整数运算符^(2)：

+   `+` 用于加法

+   `-` 用于减法

+   `*` 用于乘法

+   `/` 用于除法

+   `%` 用于余数

这些运算符的优先级和结合规则与数学中的相同。

您可以使用括号来覆盖默认的优先级。例如：`2 * (3 + 4)`。

> ⚠️ **警告**
> 
> 除法运算符 `/` 在与整数类型一起使用时执行整数除法。即结果被截断到零。例如，`5 / 2` 是 `2`，而不是 `2.5`。

## 无自动类型转换

正如我们在上一个练习中讨论的，Rust 是一种静态类型语言。

尤其是 Rust 对类型转换非常严格。它不会自动将一个值从一种类型转换为另一种类型^(3)，即使转换是无损的。您必须显式地进行转换。

例如，您不能将`u8`类型的值赋给类型为`u32`的变量，尽管所有`u8`值都是有效的`u32`值：

```rs
let b: u8 = 100;
let a: u32 = b;
```

它将抛出一个编译错误：

```rs
error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  | 
```

我们将在本课程的后续部分看到如何在不同类型之间进行转换（稍后介绍）。

## 进一步阅读

+   [官方 Rust 书籍中的整数类型部分](https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types)

## 练习

本节练习位于[`02_basic_calculator/01_integers`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers)

* * *

1.  位是计算机中最小的数据单位。它只能有两个值：`0` 或 `1`。↩

1.  Rust 不允许您定义自定义运算符，但它让您控制内置运算符的行为。我们将在介绍特质之后讨论运算符重载（稍后介绍）。↩

1.  此规则有一些例外，主要与引用、智能指针和人体工程学相关。我们将在稍后介绍这些内容（稍后介绍）。在此期间，一个“所有转换都是显式的”的心理模型将为您服务。↩

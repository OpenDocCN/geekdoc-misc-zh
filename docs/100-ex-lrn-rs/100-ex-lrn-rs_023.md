# 堆

> 原文：[`rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html`](https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html)

栈很棒，但它不能解决我们所有的问题。对于编译时不知道大小的数据怎么办？集合、字符串和其他动态大小的数据不能（完全）在栈上分配。这就是堆的作用所在。

## 堆分配

你可以将堆想象成一大块内存——如果你愿意，可以把它想象成一个巨大的数组。

每当你需要在堆上存储数据时，你都会要求一个特殊的程序，即**分配器**，为你预留堆的一个子集。我们称这种交互（以及你预留的内存）为**堆分配**。如果分配成功，分配器会给你一个指向预留块起始的**指针**。

## 无自动释放

堆的结构与栈大不相同。

堆分配不是连续的，它们可以位于堆内的任何位置。

```rs
+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  Allocation 1 | Free  | ... | ... |  Allocation N |    Free   |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+ 
```

跟踪堆中哪些部分在使用，哪些部分是空闲的，这是分配器的职责。尽管如此，分配器不会自动释放你分配的内存：你需要有意识地去做，再次调用分配器来**释放**你不再需要的内存。

## 性能

堆的灵活性是有代价的：堆分配比栈分配**慢**。涉及的记账工作更多！

如果你阅读关于性能优化的文章，你经常会得到这样的建议：尽量减少堆分配，并在可能的情况下优先选择栈分配的数据。

## `String` 的内存布局

当你创建一个类型为 `String` 的局部变量时，Rust 被迫在堆上分配^(1)：它事先不知道你将放入多少文本，因此它不能在栈上预留正确数量的空间。

但一个 `String` 并不是**完全**堆分配的，它也保留了一些数据在栈上。特别是：

+   你预留的堆区域的**指针**。

+   字符串的**长度**，即字符串中有多少字节。

+   字符串的**容量**，即已经预留了多少字节在堆上。

让我们通过一个例子来更好地理解这一点：

```rs
let mut s = String::with_capacity(5);
```

如果你运行这段代码，内存将按照以下方式布局：

```rs
 +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+ 
```

我们请求了一个可以容纳多达 5 字节文本的 `String`。

`String::with_capacity` 会去请求分配器，并要求 5 字节的堆内存。分配器返回该内存块的起始指针。

虽然 `String` 是空的。在栈上，我们通过区分长度和容量来跟踪这些信息：这个 `String` 可以容纳多达 5 字节，但目前只包含 0 字节的实际文本。

如果你将一些文本推入 `String`，情况将发生变化：

```rs
s.push_str("Hey");
```

```rs
 +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   3    |    5     |
      +--|  ----+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+ 
```

`s` 现在包含 3 个字节的文本。其长度更新为 3，但容量保持为 5。堆上的五个字节中有三个被用来存储字符 `H`、`e` 和 `y`。

### `usize`

我们需要多少空间来在栈上存储指针、长度和容量？

这取决于你运行的机器的**架构**。

您机器上的每个内存位置都有一个[**地址**](https://en.wikipedia.org/wiki/Memory_address)，通常表示为无符号整数。根据地址空间的最大大小（即您的机器可以寻址的内存量），这个整数可以有不同的大小。大多数现代机器使用 32 位或 64 位地址空间。

Rust 通过提供`usize`类型来抽象这些架构特定的细节：这是一个无符号整数，其大小与在您的机器上寻址内存所需的字节数相同。在 32 位机器上，`usize`相当于`u32`。在 64 位机器上，它匹配`u64`。

容量、长度和指针在 Rust 中都用`usize`表示^(2)。

### 没有`std::mem::size_of`用于堆

`std::mem::size_of`返回一个类型在栈上占用多少空间，这也就是所谓的**类型大小**。

> 那么`String`在堆上管理的内存缓冲区呢？这不是`String`大小的一部分吗？

不！

那堆分配是`String`正在管理的**资源**。编译器并不认为它是`String`类型的一部分。

`std::mem::size_of`不知道（或关心）类型可能通过指针管理或引用的额外堆分配数据，例如`String`，因此它不跟踪其大小。

不幸的是，没有`std::mem::size_of`的等价功能来测量运行时某个值分配的堆内存量。某些类型可能提供方法来检查它们的堆使用情况（例如`String`的`capacity`方法），但在 Rust 中没有任何通用“API”来检索运行时的堆使用情况。

然而，你可以使用内存分析工具（例如 [DHAT](https://valgrind.org/docs/manual/dh-manual.html) 或 [自定义分配器](https://docs.rs/dhat/latest/dhat/))来检查你程序的堆使用情况。

## 练习

本节的练习位于[`03_ticket_v1/09_heap`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap)

* * *

1.  如果你创建一个**空**的`String`（即`String::new()`），`std`不会进行分配。↩

1.  指针的大小也取决于操作系统。在某些环境中，指针**更大**于内存地址（例如 [CHERI](https://web.archive.org/web/20240517051950/https://blog.acolyer.org/2019/05/28/cheri-abi/))。Rust 做出了简化的假设，即指针的大小与内存地址相同，这在大多数现代系统中都是正确的。↩

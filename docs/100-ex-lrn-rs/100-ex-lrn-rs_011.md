# 溢出

> 原文：[`rust-exercises.com/100-exercises/02_basic_calculator/08_overflow.html`](https://rust-exercises.com/100-exercises/02_basic_calculator/08_overflow.html)

一个数的阶乘增长非常快。

例如，20 的阶乘是 2,432,902,008,176,640,000。这已经大于 32 位整数的最大值，2,147,483,647。

当算术运算的结果大于给定整数类型的最大值时，我们谈论的是**整数溢出**。

整数溢出是一个问题，因为它们违反了算术运算的合同。

两个给定类型的整数之间的算术运算的结果应该是同一类型的另一个整数。但是，*数学上正确的结果*无法适应那个整数类型！

> 如果结果是给定整数类型的最小值以下，我们称该事件为**整数下溢**。
> 
> 为了简洁起见，我们将在本节剩余部分仅讨论整数溢出，但请记住，我们所说的内容同样适用于整数下溢。
> 
> 你在"变量"部分中编写的`speed`函数在某些输入组合中发生了下溢。例如，如果`end`小于`start`，则`end - start`将下溢`u32`类型，因为结果应该是负数，但`u32`无法表示负数。

## 无自动提升

一种可能的方法是自动将结果提升到更大的整数类型。例如，如果你正在对两个`u8`整数求和，并且结果是 256（`u8::MAX + 1`），Rust 可以选择将结果解释为`u16`，这是足够大的下一个整数类型，可以容纳 256。

但是，正如我们之前讨论的，Rust 对类型转换非常挑剔。自动整数提升不是 Rust 解决整数溢出问题的方案。

## 替代方案

由于我们排除了自动提升，当发生整数溢出时我们该怎么办？

这归结为两种不同的方法：

+   拒绝操作

+   提出一个“合理”的结果，使其适合预期的整数类型

### 拒绝操作

这是最高保守的方法：当发生整数溢出时，我们停止程序。

这通过 panic 来实现，这是我们已经在"panic"部分中看到过的机制。

### 提出一个“合理”的结果

当算术运算的结果大于给定整数类型的最大值时，你可以选择**环绕**。

如果你将给定整数类型的所有可能值想象成一个圆，环绕意味着当你达到最大值时，你从最小值重新开始。

例如，如果您在 1 和 255（`u8::MAX`）之间进行带符号的加法，结果将是 0（`u8::MIN`）。如果您正在处理有符号整数，则相同的原理适用。例如，使用带符号的方式将 1 加到 127（`i8::MAX`）将得到-128（`i8::MIN`）。

## 溢出检查

Rust 允许您，作为开发者，在整数溢出发生时选择使用哪种方法。该行为由`overflow-checks`配置文件设置控制。

如果`overflow-checks`设置为`true`，当整数运算发生溢出时，Rust 将在运行时**恐慌**。如果`overflow-checks`设置为`false`，当整数运算发生溢出时，Rust 将**回绕**。

您可能会想知道——什么是配置文件设置？让我们来探讨一下！

## 配置文件

[配置文件](https://doc.rust-lang.org/cargo/reference/profiles.html)是一组配置选项，可用于自定义 Rust 代码的编译方式。

Cargo 提供了 4 个内置配置文件：`dev`、`release`、`test`和`bench`。

每次您运行`cargo build`、`cargo run`或`cargo test`时，都会使用`dev`配置文件。它旨在针对本地开发，因此它牺牲了运行时性能，以换取更快的编译时间和更好的调试体验。

相反，`release`配置文件针对运行时性能进行了优化，但会带来更长的编译时间。您需要通过`--release`标志显式请求——例如`cargo build --release`或`cargo run --release`。`test`配置文件是`cargo test`使用的默认配置文件。`test`配置文件从`dev`配置文件继承设置。`bench`配置文件是`cargo bench`使用的默认配置文件。`bench`配置文件从`release`配置文件继承。使用`dev`进行迭代开发和调试，使用`release`进行优化后的生产构建，

`test`用于正确性测试，`bench`用于性能基准测试。

> “你有没有以发布模式构建你的项目？”在 Rust 社区中几乎成了一个梗。
> 
> 这指的是那些不熟悉 Rust 并在社交媒体（例如 Reddit、Twitter）上对其性能提出抱怨的开发者（在意识到他们尚未以发布模式构建项目之前）。

您还可以定义自定义配置文件或自定义内置的配置文件。

### 溢出检查

默认情况下，`overflow-checks`设置为：

+   对于`dev`配置文件，设置为`true`

+   对于`release`配置文件，设置为`false`

这与两个配置文件的目标一致。

`dev`配置文件旨在针对本地开发，因此它通过尽可能早地突出潜在问题来引发恐慌。

相反，`release`配置文件针对运行时性能进行了调整：检查溢出会减慢程序运行速度，因此它更倾向于回绕。

同时，为两个配置文件提供不同的行为可能会导致微妙的错误。

我们的推荐是，为两个配置文件都启用`overflow-checks`：出错总比默默产生错误结果要好。在大多数情况下，运行时性能的影响是可以忽略不计的；如果你正在开发一个性能关键的应用程序，你可以运行基准测试来决定这是否是你负担得起的。

## 进一步阅读

+   查阅["关于 Rust 中整数溢出的神话和传说"](https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/)，以深入了解 Rust 中的整数溢出。

## 练习

本节的练习位于[`02_basic_calculator/08_overflow`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/08_overflow)

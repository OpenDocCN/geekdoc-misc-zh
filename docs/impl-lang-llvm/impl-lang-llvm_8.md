# 结论

# 结论

欢迎来到“使用 LLVM 实现语言”教程的最后一章。在本教程中，我们将我们的小型万花筒语言从一个无用的玩具发展到一个半有趣（但可能仍然无用）的玩具。:)

看到我们已经走了多远，以及所需代码量之少，实在令人感到有趣。我们手工构建了整个词法分析器、解析器、抽象语法树、代码生成器以及一个交互式运行循环（带有即时编译！），代码行数不到 700 行（不包括注释和空行）。

我们的小语言支持一些有趣的特性：它支持用户定义的二元和一元运算符，它使用 JIT 编译进行即时评估，并支持一些带 SSA 构造的控制流结构。

本教程的一部分想法是向你展示定义、构建和玩耍语言可以是多么简单和有趣。构建编译器不必是一个可怕或神秘的过程！现在你已经了解了一些基础知识，我强烈鼓励你拿起代码并进行修改。例如，尝试添加：

+   **全局变量** - 虽然全局变量在现代软件工程中的价值有争议，但在像万花筒编译器这样快速构建小型应用时，它们通常很有用。幸运的是，我们当前的设置使添加全局变量非常容易：只需在值查找时检查未解析变量是否在全局变量符号表中，然后再拒绝它。要创建一个新的全局变量，只需创建 LLVM GlobalVariable 类的一个实例。

+   **带类型的变量** - 目前，万花筒仅支持双精度类型的变量。这使得语言非常优雅，因为仅支持一种类型意味着你永远不必指定类型。不同的语言处理方式不同。最简单的方法是要求用户为每个变量定义指定类型，并将变量的类型与其 Value* 记录在符号表中。

+   **数组、结构体、向量等** - 一旦添加了类型，你可以开始以各种有趣的方式扩展类型系统。简单数组非常容易，对许多不同的应用程序非常有用。添加它们主要是为了学习 LLVM getelementptr 指令的工作原理：它非常巧妙/非传统，甚至有自己的常见问题解答！如果添加了对递归类型（例如链表）的支持，请确保阅读 LLVM 程序员手册中描述如何构建它们的部分。

+   **标准运行时** - 我们当前的语言允许用户访问任意外部函数，并且我们用它来执行诸如“printd”和“putchard”之类的操作。当你扩展语言以添加更高级别的结构时，通常这些结构最合理的方式是将它们降级为调用语言提供的运行时。例如，如果你向语言添加哈希表，最好将这些例程添加到运行时，而不是将它们全部内联。

+   **内存管理** - 目前我们只能访问 Kaleidoscope 中的堆栈。能够分配堆内存将非常有用，可以使用标准的 libc malloc/free 接口或垃圾回收器。如果您想使用垃圾回收，请注意 LLVM 完全支持准确的垃圾回收，包括移动对象和需要扫描/更新堆栈的算法。

+   **调试器支持** - LLVM 支持生成 DWARF 调试信息，这些信息可以被常见的调试器如 GDB 所理解。添加对调试信息的支持非常简单。要了解它的最佳方法是用“clang -g -O0”编译一些 C/C++代码，并查看它产生了什么。

+   **异常处理支持** - LLVM 支持生成与其他语言编译的代码相互操作的零成本异常。您还可以通过隐式地使每个函数返回一个错误值并检查它来生成代码。您还可以明确地使用 setjmp/longjmp。这里有许多不同的方法。

+   **对象导向，泛型，数据库访问，复数，几何编程，……** - 实际上，你可以向语言中添加无数疯狂的功能。

+   **不寻常的领域** - 我们一直在谈论将 LLVM 应用于许多人感兴趣的领域：为特定语言构建编译器。但是，还有许多其他领域可以使用编译器技术，这些领域通常不被考虑。例如，LLVM 已被用于实现 OpenGL 图形加速，将 C++代码翻译为 ActionScript 等许多其他有趣的事情。也许你会成为第一个使用 LLVM 将正则表达式解释器 JIT 编译成本地代码的人？

+   **玩得开心** - 尝试做一些疯狂和不寻常的事情。像其他人一样构建一种语言总是比尝试一些有点疯狂或离经叛道的事情要不那么有趣，看看结果如何。如果你遇到困难或想要讨论一下，可以随时给 llvmdev 邮件列表发邮件：那里有很多对语言感兴趣并且通常愿意帮助的人。

在结束本教程之前，我想谈谈一些生成 LLVM IR 的“技巧和窍门”。这些是一些可能不太明显但非常有用的更细微的事情，如果您想利用 LLVM 的功能，它们会很有用。

# 8.1 LLVM IR 的特性

我们关于 LLVM IR 形式的代码有几个常见问题 - 让我们现在就解决这些问题，好吗？

## 8.1.1 目标独立性

**万花筒（Kaleidoscope）**是“可移植语言”的一个示例：在任何运行的目标上，用 Kaleidoscope 编写的任何程序都会以相同的方式工作。许多其他语言也具有这个特性，例如 lisp、java、haskell、javascript、python 等（请注意，虽然这些语言是可移植的，但并非所有的库都是）。

LLVM 的一个很好的方面是，它通常能够在 IR 中保持目标独立性：你可以拿 Kaleidoscope 编译的程序的 LLVM IR，在 LLVM 支持的任何目标上运行，甚至可以生成 C 代码并在 LLVM 不原生支持的目标上进行编译。你可以轻松地确定 Kaleidoscope 编译器生成了目标无关的代码，因为在生成代码时它从未查询任何目标特定的信息。

LLVM 提供了一种紧凑、目标无关的代码表示，这让很多人感到兴奋。不幸的是，当人们询问语言可移植性时，他们通常是在考虑 C 或 C 家族的语言。我说“不幸”，是因为实际上没有办法使（完全一般的）C 代码可移植，除非把源代码传递过去（当然，一般情况下 C 源代码也不是真正可移植的——你曾经将一个真正古老的 32 位应用程序移植到 64 位吗？）。

C 语言（再次，就其全部一般性而言）的问题在于，它充满了目标特定的假设。一个简单的例子是，预处理器在处理输入文本时经常会从代码中去除目标无关性：

```
#ifdef __i386__
  int X = 1;
#else
  int X = 42;
#endif 
```

尽管可以为此类问题设计越来越复杂的解决方案，但不能以比提供实际源代码更好的方式来解决全部一般性问题。

话虽如此，有一些有趣的 C 子集可以被移植。如果你愿意将原始类型固定为一个固定的大小（比如 int = 32 位，long = 64 位），不关心与现有二进制文件的 ABI 兼容性，并且愿意放弃一些其他次要功能，那么你可以拥有可移植的代码。这对于特定领域如内核语言可能是有意义的。

## 8.1.2 安全保证

上面许多语言也是“安全”的语言：在 Java 中编写的程序不可能破坏其地址空间并使进程崩溃（假设 JVM 没有错误）。安全性是一个有趣的属性，需要语言设计、运行时支持，通常还需要操作系统支持。

实现在 LLVM 中实现安全语言是完全可能的，但 LLVM IR 本身并不保证安全。LLVM IR 允许不安全的指针转换、使用后释放漏洞、缓冲区溢出以及各种其他问题。安全性需要作为在 LLVM 之上的一层来实现，幸运的是，已经有几个团队对此进行了研究。如果您对更多细节感兴趣，请在 llvmdev 邮件列表上提问。

## 8.1.3 语言特定的优化

LLVM 的一件事让很多人失望的是，它不能在一个系统中解决世界上的所有问题（抱歉，“世界饥饿”，其他日子会有人解决你）。一个具体的抱怨是，人们认为 LLVM 无法执行高级语言特定的优化：LLVM“丢失了太多信息”。

不幸的是，这里真的不适合给你一个完整而统一的“克里斯·拉特纳的编译器设计理论”的版本。相反，我将做出一些观察：

首先，你是对的，LLVM 确实会丢失信息。例如，在撰写本文时，LLVM IR 无法区分 SSA 值是来自 C 的`int`还是 C 的`long`在 ILP32 机器上（除了调试信息）。两者都被编译为`i32`值，关于它来自何处的信息就丢失了。更一般的问题在于，LLVM 类型系统使用“结构等价”而不是“名称等价”。另一个让人感到惊讶的地方是，如果在高级语言中有两种具有相同结构的类型（例如，两个具有单个 int 字段的不同结构）：这些类型将被编译为单个 LLVM 类型，无法分辨它们来自何处。

其次，虽然 LLVM 确实会丢失信息，但 LLVM 并不是一个固定的目标：我们继续以许多不同的方式增强和改进它。除了添加新功能（LLVM 并不总是支持异常或调试信息），我们还扩展 IR 以捕获优化所需的重要信息（例如，参数是符号扩展还是零扩展，有关指针别名的信息等）。许多增强是由用户驱动的：人们希望 LLVM 包含某些特定功能，因此他们继续扩展它。

第三，可以轻松添加特定于语言的优化，并且有多种选择方法。举一个简单的例子，可以轻松添加“知道”有关为某种语言编译的代码的语言特定优化通道。在 C 系列的情况下，有一个优化通道“知道”标准 C 库函数。如果在 main()中调用“exit(0)”，它知道可以将其优化为“return 0;”，因为 C 规定了‘exit’函数的功能。

除了简单的库知识外，还可以将各种其他特定于语言的信息嵌入到 LLVM IR 中。如果你有特定需求并遇到困难，请在 llvmdev 列表上提出这个话题。在最坏的情况下，你总是可以将 LLVM 视为“愚蠢的代码生成器”，并在语言特定的 AST 上实现你所需的高级优化。

# 8.2 技巧和窍门

在使用 LLVM 工作后，你会了解到许多有用的技巧和窍门，这些并不是一眼就能看出来的。本节将讨论一些这些问题，而不是让每个人都重新发现它们。

## 8.2.1 实现可移植的 offsetof/sizeof

一个有趣的事情是，如果你试图保持编译器生成的代码“与目标无关”，通常需要知道某些 LLVM 类型的大小或 llvm 结构中某个字段的偏移量。例如，你可能需要将类型的大小传递给一个分配内存的函数。

不幸的是，这在各种目标平台上可能存在很大差异：例如，指针的宽度是与目标平台相关的微不足道的事情。然而，有一种聪明的方法可以使用`getelementptr`指令，以便以可移植的方式计算这个值。

## 8.2.2 垃圾回收的栈帧

一些语言希望显式管理它们的栈帧，通常是为了进行垃圾回收或者方便实现闭包。通常有比显式栈帧更好的实现这些功能的方法，但是如果你愿意，LLVM 也支持它们。这需要你的前端将代码转换为续传样式，并使用尾调用（LLVM 也支持）。

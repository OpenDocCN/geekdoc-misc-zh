# 使用 LLVM 实现语言

# 教程介绍

欢迎来到“使用 LLVM 实现语言”教程。本教程将演示一个简单语言的实现过程，展示它是多么有趣和简单。本教程将帮助您快速入门，并帮助构建一个可以扩展到其他语言的框架。本教程中的代码也可以用作在其他 LLVM 特定事项上进行实验的平台。

本教程的目标是逐步揭示我们的语言，描述它如何随着时间逐步构建。这将让我们涵盖相当广泛的语言设计和 LLVM 特定使用问题，一路展示和解释代码，而不会在一开始就用大量细节压倒您。

预先指出，本教程实际上是关于教授编译器技术和 LLVM，而不是教授现代和理智的软件工程原则。实际上，这意味着我们会采取许多捷径来简化表达。例如，代码会泄漏内存，到处使用全局变量，不使用像访问者这样的设计模式等...但它非常简单。如果您深入研究并将代码用作未来项目的基础，修复这些缺陷不应该很难。

我尝试将本教程组织成一种方式，使得如果您已经熟悉或对各个部分不感兴趣，可以轻松跳过章节。教程的结构如下：

+   **第一章**：介绍 Kaleidoscope 语言，以及其词法分析器的定义 - 这展示了我们的目标和我们希望它执行的基本功能。为了使本教程尽可能易懂和可操作，我们选择在 C++中实现所有内容，而不是使用词法分析器和解析器生成器。显然，LLVM 可以很好地与这些工具配合使用，如果您喜欢，可以自由选择使用。

+   **第二章**：实现解析器和 AST - 有了词法分析器，我们可以讨论解析技术和基本 AST 构建。本教程描述了递归下降解析和运算符优先级解析。第一章和第二章中的内容与 LLVM 无关，此时代码甚至没有链接到 LLVM。:)

+   **第三章**：生成 LLVM IR 代码 - 有了 AST 准备好了，我们可以展示生成 LLVM IR 代码是多么简单。

+   **第四章**：添加 JIT 和优化器支持 - 因为很多人对使用 LLVM 作为 JIT 感兴趣，我们将直接深入其中，并向您展示添加 JIT 支持只需 3 行代码。LLVM 在许多其他方面也很有用，但这是展示其强大功能的一种简单而“性感”的方式。:)

+   **第五章**：扩展语言：控制流 - 语言已经运行起来了，我们展示如何通过控制流操作（if/then/else 和‘for’循环）来扩展它。这让我们有机会讨论简单的 SSA 构建和控制流。

+   **第六章**：扩展语言：用户定义运算符 - 这是一个愚蠢但有趣的章节，讨论了如何扩展语言以让用户编程定义他们自己的任意一元和二元运算符（可分配优先级！）。这让我们可以将“语言”的一个重要部分构建为库例程。

+   **第七章**：扩展语言：可变变量 - 这一章讨论了添加用户定义的局部变量以及赋值运算符。有趣的部分在于在 LLVM 中构建 SSA 形式是多么简单和琐碎：不，LLVM 不需要你的前端构建 SSA 形式！

+   **第八章**：结论和其他有用的 LLVM 小贴士 - 这一章通过讨论扩展语言的潜在方法来结束系列，但也包括了一堆关于“特殊主题”的信息，比如添加垃圾回收支持、异常、调试、支持“意大利面条堆栈”以及一堆其他技巧和窍门。

在本教程结束时，我们将写了不到 700 行非注释、非空白的代码。通过这少量的代码，我们将为一个非平凡语言构建了一个非常合理的编译器，包括手写的词法分析器、语法分析器、抽象语法树，以及带有 JIT 编译器的代码生成支持。虽然其他系统可能有有趣的“hello world”教程，但我认为本教程的广度是对 LLVM 优势的一个很好的证明，如果你对语言或编译器设计感兴趣，你应该考虑它。

关于本教程的一点说明：我们希望你扩展这门语言并自己玩耍。拿起代码，疯狂地对其进行修改，编译器不需要是可怕的生物 - 玩转语言可以是一种很有趣的事情！

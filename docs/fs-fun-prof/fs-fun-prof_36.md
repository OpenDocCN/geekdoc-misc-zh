# 你的编程语言是否合理？

# 你的编程语言是否合理？

正如显而易见的，这个网站的目标之一是说服人们认真对待 F# 作为一种通用开发语言。

但随着函数式习惯变得更加主流，以及 C# 添加了诸如 lambda 和 LINQ 等函数式功能，似乎 C# 正在越来越“赶上” F#。

因此，具有讽刺意味的是，我现在开始听到人们说这样的话：

+   "C# 已经拥有了大部分 F# 的特性，那么我为什么要费心去切换呢？"*

+   "没有必要改变。我们只需要等几年，C# 将获得许多提供最大好处的 F# 特性。"

+   "F# 稍微比 C# 好一点，但并不值得花费精力去转向它。"

+   "F# 看起来确实很好，尽管有点令人生畏。但我看不出使用它而不是 C# 的实际目的。"

毫无疑问，在 JVM 生态系统中，关于 Scala 和 Clojure 与 Java 的对比，现在 Java 也有了 lambda，相同的评论也在被提出。

因此，在这篇文章中，我将远离 F#，专注于 C#（以及其他主流语言），并尝试证明，即使拥有世界上所有的函数式特性，使用 C# 编程永远不会与使用 F# 编程相同。

在我开始之前，我想明确一点，我*并不*讨厌 C#。事实上，我非常喜欢 C#；它是我最喜欢的主流语言之一，它已经发展成为非常强大的同时保持一致性和向后兼容性，这是一件难以实现的事情。

但是 C# 并不完美。像大多数主流面向对象语言一样，它包含一些设计决策，LINQ 或 lambda 的优点也无法弥补。

在这篇文章中，我将展示一些这些设计决策引起的问题，并提出一些改进语言以避免这些问题的方法。

*(我现在要穿上防火服了。我觉得我可能需要它！)*

* * *

更新：许多人严重误解了这篇文章，似乎是这样。所以让我明确一点：

+   我*并不*是说静态类型语言比动态语言“更好”。

+   我*并不*是说函数式编程语言比面向对象语言“更好”。

+   我*并不*是说能够推理代码是一种语言中最重要的方面。

我*所说的是*：

+   不能推理代码会带来许多开发人员可能没有意识到的成本。

+   因此，在选择编程语言时，“合理性”应该是考虑的（众多）因素之一，而不仅仅是因为缺乏认识而被忽视。

+   *如果*你想要能够推理你的代码，*那么*如果你的语言支持我提到的特性，那么将会更容易。

+   面向对象（对象标识、基于行为）的基本范式与“合理性”不兼容，因此很难向现有的面向对象语言添加这种特性。

就是这样。谢谢！

* * *

## 什么是“合理”的编程语言？

如果你经常与函数式编程人员交往，你经常会听到“推理”，比如“我们想推理我们的程序”。

这是什么意思？为什么使用“推理”这个词而不是只是“理解”？

“推理”的使用可以追溯到数学和逻辑，但我将使用一个简单而实用的定义：

+   “推理代码”意味着你可以仅仅通过你面前的信息得出结论，而不必深入到代码库的其他部分。

换句话说，你可以通过查看一些代码来预测其行为。你可能需要了解其他组件的接口，但你不应该需要深入了解它们来看看它们做了什么。

作为开发人员，我们大部分时间都在看代码，这是编程的一个非常重要的方面！

当然，关于如何做到这一点有大量的建议：命名指南，格式化规则，设计模式等等。

但是你的编程语言*本身*可以帮助你的代码更合理、更可预测吗？我认为答案是肯定的，但我会让你自己判断。

下面，我将呈现一系列代码片段。在每个片段之后，我会问你认为这段代码做了什么。我特意没有展示我的评论，这样你可以自己思考。在你思考过之后，往下滚动查看我的观点。

* * *

## 示例 1

让我们先看看下面的代码。

+   我们从一个变量`x`开始，它被赋予整数`2`。

+   然后以`x`作为参数调用`DoSomething`。

+   然后`y`被赋值为`x - 1`。

我要问你的问题很简单：`y`的值是多少？

```
var x = 2;
DoSomething(x);

// What value is y? 
var y = x - 1; 
```

（向下滚动查看答案）

答案是`-1`。你得到了那个答案吗？没有？如果你猜不出来，再次向下滚动。

这是个恶作剧问题！这段代码实际上是 JavaScript！

这就是全部内容：

```
function DoSomething (foo) { x = false}

var x = 2;
DoSomething(x);
var y = x - 1; 
```

是的，太可怕了！`DoSomething`直接访问`x`而不是通过参数，然后将其转换为布尔值！然后，从`x`中减去 1 将其从`false`转换为`0`，所以`y`是`-1`。

你难道不是完全讨厌这个吗？对不起让你误解语言，但我只是想演示当语言表现出不可预测的行为时是多么令人恼火。

JavaScript 是一种非常有用和重要的语言。但没有人会声称[合理性](http://stackoverflow.com/a/1995298/1136133)是其优势之一。事实上，大多数动态类型语言都有[怪癖，使得它们难以通过推理来理解](https://www.destroyallsoftware.com/talks/wat)。

由于静态类型和合理的作用域规则，这种事情在 C#中不可能发生（除非你非常努力！）。在 C#中，如果你没有正确匹配类型，你会得到一个*编译时*错误而不是*运行时*错误。

换句话说，C#比 JavaScript 更可预测。给静态类型加一分！

现在我们有了使语言可预测的第一个要求：

***如何使你的语言可预测***：

1.  变量不应该被允许改变它们的类型。

相比 JavaScript，C#看起来不错。但我们还没完成...

*更新：这显然是一个愚蠢的例子。回想起来，我本可以选一个更好的例子。是的，我知道没有理智的人会这么做。但问题依然存在：JavaScript 语言不会阻止你用隐式类型转换做蠢事。*

* * *

## 例 2

在下一个例子中，我们将创建两个完全相同数据的相同`Customer`类的实例。

问题是：它们相等吗？

```
// create two customers
var cust1 = new Customer(99, "J Smith");
var cust2 = new Customer(99, "J Smith");

// true or false?
cust1.Equals(cust2); 
```

（向下滚动获取答案）

```
// true or false?
cust1.Equals(cust2); 
```

谁知道呢？这取决于`Customer`类的实现方式。这段代码是*不可预测*的。

你将不得不查看类是否至少实现了`IEquatable`，而且你可能还需要查看类的内部以确切了解发生了什么。

*但这到底是个问题吗？*

让我问你这个问题：

+   你有多经常不希望实例相等？

+   你有多经常需要重写`Equals`方法？

+   你有多经常因为*忘记*重写`Equals`方法而导致 bug？

+   你有多经常因为误实现`GetHashCode`（比如在你比较的字段变化时忘记修改）而导致 bug？

为什么不默认让对象相等，而将引用相等测试作为特例呢？

所以让我们在列表中再添加一项。

***如何使你的语言可预测***：

1.  变量不应该被允许改变它们的类型。

1.  **包含相同值的对象应该默认相等。**

* * *

## 例 3

在下一个例子中，我有两个包含完全相同数据但是是不同类实例的对象。

再次问题是：它们相等吗？

```
// create a customer and an order
var cust = new Customer(99, "J Smith");
var order = new Order(99, "J Smith");

// true or false?
cust.Equals(order); 
```

（向下滚动获取答案）

```
// true or false?
cust.Equals(order); 
```

谁在乎！这几乎肯定是个 bug！你为什么一开始就要比较两个不同的类呢？

比较它们的名字或者 id，当然可以，但不是对象本身。这应该是个编译器错误。

如果不是，为什么？你可能只是错用了变量名，但现在你的代码中有一个微妙的 bug。你的语言为什么让你这样做呢？

所以让我们在列表中再添加一项。

***如何使你的语言可预测***：

1.  变量不应该被允许改变它们的类型。

1.  包含相同值的对象应该默认相等。

1.  **比较不同类型的对象是编译时错误。**

*更新：许多人指出，当比较由继承关系相关的类时，你需要这个。当然，这是真的。但这个特性的成本是多少呢？你获得了比较子类的能力，但你失去了检测意外错误的能力。*

*在实践中哪个更重要？这取决于你的决定，我只是想明确指出现状存在成本，不仅仅是好处。*

* * *

## 示例 4

在这个片段中，我们只是要创建一个`Customer`实例。就这样。不能再基本了。

```
// create a customer
var cust = new Customer();

// what is the expected output?
Console.WriteLine(cust.Address.Country); 
```

现在的问题是：`WriteLine`的预期输出是什么？

（向下滚动查看答案）

```
// what is the expected output?
Console.WriteLine(cust.Address.Country); 
```

谁知道呢？

这取决于`Address`属性是否为空。而且这是你无法不查看`Customer`类的内部就无法确定的事情。

是的，我们知道构造函数应在构建时初始化所有字段是一种最佳实践，但为什么语言不强制执行呢？

如果地址是必需的，则在构造函数中使其为必需。如果地址*不*总是必需的，那么明确地指出`Address`属性是可选的，并且可能会丢失。

所以让我们将另一个改进项目添加到我们的列表中。

***如何使你的语言可预测***：

1.  变量不应允许更改其类型。

1.  包含相同值的对象默认应该是相等的。

1.  比较不同类型的对象是一个编译时错误。

1.  **对象必须*始终*初始化为有效状态。不这样做将导致编译时错误。**

* * *

## 示例 5

在下一个示例中，我们将：

+   创建一个客户。

+   将其添加到使用哈希的集合中。

+   对客户对象进行一些操作。

+   查看客户是否仍在集合中。

会有什么问题吗？

```
// create a customer
var cust = new Customer(99, "J Smith");

// add it to a set
var processedCustomers = new HashSet<Customer>();
processedCustomers.Add(cust);

// process it
ProcessCustomer(cust);

// Does the set contain the customer? true or false?
processedCustomers.Contains(cust); 
```

所以，这段代码结束时，集合中还包含客户吗？

（向下滚动查看答案）

```
// Does the set contain the customer?
processedCustomers.Contains(cust); 
```

可能。也可能不是。

它取决于两件事：

+   首先，客户的哈希码是否取决于一个*可变*字段，比如一个 id。

+   第二，`ProcessCustomer`是否更改了这个字段？

如果两者都是真的，那么哈希码将被更改，并且客户将不再*看起来*存在于集合中（即使它仍然存在于其中的某个地方！）。

这可能会导致微妙的性能和内存问题（例如，如果集合是一个缓存）。

语言如何防止这种情况发生？

一种方法是说，`GetHashCode`中使用的任何字段或属性都必须是不可变的，而允许其他属性是可变的。但这真的不切实际。

最好只是将整个`Customer`类设为不可变！

现在如果`Customer`类是不可变的，并且`ProcessCustomer`想要进行更改，它将不得不返回客户的*新版本*，代码将如下所示：

```
// create a customer
var cust = new ImmutableCustomer(99, "J Smith");

// add it to a set
var processedCustomers = new HashSet<ImmutableCustomer>();
processedCustomers.Add(cust);

// process it and return the changes
var changedCustomer = ProcessCustomer(cust);

// true or false?
processedCustomers.Contains(cust); 
```

注意，`ProcessCustomer`行已更改为：

```
var changedCustomer = ProcessCustomer(cust); 
```

很明显，`ProcessCustomer`通过查看这段代码就改变了一些东西。如果`ProcessCustomer` *没有*改变任何东西，它根本就不需要返回一个对象。

回到问题，很明显，在这个实现中，无论`ProcessCustomer`做了什么，原始版本的顾客都保证仍然在集合中。

当然，这并没有解决新旧版本中应该在集合中的问题。但是，与使用可变顾客的实现不同，这个问题现在直接摆在你面前，不会被无意中忽略。

所以[不可变性万岁](http://stackoverflow.com/a/4763485/1136133)！

所以这是我们清单上的另一项。

***如何使你的语言可预测***：

1.  变量不应该允许改变它们的类型。

1.  包含相同值的对象默认应该是相等的。

1.  比较不同类型的对象是编译时错误。

1.  对象必须*始终*被初始化为有效状态。不这样做是编译时错误。

1.  **一旦创建，对象和集合*必须*是不可变的。**

是时候讲一个关于不可变性的笑话了：

> "有多少 Haskell 程序员需要更换灯泡？"
> 
> "Haskell 程序员不会“更改”灯泡，他们会“替换”它们。而且你还必须同时替换整个房子。"

快完成了 -- 只剩下一个了！

* * *

## 例子 6

在这个最后的例子中，我们将尝试从`CustomerRepository`中获取一个客户。

```
// create a repository
var repo = new CustomerRepository();

// find a customer by id
var customer = repo.GetById(42);

// what is the expected output?
Console.WriteLine(customer.Id); 
```

问题是：我们执行`customer = repo.GetById(42)`之后，`customer.Id`的值是多少？

（向下滚动查看答案）

```
var customer = repo.GetById(42);

// what is the expected output?
Console.WriteLine(customer.Id); 
```

当然，这一切都取决于情况。

如果我查看`GetById`的方法签名，它告诉我它总是返回一个`Customer`。但是它*真的*吗？

如果客户丢失会发生什么？`repo.GetById`返回`null`吗？它会抛出异常吗？你只是通过查看我们的代码无法确定。

特别是，返回`null`是一件可怕的事情。它是一个背叛者，假装是一个`Customer`，并且可以被分配给`Customer`变量，而编译器却毫不抱怨，但是当你实际要求它做点什么时，它会冷笑着在你脸上爆炸。不幸的是，通过查看这段代码，我无法确定是否返回了 null。

异常稍微好一点，因为至少它们是有类型的，并且包含有关上下文的信息。但是从方法签名中看不出可能抛出哪些异常。你唯一可以确定的方法是查看内部源代码（也许还有文档，如果你幸运的话，并且它是最新的）。

但是现在想象一下，你的语言不允许`null`，也不允许异常。那你可以做什么呢？

答案是，你会被迫返回一个特殊的类，它可能包含*一个*顾客*或者*一个错误，就像这样：

```
// create a repository
var repo = new CustomerRepository();

// find a customer by id and
// return a CustomerOrError result
var customerOrError = repo.GetById(42); 
```

处理这个“customerOrError”结果的代码然后必须测试它是什么类型的结果，并分别处理每种情况，就像这样：

```
// handle both cases
if (customerOrError.IsCustomer)
    Console.WriteLine(customerOrError.Customer.Id);

if (customerOrError.IsError)
    Console.WriteLine(customerOrError.ErrorMessage); 
```

这正是大多数函数式语言采取的方法。如果语言提供了使这种技术更容易的便利，比如和类型，那么这将有所帮助，但即使没有，这种方法仍然是唯一可行的方式，如果你想让你的代码明确地表达出来的话。（你可以在[这里](http://fsharpforfunandprofit.com/rop/)阅读更多关于这种技术的内容。）

所以这是我们的清单中要添加的最后两个项目，至少目前是这样。

***如何使您的语言可预测***：

1.  不应允许变量更改其类型。

1.  包含相同值的对象默认应该相等。

1.  比较不同类型的对象是编译时错误。

1.  对象必须始终初始化为有效状态。不这样做是编译时错误。

1.  一旦创建，对象和集合必须是不可变的。

1.  **不允许空值。**

1.  **函数签名中必须明确表示缺失数据或错误。**

我可以继续，用一些片段来展示全局变量、副作用、强制转换等的错误用法。但我想我会在这里停下来--你现在可能已经有了想法！

## 你的编程语言能做到*这个*吗？

我希望很明显，对编程语言进行这些增强将有助于使其更加合理。

不幸的是，主流 OO 语言如 C#很不可能添加这些功能。

首先，这将是对所有现有代码的重大破坏性更改。

其次，许多这些变化深深违背了面向对象编程模型本身的基本原则。

例如，在 OO 模型中，对象的身份至关重要，因此默认情况下是按引用相等的。

此外，从 OO 的角度来看，两个对象如何进行比较完全取决于对象本身--OO 完全是关于多态行为的，编译器需要保持距离！同样，对象如何构造和初始化也完全取决于对象本身。没有规则规定允许什么或不允许什么。

最后，在没有实现点 4 中的初始化约束的情况下，向静态类型的 OO 语言添加非空引用类型非常困难。正如 Eric Lippert 本人所说的["非空性是你希望从第一天就包含在类型系统中的东西，而不是 12 年后才想要进行后期改造"](http://blog.coverity.com/2013/11/20/c-non-nullable-reference-types/)。

相比之下，大多数函数式编程语言将这些“高可预测性”特性作为语言的核心部分。

例如，在 F#中，除了列表中的一个项目外，所有项目都已内置到语言中：

1.  值不允许更改其类型。（甚至包括从 int 到 float 的隐式转换，比如说）。

1.  具有相同内部数据的记录默认是相等的。

1.  比较不同类型的值是编译时错误。

1.  值必须初始化为有效状态。不这样做是编译时错误。

1.  一旦创建，值默认是不可变的。

1.  一般情况下不允许空值。

编号#7 不受编译器强制执行，但通常使用区分联合（和类型）来返回错误，而不是使用异常，以便函数签名明确指示可能的错误。

事实上，当使用 F#时仍然存在许多注意事项。你*可以*有可变值，你*可以*创建并抛出异常，并且你确实可能不得不处理来自非 F#代码的空值。

但这些事情被认为是代码异味并且不寻常，而不是一般的默认设置。

其他语言如 Haskell 甚至比 F#更加纯粹（因此更加合理），但即使是 Haskell 程序也不会是完美的。

实际上，没有一种语言可以完美地进行推理并且仍然是实用的。但是，有些语言确实比其他语言更合理。

我认为许多人对函数式代码如此热衷（甚至称其为“简单”尽管它充满了[奇怪的符号](https://gist.github.com/folone/6089236)）的其中一个原因恰恰是这个：不可变性，缺乏副作用以及其他所有函数式原则共同作用，以强制执行这种合理性和可预测性，进而帮助减轻你的认知负担，让你只需专注于眼前的代码。

## Lambda 不是解决方案

现在应该清楚了，这个提出的改进列表与诸如 lambda 或聪明的函数库等语言增强无关。

换句话说，当我关注合理性时，**我不关心我的语言会让我做什么，我更关心的是我的语言不会让我做什么。** 我想要一种语言，可以阻止我犯愚蠢的错误。

换句话说，如果让我在允许空值的语言 A 和拥有高阶类型但仍容易允许对象为空的语言 B 之间选择，我会毫不犹豫地选择语言 A。

## 问题

让我看看我是否可以预先回答一些问题...

**问题：这些例子非常牵强！如果你小心编码并遵循良好的实践，你可以在没有这些功能的情况下编写安全的代码！**

是的，你可以。我并没有说你不能。但是这篇文章不是关于编写安全代码，而是关于*对代码进行推理*。有区别。

并不是说只要你小心就可以做什么。而是说如果你不小心会发生什么！

换句话说，你的*编程语言*（而不是你的编码指南、测试、IDE 或开发实践）是否为你的代码推理提供支持？

**问题：你在告诉我语言*应该*具有这些特性。这不是非常傲慢吗？**

请仔细阅读。我根本没有这么说。我*要*说的是：

+   *如果*你想要能够推理你的代码，*那么*如果你的语言支持我提到的功能，那将会更容易。

如果你并不重视对代码的推理，那么请随意忽略我所说的一切！

**问题：专注于编程语言的某个方面会太过狭隘。其他品质肯定也同样重要吧？**

是的，当然它们是。我在这个问题上不是绝对主义者。我认为全面的库、良好的工具、友好的社区以及生态系统的强大性等因素也非常重要。

但本文的目的是解决我在开头提到的特定评论，例如：“C#已经拥有了大部分 F#的功能，那么我为什么要费心去转换呢？”。

**问题：为什么你会这么快地排除动态语言？**

首先，我为 JavaScript 开发人员之前的调侃道歉！

我非常喜欢动态语言，我最喜欢的语言之一，Smalltalk，完全不符合我上面谈到的标准。幸运的是，本文并不试图说服你哪些语言在总体上是“最好的”，而只是讨论了这个选择的一个方面。

**问题：不可变数据结构很慢，并且会产生大量额外的分配。这不会影响性能吗？**

本文不试图解决这些特性（或其他任何方面）的性能影响。

但确实有一个有效的问题值得提出：代码质量和性能哪个应该更重要？这取决于你自己来决定，也取决于具体情境。

个人而言，我会优先考虑安全和质量，除非有充分的理由不这样做。以下是我喜欢的一则标志：

![按顺序排列的安全、质量、数量](img/safety_first.jpg)

## 摘要

我刚才说过，本文并不试图仅仅基于“合理性”来说服你选择一种语言。但这并不完全正确。

如果你已经选择了像 C#或 Java 这样的静态类型、高级语言，那么显然合理性或类似的因素是你语言选择中的重要标准之一。

在那种情况下，我希望本文中的示例能让你更愿意考虑在你选择的平台（.NET 或 JVM）上使用更“合理”的语言。

留在原地的论点是，你当前的语言最终会“赶上”——这在功能上可能是真的，但任何未来的增强都不能真正改变面向对象语言的核心设计决策。你永远无法摆脱空指针、可变性，或者一直要覆盖相等性。

F#、Scala/Clojure 之类的优点在于，这些函数式的替代方案不需要你改变你的生态系统，但它们立即提高了你的代码质量。

在我看来，与业务惯例的成本相比，这是一个非常低风险的选择。

*(我将把寻找熟练人才、培训、支持等问题留到另一篇文章。但如果你担心招聘问题，可以参考[这篇文章](http://www.paulgraham.com/pypar.html)，[这条推文](https://twitter.com/panesofglass/status/559431579328475136)，[这条推文](https://twitter.com/foxyjackfox/status/559415445594206208)，以及[这篇文章](http://wesmorgan.svbtle.com/recruiting-software-developers-language-matters)*

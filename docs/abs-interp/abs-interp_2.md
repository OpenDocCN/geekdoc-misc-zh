# 2  什么可以通过抽象解释来形式化？

在计算机科学中，抽象解释用于形式化涉及形式系统语义的[准确 [和完整]] 近似。下面列举了一些典型的应用示例，但并不穷尽。

### 2.1  语法

对语法的性质进行分析以及解析都是语法操作语义及其抽象（如解析树、原型语言或终端语言）的抽象解释[39]。

### 2.2  语义

程序的语义描述了它们在所有可能的执行环境中的可能运行时执行的层次。语义的层次结构，包括跟踪、小步、大步操作语义、关系语义、表示性语义、谓词变换器和天使、自然和恶魔版本的公理语义，都可以通过抽象解释来设计[32,19]。对于超限行为的扩展对于形式化例如*语义切片*[54]是有用的。

### 2.3  证明

程序正确性的形式证明涉及一种抽象，因为规范总是忽略了程序执行的某些方面，在证明中不需要考虑[18]。

### 2.4  静态分析

静态分析是抽象程序属性的自动确定[22,44,26,15]，包括*数据流分析*[67], [26,36], *基于集合的分析*[35]等。这是引入抽象解释理论的动机应用。

### 2.5  类型

静态类型和类型推断[97]可以被理解为运行时类型检查的抽象解释，因此提供了一种"通过构造实现正确"的设计方法[16,11]。

### 2.6  模型检查

*模型检查* 在硬件或软件计算机系统的有限模型上详尽验证时间属性[10]。 将系统抽象为模型的这种抽象通常被省略。 由抽象解释形式化的*抽象模型检查* 使这种抽象显式化[9]，[36]。模型检查被认为是在模型上终止，完备和完备的。 从抽象解释的角度来看，将系统与其模型相关联，它可能对模型是完备的，但对系统是不完备的（例如，模型对于安全属性是正确的，但对于活力属性是错误的），它经常是不完整的（没有有限模型可以覆盖系统的指定行为[100]）且在实践中可能会组合爆炸。 在所有情况下，系统对模型的抽象解释都必须被考虑。 所有转换模型都是抽象语义，但反之则不然。

### 2.7  谓词抽象

谓词抽象[61]可用于将*有限*抽象域上的任何静态分析减少为模型检查器执行的布尔不动点计算，使用定理证明器自动推导出固定点定义中涉及的抽象变换器。 参数化谓词抽象是对无限抽象域的扩展[20]。

### 2.8  基于反例的细化

在抽象模型检查中基于虚假反例的细化被形式化为抽象解释理论中的抽象域完成问题[56,43]。

### 2.9  强保持性

通过最小细化修改有限抽象模型检查问题，以获得某些规范语言的强保持性，包括分区细化算法，在抽象解释理论中是一个完成问题[101]。

### 2.10  程序转换

程序转换（如*部分求值*[72]）通常需要对源程序进行静态分析，由抽象解释形式化（例如[71]）。 此外，从源到目标程序的转换本身涉及对原始程序的信息丢失或可能的程序行为限制。 这种近似可以通过抽象解释形式化。 这在死代码消除，切片，部分求值或程序监视[38]中得到了示范。

### 2.11  水印

寻找不受混淆影响的程序水印，可以考虑对程序语义进行抽象解释[40]。

### 2.12  信息隐藏

在基于语言的软件安全领域，对入侵者隐藏的信息可以被形式化为程序语义的抽象解释[55]。

### 2.13  代码混淆

代码混淆的目的是防止恶意用户发现原始源程序的属性。这个目标可以通过抽象解释进行精确建模，其中属性的隐藏对应于抽象化语义[99]。

### 2.14  恶意软件检测

通过抽象解释识别执行效果，而不是通过语法签名[98]，更容易检测出混淆的恶意软件。

### 2.15  终止

基于关系抽象解释的静态分析在良好基础的抽象域上可以被系统地扩展到终止分析[3]（因此生存性分析）。终止分析可能需要对并行进程[78]进行概率假设[87]或公平性假设。

# LibTacticsA Collection of Handy General-Purpose Tactics

```

```

(* Chapter maintained by Arthur Chargueraud *)

```

    This file contains a set of tactics that extends the set of builtin
    tactics provided with the standard distribution of Coq. It intends
    to overcome a number of limitations of the standard set of tactics,
    and thereby to help user to write shorter and more robust scripts.

    Hopefully, Coq tactics will be improved as time goes by, and this
    file should ultimately be useless. In the meanwhile, serious Coq
    users will probably find it very useful.

    The present file contains the implementation and the detailed
    documentation of those tactics. The SF reader need not read this
    file; instead, he/she is encouraged to read the chapter named
    UseTactics.v, which is gentle introduction to the most useful
    tactics from the LibTactic library. 

    The main features offered are:

*   More convenient syntax for naming hypotheses, with tactics for introduction and inversion that take as input only the name of hypotheses of type Prop, rather than the name of all variables.

*   Tactics providing true support for manipulating N-ary conjunctions, disjunctions and existentials, hidding the fact that the underlying implementation is based on binary propositions.

*   Convenient support for automation: tactic followed with the symbol "~" or "*" will call automation on the generated subgoals. Symbol "~" stands for auto and "*" for intuition eauto. These bindings can be customized.

*   Forward-chaining tactics are provided to instantiate lemmas either with variable or hypotheses or a mix of both.

*   A more powerful implementation of apply is provided (it is based on refine and thus behaves better with respect to conversion).

*   An improved inversion tactic which substitutes equalities on variables generated by the standard inversion mecanism. Moreover, it supports the elimination of dependently-typed equalities (requires axiom K, which is a weak form of Proof Irrelevance).

*   Tactics for saving time when writing proofs, with tactics to asserts hypotheses or sub-goals, and improved tactics for clearing, renaming, and sorting hypotheses.

    External credits:

*   thanks to Xavier Leroy for providing the idea of tactic forward,

*   thanks to Georges Gonthier for the implementation trick in rapply,

```

(* DROP *)

Set Implicit Arguments.

Require Import List.

(* Very important to remove hint trans_eq_bool from LibBool,    otherwise eauto slows down dramatically:    Lemma test : forall b, b = false.    time eauto 7. (* takes over 4 seconds  to fail! *) *)

Remove Hints Bool.trans_eq_bool.

(* ********************************************************************** *)

```

# Tools for Programming with Ltac

```

(* ---------------------------------------------------------------------- *)

```

## Identity Continuation

```

Ltac idcont tt :=

idtac.

(* ---------------------------------------------------------------------- *)

```

## Untyped Arguments for Tactics

    Any Coq value can be boxed into the type Boxer. This is
    useful to use Coq computations for implementing tactics.

```

Inductive Boxer : Type :=

| boxer : ∀(A:Type), A → Boxer.

(* ---------------------------------------------------------------------- *)

```

## Optional Arguments for Tactics

    ltac_no_arg is a constant that can be used to simulate
    optional arguments in tactic definitions.
    Use mytactic ltac_no_arg on the tactic invokation,
    and use match arg with ltac_no_arg ⇒ .. or
    match type of arg with ltac_No_arg ⇒ .. to
    test whether an argument was provided.

```

Inductive ltac_No_arg : Set :=

| ltac_no_arg : ltac_No_arg.

(* ---------------------------------------------------------------------- *)

```

## Wildcard Arguments for Tactics

    ltac_wild is a constant that can be used to simulate
    wildcard arguments in tactic definitions. Notation is __.

```

Inductive ltac_Wild : Set :=

| ltac_wild : ltac_Wild.

Notation "'__'" := ltac_wild : ltac_scope.

```

    ltac_wilds is another constant that is typically used to
    simulate a sequence of N wildcards, with N chosen
    appropriately depending on the context. Notation is ___.

```

Inductive ltac_Wilds : Set :=

| ltac_wilds : ltac_Wilds.

Notation "'___'" := ltac_wilds : ltac_scope.

Open Scope ltac_scope.

(* ---------------------------------------------------------------------- *)

```

## Position Markers

    ltac_Mark and ltac_mark are dummy definitions used as sentinel
    by tactics, to mark a certain position in the context or in the goal.

```

Inductive ltac_Mark : Type :=

| ltac_mark : ltac_Mark.

```

    gen_until_mark repeats generalize on hypotheses from the
    context, starting from the bottom and stopping as soon as reaching
    an hypothesis of type Mark. If fails if Mark does not
    appear in the context.

```

Ltac gen_until_mark :=

match goal with H: ?T ⊢ _ ⇒

match T with

| ltac_Mark ⇒ clear H

| _ ⇒ generalize H; clear H; gen_until_mark

end end.

```

    intro_until_mark repeats intro until reaching an hypothesis of
    type Mark. It throws away the hypothesis Mark.
    It fails if Mark does not appear as an hypothesis in the
    goal.

```

Ltac intro_until_mark :=

match goal with

| ⊢ (ltac_Mark → _) ⇒ intros _

| _ ⇒ intro; intro_until_mark

end.

(* ---------------------------------------------------------------------- *)

```

## List of Arguments for Tactics

    A datatype of type list Boxer is used to manipulate list of
    Coq values in ltac. Notation is >> v[1] v[2] ... vN for building
    a list containing the values v[1] through vN.

```

Notation "'>>'" :=

(@nil Boxer)

(at level 0)

: ltac_scope.

Notation "'>>' v1" :=

((boxer v[1])::nil)

(at level 0, v[1] at level 0)

: ltac_scope.

Notation "'>>' v1 v2" :=

((boxer v[1])::(boxer v[2])::nil)

(at level 0, v[1] at level 0, v[2] at level 0)

: ltac_scope.

Notation "'>>' v1 v2 v3" :=

((boxer v[1])::(boxer v[2])::(boxer v[3])::nil)

(at level 0, v[1] at level 0, v[2] at level 0, v[3] at level 0)

: ltac_scope.

Notation "'>>' v1 v2 v3 v4" :=

((boxer v[1])::(boxer v[2])::(boxer v[3])::(boxer v[4])::nil)

(at level 0, v[1] at level 0, v[2] at level 0, v[3] at level 0,

v[4] at level 0)

: ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5" :=

((boxer v[1])::(boxer v[2])::(boxer v[3])::(boxer v[4])::(boxer v[5])::nil)

(at level 0, v[1] at level 0, v[2] at level 0, v[3] at level 0,

v[4] at level 0, v[5] at level 0)

: ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6" :=

((boxer v[1])::(boxer v[2])::(boxer v[3])::(boxer v[4])::(boxer v[5])

::(boxer v[6])::nil)

(at level 0, v[1] at level 0, v[2] at level 0, v[3] at level 0,

v[4] at level 0, v[5] at level 0, v[6] at level 0)

: ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7" :=

((boxer v[1])::(boxer v[2])::(boxer v[3])::(boxer v[4])::(boxer v[5])

::(boxer v[6])::(boxer v[7])::nil)

(at level 0, v[1] at level 0, v[2] at level 0, v[3] at level 0,

v[4] at level 0, v[5] at level 0, v[6] at level 0, v[7] at level 0)

: ltac_scope.

符号 "'>>' v1 v2 v3 v4 v5 v6 v7 v8" :=

((拳击手 v[1])::(拳击手 v[2])::(拳击手 v[3])::(拳击手 v[4])::(拳击手 v[5])

::(拳击手 v[6])::(拳击手 v[7])::(拳击手 v[8])::nil)

(在 0 级, v[1] 在 0 级, v[2] 在 0 级, v[3] 在 0 级,

v[4] 在 0 级, v[5] 在 0 级, v[6] 在 0 级, v[7] 在 0 级,

v[8] 在 0 级)

: ltac_scope.

符号 "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9" :=

((拳击手 v[1])::(拳击手 v[2])::(拳击手 v[3])::(拳击手 v[4])::(拳击手 v[5])

::(拳击手 v[6])::(拳击手 v[7])::(拳击手 v[8])::(拳击手 v[9])::nil)

(在 0 级, v[1] 在 0 级, v[2] 在 0 级, v[3] 在 0 级,

v[4] 在 0 级, v[5] 在 0 级, v[6] 在 0 级, v[7] 在 0 级,

v[8] 在 0 级, v[9] 在 0 级)

: ltac_scope.

符号 "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10" :=

((拳击手 v[1])::(拳击手 v[2])::(拳击手 v[3])::(拳击手 v[4])::(拳击手 v[5])

::(拳击手 v[6])::(拳击手 v[7])::(拳击手 v[8])::(拳击手 v[9])::(拳击手 v[10])::nil)

(在 0 级, v[1] 在 0 级, v[2] 在 0 级, v[3] 在 0 级,

v[4] 在 0 级, v[5] 在 0 级, v[6] 在 0 级, v[7] 在 0 级,

v[8] 在 0 级, v[9] 在 0 级, v[10] 在 0 级)

: ltac_scope.

符号 "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11" :=

((拳击手 v[1])::(拳击手 v[2])::(拳击手 v[3])::(拳击手 v[4])::(拳击手 v[5])

::(拳击手 v[6])::(拳击手 v[7])::(拳击手 v[8])::(拳击手 v[9])::(拳击手 v[10])

::(拳击手 v[11])::nil)

(在 0 级, v[1] 在 0 级, v[2] 在 0 级, v[3] 在 0 级,

v[4] 在 0 级, v[5] 在 0 级, v[6] 在 0 级, v[7] 在 0 级,

v[8] 在 0 级, v[9] 在 0 级, v[10] 在 0 级, v[11] 在 0 级)

: ltac_scope.

符号 "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12" :=

((拳击手 v[1])::(拳击手 v[2])::(拳击手 v[3])::(拳击手 v[4])::(拳击手 v[5])

::(拳击手 v[6])::(拳击手 v[7])::(拳击手 v[8])::(拳击手 v[9])::(拳击手 v[10])

::(拳击手 v[11])::(拳击手 v[12])::nil)

(在 0 级, v[1] 在 0 级, v[2] 在 0 级, v[3] 在 0 级,

v[4] 在 0 级, v[5] 在 0 级, v[6] 在 0 级, v[7] 在 0 级,

v[8] 在 0 级, v[9] 在 0 级, v[10] 在 0 级, v[11] 在 0 级,

v[12] 在 0 级)

: ltac_scope.

符号 "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13" :=

((拳击手 v[1])::(拳击手 v[2])::(拳击手 v[3])::(拳击手 v[4])::(拳击手 v[5])

::(拳击手 v[6])::(拳击手 v[7])::(拳击手 v[8])::(拳击手 v[9])::(拳��手 v[10])

::(拳击手 v[11])::(拳击手 v[12])::(拳击手 v[13])::nil)

(在 0 级, v[1] 在 0 级, v[2] 在 0 级, v[3] 在 0 级,

v[4] 在 0 级, v[5] 在 0 级, v[6] 在 0 级, v[7] 在 0 级,

v[8] 在 0 级, v[9] 在 0 级, v[10] 在 0 级, v[11] 在 0 级,

v[12] 在 0 级, v[13] 在 0 级)

: ltac_scope.

```

    The tactic list_boxer_of inputs a term E and returns a term
    of type "list boxer", according to the following rules:

*   if E is already of type "list Boxer", then it returns E;

*   otherwise, it returns the list (boxer E)::nil.

```

Ltac list_boxer_of E :=

匹配 E 的类型

| List.list 拳击手 ⇒ 构造:(E)

| _ ⇒ 构造:((拳击手 E)::nil)

end.

(* ---------------------------------------------------------------------- *)

```

## Databases of Lemmas

    Use the hint facility to implement a database mapping
    terms to terms. To declare a new database, use a definition:
    Definition mydatabase := True. 

    Then, to map mykey to myvalue, write the hint:
    Hint Extern 1 (Register mydatabase mykey) ⇒ Provide myvalue. 

    Finally, to query the value associated with a key, run the
    tactic ltac_database_get mydatabase mykey. This will leave
    at the head of the goal the term myvalue. It can then be
    named and exploited using intro.

```

归纳 Ltac_database_token : 命题 := ltac_database_token.

定义 ltac_database (D:拳击手) (T:拳击手) (A:拳击手) := Ltac_database_token.

符号 "'Register' D T" := (ltac_database (拳击手 D) (拳击手 T) _)

(在 69 级, D 在 0 级, T 在 0 级).

引理 ltac_database_provide : ∀(A:拳击手) (D:拳击手) (T:拳击手),

ltac_database D T A.

Proof using. 分割. 完成.

Ltac 提供 T := 应用 (@ltac_database_provide (boxer T)).

Ltac ltac_database_get D T :=

让 A := fresh "TEMP" 在 evar (A:Boxer);

让 H := fresh "TEMP" 在

断言 (H : ltac_database (boxer D) (boxer T) A);

[ subst A; 自动

| subst A; 匹配 H 的类型为 ltac_database _ _ (boxer ?L) ⇒

推广 L 结束; 清除 H ].

(* 对于 ltac_database_token 的可能替代实现的注意事项：    Inductive Ltac_database : Type :=      | ltac_database : forall A, A -> Ltac_database.    Implicit Arguments ltac_database A. *)

(* ---------------------------------------------------------------------- *)

```

## On-the-Fly Removal of Hypotheses

    In a list of arguments >> H[1] H[2] .. HN passed to a tactic
    such as lets or applys or forwards or specializes,
    the term rm, an identity function, can be placed in front
    of the name of an hypothesis to be deleted.

```

定义 rm (A:Type) (X:A) := X.

```

    rm_term E removes one hypothesis that admits the same
    type as E.

```

Ltac rm_term E :=

让 T := E 的类型

匹配目标为 H: T ⊢ _ ⇒ 尝试清除 H

```

    rm_inside E calls rm_term Ei for any subterm
    of the form rm Ei found in E

```

Ltac rm_inside E :=

让 go E := rm_inside E

match E with

| rm ?X ⇒ rm_term X

| ?X[1] ?X[2] ⇒

go X[1]; go X[2]

| ?X[1] ?X[2] ?X[3] ⇒

go X[1]; go X[2]; go X[3]

| ?X[1] ?X[2] ?X[3] ?X[4] ⇒

go X[1]; go X[2]; go X[3]; go X[4]

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ⇒

go X[1]; go X[2]; go X[3]; go X[4]; go X[5]

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X[6] ⇒

go X[1]; go X[2]; go X[3]; go X[4]; go X[5]; go X[6]

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X[6] ?X[7] ⇒

go X[1]; go X[2]; go X[3]; go X[4]; go X[5]; go X[6]; go X[7]

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X[6] ?X[7] ?X[8] ⇒

go X[1]; go X[2]; go X[3]; go X[4]; go X[5]; go X[6]; go X[7]; go X[8]

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X[6] ?X[7] ?X[8] ?X[9] ⇒

go X[1]; go X[2]; go X[3]; go X[4]; go X[5]; go X[6]; go X[7]; go X[8]; go X[9]

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X[6] ?X[7] ?X[8] ?X[9] ?X[10] ⇒

go X[1]; go X[2]; go X[3]; go X[4]; go X[5]; go X[6]; go X[7]; go X[8]; go X[9]; go X[10]

| _ ⇒ idtac

end.

```

    For faster performance, one may deactivate rm_inside by
    replacing the body of this definition with idtac.

```

Ltac fast_rm_inside E :=

rm_inside E.

(* ---------------------------------------------------------------------- *)

```

## Numbers as Arguments

    When tactic takes a natural number as argument, it may be
    parsed either as a natural number or as a relative number.
    In order for tactics to convert their arguments into natural numbers,
    we provide a conversion tactic.

```

(* COQ-8.4:    Require Coq.Numbers.BinNums Coq.ZArith.BinInt. *)

Require BinPos Coq.ZArith.BinInt.

定义 ltac_nat_from_int (x:BinInt.Z) : nat :=

匹配 x 为

| BinInt.Z0 ⇒ 0%nat

| BinInt.Zpos p ⇒ BinPos.nat_of_P p

| BinInt.Zneg p ⇒ 0%nat

end.

Ltac nat_from_number N :=

匹配 N 的类型为

| nat ⇒ 让 N

| BinInt.Z ⇒ 让 N' := constr:(ltac_nat_from_int N) 在 N' 中计算

end.

```

    ltac_pattern E at K is the same as pattern E at K except that
    K is a Coq natural rather than a Ltac integer. Syntax
    ltac_pattern E as K in H is also available.

```

Tactic Notation "ltac_pattern" constr(E) "at" constr(K) :=

匹配 nat_from_number K 为

| 1 ⇒ 在位置 1 处的模式 E

| 2 ⇒ 在位置 2 处的模式 E

| 3 ⇒ 在位置 3 处的模式 E

| 4 ⇒ 在位置 4 处的模式 E

| 5 ⇒ 在位置 5 处的模式 E

| 6 ⇒ 在位置 6 处的模式 E

| 7 ⇒ 在位置 7 处的模式 E

| 8 ⇒ 在位置 8 处的模式 E

end.

Tactic Notation "ltac_pattern" constr(E) "at" constr(K) "in" hyp(H) :=

匹配 nat_from_number K 为

| 1 ⇒ 在 H 中的位置 1 处的模式 E

| 2 ⇒ 在 H 中的位置 2 处的模式 E

| 3 ⇒ 在 H 中的位置 3 处的模式 E

| 4 ⇒ 在 H 中的位置 4 处的模式 E

| 5 ⇒ 在 H 中的位置 5 处的模式 E

| 6 ⇒ 在 H 中的位置 6 处的模式 E

| 7 ⇒ 在 H 中的位置 7 处的模式 E

| 8 ⇒ 在 H 中的位置 8 处的模式 E

end.

(* ---------------------------------------------------------------------- *)

```

## Testing Tactics

    show tac executes a tactic tac that produces a result,
    and then display its result.

```

Tactic Notation "show" tactic(tac) :=

让 R := tac 在 R 中 pose.

```

    dup N produces N copies of the current goal. It is useful
    for building examples on which to illustrate behaviour of tactics.
    dup is short for dup 2.

```

引理 dup_lemma : ∀P, P → P → P.

Proof using. 自动. 完成.

Ltac dup_tactic N :=

匹配 nat_from_number N 与之；

| 0 ⇒ idtac

| S 0 ⇒ idtac

| S ?N' ⇒ 应用 dup_lemma; [ | dup_tactic N' ]

end。

策略 Notation "dup" constr(N) :=

复制策略 N.

策略 Notation "dup" :=

复制 2.

(* ---------------------------------------------------------------------- *)

```

## Check No Evar in Goal

```

(* COQ8.4: Ltac check_noevar M :=   match M with M => idtac end. Ltac check_noevar_hyp H := (* todo: imlement using check_noevar *)   let T := type of H in   match type of H with T => idtac end. Ltac check_noevar_goal := (* todo: imlement using check_noevar *)   match goal with |- ?G => match G with G => idtac end end. *)

Ltac 检查无自由变量 M :=

首先 [ has_evar M; fail 2 | idtac ]。

Ltac 检查无自由变量假设 H := (* todo: imlement using check_noevar *)

让 T := H 的类型 in check_noevar T。

Ltac 检查无自由变量目标 := (* todo: imlement using check_noevar *)

匹配目标为 ⊢ ?G ⇒ check_noevar G end.

(* ---------------------------------------------------------------------- *)

```

## Helper Function for Introducing Evars

    with_evar T (fun M ⇒ tac) creates a new evar that can
    be used in the tactic tac under the name M.

```

Ltac with_evar_base T cont：

让 x := 新鲜的 in evar (x:T); cont x; subst x.

策略 Notation "with_evar" constr(T) tactic(cont) :=

用 _evar_base T cont。

(* ---------------------------------------------------------------------- *)

```

## Tagging of Hypotheses

    get_last_hyp tt is a function that returns the last hypothesis
    at the bottom of the context. It is useful to obtain the default
    name associated with the hypothesis, e.g.
    intro; let H := get_last_hyp tt in let H' := fresh "P" H in ...

```

Ltac 获取最后的假设 tt :=

匹配目标为 H: _ ⊢ _ ⇒ constr:(H) end.

(* ---------------------------------------------------------------------- *)

```

## More Tagging of Hypotheses

    ltac_tag_subst is a specific marker for hypotheses
    which is used to tag hypotheses that are equalities to
    be substituted.

```

定义 ltac_tag_subst (A:Type) (x:A) := x。

```

    ltac_to_generalize is a specific marker for hypotheses
    to be generalized.

```

定义 ltac_to_generalize (A:Type) (x:A) := x.

Ltac gen_to_generalize :=

重复 匹配目标为

H: ltac_to_generalize _ ⊢ _ ⇒ generalize H; clear H end.

Ltac 标记为通用化 H :=

让 T := H 的类型 in

在 H 中用 T 替换为 (ltac_to_generalize T)。

(* ---------------------------------------------------------------------- *)

```

## Deconstructing Terms

    get_head E is a tactic that returns the head constant of the
    term E, ie, when applied to a term of the form P x[1] ... xN
    it returns P. If E is not an application, it returns E.
    Warning: the tactic seems to loop in some cases when the goal is
    a product and one uses the result of this function.

```

Ltac 获取头部 E :=

匹配 E 与之；

| ?P _ _ _ _ _ _ _ _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ _ _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ _ _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ _ ⇒ constr:(P)

| ?P _ _ _ ⇒ constr:(P)

| ?P _ _ ⇒ constr:(P)

| ?P _ ⇒ constr:(P)

| ?P ⇒ constr:(P)

end。

```

    get_fun_arg E is a tactic that decomposes an application
  term E, ie, when applied to a term of the form X[1] ... XN
  it returns a pair made of X[1] .. X(N-1) and XN.

```

Ltac 获取函数参数 E :=

匹配 E 与之；

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X[6] ?X[7] ?X ⇒ constr:((X[1] X[2] X[3] X[4] X[5] X[6],X))

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X[6] ?X ⇒ constr:((X[1] X[2] X[3] X[4] X[5],X))

| ?X[1] ?X[2] ?X[3] ?X[4] ?X[5] ?X ⇒ constr:((X[1] X[2] X[3] X[4],X))

| ?X[1] ?X[2] ?X[3] ?X[4] ?X ⇒ constr:((X[1] X[2] X[3],X))

| ?X[1] ?X[2] ?X[3] ?X ⇒ constr:((X[1] X[2],X))

| ?X[1] ?X[2] ?X ⇒ constr:((X[1],X))

| ?X[1] ?X ⇒ constr:((X[1],X))

end。

(* ---------------------------------------------------------------------- *)

```

## Action at Occurence and Action Not at Occurence

    ltac_action_at K of E do Tac isolates the K-th occurence of E in the
    goal, setting it in the form P E for some named pattern P,
    then calls tactic Tac, and finally unfolds P. Syntax
    ltac_action_at K of E in H do Tac is also available.

```

策略 Notation "ltac_action_at" constr(K) "of" constr(E) "do" tactic(Tac) :=

让 p := 新鲜的 in ltac_pattern E at K;

匹配目标为 ⊢ ?P _ ⇒ set (p:=P) end;

Tac; 展开 p; 清除 p。

策略 Notation "ltac_action_at" constr(K) "of" constr(E) "in" hyp(H) "do" tactic(Tac) :=

让 p := 新鲜的 in ltac_pattern E at K in H;

refine (@t)

| lets_base H (E _ _ _ _ _ _ H')

```

    protects E do Tac temporarily assigns a name to the expression E
    so that the execution of tactic Tac will not modify E. This is
    useful for instance to restrict the action of simpl.

```

| ⊢ _ ∧ _ ⇒ split

match T with

[ eexact (@t)

Ltac jauto_set :=

| lets_base H (E _ _ H')

end

intros; jauto_set_hyps;

first  (* todo: les @ sont inutiles *)

```

## An Alias for eq

    eq' is an alias for eq to be used for equalities in
    inductive definitions, so that they don't get mixed with
    equalities generated by inversion.

```

let H' := fresh in rename H into H';

Tac; unfold p in H; clear p.

Notation "x '='' y" := (@eq' _ x y)

Tactic Notation "rapply_9" constr(t) :=

(* ********************************************************************** *)

```

# Common Tactics for Simplifying Goals Like intuition

```

Tactic Notation "rapply_6" constr(t) :=

(* ---------------------------------------------------------------------- *)

Tactic Notation "rapply_7" constr(t) :=

let x := fresh "TEMP" in let H := fresh "TEMP" in

| ∃a, _ ⇒ destruct H

| refine (@t)

| lets_base H (E _ _ _ _ _ _ _ _ _ H') ]

Tactic Notation "rapply_8" constr(t) :=

Ltac jauto_set_goal :=

| refine (@t)

refine (@t).

(* ********************************************************************** *)

| refine (@t)

| refine (@t)

Tactic Notation "protects" constr(E) "do" tactic(Tac) "/" :=

refine (@t)

Tactic Notation "rapply_1" constr(t) :=

repeat match goal with H: ?T ⊢ _ ⇒

```

# Backward and Forward Chaining

```

| lets_base H (E _ _ _ H')

```

## Application

```

Ltac lets_base I E := generalize E; intros I.

(* let x := fresh "TEMP" in sets_eq x: E; T; subst x. *)

```

    rapply is a tactic similar to eapply except that it is
    based on the refine tactics, and thus is strictly more
    powerful (at least in theory :). In short, it is able to perform
    on-the-fly conversions when required for arguments to match,
    and it is able to instantiate existentials when required.

```

Tactic Notation "rapply" constr(t) :=

Tactic Notation "rapply_2" constr(t) :=

Tactic Notation "rapply_0" constr(t) :=

| refine (@t)

| refine (@t)

(* ---------------------------------------------------------------------- *)

| refine (@t)

| lets_base H (E _ _ _ _ H')

| refine (@t)

Tactic Notation "rapply_3" constr(t) :=

| refine (@t)

refine (@t)

(at level 70, y at next level).

Tactic Notation "protects" constr(E) "do" tactic(Tac) :=

| refine (@t)

| refine (@t)

| refine (@t)

end.

| refine (@t)

| refine (@t)

```

    The tactics applys_N T, where N is a natural number,
    provides a more efficient way of using applys T. It avoids
    trying out all possible arities, by specifying explicitely
    the arity of function T.

```

| refine (@t)

refine (@t).

| lets_base H (E _ _ _ _ _ _ _ _ H')

| refine (@t)

| _ ∧ _ ⇒ destruct H

repeat match goal with

Ltac old_refine f :=

set (X := E) in *; assert (H : X = E) by reflexivity;

Tactic Notation "rapply_4" constr(t) :=

refine f. (* ; shelve_unifiable. *)

| lets_base H (E _ H')

refine (@t)

| ⊢ ∃a, _ ⇒ esplit

refine (@t)

Tactic Notation "rapply_5" constr(t) :=

refine (@t).

(first [ lets_base H (E H')

refine (@t)

Ltac jauto_set_hyps :=

refine (@t).

Tactic Notation "rapply_10" constr(t) :=

unfold not in *.

```

    lets_base H E adds an hypothesis H : T to the context, where T is
    the type of term E. If H is an introduction pattern, it will
    destruct H according to the pattern.

```

refine (@t)

```

    applys_to H E transform the type of hypothesis H by
    replacing it by the result of the application of the term
    E to H. Intuitively, it is equivalent to lets H: (E H).

```

Tactic Notation "applys_to" hyp(H) constr(E) :=

Hint Unfold eq'.

Definition eq' := @eq.

protects E do Tac.

intros; jauto_set_goal;

match type of H with ?P _ ⇒ set (p:=P) in H end;

refine (@t)

| lets_base H (E _ _ _ _ _ H')

].

| lets_base H (E _ _ _ _ _ _ _ H')

end.

clearbody X; Tac; subst x.

); clear H'.

```

    applys_to H[1],...,HN E applys E to several hypotheses

```

Tactic Notation "applys_to" hyp(H[1]) "," hyp(H[2]) constr(E) :=

applys_to H[1] E; applys_to H[2] E。

策略符号“applys_to” hyp(H[1])，“hyp(H[2])”，hyp(H[3]) constr(E) :=

applys_to H[1] E; applys_to H[2] E; applys_to H[3] E。

策略符号“applys_to” hyp(H[1])，“hyp(H[2])”，“hyp(H[3])”，“hyp(H[4])” constr(E) :=

applys_to H[1] E; applys_to H[2] E; applys_to H[3] E; applys_to H[4] E。

```

    constructors calls constructor or econstructor.

```

策略符号“constructors” :=

first [ constructor | econstructor ]; unfold eq'。

(* ---------------------------------------------------------------------- *)

```

## Assertions

    asserts H: T is another syntax for assert (H : T), which
    also works with introduction patterns. For instance, one can write:
    asserts \[x P\] (∃ n, n = 3), or
    asserts \[H|H\] (n = 0 ∨ n = 1).  

```

策略符号“asserts” simple_intropattern(I)：“constr(T) :=

let H := fresh in assert (H : T);

[ | generalize H; clear H; intros I ]。

```

    asserts H[1] .. HN: T is a shorthand for
    asserts \[H[1] \[H[2] \[.. HN\]\]\]\: T].

```

策略符号“asserts” simple_intropattern(I[1])

simple_intropattern(I[2])：“constr(T) :=

断言[I[1] I[2]]：T。

策略符号“asserts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])：“constr(T) :=

断言[I[1] [I[2] I[3]]]：T。

策略符号“asserts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4])：“constr(T) :=

断言[I[1] [I[2] [I[3] I[4]]]：T。

策略符号“asserts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4]) simple_intropattern(I[5])：“constr(T) :=

asserts [I[1] [I[2] [I[3] [I[4] I[5]]]]：T。

策略符号“asserts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6])：“constr(T) :=

断言[I[1] [I[2] [I[3] [I[4] [I[5] I[6]]]]]：T。

```

    asserts: T is asserts H: T with H being chosen automatically.

```

策略符号“asserts”：“constr(T) :=

let H := fresh in asserts H : T。

```

    cuts H: T is the same as asserts H: T except that the two subgoals
    generated are swapped: the subgoal T comes second. Note that contrary
    to cut, it introduces the hypothesis.

```

策略符号“cuts” simple_intropattern(I)：“constr(T) :=

cut (T); [ intros I | idtac ]。

```

    cuts: T is cuts H: T with H being chosen automatically.

```

策略符号“cuts”：“constr(T) :=

let H := fresh in cuts H: T。

```

    cuts H[1] .. HN: T is a shorthand for
    cuts \[H[1] \[H[2] \[.. HN\]\]\]\: T].

```

策略符号“cuts” simple_intropattern(I[1])

simple_intropattern(I[2])：“constr(T) :=

cuts [I[1] I[2]]：T。

策略符号“cuts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])：“constr(T) :=

cuts [I[1] [I[2] I[3]]]：T。

策略符号“cuts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4])：“constr(T) :=

cuts [I[1] [I[2] [I[3] I[4]]]：T。

策略符号“cuts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4]) simple_intropattern(I[5])：“constr(T) :=

cuts [I[1] [I[2] [I[3] [I[4] I[5]]]]：T。

策略符号“cuts” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6])：“constr(T) :=

cuts [I[1] [I[2] [I[3] [I[4] [I[5] I[6]]]]]：T。

(* ---------------------------------------------------------------------- *)

```

## Instantiation and Forward-Chaining

    The instantiation tactics are used to instantiate a lemma E
    (whose type is a product) on some arguments. The type of E is
    made of implications and universal quantifications, e.g.
    ∀ x, P x → ∀ y z, Q x y z → R z.

    The first possibility is to provide arguments in order: first x,
    then a proof of P x, then y etc... In this mode, called "Args",
    all the arguments are to be provided. If a wildcard is provided
    (written __), then an existential variable will be introduced in
    place of the argument.

    It is very convenient to give some arguments the lemma should be
    instantiated on, and let the tactic find out automatically where
    underscores should be insterted. Underscore arguments __ are
    interpret as follows: an underscore means that we want to skip the
    argument that has the same type as the next real argument provided
    (real means not an underscore). If there is no real argument after
    underscore, then the underscore is used for the first possible argument.

    The general syntax is tactic (>> E[1] .. EN) where tactic is
    the name of the tactic (possibly with some arguments) and Ei
    are the arguments. Moreover, some tactics accept the syntax
    tactic E[1] .. EN as short for tactic (>> E[1] .. EN) for
    values of N up to 5.

    Finally, if the argument EN given is a triple-underscore ___,
    then it is equivalent to providing a list of wildcards, with
    the appropriate number of wildcards. This means that all
    the remaining arguments of the lemma will be instantiated. 
    Definitions in the conclusion are not unfolded in this case.

```

(* Underlying implementation *)

Ltac app_assert t P cont :=

let H := fresh "TEMP" in

assert (H : P); [ | cont(t H); clear H ]。

Ltac app_evar t A cont :=

let x := fresh "TEMP" in

evar (x:A);

let t' := constr:(t x) in

让 t'' := (eval unfold x in t') in

替换 x; cont t''.

Ltac app_arg t P v cont :=

让 H := fresh "TEMP" in

断言 (H : P); [ 应用 v | cont(t H); 尝试清除 H ].

Ltac build_app_alls t final :=

让 rec go t :=

匹配 t 的类型与

| ?P → ?Q ⇒ app_assert t P go

| ∀_:?A, _ ⇒ app_evar t A go

| _ ⇒ final t

end in

进行 t.

Ltac boxerlist_next_type vs :=

匹配 vs 与

| 空 ⇒ 构造:(ltac_wild)

| (拳击手 ltac_wild)::?vs' ⇒ boxerlist_next_type vs'

| (拳击手 ltac_wilds)::_ ⇒ 构造:(ltac_wild)

| (@拳击手 ?T _)::_ ⇒ 构造:(T)

end.

(* 注意：拒绝用命题实例化依赖假设； 拒绝用类型为 Type 的参数实例化一个不具有类型 Type 的参数。 *)

Ltac build_app_hnts t vs final :=

让 rec go t vs :=

匹配 vs 与

| 空 ⇒ 首先 [ final t | fail 1 ]

| (拳击手 ltac_wilds)::_ ⇒ 首先 [ build_app_alls t final | fail 1 ]

| (拳击手 ?v)::?vs' ⇒

让 cont t' := go t' vs in

让 cont' t' := go t' vs' in

让 T := t 的类型 in

让 T := eval hnf in T in

匹配 v 与

| ltac_wild ⇒

首先 [ 让 U := boxerlist_next_type vs' in

匹配 U 与

| ltac_wild ⇒

匹配 T 与

| ?P → ?Q ⇒ 首先 [ app_assert t P cont' | fail 3 ]

| ∀_:?A, _ ⇒ 首先 [ app_evar t A cont' | fail 3 ]

end

| _ ⇒

匹配 T 与  (* 应该 测试 T 是否 可统一 *)

| U → ?Q ⇒ 首先 [ app_assert t U cont' | fail 3 ]

| ∀_:U, _ ⇒ 首先 [ app_evar t U cont' | fail 3 ]

| ?P → ?Q ⇒ 首先 [ app_assert t P cont | fail 3 ]

| ∀_:?A, _ ⇒ 首先 [ app_evar t A cont | fail 3 ]

end

end

| fail 2 ]

| _ ⇒

匹配 T 与

| ?P → ?Q ⇒ 首先 [ app_arg t P v cont'

| app_assert t P cont

| fail 3 ]

| ∀_:Type, _ ⇒

匹配 v 的类型与

| 类型 ⇒ 首先 [ cont' (t v)

| app_evar t 类型 cont

| fail 3 ]

| _ ⇒ 首先 [ app_evar t 类型 cont

| fail 3 ]

end

| ∀_:?A, _ ⇒

让 V := v 的类型 in

匹配 V 的类型与

| 命题 ⇒  首先 [ app_evar t A cont

| fail 3 ]

| _ ⇒ 首先 [ cont' (t v)

| app_evar t A cont

| fail 3 ]

end

end

end

end in

go t vs.

```

    newer version : support for typeclasses

```

Ltac app_typeclass t cont :=

让 t' := 构造:(t _) in

cont t'.

Ltac build_app_alls t final ::=

让 rec go t :=

匹配 t 的类型与

| ?P → ?Q ⇒ app_assert t P go

| ∀_:?A, _ ⇒

首先 [ app_evar t A go

| app_typeclass t go

| fail 3 ]

| _ ⇒ final t

end in

go t.

Ltac build_app_hnts t vs final ::=

让 rec go t vs :=

匹配 vs 与

| 空 ⇒ 首先 [ final t | fail 1 ]

| (拳击手 ltac_wilds)::_ ⇒ 首先 [ build_app_alls t final | fail 1 ]

| (拳击手 ?v)::?vs' ⇒

让 cont t' := go t' vs in

让 cont' t' := go t' vs' in

让 T := t 的类型 in

让 T := eval hnf in T in

匹配 v 与

| ltac_wild ⇒

首先 [ 让 U := boxerlist_next_type vs' in

匹配 U 与

| ltac_wild ⇒

匹配 T 与

| ?P → ?Q ⇒ 首先 [ app_assert t P cont' | fail 3 ]

| ∀_:?A, _ ⇒ 首先 [ app_typeclass t cont'

| app_evar t A cont'

| fail 3 ]

end

| _ ⇒

匹配 T 与  (* 应该 测试 T 是否 可统一 *)

| U → ?Q ⇒ 首先 [ app_assert t U cont' | fail 3 ]

| ∀_:U, _ ⇒ 首先

[ app_typeclass t cont'

| app_evar t U cont'

| fail 3 ]

| ?P → ?Q ⇒ 首先 [ app_assert t P cont | fail 3 ]

| ∀_:?A, _ ⇒ 首先

[ app_typeclass t cont

| app_evar t A cont

| 失败 3 ]

end

end

| 失败 2 ]

| _ ⇒

匹配 T with

| ?P → ?Q ⇒ first [ app_arg t P v cont'

| app_assert t P cont

| 失败 3 ]

| ∀_:Type, _ ⇒

匹配 v 的类型 with

| Type ⇒ first [ cont' (t v)

| app_evar t Type cont

| 失败 3 ]

| _ ⇒ first [ app_evar t Type cont

| 失败 3 ]

end

| ∀_:?A, _ ⇒

让 V := v 的类型 in

匹配 V 的类型 with

| Prop ⇒ first [ app_typeclass t cont

| app_evar t A cont

| 失败 3 ]

| _ ⇒ first [ cont' (t v)

| app_typeclass t cont

| app_evar t A cont

| 失败 3 ]

end

end

end

end in

go t vs。

(* todo: use local function for first ... *)

(*--old version Ltac build_app_hnts t vs final :=   let rec go t vs :=     match vs with     | nil => first  final t | 失败 1 | (boxer ltac_wilds)::_ => first  build_app_alls t final | 失败 1 | (boxer ?v)::?vs' =>       let cont t' := go t' vs in       let cont' t' := go t' vs' in       let T := t 的类型 in       let T := eval hnf in T in       match v with       | ltac_wild =>          first  let U := boxerlist_next_type vs' in match U with | ltac_wild ⇒ match T with | ?P → ?Q ⇒ first [ app_assert t P cont' | 失败 3 ] | ∀ _:?A, _ ⇒ first [ app_evar t A cont' | 失败 3 ] end | _ ⇒ match T with  should test T for unifiability *)             | U → ?Q ⇒ first [ app_assert t U cont' | 失败 3 ]

            | ∀ _:U, _ ⇒ first [ app_evar t U cont' | 失败 3 ]

            | ?P → ?Q ⇒ first [ app_assert t P cont | 失败 3 ]

            | ∀ _:?A, _ ⇒ first [ app_evar t A cont | 失败 3 ]

            end

        end

        | 失败 2 | _ =>

匹配 T with

| ?P -> ?Q => first  app_arg t P v cont'

                            | app_assert t P cont

                            | 失败 3 | forall _:?A, _ => first  cont' (t v)

                                    | app_evar t A cont

                                    | 失败 3 end

end

end in

go t vs。

*)

Ltac build_app args final :=

first 

匹配 args with (@[boxer ?T ?t)::?vs ⇒

让 t := 构造:(t:T) in

build_app_hnts t vs final;

fast_rm_inside args

end

| 失败 1 "实例化失败:" args]。

Ltac unfold_head_until_product T :=

eval hnf in T。

Ltac args_unfold_head_if_not_product args :=

匹配 args with (@boxer ?T ?t)::?vs ⇒

让 T' := unfold_head_until_product T in

constr:((@boxer T' t)::vs)

end.

Ltac args_unfold_head_if_not_product_but_params args :=

匹配 args with

| (boxer ?t)::(boxer ?v)::?vs ⇒

args_unfold_head_if_not_product args

| _ ⇒ 构造:(args)

end.

```

    lets H: (>> E[0] E[1] .. EN) will instantiate lemma E[0]
    on the arguments Ei (which may be wildcards __),
    and name H the resulting term. H may be an introduction
    pattern, or a sequence of introduction patterns I[1] I[2] IN,
    or empty.
    Syntax lets H: E[0] E[1] .. EN is also available. If the last
    argument EN is ___ (triple-underscore), then all
    arguments of H will be instantiated.

```

Ltac lets_build I Ei :=

让 args := list_boxer_of Ei in

让 args := args_unfold_head_if_not_product_but_params args in

(*    让 Ei''' := args_unfold_head_if_not_product Ei'' in*)

build_app args ltac:(fun R ⇒ lets_base I R)。

策略 符号 "lets" simple_intropattern(I) ":" constr(E) :=

lets_build I E。

策略 符号 "lets" ":" constr(E) :=

让 H := 新鲜 in lets H: E。

策略 符号 "lets" ":" constr(E[0])

constr(A[1]) :=

lets: (>> E[0] A[1])。

策略 符号 "lets" ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

lets: (>> E[0] A[1] A[2])。

策略 符号 "lets" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

lets: (>> E[0] A[1] A[2] A[3])。

Tactic Notation "lets" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

lets: (>> E[0] A[1] A[2] A[3] A[4]).

Tactic Notation "lets" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

lets: (>> E[0] A[1] A[2] A[3] A[4] A[5]).

(* --todo: deprecated, do not use *)

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2])

":" constr(E) :=

lets [I[1] I[2]]: E.

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) ":" constr(E) :=

lets [I[1] [I[2] I[3]]]: E.

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) ":" constr(E) :=

lets [I[1] [I[2] [I[3] I[4]]]]: E.

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5])

":" constr(E) :=

lets [I[1] [I[2] [I[3] [I[4] I[5]]]]]: E.

Tactic Notation "lets" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) :=

lets I: (>> E[0] A[1]).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

lets I: (>> E[0] A[1] A[2]).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

lets I: (>> E[0] A[1] A[2] A[3]).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

lets I: (>> E[0] A[1] A[2] A[3] A[4]).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

lets I: (>> E[0] A[1] A[2] A[3] A[4] A[5]).

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2]) ":" constr(E[0])

constr(A[1]) :=

lets [I[1] I[2]]: E[0] A[1].

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2]) ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

lets [I[1] I[2]]: E[0] A[1] A[2].

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2]) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

lets [I[1] I[2]]: E[0] A[1] A[2] A[3].

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2]) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

lets [I[1] I[2]]: E[0] A[1] A[2] A[3] A[4].

Tactic Notation "lets" simple_intropattern(I[1]) simple_intropattern(I[2]) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

lets [I[1] I[2]]: E[0] A[1] A[2] A[3] A[4] A[5].

```

    forwards H: (>> E[0] E[1] .. EN) is short for
    forwards H: (>> E[0] E[1] .. EN ___).
    The arguments Ei can be wildcards __ (except E[0]).
    H may be an introduction pattern, or a sequence of
    introduction pattern, or empty.
    Syntax forwards H: E[0] E[1] .. EN is also available.

```

Ltac forwards_build_app_arg Ei :=

让 args := list_boxer_of Ei in

让 args := (eval simpl in (args ++ ((boxer ___)::nil))) in

让 args := args_unfold_head_if_not_product args in

args.

Ltac forwards_then Ei cont :=

让 args := forwards_build_app_arg Ei in

让 args := args_unfold_head_if_not_product_but_params args in

build_app args cont.

Tactic Notation "forwards" simple_intropattern(I) ":" constr(Ei) :=

让 args := forwards_build_app_arg Ei in

lets I: args.

Tactic Notation "forwards" ":" constr(E) :=

让 H := fresh in forwards H: E.

Tactic Notation "forwards" ":" constr(E[0])

constr(A[1]) :=

forwards: (>> E[0] A[1]).

Tactic Notation "forwards" ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

forwards: (>> E[0] A[1] A[2]).

Tactic Notation "forwards" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

forwards: (>> E[0] A[1] A[2] A[3]).

Tactic Notation "forwards" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

forwards: (>> E[0] A[1] A[2] A[3] A[4]).

Tactic Notation "forwards" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

forwards: (>> E[0] A[1] A[2] A[3] A[4] A[5]).

(* todo: deprecated, do not use *)

Tactic Notation "forwards" simple_intropattern(I[1]) simple_intropattern(I[2])

":" constr(E) :=

forwards [I[1] I[2]]: E.

Tactic Notation "forwards" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) ":" constr(E) :=

forwards [I[1] [I[2] I[3]]]: E.

Tactic Notation "forwards" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) ":" constr(E) :=

forwards [I[1] [I[2] [I[3] I[4]]]]: E.

Tactic Notation "forwards" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5])

":" constr(E) :=

forwards [I[1] [I[2] [I[3] [I[4] I[5]]]]]: E.

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) :=

forwards I: (>> E[0] A[1]).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

forwards I: (>> E[0] A[1] A[2]).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

forwards I: (>> E[0] A[1] A[2] A[3]).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

forwards I: (>> E[0] A[1] A[2] A[3] A[4]).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

forwards I: (>> E[0] A[1] A[2] A[3] A[4] A[5]).

(* for use by tactics -- todo: factorize better *)

Tactic Notation "forwards_nounfold" simple_intropattern(I) ":" constr(Ei) :=

让 args := list_boxer_of Ei in

让 args := (eval simpl in (args ++ ((boxer ___)::nil))) in

build_app args ltac:(fun R ⇒ lets_base I R).

Ltac forwards_nounfold_then Ei cont :=

让 args := list_boxer_of Ei in

让 args := (eval simpl in (args ++ ((boxer ___)::nil))) in

build_app args cont.

```

    applys (>> E[0] E[1] .. EN) instantiates lemma E[0]
    on the arguments Ei (which may be wildcards __),
    and apply the resulting term to the current goal,
    using the tactic applys defined earlier on.
    applys E[0] E[1] E[2] .. EN is also available.

```

Ltac applys_build Ei :=

让 args := list_boxer_of Ei in

让 args := args_unfold_head_if_not_product_but_params args in

build_app args ltac:(fun R ⇒

first [ apply R | eapply R | rapply R ]).

Ltac applys_base E :=

match type of E with

| list Boxer ⇒ applys_build E

| _ ⇒ first [ rapply E | applys_build E ]

end; fast_rm_inside E.

Tactic Notation "applys" constr(E) :=

applys_base E.

Tactic Notation "applys" constr(E[0]) constr(A[1]) :=

applys (>> E[0] A[1]).

策略记法 "applys" 构造(E[0]) 构造(A[1]) 构造(A[2]) :=

applys (>> E[0] A[1] A[2]).

策略记法 "applys" 构造(E[0]) 构造(A[1]) 构造(A[2]) 构造(A[3]) :=

applys (>> E[0] A[1] A[2] A[3]).

策略记法 "applys" 构造(E[0]) 构造(A[1]) 构造(A[2]) 构造(A[3]) 构造(A[4]) :=

applys (>> E[0] A[1] A[2] A[3] A[4]).

策略记法 "applys" 构造(E[0]) 构造(A[1]) 构造(A[2]) 构造(A[3]) 构造(A[4]) 构造(A[5]) :=

applys (>> E[0] A[1] A[2] A[3] A[4] A[5]).

```

    fapplys (>> E[0] E[1] .. EN) instantiates lemma E[0]
    on the arguments Ei and on the argument ___ meaning
    that all evars should be explicitly instantiated,
    and apply the resulting term to the current goal.
    fapplys E[0] E[1] E[2] .. EN is also available.

```

Ltac fapplys_build Ei :=

让 args := list_boxer_of Ei in

让 args := (eval simpl in (args ++ ((boxer ___)::nil))) in

让 args := args_unfold_head_if_not_product_but_params args in

build_app args ltac:(fun R ⇒ apply R).

策略记法 "fapplys" 构造(E[0]) :=  (* todo: use the tactic for that*)

匹配 E[0] 的类型为

| list Boxer ⇒ fapplys_build E[0]

| _ ⇒ fapplys_build (>> E[0])

end.

策略记法 "fapplys" 构造(E[0]) 构造(A[1]) :=

fapplys (>> E[0] A[1]).

策略记法 "fapplys" 构造(E[0]) 构造(A[1]) 构造(A[2]) :=

fapplys (>> E[0] A[1] A[2]).

策略记法 "fapplys" 构造(E[0]) 构造(A[1]) 构造(A[2]) 构造(A[3]) :=

fapplys (>> E[0] A[1] A[2] A[3]).

策略记法 "fapplys" 构造(E[0]) 构造(A[1]) 构造(A[2]) 构造(A[3]) 构造(A[4]) :=

fapplys (>> E[0] A[1] A[2] A[3] A[4]).

策略记法 "fapplys" 构造(E[0]) 构造(A[1]) 构造(A[2]) 构造(A[3]) 构造(A[4]) 构造(A[5]) :=

fapplys (>> E[0] A[1] A[2] A[3] A[4] A[5]).

```

    specializes H (>> E[1] E[2] .. EN) will instantiate hypothesis H
    on the arguments Ei (which may be wildcards __). If the last
    argument EN is ___ (triple-underscore), then all arguments of
    H get instantiated.

```

Ltac specializes_build H Ei :=

让 H' := fresh "TEMP" in rename H into H';

让 args := list_boxer_of Ei in

让 args := 构造:((boxer H')::args) in

让 args := args_unfold_head_if_not_product args in

build_app args ltac:(fun R ⇒ lets H: R);

清除 H'.

Ltac specializes_base H Ei :=

specializes_build H Ei; fast_rm_inside Ei.

策略记法 "specializes" 假设(H) :=

specializes_base H (___).

策略记法 "specializes" 假设(H) 构造(A) :=

specializes_base H A.

策略记法 "specializes" 假设(H) 构造(A[1]) ���造(A[2]) :=

specializes H (>> A[1] A[2]).

策略记法 "specializes" 假设(H) 构造(A[1]) 构造(A[2]) 构造(A[3]) :=

specializes H (>> A[1] A[2] A[3]).

策略记法 "specializes" 假设(H) 构造(A[1]) 构造(A[2]) 构造(A[3]) 构造(A[4]) :=

specializes H (>> A[1] A[2] A[3] A[4]).

策略记法 "specializes" 假设(H) 构造(A[1]) 构造(A[2]) 构造(A[3]) 构造(A[4]) 构造(A[5]) :=

specializes H (>> A[1] A[2] A[3] A[4] A[5]).

```

    specializes_vars H is equivalent to specializes H __ .. __ 
    with as many double underscore as the number of dependent arguments
    visible from the type of H. Note that no unfolding is currently
    being performed (this behavior might change in the future).
    The current implementation is restricted to the case where
    H is an existing hypothesis — TODO: generalize.

```

Ltac specializes_var_base H :=

匹配 H 的类型为

| ?P → ?Q ⇒ 失败 1

| ∀_:_, _ ⇒ specializes H __

end.

Ltac specializes_vars_base H :=

重复 (specializes_var_base H).

策略记法 "specializes_var" 假设(H) :=

specializes_var_base H.

策略记法 "specializes_vars" 假设(H) :=

specializes_vars_base H.

(* ---------------------------------------------------------------------- *)

```

## Experimental Tactics for Application

    fapply is a version of apply based on forwards.

```

策略记法 "fapply" 构造(E) :=

让 H := fresh in forwards H: E;

首先[应用 H | 应用 H | 应用 H | hnf; 应用 H

| hnf; 应用 H | applys H ].

（* todo: is applys redundant with rapply ? *）

```

    sapply stands for "super apply". It tries
    apply, eapply, applys and fapply,
    and also tries to head-normalize the goal first.

```

策略 Notation "sapply" constr(H) :=

first [ apply H | eapply H | rapply H | applys H

| hnf; apply H | hnf; eapply H | hnf; applys H

| fapply H ]。

（* ---------------------------------------------------------------------- *）

```

## Adding Assumptions

    lets_simpl H: E is the same as lets H: E excepts that it
    calls simpl on the hypothesis H.
    lets_simpl: E is also provided.

```

策略 Notation "lets_simpl" ident(H) "：" constr(E) :=

lets H: E; try simpl in H.

策略 Notation "lets_simpl" "：" constr(T) :=

let H := fresh in lets_simpl H: T。

```

    lets_hnf H: E is the same as lets H: E excepts that it
    calls hnf to set the definition in head normal form. 
    lets_hnf: E is also provided.

```

策略 Notation "lets_hnf" ident(H) "：" constr(E) :=

lets H: E; hnf in H。

策略 Notation "lets_hnf" "：" constr(T) :=

let H := fresh in lets_hnf H: T。

```

    puts X: E is a synonymous for pose (X := E).
    Alternative syntax is puts: E.

```

策略 Notation "puts" ident(X) "：" constr(E) :=

pose (X := E)。

策略 Notation "puts" "：" constr(E) :=

let X := fresh "X" in pose (X := E)。

（* ---------------------------------------------------------------------- *）

```

## Application of Tautologies

    logic E, where E is a fact, is equivalent to
    assert H:E; [tauto | eapply H; clear H]. It is useful for instance to prove a conjunction [A ∧ B] by showing first [A] and then [A → B], through the command [logic (foral A B, A → (A → B) → A ∧ B)]  

```

Ltac logic_base E cont :=

assert (H:E); [ cont tt | eapply H; clear H ]。

策略 Notation "logic" constr(E) :=

logic_base E ltac:(fun _ ⇒ tauto).

（* ---------------------------------------------------------------------- *）

```

## Application Modulo Equalities

    The tactic equates replaces a goal of the form
    P x y z with a goal of the form P x ?a z and a
    subgoal ?a = y. The introduction of the evar ?a makes
    it possible to apply lemmas that would not apply to the
    original goal, for example a lemma of the form
    ∀ n m, P n n m, because x and y might be equal
    but not convertible.

    Usage is equates i[1] ... ik, where the indices are the
    positions of the arguments to be replaced by evars,
    counting from the right-hand side. If 0 is given as
    argument, then the entire goal is replaced by an evar.

```

区 equatesLemma。

变量 (A[0] A[1]：类型)。

变量 (A[2]：∀(x[1]：A[1]), 类型)。

变量 (A[3]：∀(x[1]：A[1]) (x[2]：A[2] x[1]), 类型)。

变量 (A[4]：∀(x[1]：A[1]) (x[2]：A[2] x[1]) (x[3]：A[3] x[2]), 类型)。

变量 (A[5]：∀(x[1]：A[1]) (x[2]：A[2] x[1]) (x[3]：A[3] x[2]) (x[4]：A[4] x[3]), 类型)。

变量 (A[6]：∀(x[1]：A[1]) (x[2]：A[2] x[1]) (x[3]：A[3] x[2]) (x[4]：A[4] x[3]) (x[5]：A[5] x[4]), 类型)。

引理 equates_0：∀(P Q:Prop)，

P → P = Q → Q.

证明。intros。subst。auto。Qed。

引理 equates_1：

∀(P:A[0]→Prop) x[1] y[1]，

P y[1] → x[1] = y[1] → P x[1]。

证明。intros。subst。auto。Qed。

引理 equates_2：

∀y[1] (P:A[0]→∀(x[1]:A[1]),Prop) x[1] x[2]，

P y[1] x[2] → x[1] = y[1] → P x[1] x[2]。

证明。intros。subst。auto。Qed。

引理 equates_3：

∀y[1] (P:A[0]→∀(x[1]:A[1])(x[2]:A[2] x[1]),Prop) x[1] x[2] x[3]，

P y[1] x[2] x[3] → x[1] = y[1] → P x[1] x[2] x[3]。

证明。intros。subst。auto。Qed。

引理 equates_4：

∀y[1] (P:A[0]→∀(x[1]:A[1])(x[2]:A[2] x[1])(x[3]:A[3] x[2]),Prop) x[1] x[2] x[3] x[4]，

P y[1] x[2] x[3] x[4] → x[1] = y[1] → P x[1] x[2] x[3] x[4]。

证明。intros。subst。auto。Qed。

引理 equates_5：

∀y[1] (P:A[0]→∀(x[1]:A[1])(x[2]:A[2] x[1])(x[3]:A[3] x[2])(x[4]:A[4] x[3]),Prop) x[1] x[2] x[3] x[4] x[5]，

P y[1] x[2] x[3] x[4] x[5] → x[1] = y[1] → P x[1] x[2] x[3] x[4] x[5]。

证明。intros。subst。auto。Qed。

引理 equates_6：

∀y[1] (P:A[0]→∀(x[1]:A[1])(x[2]:A[2] x[1])(x[3]:A[3] x[2])(x[4]:A[4] x[3])(x[5]:A[5] x[4]),Prop)

x[1] x[2] x[3] x[4] x[5] x[6]，

P y[1] x[2] x[3] x[4] x[5] x[6] → x[1] = y[1] → P x[1] x[2] x[3] x[4] x[5] x[6]。

证明。intros。subst。auto。Qed。

End equatesLemma。

Ltac equates_lemma n :=

match nat_from_number n with

| 0 ⇒ constr:(equates_0)

| 1 ⇒ constr:(equates_1)

| 2 ⇒ constr:(equates_2)

| 3 ⇒ constr:(equates_3)

| 4 ⇒ constr:(equates_4)

| 5 ⇒ constr:(equates_5)

| 6 ⇒ constr:(equates_6)

end。

Ltac equates_one n :=

let L := equates_lemma n in

eapply L。

Ltac equates_several E cont :=

let all_pos := match type of E with

| List.list Boxer ⇒ constr:(E)

| _ ⇒ constr:((boxer E)::nil)

end in

let rec go pos :=

match pos with

| nil ⇒ cont tt

| (boxer ?n)::?pos' ⇒ equates_one n; [ instantiate; go pos' | ]

end in

go all_pos.

Tactic Notation "equates" constr(E) :=

equates_several E ltac:(fun _ ⇒ idtac).

Tactic Notation "equates" constr(n[1]) constr(n[2]) :=

equates (>> n[1] n[2]).

Tactic Notation "equates" constr(n[1]) constr(n[2]) constr(n[3]) :=

equates (>> n[1] n[2] n[3]).

Tactic Notation "equates" constr(n[1]) constr(n[2]) constr(n[3]) constr(n[4]) :=

equates (>> n[1] n[2] n[3] n[4]).

```

    applys_eq H i[1] .. iK is the same as
    equates i[1] .. iK followed by apply H
    on the first subgoal.

```

Tactic Notation "applys_eq" constr(H) constr(E) :=

equates_several E ltac:(fun _ ⇒ sapply H).

Tactic Notation "applys_eq" constr(H) constr(n[1]) constr(n[2]) :=

applys_eq H (>> n[1] n[2]).

Tactic Notation "applys_eq" constr(H) constr(n[1]) constr(n[2]) constr(n[3]) :=

applys_eq H (>> n[1] n[2] n[3]).

Tactic Notation "applys_eq" constr(H) constr(n[1]) constr(n[2]) constr(n[3]) constr(n[4]) :=

applys_eq H (>> n[1] n[2] n[3] n[4]).

(* ---------------------------------------------------------------------- *)

```

## Absurd Goals

    false_goal replaces any goal by the goal False. 
    Contrary to the tactic false (below), it does not try to do
    anything else

```

Tactic Notation "false_goal" :=

elimtype False.

```

    false_post is the underlying tactic used to prove goals
    of the form False. In the default implementation, it proves
    the goal if the context contains False or an hypothesis of the
    form C x[1] .. xN = D y[1] .. yM, or if the congruence tactic
    finds a proof of x ≠ x for some x.

```

Ltac false_post :=

solve [ assumption | discriminate | congruence ].

```

    false replaces any goal by the goal False, and calls false_post

```

Tactic Notation "false" :=

false_goal; try false_post.

```

    tryfalse tries to solve a goal by contradiction, and leaves
    the goal unchanged if it cannot solve it.
    It is equivalent to try solve \[ false \].

```

Tactic Notation "tryfalse" :=

try solve [ false ].

```

    false E tries to exploit lemma E to prove the goal false.
    false E[1] .. EN is equivalent to false (>> E[1] .. EN),
    which tries to apply applys (>> E[1] .. EN) and if it
    does not work then tries forwards H: (>> E[1] .. EN)
    followed with false

```

Ltac false_then E cont :=

false_goal; first

[ applys E; instantiate

| forwards_then E ltac:(fun M ⇒

pose M; jauto_set_hyps; intros; false) ];

cont tt.

(* TODO: is cont needed? *)

Tactic Notation "false" constr(E) :=

false_then E ltac:(fun _ ⇒ idtac).

Tactic Notation "false" constr(E) constr(E[1]) :=

false (>> E E[1]).

Tactic Notation "false" constr(E) constr(E[1]) constr(E[2]) :=

false (>> E E[1] E[2]).

Tactic Notation "false" constr(E) constr(E[1]) constr(E[2]) constr(E[3]) :=

false (>> E E[1] E[2] E[3]).

Tactic Notation "false" constr(E) constr(E[1]) constr(E[2]) constr(E[3]) constr(E[4]) :=

false (>> E E[1] E[2] E[3] E[4]).

```

    false_invert H proves a goal if it absurd after
    calling inversion H and false

```

Ltac false_invert_for H :=

let M := fresh in pose (M := H); inversion H; false.

Tactic Notation "false_invert" constr(H) :=

try solve [ false_invert_for H | false ].

```

    false_invert proves any goal provided there is at least 
    one hypothesis H in the context (or as a universally quantified
    hypothesis visible at the head of the goal) that can be proved absurd by calling 
    inversion H.

```

Ltac false_invert_iter :=

match goal with H:_ ⊢ _ ⇒

solve [ inversion H; false

| clear H; false_invert_iter

| fail 2 ] end.

Tactic Notation "false_invert" :=

intros; solve [ false_invert_iter | false ].

```

    tryfalse_invert H and tryfalse_invert are like the 
    above but leave the goal unchanged if they don't solve it.

```

Tactic Notation "tryfalse_invert" constr(H) :=

try (false_invert H).

Tactic Notation "tryfalse_invert" :=

try false_invert.

```

    false_neq_self_hyp proves any goal if the context
    contains an hypothesis of the form E ≠ E. It is 
    a restricted and optimized version of false. It is 
    intended to be used by other tactics only.

```

Ltac false_neq_self_hyp :=

match goal with H: ?x ≠ ?x ⊢ _ ⇒

false_goal; apply H; reflexivity end.

(* ********************************************************************** *)

```

# Introduction and Generalization

```

(* ---------------------------------------------------------------------- *)

```

## Introduction

    introv is used to name only non-dependent hypothesis.

*   If introv is called on a goal of the form ∀ x, H, it should introduce all the variables quantified with a ∀ at the head of the goal, but it does not introduce hypotheses that preceed an arrow constructor, like in P → Q.

*   If introv is called on a goal that is not of the form ∀ x, H nor P → Q, the tactic unfolds definitions until the goal takes the form ∀ x, H or P → Q. If unfolding definitions does not produces a goal of this form, then the tactic introv does nothing at all.

```

(* introv_rec introduces all visible variables.    It does not try to unfold any definition. *)

Ltac introv_rec :=

match goal with

| ⊢ ?P → ?Q ⇒ idtac

| ⊢ ∀_, _ ⇒ intro; introv_rec

| ⊢ _ ⇒ idtac

end.

(* introv_noarg 强制目标为∀或→，然后调用 introv_rec 引入变量（可能没有，在这种情况下 introv 与 hnf 相同）。如果目标不是乘积，则不执行任何操作。*)

Ltac introv_noarg :=

match goal with

| ⊢ ?P → ?Q ⇒ idtac

| ⊢ ∀_, _ ⇒ introv_rec

| ⊢ ?G ⇒ hnf;

match goal with

| ⊢ ?P → ?Q ⇒ idtac

| ⊢ ∀_, _ ⇒ introv_rec

end

| ⊢ _ ⇒ idtac

end.

(* 更简单但可能效率较低的实现*)

Ltac introv_noarg_not_optimized :=

intro; match goal with H:_|-_ ⇒ revert H end; introv_rec.

(* introv_arg H 在引入前导此假设的∀量化变量后，引入一个非依赖假设 H。如果不存在要引入的假设，则此策略失败。*)

(* todo: __ 在 introv 中表示"intros"*)

Ltac introv_arg H :=

hnf; match goal with

| ⊢ ?P → ?Q ⇒ intros H

| ⊢ ∀_, _ ⇒ intro; introv_arg H

end.

(* introv I[1] .. IN 迭代 introv Ik*)

Tactic Notation "introv" :=

introv_noarg.

Tactic Notation "introv" simple_intropattern(I[1]) :=

introv_arg I[1].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2]) :=

introv I[1]; introv I[2].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) :=

introv I[1]; introv I[2] I[3].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) :=

introv I[1]; introv I[2] I[3] I[4].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5]) :=

introv I[1]; introv I[2] I[3] I[4] I[5].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6]) :=

introv I[1]; introv I[2] I[3] I[4] I[5] I[6].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6]) simple_intropattern(I[7]) :=

introv I[1]; introv I[2] I[3] I[4] I[5] I[6] I[7].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6]) simple_intropattern(I[7]) simple_intropattern(I[8]) :=

introv I[1]; introv I[2] I[3] I[4] I[5] I[6] I[7] I[8].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6]) simple_intropattern(I[7]) simple_intropattern(I[8])

simple_intropattern(I[9]) :=

introv I[1]; introv I[2] I[3] I[4] I[5] I[6] I[7] I[8] I[9].

Tactic Notation "introv" simple_intropattern(I[1]) simple_intropattern(I[2])

simple_intropattern(I[3]) simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6]) simple_intropattern(I[7]) simple_intropattern(I[8])

simple_intropattern(I[9]) simple_intropattern(I[10]) :=

introv I[1]; introv I[2] I[3] I[4] I[5] I[6] I[7] I[8] I[9] I[10].

```

    intros_all repeats intro as long as possible. Contrary to intros,
    it unfolds any definition on the way. Remark that it also unfolds the
    definition of negation, so applying introz to a goal of the form
    ∀ x, P x → ¬Q will introduce x and P x and Q, and will
    leave False in the goal.

```

Tactic Notation "intros_all" :=

repeat intro.

```

    intros_hnf introduces an hypothesis and sets in head normal form

```

Tactic Notation "intro_hnf" :=

intro; match goal with H: _ ⊢ _ ⇒ hnf in H end.

(* ---------------------------------------------------------------------- *)

```

## Generalization

    gen X[1] .. XN is a shorthand for calling generalize dependent
    successively on variables XN...X[1]. Note that the variables
    are generalized in reverse order, following the convention of
    the generalize tactic: it means that X[1] will be the first
    quantified variable in the resulting goal.

```

Tactic Notation "gen" ident(X[1]) :=

generalize dependent X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) :=

gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) :=

gen X[3]; gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) ident(X[4])  :=

gen X[4]; gen X[3]; gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) ident(X[4]) ident(X[5]) :=

gen X[5]; gen X[4]; gen X[3]; gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) ident(X[4]) ident(X[5])

ident(X[6]) :=

gen X[6]; gen X[5]; gen X[4]; gen X[3]; gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) ident(X[4]) ident(X[5])

ident(X[6]) ident(X[7]) :=

gen X[7]; gen X[6]; gen X[5]; gen X[4]; gen X[3]; gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) ident(X[4]) ident(X[5])

ident(X[6]) ident(X[7]) ident(X[8]) :=

gen X[8]; gen X[7]; gen X[6]; gen X[5]; gen X[4]; gen X[3]; gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) ident(X[4]) ident(X[5])

ident(X[6]) ident(X[7]) ident(X[8]) ident(X[9]) :=

gen X[9]; gen X[8]; gen X[7]; gen X[6]; gen X[5]; gen X[4]; gen X[3]; gen X[2]; gen X[1].

Tactic Notation "gen" ident(X[1]) ident(X[2]) ident(X[3]) ident(X[4]) ident(X[5])

ident(X[6]) ident(X[7]) ident(X[8]) ident(X[9]) ident(X[10]) :=

gen X[10]; gen X[9]; gen X[8]; gen X[7]; gen X[6]; gen X[5]; gen X[4]; gen X[3]; gen X[2]; gen X[1].

```

    generalizes X is a shorthand for calling generalize X; clear X.
    It is weaker than tactic gen X since it does not support
    dependencies. It is mainly intended for writing tactics.

```

Tactic Notation "generalizes" hyp(X) :=

generalize X; clear X.

Tactic Notation "generalizes" hyp(X[1]) hyp(X[2]) :=

generalizes X[1]; generalizes X[2].

Tactic Notation "generalizes" hyp(X[1]) hyp(X[2]) hyp(X[3]) :=

generalizes X[1] X[2]; generalizes X[3].

Tactic Notation "generalizes" hyp(X[1]) hyp(X[2]) hyp(X[3]) hyp(X[4]) :=

generalizes X[1] X[2] X[3]; generalizes X[4].

(* ---------------------------------------------------------------------- *)

```

## Naming

    sets X: E is the same as set (X := E) in *, that is,
    it replaces all occurences of E by a fresh meta-variable X
    whose definition is E.

```

Tactic Notation "sets" ident(X) ":" constr(E) :=

set (X := E) in *.

```

    def_to_eq E X H applies when X := E is a local
    definition. It adds an assumption H: X = E
    and then clears the definition of X.
    def_to_eq_sym is similar except that it generates
    the equality H: E = X.

```

Ltac def_to_eq X HX E :=

assert (HX : X = E) by reflexivity; clearbody X.

Ltac def_to_eq_sym X HX E :=

assert (HX : E = X) by reflexivity; clearbody X.

```

    set_eq X H: E generates the equality H: X = E,
    for a fresh name X, and replaces E by X in the
    current goal. Syntaxes set_eq X: E and
    set_eq: E are also available. Similarly,
    set_eq ← X H: E generates the equality H: E = X.

    sets_eq X HX: E does the same but replaces E by X
    everywhere in the goal. sets_eq X HX: E in H replaces in H.
    set_eq X HX: E in ⊢ performs no substitution at all.

```

Tactic Notation "set_eq" ident(X) ident(HX) ":" constr(E) :=

set (X := E); def_to_eq X HX E.

Tactic Notation "set_eq" ident(X) ":" constr(E) :=

let HX := fresh "EQ" X in set_eq X HX: E.

Tactic Notation "set_eq" ":" constr(E) :=

let X := fresh "X" in set_eq X: E.

Tactic Notation "set_eq" "←" ident(X) ident(HX) ":" constr(E) :=

set (X := E); def_to_eq_sym X HX E.

Tactic Notation "set_eq" "←" ident(X) ":" constr(E) :=

let HX := fresh "EQ" X in set_eq ← X HX: E.

策略记法 "set_eq" "←" ":" constr(E) :=

let X := fresh "X" in set_eq ← X: E.

策略记法 "sets_eq" ident(X) ident(HX) ":" constr(E) :=

set (X := E) in *; def_to_eq X HX E.

策略记法 "sets_eq" ident(X) ":" constr(E) :=

let HX := fresh "EQ" X in sets_eq X HX: E.

策略记法 "sets_eq" ":" constr(E) :=

let X := fresh "X" in sets_eq X: E.

策略记法 "sets_eq" "←" ident(X) ident(HX) ":" constr(E) :=

set (X := E) in *; def_to_eq_sym X HX E.

策略记法 "sets_eq" "←" ident(X) ":" constr(E) :=

let HX := fresh "EQ" X in sets_eq ← X HX: E.

策略记法 "sets_eq" "←" ":" constr(E)：

let X := fresh "X" in sets_eq ← X: E.

策略记法 "set_eq" ident(X) ident(HX) ":" constr(E) "in" hyp(H) :=

set (X := E) in H; def_to_eq X HX E.

策略记法 "set_eq" ident(X) ":" constr(E) "in" hyp(H) :=

let HX := fresh "EQ" X in set_eq X HX: E in H.

策略记法 "set_eq" ":" constr(E) "in" hyp(H) :=

let X := fresh "X" in set_eq X: E in H.

策略记法 "set_eq" "←" ident(X) ident(HX) ":" constr(E) "in" hyp(H) :=

set (X := E) in H; def_to_eq_sym X HX E.

策略记法 "set_eq" "←" ident(X) ":" constr(E) "in" hyp(H) :=

let HX := fresh "EQ" X in set_eq ← X HX: E in H.

策略记法 "set_eq" "←" ":" constr(E) "in" hyp(H) :=

let X := fresh "X" in set_eq ← X: E in H.

策略记法 "set_eq" ident(X) ident(HX) ":" constr(E) "in" "⊢" :=

set (X := E) in ⊢; def_to_eq X HX E.

策略记法 "set_eq" ident(X) ":" constr(E) "in" "⊢" :=

let HX := fresh "EQ" X in set_eq X HX: E in ⊢.

策略记法 "set_eq" ":" constr(E) "in" "⊢" :=

let X := fresh "X" in set_eq X: E in ⊢.

策略记法 "set_eq" "←" ident(X) ident(HX) ":" constr(E) "in" "⊢" :=

set (X := E) in ⊢; def_to_eq_sym X HX E.

策略记法 "set_eq" "←" ident(X) ":" constr(E) "in" "⊢" :=

let HX := fresh "EQ" X in set_eq ← X HX: E in ⊢.

策略记法 "set_eq" "←" ":" constr(E) "in" "⊢" :=

let X := fresh "X" in set_eq ← X: E in ⊢.

```

    gen_eq X: E is a tactic whose purpose is to introduce
    equalities so as to work around the limitation of the induction
    tactic which typically loses information. gen_eq E as X replaces
    all occurences of term E with a fresh variable X and the equality
    X = E as extra hypothesis to the current conclusion. In other words
    a conclusion C will be turned into (X = E) → C.
    gen_eq: E and gen_eq: E as X are also accepted.

```

策略记法 "gen_eq" ident(X) ":" constr(E) :=

let EQ := fresh in sets_eq X EQ: E; revert EQ.

策略记法 "gen_eq" ":" constr(E) :=

let X := fresh "X" in gen_eq X: E.

策略记法 "gen_eq" ":" constr(E) "as" ident(X) :=

gen_eq X: E.

策略记法 "gen_eq" ident(X[1]) ":" constr(E[1]) ","

ident(X[2]) ":" constr(E[2]) :=

gen_eq X[2]: E[2]; gen_eq X[1]: E[1].

策略记法 "gen_eq" ident(X[1]) ":" constr(E[1]) ","

ident(X[2]) ":" constr(E[2]) "," ident(X[3]) ":" constr(E[3]) :=

gen_eq X[3]: E[3]; gen_eq X[2]: E[2]; gen_eq X[1]: E[1].

```

    sets_let X finds the first let-expression in the goal
    and names its body X. sets_eq_let X is similar,
    except that it generates an explicit equality.
    Tactics sets_let X in H and sets_eq_let X in H
    allow specifying a particular hypothesis (by default,
    the first one that contains a let is considered).

    Known limitation: it does not seem possible to support
    naming of multiple let-in constructs inside a term, from ltac.

```

Ltac sets_let_base tac :=

match goal with

| ⊢ context[let _ := ?E in _] ⇒ tac E; cbv zeta

| H: context[let _ := ?E in _] ⊢ _ ⇒ tac E; cbv zeta in H

end.

Ltac sets_let_in_base H tac :=

匹配 H 的类型为 context[let _ := ?E in _] ⇒

tac E; cbv zeta in H end.

策略记法 "sets_let" ident(X) :=

sets_let_base ltac:(fun E ⇒ sets X: E).

策略记法 "sets_let" ident(X) "in" hyp(H) :=

sets_let_in_base H ltac:(fun E ⇒ sets X: E).

策略记法 "sets_eq_let" ident(X) :=

sets_let_base ltac:(fun E ⇒ sets_eq X: E).

Tactic Notation "sets_eq_let" ident(X) "in" hyp(H) :=

sets_let_in_base H ltac:(fun E ⇒ sets_eq X: E).

(* ********************************************************************** *)

```

# Rewriting

    rewrites E is similar to rewrite except that
    it supports the rm directives to clear hypotheses
    on the fly, and that it supports a list of arguments in the form
    rewrites (>> E[1] E[2] E[3]) to indicate that forwards should be 
    invoked first before rewrites is called.

```

Ltac rewrites_base E cont :=

match type of E with

| List.list Boxer ⇒ forwards_then E cont

| _ ⇒ cont E; fast_rm_inside E

end.

Tactic Notation "rewrites" constr(E) :=

rewrites_base E ltac:(fun M ⇒ rewrite M ).

Tactic Notation "rewrites" constr(E) "in" hyp(H) :=

rewrites_base E ltac:(fun M ⇒ rewrite M in H).

Tactic Notation "rewrites" constr(E) "in" "*" :=

rewrites_base E ltac:(fun M ⇒ rewrite M in *).

Tactic Notation "rewrites" "←" constr(E) :=

rewrites_base E ltac:(fun M ⇒ rewrite ← M ).

Tactic Notation "rewrites" "←" constr(E) "in" hyp(H) :=

rewrites_base E ltac:(fun M ⇒ rewrite ← M in H).

Tactic Notation "rewrites" "←" constr(E) "in" "*" :=

rewrites_base E ltac:(fun M ⇒ rewrite ← M in *).

(* TODO: extend tactics below to use rewrites *)

```

    rewrite_all E iterates version of rewrite E as long as possible.
    Warning: this tactic can easily get into an infinite loop.
    Syntax for rewriting from right to left and/or into an hypothese
    is similar to the one of rewrite.

```

Tactic Notation "rewrite_all" constr(E) :=

repeat rewrite E.

Tactic Notation "rewrite_all" "←" constr(E) :=

repeat rewrite ← E.

Tactic Notation "rewrite_all" constr(E) "in" ident(H) :=

repeat rewrite E in H.

Tactic Notation "rewrite_all" "←" constr(E) "in" ident(H) :=

repeat rewrite ← E in H.

Tactic Notation "rewrite_all" constr(E) "in" "*" :=

repeat rewrite E in *.

Tactic Notation "rewrite_all" "←" constr(E) "in" "*" :=

repeat rewrite ← E in *.

```

    asserts_rewrite E asserts that an equality E holds (generating a
    corresponding subgoal) and rewrite it straight away in the current
    goal. It avoids giving a name to the equality and later clearing it.
    Syntax for rewriting from right to left and/or into an hypothese
    is similar to the one of rewrite. Note: the tactic replaces
    plays a similar role.

```

Ltac asserts_rewrite_tactic E action :=

let EQ := fresh in (assert (EQ : E);

[ idtac | action EQ; clear EQ ]).

Tactic Notation "asserts_rewrite" constr(E) :=

asserts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite EQ).

Tactic Notation "asserts_rewrite" "←" constr(E) :=

asserts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite ← EQ).

Tactic Notation "asserts_rewrite" constr(E) "in" hyp(H) :=

asserts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite EQ in H).

Tactic Notation "asserts_rewrite" "←" constr(E) "in" hyp(H) :=

asserts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite ← EQ in H).

Tactic Notation "asserts_rewrite" constr(E) "in" "*" :=

asserts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite EQ in *).

Tactic Notation "asserts_rewrite" "←" constr(E) "in" "*" :=

asserts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite ← EQ in *).

```

    cuts_rewrite E is the same as asserts_rewrite E except
    that subgoals are permuted.

```

Ltac cuts_rewrite_tactic E action :=

let EQ := fresh in (cuts EQ: E;

[ action EQ; clear EQ | idtac ]).

Tactic Notation "cuts_rewrite" constr(E) :=

cuts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite EQ).

Tactic Notation "cuts_rewrite" "←" constr(E) :=

cuts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite ← EQ).

Tactic Notation "cuts_rewrite" constr(E) "in" hyp(H) :=

cuts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite EQ in H).

Tactic Notation "cuts_rewrite" "←" constr(E) "in" hyp(H) :=

cuts_rewrite_tactic E ltac:(fun EQ ⇒ rewrite ← EQ in H).

```

    rewrite_except H EQ rewrites equality EQ everywhere
    but in hypothesis H. Mainly useful for other tactics.

```

Ltac rewrite_except H EQ :=

let K := fresh in let T := type of H in

set (K := T) in H;

rewrite EQ in *; unfold K in H; clear K.

```

    rewrites E at K applies when E is of the form T[1] = T[2]
    rewrites the equality E at the K-th occurence of T[1]
    in the current goal.
    Syntaxes rewrites ← E at K and rewrites E at K in H
    are also available.

```

Tactic Notation "rewrites" constr(E) "at" constr(K) :=

match type of E with ?T[1] = ?T[2] ⇒

在 T[1] 中的 K 处执行 (重写 E) 结束。

策略 Notation "rewrites" "←" constr(E) "at" constr(K) :=

匹配 E 的类型为 ?T[1] = ?T[2] ⇒

在 T[2] 中的 K 处执行 (在 T[2] 中重写 ← E) 结束。

策略 Notation "rewrites" constr(E) "at" constr(K) "in" hyp(H) :=

匹配 E 的类型为 ?T[1] = ?T[2] ⇒

在 H 中的 T[1] 处的 K 处执行 (在 H 中重写 E) 结束。

策略 Notation "rewrites" "←" constr(E) "at" constr(K) "in" hyp(H) :=

匹配 E 的类型为 ?T[1] = ?T[2] ⇒

在 H 中的 T[2] 处的 K 处执行 (在 H 中重写 ← E) 结束。

(* ---------------------------------------------------------------------- *)

```

## Replace

    replaces E with F is the same as replace E with F except that
    the equality E = F is generated as first subgoal. Syntax
    replaces E with F in H is also available. Note that contrary to
    replace, replaces does not try to solve the equality
    by assumption. Note: replaces E with F is similar to
    asserts_rewrite (E = F).

```

策略 Notation "replaces" constr(E) "with" constr(F) :=

让 T := fresh in 断言 (T: E = F); [ | 替换 E 为 F; 清除 T ]。

策略 Notation "replaces" constr(E) "with" constr(F) "in" hyp(H) :=

让 T := fresh in 断言 (T: E = F); [ | 在 H 中替换 E 为 F; 清除 T ]。

```

    replaces E at K with F replaces the K-th occurence of E
    with F in the current goal. Syntax replaces E at K with F in H
    is also available.

```

策略 Notation "replaces" constr(E) "at" constr(K) "with" constr(F) :=

让 T := fresh in 断言 (T: E = F); [ | 在 K 处重写 T; 清除 T ]。

策略 Notation "replaces" constr(E) "at" constr(K) "with" constr(F) "in" hyp(H) :=

让 T := fresh in 断言 (T: E = F); [ | 在 K 处的 H 中重写 T; 清除 T ]。

(* ---------------------------------------------------------------------- *)

```

## Change

    changes is like change except that it does not silently
   fail to perform its task. (Note that, changes is implemented
   using rewrite, meaning that it might perform additional 
   beta-reductions compared with the original change tactic.

```

(* TODO: 支持 "changes (E[1] = E[2])" *)

策略 Notation "changes" constr(E[1]) "with" constr(E[2]) "in" hyp(H) :=

断言重写 (E[1] = E[2]) 在 H 中; [ 反射性 | ]。

策略 Notation "changes" constr(E[1]) "with" constr(E[2]) :=

断言重写 (E[1] = E[2]); [ 反射性 | ]。

策略 Notation "changes" constr(E[1]) "with" constr(E[2]) "in" "*" :=

断言重写 (E[1] = E[2]) 在 * 中; [ 反射性 | ]。

(* ---------------------------------------------------------------------- *)

```

## Renaming

    renames X[1] to Y[1], ..., XN to YN is a shorthand for a sequence of
    renaming operations rename Xi into Yi.

```

策略 Notation "renames" ident(X[1]) "to" ident(Y[1]) :=

将 X[1] 重命名为 Y[1]。

策略 Notation "renames" ident(X[1]) "to" ident(Y[1]) ","

ident(X[2]) "to" ident(Y[2]) :=

将 X[1] 重命名为 Y[1]; 将 X[2] 重命名为 Y[2].

策略 Notation "renames" ident(X[1]) "to" ident(Y[1]) ","

ident(X[2]) "to" ident(Y[2]) "," ident(X[3]) "to" ident(Y[3]) :=

将 X[1] 重命名为 Y[1]; 将 X[2] 重命名为 Y[2], X[3] 重命名为 Y[3].

策略 Notation "renames" ident(X[1]) "to" ident(Y[1]) ","

ident(X[2]) "to" ident(Y[2]) "," ident(X[3]) "to" ident(Y[3]) ","

ident(X[4]) "to" ident(Y[4]) :=

将 X[1] 重命名为 Y[1]; 将 X[2] 重命名为 Y[2], X[3] 重命名为 Y[3], X[4] 重命名为 Y[4]。

策略 Notation "renames" ident(X[1]) "to" ident(Y[1]) ","

ident(X[2]) "to" ident(Y[2]) "," ident(X[3]) "to" ident(Y[3]) ","

ident(X[4]) "to" ident(Y[4]) "," ident(X[5]) "to" ident(Y[5]) :=

将 X[1] 重命名为 Y[1]; 将 X[2] 重命名为 Y[2], X[3] 重命名为 Y[3], X[4] 重命名为 Y[4], X[5] 重命名为 Y[5]。

策略 Notation "renames" ident(X[1]) "to" ident(Y[1]) ","

ident(X[2]) "to" ident(Y[2]) "," ident(X[3]) "to" ident(Y[3]) ","

ident(X[4]) "to" ident(Y[4]) "," ident(X[5]) "to" ident(Y[5]) ","

ident(X[6]) "to" ident(Y[6]) :=

将 X[1] 重命名为 Y[1]; 将 X[2] 重命名为 Y[2], X[3] 重命名为 Y[3], X[4] 重命名为 Y[4], X[5] 重命名为 Y[5], X[6] 重命名为 Y[6]。

(* ---------------------------------------------------------------------- *)

```

## Unfolding

    unfolds unfolds the head definition in the goal, i.e., if the
    goal has form P x[1] ... xN then it calls unfold P.
    If the goal is an equality, it tries to unfold the head constant
    on the left-hand side, and otherwise tries on the right-hand side.
    If the goal is a product, it calls intros first.
 warning: this tactic is overriden in LibReflect.

```

Ltac 对 E 的头部应用 cont :=

让 go E :=

让 P := 获取 E 的头部 in cont P in

匹配 E 为

| ∀_,_ ⇒ 引入；对 E 的头部应用 cont

| ?A = ?B ⇒ 首选 [ go A | go B ]

| ?A ⇒ go A

end。

Ltac 展开基础 :=

匹配目标为 ⊢ ?G ⇒

对 G 的头部应用 ltac:(fun P ⇒ 展开 P) 结束。

Tactic Notation "展开" :=

展开基础。

```

    unfolds in H unfolds the head definition of hypothesis H, i.e., if
    H has type P x[1] ... xN then it calls unfold P in H.

```

Ltac 在基础上展开 H :=

匹配 H 的类型为 ?G ⇒

对 G 的头部应用 ltac:(fun P ⇒ 在 H 中展开 P) 结束。

Tactic Notation "在" hyp(H) 中展开 :=

在基础上展开 H。

```

    unfolds in H[1],H[2],..,HN allows unfolding the head constant
    in several hypotheses at once.

```

Tactic Notation "在" hyp(H[1]) hyp(H[2]) 中展开 :=

在 H[1] 中展开；在 H[2] 中展开。

Tactic Notation "在" hyp(H[1]) hyp(H[2]) hyp(H[3]) 中展开 :=

在 H[1] 中展开；在 H[2]，H[3] 中展开。

Tactic Notation "在" hyp(H[1]) hyp(H[2]) hyp(H[3]) hyp(H[4]) 中展开 :=

在 H[1]，H[2]，H[3]，H[4] 中展开。

```

    unfolds P[1],..,PN is a shortcut for unfold P[1],..,PN in *.

```

Tactic Notation "展开" constr(F[1]) :=

在 * 中展开 F[1]。

Tactic Notation "展开" constr(F[1]) "," constr(F[2]) :=

在 * 中展开 F[1]，F[2]。

Tactic Notation "展开" constr(F[1]) "," constr(F[2])

"," constr(F[3]) :=

在 * 中展开 F[1]，F[2]，F[3]。

Tactic Notation "展开" constr(F[1]) "," constr(F[2])

"," constr(F[3]) "," constr(F[4]) :=

在 * 中展开 F[1]，F[2]，F[3]，F[4]。

Tactic Notation "展开" constr(F[1]) "," constr(F[2])

"," constr(F[3]) "," constr(F[4]) "," constr(F[5]) :=

在 * 中展开 F[1]，F[2]，F[3]，F[4]，F[5]。

Tactic Notation "展开" constr(F[1]) "," constr(F[2])

"," constr(F[3]) "," constr(F[4]) "," constr(F[5]) "," constr(F[6]) :=

在 * 中展开 F[1]，F[2]，F[3]，F[4]，F[5]，F[6]。

Tactic Notation "展开" constr(F[1]) "," constr(F[2])

"," constr(F[3]) "," constr(F[4]) "," constr(F[5])

"," constr(F[6]) "," constr(F[7]) :=

在 * 中展开 F[1]，F[2]，F[3]，F[4]，F[5]，F[6]，F[7]。

Tactic Notation "展开" constr(F[1]) "," constr(F[2])

"," constr(F[3]) "," constr(F[4]) "," constr(F[5])

"," constr(F[6]) "," constr(F[7]) "," constr(F[8]) :=

在 * 中展开 F[1]，F[2]，F[3]，F[4]，F[5]，F[6]，F[7]，F[8]。

```

    folds P[1],..,PN is a shortcut for fold P[1] in *; ..; fold PN in *.

```

Tactic Notation "折叠" constr(H) :=

在 * 中折叠 H。

Tactic Notation "折叠" constr(H[1]) "," constr(H[2]) :=

folds H[1]; folds H[2]。

Tactic Notation "折叠" constr(H[1]) "," constr(H[2]) "," constr(H[3]) :=

folds H[1]; folds H[2]; folds H[3]。

Tactic Notation "折叠" constr(H[1]) "," constr(H[2]) "," constr(H[3])

"," constr(H[4]) :=

folds H[1]; folds H[2]; folds H[3]; folds H[4]。

Tactic Notation "折叠" constr(H[1]) "," constr(H[2]) "," constr(H[3])

"," constr(H[4]) "," constr(H[5]) :=

folds H[1]; folds H[2]; folds H[3]; folds H[4]; folds H[5]。

(* ---------------------------------------------------------------------- *)

```

## Simplification

    simpls is a shortcut for simpl in *.

```

Tactic Notation "简化" :=

简化 在 * 中。

```

    simpls P[1],..,PN is a shortcut for
    simpl P[1] in *; ..; simpl PN in *.

```

Tactic Notation "简化" constr(F[1]) :=

简化 F[1] 在 * 中。

Tactic Notation "简化" constr(F[1]) "," constr(F[2]) :=

简化 F[1]；简化 F[2]。

Tactic Notation "简化" constr(F[1]) "," constr(F[2])

"," constr(F[3]) :=

简化 F[1]；简化 F[2]；简化 F[3]。

Tactic Notation "简化" constr(F[1]) "," constr(F[2])

"," constr(F[3]) "," constr(F[4]) :=

simpls F[1]; simpls F[2]; simpls F[3]; simpls F[4].

```

    unsimpl E replaces all occurence of X by E, where X is
   the result which the tactic simpl would give when applied to E.
   It is useful to undo what simpl has simplified too far.

```

Tactic Notation "unsimpl" constr(E) :=

let F := (eval simpl in E) in change F with E.

```

    unsimpl E in H is similar to unsimpl E but it applies
    inside a particular hypothesis H.

```

Tactic Notation "unsimpl" constr(E) "in" hyp(H) :=

let F := (eval simpl in E) in change F with E in H.

```

    unsimpl E in * applies unsimpl E everywhere possible.
    unsimpls E is a synonymous.

```

Tactic Notation "unsimpl" constr(E) "in" "*" :=

let F := (eval simpl in E) in change F with E in *.

Tactic Notation "unsimpls" constr(E) :=

unsimpl E in *.

```

    nosimpl t protects the Coq termt against some forms of
    simplification. See Gonthier's work for details on this trick.

```

Notation "'nosimpl' t" := (match tt with tt ⇒ t end)

(at level 10).

(* ---------------------------------------------------------------------- *)

```

## Reduction

```

Tactic Notation "hnfs" := hnf in *.

(* ---------------------------------------------------------------------- *)

```

## Substitution

    substs does the same as subst, except that it does not fail
    when there are circular equalities in the context.

```

Tactic Notation "substs" :=

repeat (match goal with H: ?x = ?y ⊢ _ ⇒

first [ subst x | subst y ] end).

```

    Implementation of substs below, which allows to call
    subst on all the hypotheses that lie beyond a given
    position in the proof context.

```

Ltac substs_below limit :=

match goal with H: ?T ⊢ _ ⇒

match T with

| limit ⇒ idtac

| ?x = ?y ⇒

first [ subst x; substs_below limit

| subst y; substs_below limit

| generalizes H; substs_below limit; intro ]

end end.

```

    substs below body E applies subst on all equalities that appear
    in the context below the first hypothesis whose body is E.
    If there is no such hypothesis in the context, it is equivalent
    to subst. For instance, if H is an hypothesis, then
    substs below H will substitute equalities below hypothesis H.

```

Tactic Notation "substs" "below" "body" constr(M) :=

substs_below M.

```

    substs below H applies subst on all equalities that appear
    in the context below the hypothesis named H. Note that
    the current implementation is technically incorrect since it
    will confuse different hypotheses with the same body.

```

Tactic Notation "substs" "below" hyp(H) :=

match type of H with ?M ⇒ substs below body M end.

```

    subst_hyp H substitutes the equality contained in the
    first hypothesis from the context.

```

Ltac intro_subst_hyp := fail. (* definition further on *)

```

    subst_hyp H substitutes the equality contained in H.

```

Ltac subst_hyp_base H :=

match type of H with

| (_,_,_,_,_) = (_,_,_,_,_) ⇒ injection H; clear H; do 4 intro_subst_hyp

| (_,_,_,_) = (_,_,_,_) ⇒ injection H; clear H; do 4 intro_subst_hyp

| (_,_,_) = (_,_,_) ⇒ injection H; clear H; do 3 intro_subst_hyp

| (_,_) = (_,_) ⇒ injection H; clear H; do 2 intro_subst_hyp

| ?x = ?x ⇒ clear H

| ?x = ?y ⇒ first [ subst x | subst y ]

end.

Tactic Notation "subst_hyp" hyp(H) := subst_hyp_base H.

Ltac intro_subst_hyp ::=

let H := fresh "TEMP" in intros H; subst_hyp H.

```

    intro_subst is a shorthand for intro H; subst_hyp H:
    it introduces and substitutes the equality at the head
    of the current goal.

```

Tactic Notation "intro_subst" :=

let H := fresh "TEMP" in intros H; subst_hyp H.

```

    subst_local substitutes all local definition from the context

```

Ltac subst_local :=

repeat match goal with H:=_ ⊢ _ ⇒ subst H end.

```

    subst_eq E takes an equality x = t and replace x
    with t everywhere in the goal

```

Ltac subst_eq_base E :=

let H := fresh "TEMP" in lets H: E; subst_hyp H.

Tactic Notation "subst_eq" constr(E) :=

subst_eq_base E.

(* ---------------------------------------------------------------------- *)

```

## Tactics to Work with Proof Irrelevance

```

Require Import ProofIrrelevance.

```

    pi_rewrite E replaces E of type Prop with a fresh
    unification variable, and is thus a practical way to
    exploit proof irrelevance, without writing explicitly
    rewrite (proof_irrelevance E E'). Particularly useful
    when E' is a big expression.

```

Ltac pi_rewrite_base E rewrite_tac :=

let E' := fresh in let T := type of E in evar (E':T);

rewrite_tac (@proof_irrelevance _ E E'); subst E'.

Tactic Notation "pi_rewrite" constr(E) :=

pi_rewrite_base E ltac:(fun X ⇒ rewrite X).

Tactic Notation "pi_rewrite" constr(E) "in" hyp(H) :=

pi_rewrite_base E ltac:(fun X ⇒ rewrite X in H).

(* ---------------------------------------------------------------------- *)

```

## Proving Equalities

    Note: current implementation only supports up to arity 5 

    fequal is a variation on f_equal which has a better behaviour
    on equalities between n-ary tuples.

```

Ltac fequal_base :=

let go := f_equal; [ fequal_base | ] in

match goal with

| ⊢ (_,_,_) = (_,_,_) ⇒ go

| ⊢ (_,_,_,_) = (_,_,_,_) ⇒ go

| ⊢ (_,_,_,_,_) = (_,_,_,_,_) ⇒ go

| ⊢ (_,_,_,_,_,_) = (_,_,_,_,_,_) ⇒ go

| ⊢ _ ⇒ f_equal

end.

Tactic Notation "fequal" :=

fequal_base.

```

    fequals is the same as fequal except that it tries and solve
    all trivial subgoals, using reflexivity and congruence
    (as well as the proof-irrelevance principle).
    fequals applies to goals of the form f x[1] .. xN = f y[1] .. yN
    and produces some subgoals of the form xi = yi).

```

Ltac fequal_post :=

first [ reflexivity | congruence | apply proof_irrelevance | idtac ].

Tactic Notation "fequals" :=

fequal; fequal_post.

```

    fequals_rec calls fequals recursively.
    It is equivalent to repeat (progress fequals).

```

Tactic Notation "fequals_rec" :=

repeat (progress fequals).

(* ********************************************************************** *)

```

# Inversion

```

(* ---------------------------------------------------------------------- *)

```

## Basic Inversion

    invert keep H is same to inversion H except that it puts all the
    facts obtained in the goal. The keyword keep means that the
    hypothesis H should not be removed.

```

Tactic Notation "invert" "keep" hyp(H) :=

pose ltac_mark; inversion H; gen_until_mark.

```

    invert keep H as X[1] .. XN is the same as inversion H as ... except
    that only hypotheses which are not variable need to be named
    explicitely, in a similar fashion as introv is used to name
    only hypotheses.

```

Tactic Notation "invert" "keep" hyp(H) "as" simple_intropattern(I[1])：

invert keep H; introv I[1].

Tactic Notation "invert" "keep" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) :=

invert keep H; introv I[1] I[2].

Tactic Notation "invert" "keep" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) :=

invert keep H; introv I[1] I[2] I[3].

```

    invert H is same to inversion H except that it puts all the
    facts obtained in the goal and clears hypothesis H.
    In other words, it is equivalent to invert keep H; clear H.

```

Tactic Notation "invert" hyp(H) :=

invert keep H; clear H.

```

    invert H as X[1] .. XN is the same as invert keep H as X[1] .. XN
    but it also clears hypothesis H.

```

Tactic Notation "invert_tactic" hyp(H) tactic(tac) :=

let H' := fresh in rename H into H'; tac H'; clear H'.

Tactic Notation "invert" hyp(H) "as" simple_intropattern(I[1]) :=

invert_tactic H (fun H ⇒ invert keep H as I[1]).

Tactic Notation "invert" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) :=

invert_tactic H (fun H ⇒ invert keep H as I[1] I[2]).

Tactic Notation "invert" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) :=

invert_tactic H (fun H ⇒ invert keep H as I[1] I[2] I[3]).

(* ---------------------------------------------------------------------- *)

```

## Inversion with Substitution

    Our inversion tactics is able to get rid of dependent equalities
    generated by inversion, using proof irrelevance.

```

(* --we do not import Eqdep because it imports nasty hints automatically     Require Import Eqdep. *)

Axiom inj_pair2 :  (* is in fact derivable from the axioms in LibAxiom.v *)

∀(U : Type) (P : U → Type) (p : U) (x y : P p),

存在 T P p x = 存在 T P p y → x = y.

(* Proof using. apply Eqdep.EqdepTheory.inj_pair2. Qed.*)

Ltac inverts_tactic H i[1] i[2] i[3] i[4] i[5] i[6] :=

let rec go i[1] i[2] i[3] i[4] i[5] i[6] :=

match goal with

| ⊢ (ltac_Mark → _) ⇒ intros _

| ⊢ (?x = ?y → _) ⇒ let H := fresh in intro H;

first [ subst x | subst y ];

go i[1] i[2] i[3] i[4] i[5] i[6]

| ⊢ (existT ?P ?p ?x = existT ?P ?p ?y → _) ⇒

let H := fresh in intro H;

generalize (@inj_pair2 _ P p x y H);

clear H; go i[1] i[2] i[3] i[4] i[5] i[6]

| ⊢ (?P → ?Q) ⇒ i[1]; go i[2] i[3] i[4] i[5] i[6] ltac:(intro)

| ⊢ (∀_, _) ⇒ intro; go i[1] i[2] i[3] i[4] i[5] i[6]

end in

generalize ltac_mark; invert keep H; go i[1] i[2] i[3] i[4] i[5] i[6];

unfold eq' in *.

```

    inverts keep H is same to invert keep H except that it
    applies subst to all the equalities generated by the inversion.

```

Tactic Notation "inverts" "keep" hyp(H) :=

inverts_tactic H ltac:(intro) ltac:(intro) ltac:(intro)

ltac:(intro) ltac:(intro) ltac:(intro).

```

    inverts keep H as X[1] .. XN is the same as
    invert keep H as X[1] .. XN except that it applies subst to all the
    equalities generated by the inversion

```

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I[1]) :=

inverts_tactic H ltac:(intros I[1])

ltac:(intro) ltac:(intro) ltac:(intro) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) :=

inverts_tactic H ltac:(intros I[1]) ltac:(intros I[2])

ltac:(intro) ltac:(intro) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) :=

inverts_tactic H ltac:(intros I[1]) ltac:(intros I[2]) ltac:(intros I[3])

ltac:(intro) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4]) :=

inverts_tactic H ltac:(intros I[1]) ltac:(intros I[2]) ltac:(intros I[3])

ltac:(intros I[4]) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4])

simple_intropattern(I[5]) :=

inverts_tactic H ltac:(intros I[1]) ltac:(intros I[2]) ltac:(intros I[3])

ltac:(intros I[4]) ltac:(intros I[5]) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4])

simple_intropattern(I[5]) simple_intropattern(I[6]) :=

inverts_tactic H ltac:(intros I[1]) ltac:(intros I[2]) ltac:(intros I[3])

ltac:(intros I[4]) ltac:(intros I[5]) ltac:(intros I[6]).

```

    inverts H is same to inverts keep H except that it
    clears hypothesis H.

```

Tactic Notation "inverts" hyp(H) :=

inverts keep H; clear H.

```

    inverts H as X[1] .. XN is the same as inverts keep H as X[1] .. XN
    but it also clears the hypothesis H.

```

Tactic Notation "inverts_tactic" hyp(H) tactic(tac) :=

let H' := fresh in rename H into H'; tac H'; clear H'.

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I[1]) :=

invert_tactic H (fun H ⇒ inverts keep H as I[1]).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) :=

invert_tactic H (fun H ⇒ inverts keep H as I[1] I[2]).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) :=

invert_tactic H (fun H ⇒ inverts keep H as I[1] I[2] I[3]).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4]) :=

invert_tactic H (fun H ⇒ inverts keep H as I[1] I[2] I[3] I[4]).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4])

simple_intropattern(I[5]) :=

invert_tactic H (fun H ⇒ inverts keep H as I[1] I[2] I[3] I[4] I[5]).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4])

simple_intropattern(I[5]) simple_intropattern(I[6]) :=

invert_tactic H (fun H ⇒ inverts keep H as I[1] I[2] I[3] I[4] I[5] I[6]).

```

    inverts H as performs an inversion on hypothesis H, substitutes
    generated equalities, and put in the goal the other freshly-created
    hypotheses, for the user to name explicitly.
    inverts keep H as is the same except that it does not clear H.
TODO: reimplement inverts above using this one

```

Ltac inverts_as_tactic H :=

let rec go tt :=

match goal with

| ⊢ (ltac_Mark → _) ⇒ intros _

| ⊢ (?x = ?y → _) ⇒ let H := fresh "TEMP" in intro H;

first [ subst x | subst y ];

go tt

| ⊢ (existT ?P ?p ?x = existT ?P ?p ?y → _) ⇒

let H := fresh in intro H;

generalize (@inj_pair2 _ P p x y H);

clear H; go tt

| ⊢ (∀_, _) ⇒

intro; let H := get_last_hyp tt in mark_to_generalize H; go tt

end in

pose ltac_mark; inversion H;

generalize ltac_mark; gen_until_mark;

go tt; gen_to_generalize; unfolds ltac_to_generalize;

unfold eq' in *.

Tactic Notation "inverts" "keep" hyp(H) "as" :=

inverts_as_tactic H.

Tactic Notation "inverts" hyp(H) "as" :=

inverts_as_tactic H; clear H.

策略 符号 "inverts" 假设(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4])

simple_intropattern(I[5]) simple_intropattern(I[6]) simple_intropattern(I[7]) :=

inverts H as; introv I[1] I[2] I[3] I[4] I[5] I[6] I[7].

策略 符号 "inverts" 假设(H) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4])

simple_intropattern(I[5]) simple_intropattern(I[6]) simple_intropattern(I[7])

simple_intropattern(I[8]) :=

inverts H as; introv I[1] I[2] I[3] I[4] I[5] I[6] I[7] I[8].

```

    lets_inverts E as I[1] .. IN is intuitively equivalent to
    inverts E, with the difference that it applies to any 
    expression and not just to the name of an hypothesis.

```

Ltac lets_inverts_base E cont :=

let H := fresh "TEMP" in lets H: E; try cont H.

策略 符号 "lets_inverts" 构造(E) :=

lets_inverts_base E ltac:(fun H ⇒ inverts H).

策略 符号 "lets_inverts" 构造(E) "as" simple_intropattern(I[1]) :=

lets_inverts_base E ltac:(fun H ⇒ inverts H as I[1]).

策略 符号 "lets_inverts" 构造(E) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) :=

lets_inverts_base E ltac:(fun H ⇒ inverts H as I[1] I[2]).

策略 符号 "lets_inverts" 构造(E) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) :=

lets_inverts_base E ltac:(fun H ⇒ inverts H as I[1] I[2] I[3]).

策略 符号 "lets_inverts" 构造(E) "as" simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3]) simple_intropattern(I[4]) :=

lets_inverts_base E ltac:(fun H ⇒ inverts H as I[1] I[2] I[3] I[4]).

(* ---------------------------------------------------------------------- *)

```

## Injection with Substitution

    Underlying implementation of injects

```

Ltac injects_tactic H :=

let rec go _ :=

match goal with

| ⊢ (ltac_Mark → _) ⇒ intros _

| ⊢ (?x = ?y → _) ⇒ let H := fresh in intro H;

first [ subst x | subst y | idtac ];

go tt

end in

generalize ltac_mark; injection H; go tt.

```

    injects keep H takes an hypothesis H of the form
    C a[1] .. aN = C b[1] .. bN and substitute all equalities
    ai = bi that have been generated.

```

策略 符号 "injects" "keep" 假设(H) :=

injects_tactic H.

```

    injects H is similar to injects keep H but clears
    the hypothesis H.

```

策略 符号 "injects" 假设(H) :=

injects_tactic H; clear H.

```

    inject H as X[1] .. XN is the same as injection
    followed by intros X[1] .. XN

```

策略 符号 "inject" 假设(H) :=

injection H.

策略 符号 "inject" 假设(H) "as" 标识符(X[1]) :=

injection H; intros X[1].

策略 符号 "inject" 假设(H) "as" 标识符(X[1]) 标识符(X[2]) :=

injection H; intros X[1] X[2].

策略 符号 "inject" 假设(H) "as" 标识符(X[1]) 标识符(X[2]) 标识符(X[3]) :=

injection H; intros X[1] X[2] X[3].

策略 符号 "inject" 假设(H) "as" 标识符(X[1]) 标识符(X[2]) 标识符(X[3])

标识符(X[4]) :=

injection H; intros X[1] X[2] X[3] X[4].

策略 符号 "inject" 假设(H) "as" 标识符(X[1]) 标识符(X[2]) 标识符(X[3])

标识符(X[4]) 标识符(X[5]) :=

injection H; intros X[1] X[2] X[3] X[4] X[5].

(* ---------------------------------------------------------------------- *)

```

## Inversion and Injection with Substitution —rough implementation

    The tactics inversions and injections provided in this section
    are similar to inverts and injects except that they perform
    substitution on all equalities from the context and not only
    the ones freshly generated. The counterpart is that they have
    simpler implementations. 

    inversions keep H is the same as inversions H but it does
    not clear hypothesis H.

```

策略 符号 "inversions" "keep" 假设(H) :=

inversion H; subst.

```

    inversions H is a shortcut for inversion H followed by subst
    and clear H.
    It is a rough implementation of inverts keep H which behave
    badly when the proof context already contains equalities.
    It is provided in case the better implementation turns out to be
    too slow.

```

策略 符号 "inversions" 假设(H) :=

inversion H; subst; clear H.

```

    injections keep H is the same as injection H followed
    by intros and subst. It is a rough implementation of
    injects keep H which behave
    badly when the proof context already contains equalities,
    or when the goal starts with a forall or an implication.

```

策略 符号 "injections" "keep" 假设(H) :=

injection H; intros; subst.

```

    injections H is the same as injection H followed
    by intros and clear H and subst. It is a rough
    implementation of injects keep H which behave
    badly when the proof context already contains equalities,
    or when the goal starts with a forall or an implication.

```

策略 符号 "injections" "keep" 假设(H) :=

injection H; clear H; intros; subst.

(* ---------------------------------------------------------------------- *)

```

## Case Analysis

    cases is similar to case_eq E except that it generates the
    equality in the context and not in the goal, and generates the
    equality the other way round. The syntax cases E as H
    allows specifying the name H of that hypothesis.

```

策略 符号 "cases" 构造(E) "as" 标识符(H) :=

令 X := fresh "TEMP" in

end。

destruct X。

战术记号 "cases_if" "as" simple_intropattern(Eq) :=

| {_}+{_} ⇒ destruct E as [Eq | Eq]

```

    case_if_post is to be defined later as a tactic to clean
    up goals. By defaults, it looks for obvious contradictions. 
    Currently, this tactic is extended in LibReflect to clean up
    boolean propositions.

```

cases_if_on B as Eq end。

```

    case_if looks for a pattern of the form if ?B then ?E[1] else ?E[2]
    in the goal, and perform a case analysis on B by calling
    destruct B. Subgoals containing a contradiction are discarded.
    case_if looks in the goal first, and otherwise in the
    first hypothesis that contains and if statement.
    case_if in H can be used to specify which hypothesis to consider.
    Syntaxes case_if as Eq and case_if in H as Eq allows to name
    the hypothesis coming from the case analysis.

```

战术记号 "destruct_if" "in" hyp(H) :=

"as" simple_intropattern(Eq[1]) simple_intropattern(Eq[2]) :=

end

匹配目标 with

战术记号 "destruct_if" "as" simple_intropattern(Eq) :=

匹配 T with context [?E] ⇒

匹配目标 with

战术记号 "case_if_on" 战术记号 E "as" simple_intropattern(Eq) :=

令 Eq := fresh in case_if in H as Eq。

战术记号 "case_if_on" constr(E) "as" simple_intropattern(Eq) :=

end。

战术记号 "case_if" "as" simple_intropattern(Eq) :=

匹配目标 with

| ⊢ context [if ?B then _ else _] ⇒ case_if_on B as Eq

重复 case_if。

"as" simple_intropattern(Eq[1]) simple_intropattern(Eq[2]) :=

case_if_on_tactic_core E Eq; case_if_post。

匹配类型为 H 的目标 with context [if ?B then _ else _] ⇒

令 Eq := fresh in cases_if in H as Eq。

战术记号 "case_if" :=

令 Eq := fresh in case_if as Eq。

战术记号 "case_if" "in" hyp(H) :=

case_if_on_tactic E Eq。

```

    cases_if is similar to case_if with two main differences:
    if it creates an equality of the form x = y and then 
    substitutes it in the goal

```

Ltac cases_if_on_tactic_core E Eq :=

战术记号 "cases_if" "in" hyp(H) :=

| {_}+{_} ⇒ destruct E as [Eq | Eq]

| _ ⇒ 令 X := fresh in

end

destruct X

end。

Ltac cases_if_on_tactic E Eq :=

战术记号 "destruct_if_post" := tryfalse。

destruct X

cases_if_on_tactic E Eq。

destruct_if_post。

匹配目标 with

| K: context [if ?B then _ else _] ⊢ _ ⇒ cases_if_on B as Eq

cases_if_on B as Eq end。

匹配类型为 E 的目标 with

战术记号 "cases_if" "in" hyp(H) "as" simple_intropattern(Eq) :=

匹配 H 的类型为 context [if ?B then _ else _] ⇒

战术记号 "as" simple_intropattern(Eq[1]) simple_intropattern(Eq[2]) :=

战术记号 "cases_if" :=

| _ ⇒ constr:(E)

战术记号 "case_if_on" 战术记号 E "as" simple_intropattern(Eq) :=

| K: context [if ?B then _ else _] ⊢ _ ⇒ case_if_on B as Eq

```

    case_ifs is like repeat case_if

```

Ltac case_ifs_core :=

end。

设置 (X := E) in *; def_to_eq_sym X H E;

case_ifs_core。

```

    destruct_if looks for a pattern of the form if ?B then ?E[1] else ?E[2]
    in the goal, and perform a case analysis on B by calling
    destruct B. It looks in the goal first, and otherwise in the
    first hypothesis that contains and if statement.

```

战术记号 "case_ifs" :=

查找 T 的头匹配 :=

战术记号 "case_if_post" := tryfalse。

| {_}+{_} ⇒ destruct E as [Eq|Eq]; try subst_hyp Eq

| ⊢ context [if ?B then _ else _] ⇒ destruct B as [Eq[1]|Eq[2]]

| K: context [if ?B then _ else _] ⊢ _ ⇒ destruct B as [Eq[1]|Eq[2]]

end;

destruct_if_post。

战术记号 "destruct_if" "in" hyp(H)

| ⊢ context [if ?B then _ else _] ⇒ cases_if_on B as Eq

令 Eq := fresh in cases_if as Eq。

destruct B as [Eq[1]|Eq[2]] end;

| _ ⇒ 令 X := fresh in

战术记号 "destruct_if"

destruct_if as Eq Eq。

战术记号 "destruct_if" "in" hyp(H) "as" simple_intropattern(Eq) :=

战术记号 "cases_if_on" 战术记号 E "as" simple_intropattern(Eq) :=

战术记号 "destruct_if" :=

令 Eq := fresh "C" in destruct_if as Eq Eq。

destruct_if in H as Eq Eq。

匹配类型为 H 的目标 with context [if ?B then _ else _] ⇒

```

    BROKEN since v[8].5beta2.

    destruct_head_match performs a case analysis on the argument
    of the head pattern matching when the goal has the form
    match ?E with ... or match ?E with ... = _ or
    _ = match ?E with .... Due to the limits of Ltac, this tactic
    will not fail if a match does not occur. Instead, it might
    perform a case analysis on an unspecified subterm from the goal.
    Warning: experimental.

```

战术记号 "cases" constr(E) :=

end。

匹配 T with

| E ⇒ fail 1

令 H := fresh "Eq" in cases E as H。

匹配类型为 E 的目标 with

设置 (X := E) in *; def_to_eq_sym X H E;

Ltac destruct_head_match_core cont :=

cases_if_on_tactic_core E Eq; tryfalse; case_if_post。

| ⊢ ?T[1] = ?T[2] ⇒ first [ let E := find_head_match T[1] in cont E

| let E := find_head_match T[2] in cont E ]

| ⊢ ?T[1] ⇒ let E := find_head_match T[1] in cont E

end;

根据条件后处理。

策略记法"destruct_head_match" "as" simple_intropattern(I) :=

destruct_head_match_core ltac:(fun E ⇒ destruct E as I).

策略记法"destruct_head_match" :=

destruct_head_match_core ltac:(fun E ⇒ destruct E).

(**--provided for compatibility with remember *)

```

    cases' E is similar to case_eq E except that it generates the
    equality in the context and not in the goal. The syntax cases E as H
    allows specifying the name H of that hypothesis.

```

策略记法"cases'" constr(E) "as" ident(H) :=

let X := fresh "TEMP" in

set (X := E) in *; def_to_eq X H E;

destruct X.

策略记法"cases'" constr(E) :=

let x := fresh "Eq" in cases' E as H.

```

    cases_if' is similar to cases_if except that it generates
    the symmetric equality.

```

cases_if_on' E Eq :=

根据 E 的类型进行匹配

| {_}+{_} ⇒ destruct E as [Eq|Eq]; try subst_hyp Eq

| _ ⇒ let X := fresh in

sets_eq X Eq: E;

destruct X

end; 情况后处理。

策略记法"cases_if'" "as" simple_intropattern(Eq) :=

match goal with

| ⊢ context [if ?B then _ else _] ⇒ cases_if_on' B Eq

| K: context [if ?B then _ else _] ⊢ _ ⇒ cases_if_on' B Eq

end.

策略记法"cases_if'" :=

let Eq := fresh in cases_if' as Eq.

(* ********************************************************************** *)

```

# Induction

    inductions E is a shorthand for dependent induction E.
    inductions E gen X[1] .. XN is a shorthand for
    dependent induction E generalizing X[1] .. XN.

```

Require Import Coq.Program.Equality.

归纳后处理。

展开 eq'；

策略记法"inductions" ident(E) :=

依赖归纳 E; 归纳后处理��

策略记法"inductions" ident(E) "gen" ident(X[1]) :=

依赖归纳 E 通用于 X[1]; 归纳后处理。

策略记法"inductions" ident(E) "gen" ident(X[1]) ident(X[2]) :=

依赖归纳 E 通用于 X[1] X[2]; 归纳后处理。

策略记法"inductions" ident(E) "gen" ident(X[1]) ident(X[2])

ident(X[3]) :=

依赖归纳 E 通用于 X[1] X[2] X[3]; 归纳后处理。

策略记法"inductions" ident(E) "gen" ident(X[1]) ident(X[2])

ident(X[3]) ident(X[4]) :=

依赖归纳 E 通用于 X[1] X[2] X[3] X[4]; 归纳后处理。

策略记法"inductions" ident(E) "gen" ident(X[1]) ident(X[2])

ident(X[3]) ident(X[4]) ident(X[5]) :=

依赖归纳 E 通用于 X[1] X[2] X[3] X[4] X[5]; 归纳后处理。

策略记法"inductions" ident(E) "gen" ident(X[1]) ident(X[2])

ident(X[3]) ident(X[4]) ident(X[5]) ident(X[6]) :=

依赖归纳 E 通用于 X[1] X[2] X[3] X[4] X[5] X[6]; 归纳后处理。

策略记法"inductions" ident(E) "gen" ident(X[1]) ident(X[2])

ident(X[3]) ident(X[4]) ident(X[5]) ident(X[6]) ident(X[7]) :=

依赖归纳 E 通用于 X[1] X[2] X[3] X[4] X[5] X[6] X[7]; 归纳后处理。

策略记法"inductions" ident(E) "gen" ident(X[1]) ident(X[2])

ident(X[3]) ident(X[4]) ident(X[5]) ident(X[6]) ident(X[7]) ident(X[8]) :=

依赖归纳 E 通用于 X[1] X[2] X[3] X[4] X[5] X[6] X[7] X[8]; 归纳后处理。

```

    induction_wf IH: E X is used to apply the well-founded induction
    principle, for a given well-founded relation. It applies to a goal
    PX where PX is a proposition on X. First, it sets up the
    goal in the form (fun a ⇒ P a) X, using pattern X, and then
    it applies the well-founded induction principle instantiated on E,
    where E is a term of type well_founded R, and R is a binary
    relation.
    Syntaxes induction_wf: E X and induction_wf E X.

```

策略记法"induction_wf" ident(IH) ":" constr(E) ident(X) :=

模式匹配 X; 应用 (well_founded_ind E); 清除 X; 引入 X IH。

策略记法"induction_wf" ":" constr(E) ident(X) :=

let IH := fresh "IH" in induction_wf IH: E X.

Tactic Notation "induction_wf" ":" constr(E) ident(X) :=

induction_wf: E X.

```

    Induction on the height of a derivation: the helper tactic
    induct_height helps proving the equivalence of the auxiliary 
    judgment that includes a counter for the maximal height
    (see LibTacticsDemos for an example)

```

Require Import Compare_dec Omega.

Lemma induct_height_max2 : ∀n[1] n[2] : nat,

∃n, n[1] < n ∧ n[2] < n.

Proof using.

intros. destruct (lt_dec n[1] n[2]).

∃(S n[2]). omega.

∃(S n[1]). omega.

Qed.

Ltac induct_height_step x :=

match goal with

| H: ∃_, _ ⊢ _ ⇒

let n := fresh "n" in let y := fresh "x" in

destruct H as [n ?];

forwards (y&?&?): induct_height_max2 n x;

induct_height_step y

| _ ⇒ ∃(S x); eauto

end.

Ltac induct_height := induct_height_step O.

(* ********************************************************************** *)

```

# Coinduction

    Tactic cofixs IH is like cofix IH except that the
    coinduction hypothesis is tagged in the form IH: COIND P
    instead of being just IH: P. This helps other tactics
    clearing the coinduction hypothesis using clear_coind

```

Definition COIND (P:Prop) := P.

Tactic Notation "cofixs" ident(IH) :=

cofix IH;

match type of IH with ?P ⇒ change P with (COIND P) in IH end.

```

    Tactic clear_coind clears all the coinduction hypotheses,
    assuming that they have been tagged

```

Ltac clear_coind :=

repeat match goal with H: COIND _ ⊢ _ ⇒ clear H end.

```

    Tactic abstracts tac is like abstract tac except that
    it clears the coinduction hypotheses so that the productivity
    check will be happy. For example, one can use abstracts omega
    to obtain the same behavior as omega but with an auxiliary
    lemma being generated.

```

Tactic Notation "abstracts" tactic(tac) :=

clear_coind; tac.

(* ********************************************************************** *)

```

# Decidable Equality

    decides_equality is the same as decide equality excepts that it
    is able to unfold definitions at head of the current goal.

```

Ltac decides_equality_tactic :=

first [ decide equality | progress(unfolds); decides_equality_tactic ].

Tactic Notation "decides_equality" :=

decides_equality_tactic.

(* ********************************************************************** *)

```

# Equivalence

    iff H can be used to prove an equivalence P ↔ Q and name H
    the hypothesis obtained in each case. The syntaxes iff and iff H[1] H[2]
    are also available to specify zero or two names. The tactic iff ← H
    swaps the two subgoals, i.e., produces (Q -> P) as first subgoal.

```

Lemma iff_intro_swap : ∀(P Q : Prop),

(Q → P) → (P → Q) → (P ↔ Q).

Proof using. intuition. Qed.

Tactic Notation "iff" simple_intropattern(H[1]) simple_intropattern(H[2]) :=

split; [ intros H[1] | intros H[2] ].

Tactic Notation "iff" simple_intropattern(H) :=

iff H H.

Tactic Notation "iff" :=

let H := fresh "H" in iff H.

Tactic Notation "iff" "←" simple_intropattern(H[1]) simple_intropattern(H[2]) :=

apply iff_intro_swap; [ intros H[1] | intros H[2] ].

Tactic Notation "iff" "←" simple_intropattern(H) :=

iff ← H H.

Tactic Notation "iff" "←" :=

let H := fresh "H" in iff ← H.

(* ********************************************************************** *)

```

# N-ary Conjunctions and Disjunctions

```

(* ---------------------------------------------------------------------- *)

```

    N-ary Conjunctions Splitting in Goals 

    Underlying implementation of splits.

```

Ltac splits_tactic N :=

match N with

| O ⇒ fail

| S O ⇒ idtac

| S ?N' ⇒ split; [| splits_tactic N']

end.

Ltac unfold_goal_until_conjunction :=

match goal with

| ⊢ _ ∧ _ ⇒ idtac

| _ ⇒ progress(unfolds); unfold_goal_until_conjunction

end.

Ltac get_term_conjunction_arity T :=

match T with

| _ ∧ _ ∧ _ ∧ _ ∧ _ ∧ _ ∧ _ ∧ _ ⇒ constr:(8)

| _ ∧ _ ∧ _ ∧ _ ∧ _ ∧ _ ∧ _ ⇒ constr:(7)

| _ ∧ _ ∧ _ ∧ _ ∧ _ ∧ _ ⇒ constr:(6)

| _ ∧ _ ∧ _ ∧ _ ∧ _ ⇒ constr:(5)

| _ ∧ _ ∧ _ ∧ _ ⇒ constr:(4)

| _ ∧ _ ∧ _ ⇒ constr:(3)

| _ ∧ _ ⇒ constr:(2)

| _ → ?T' ⇒ get_term_conjunction_arity T'

| _ ⇒ let P := get_head T in

let T' := eval unfold P in T in

match T' with

| T ⇒ fail 1

| _ ⇒ get_term_conjunction_arity T'

end

(* todo: warning this can loop... *)

end.

Ltac get_goal_conjunction_arity :=

match goal with ⊢ ?T ⇒ get_term_conjunction_arity T end.

```

    splits applies to a goal of the form (T[1] ∧ .. ∧ TN) and
    destruct it into N subgoals T[1] .. TN. If the goal is not a
    conjunction, then it unfolds the head definition.

```

Tactic Notation "splits" :=

unfold_goal_until_conjunction;

let N := get_goal_conjunction_arity in

splits_tactic N.

```

    splits N is similar to splits, except that it will unfold as many
    definitions as necessary to obtain an N-ary conjunction.

```

Tactic Notation "splits" constr(N) :=

let N := nat_from_number N in

splits_tactic N.

```

    splits_all will recursively split any conjunction, unfolding
    definitions when necessary. Warning: this tactic will loop
    on goals of the form well_founded R. Todo: fix this

```

Ltac splits_all_base := repeat split.

Tactic Notation "splits_all" :=

splits_all_base.

(* ---------------------------------------------------------------------- *)

```

    N-ary Conjunctions Deconstruction 

    Underlying implementation of destructs.

```

Ltac destructs_conjunction_tactic N T :=

match N with

| 2 ⇒ destruct T as [? ?]

| 3 ⇒ destruct T as [? [? ?]]

| 4 ⇒ destruct T as [? [? [? ?]]]

| 5 ⇒ destruct T as [? [? [? [? ?]]]]

| 6 ⇒ destruct T as [? [? [? [? [? ?]]]]

| 7 ⇒ destruct T as [? [? [? [? [? [? ?]]]]]]

end.

```

    destructs T allows destructing a term T which is a N-ary
    conjunction. It is equivalent to destruct T as (H[1] .. HN),
    except that it does not require to manually specify N different
    names.

```

Tactic Notation "destructs" constr(T) :=

let TT := type of T in

let N := get_term_conjunction_arity TT in

destructs_conjunction_tactic N T.

```

    destructs N T is equivalent to destruct T as (H[1] .. HN),
    except that it does not require to manually specify N different
    names. Remark that it is not restricted to N-ary conjunctions.

```

Tactic Notation "destructs" constr(N) constr(T) :=

let N := nat_from_number N in

destructs_conjunction_tactic N T.

(* ---------------------------------------------------------------------- *)

```

    Proving goals which are N-ary disjunctions 

    Underlying implementation of branch.

```

Ltac branch_tactic K N :=

match constr:((K,N)) with

| (_,0) ⇒ fail 1

| (0,_) ⇒ fail 1

| (1,1) ⇒ idtac

| (1,_) ⇒ left

| (S ?K', S ?N') ⇒ right; branch_tactic K' N'

end.

Ltac unfold_goal_until_disjunction :=

match goal with

| ⊢ _ ∨ _ ⇒ idtac

| _ ⇒ progress(unfolds); unfold_goal_until_disjunction

end.

Ltac get_term_disjunction_arity T :=

match T with

| _ ∨ _ ∨ _ ∨ _ ∨ _ ∨ _ ∨ _ ∨ _ ⇒ constr:(8)

| _ ∨ _ ∨ _ ∨ _ ∨ _ ∨ _ ∨ _ ⇒ constr:(7)

| _ ∨ _ ∨ _ ∨ _ ∨ _ ∨ _ ⇒ constr:(6)

| _ ∨ _ ∨ _ ∨ _ ∨ _ ⇒ constr:(5)

| _ ∨ _ ∨ _ ∨ _ ⇒ constr:(4)

| _ ∨ _ ∨ _ ⇒ constr:(3)

| _ ∨ _ ⇒ constr:(2)

| _ → ?T' ⇒ get_term_disjunction_arity T'

| _ ⇒ let P := get_head T in

let T' := eval unfold P in T in

match T' with

| T ⇒ fail 1

| _ ⇒ get_term_disjunction_arity T'

end

end.

Ltac get_goal_disjunction_arity :=

match goal with ⊢ ?T ⇒ get_term_disjunction_arity T end.

```

    branch N applies to a goal of the form
    P[1] ∨ ... ∨ PK ∨ ... ∨ PN and leaves the goal PK.
    It only able to unfold the head definition (if there is one),
    but for more complex unfolding one should use the tactic
    branch K of N.

```

Tactic Notation "branch" constr(K) :=

let K := nat_from_number K in

unfold_goal_until_disjunction;

let N := get_goal_disjunction_arity in

branch_tactic K N.

```

    branch K of N is similar to branch K except that the
    arity of the disjunction N is given manually, and so this
    version of the tactic is able to unfold definitions.
    In other words, applies to a goal of the form
    P[1] ∨ ... ∨ PK ∨ ... ∨ PN and leaves the goal PK.

```

Tactic Notation "branch" constr(K) "of" constr(N) :=

let N := nat_from_number N in

let K := nat_from_number K in

branch_tactic K N.

(* ---------------------------------------------------------------------- *)

```

    N-ary Disjunction Deconstruction 

    Underlying implementation of branches.

```

Ltac destructs_disjunction_tactic N T :=

match N with

| 2 ⇒ destruct T as [? | ?]

| 3 ⇒ destruct T as [? | [? | ?]]

| 4 ⇒ destruct T as [? | [? | [? | ?]]]

| 5 ⇒ destruct T as [? | [? | [? | [? | ?]]]]

end.

```

    branches T allows destructing a term T which is a N-ary
    disjunction. It is equivalent to destruct T as [ H[1] | .. | HN ] ,
    and produces N subgoals corresponding to the N possible cases. 

```

Tactic Notation "branches" constr(T) :=

let TT := type of T in

let N := get_term_disjunction_arity TT in

destructs_disjunction_tactic N T.

```

    branches N T is the same as branches T except that the arity is
    forced to N. This version is useful to unfold definitions
    on the fly.

```

Tactic Notation "branches" constr(N) constr(T) :=

let N := nat_from_number N in

destructs_disjunction_tactic N T.

(* ---------------------------------------------------------------------- *)

```

    N-ary Existentials

```

(* ∃的基础实现。*)

Ltac get_term_existential_arity T :=

match T with

| ∃x[1] x[2] x[3] x[4] x[5] x[6] x[7] x[8], _ ⇒ constr:(8)

| ∃x[1] x[2] x[3] x[4] x[5] x[6] x[7], _ ⇒ constr:(7)

| ∃x[1] x[2] x[3] x[4] x[5] x[6], _ ⇒ constr:(6)

| ∃x[1] x[2] x[3] x[4] x[5], _ ⇒ constr:(5)

| ∃x[1] x[2] x[3] x[4], _ ⇒ constr:(4)

| ∃x[1] x[2] x[3], _ ⇒ constr:(3)

| ∃x[1] x[2], _ ⇒ constr:(2)

| ∃x[1], _ ⇒ constr:(1)

| _ → ?T' ⇒ get_term_existential_arity T'

| _ ⇒ let P := get_head T in

让 T' := eval unfold P in T in

匹配 T' with

| T ⇒ 失败 1

| _ ⇒ 获取项存在性数目 T'

end

end。

Ltac 获取目标存在性数目 :=

匹配目标 with ⊢ ?T ⇒ 获取项存在性数目 T end。

```

    ∃ T[1] ... TN is a shorthand for ∃ T[1]; ...; ∃ TN.
    It is intended to prove goals of the form exist X[1] .. XN, P.
    If an argument provided is __ (double underscore), then an
    evar is introduced. ∃ T[1] .. TN ___ is equivalent to
    ∃ T[1] .. TN __ __ __ with as many __ as possible.

```

策略 Notation "存在原始" constr(T[1]) :=

∃T[1]。

策略 Notation "存在" constr(T[1]) :=

匹配 T[1] 与

| ltac_wild ⇒ esplit

| ltac_wilds ⇒ 重复 esplit

| _ ⇒ ∃T[1]

end。

策略 Notation "存在" constr(T[1]) constr(T[2]) :=

∃T[1]; ∃T[2]。

策略 Notation "存在" constr(T[1]) constr(T[2]) constr(T[3]) :=

∃T[1]; ∃T[2]; ∃T[3]。

策略 Notation "存在" constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4]) :=

∃T[1]; ∃T[2]; ∃T[3]; ∃T[4]。

策略 Notation "存在" constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4])

constr(T[5]) :=

∃T[1]; ∃T[2]; ∃T[3]; ∃T[4]; ∃T[5]。

策略 Notation "存在" constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4])

constr(T[5]) constr(T[6]) :=

∃T[1]; ∃T[2]; ∃T[3]; ∃T[4]; ∃T[5]; ∃T[6]。

(* 策略 exists___ N 是表示 ∃ __ ... __ 与 N 个双下划线。策略 ∃ 等同于调用 exists___ N，其中 N 的值通过在目标头部句法上存在的存在量进行计数获得。∃ 的行为与在目标是一个定义且只有在展开后才产生存在量的情况下的 ∃ ___ 的行为不同。 *)

策略 Notation "存在 ___" constr(N) :=

让 rec aux N :=

匹配 N 与

| 0 ⇒ idtac

| S ?N' ⇒ esplit; aux N'

end in

让 N := nat_from_number N in aux N。

(* todo: 废弃 *)

策略 Notation "存在 ___" :=

让 N := get_goal_existential_arity in

exists___ N。

(* todo: 似乎不起作用 *)

策略 Notation "存在" :=

存在 ___。

(* todo: exists_all 是 exists___ 的新语法 *)

策略 Notation "存在所有" := 存在 ___。

(* ---------------------------------------------------------------------- *)

```

    Existentials and conjunctions in hypotheses 

    unpack or unpack H destructs conjunctions and existentials in
    all or one hypothesis.

```

Ltac unpack_core :=

重复匹配目标 with

| H: _ ∧ _ ⊢ _ ⇒ 解构 H

| H: ∃a, _ ⊢ _ ⇒ 解构 H

end。

Ltac 从 H 解包 :=

首先 [ 进展 (unpack_core)

| 解构 H; unpack_core ]。

策略 Notation "解包" :=

unpack_core。

策略 Notation "解包" constr(H) :=

从 H 解包。

(* ********************************************************************** *)

```

# Tactics to Prove Typeclass Instances

    typeclass is an automation tactic specialized for finding
    typeclass instances.

```

策略 Notation "类型类" :=

让 go _ := eauto with typeclass_instances in

解决 [ go tt | 构造子; go tt ]。

```

    solve_typeclass is a simpler version of typeclass, to use
    in hint tactics for resolving instances

```

策略 Notation "解决类型类" :=

解决 [ eauto with typeclass_instances ]。

(* ********************************************************************** *)

```

# Tactics to Invoke Automation

```

(* ---------------------------------------------------------------------- *)

```

## Definitions for Parsing Compatibility

```

策略 Notation "f_equal" :=

f_equal。

策略 Notation "构造子" :=

构造子。

策略 Notation "简单" :=

简化。

策略 Notation "分割" :=

分割。

策略 Notation "右" :=

右。

策略 Notation "左" :=

左。

(* ---------------------------------------------------------------------- *)

```

## hint to Add Hints Local to a Lemma

    hint E adds E as an hypothesis so that automation can use it.
    Syntax hint E[1],..,EN is available

```

策略 Notation "提示" constr(E) :=

让 H := fresh "Hint" in lets H: E。

策略 Notation "提示" constr(E[1]) "," constr(E[2]) :=

提示 E[1]; 提示 E[2]。

策略符号“hint”constr(E[1])，“”constr(E[2])，“”constr(E[3]) :=

hint E[1]; hint E[2]; hint(E[3]).

策略符号“hint” constr(E[1])，“”constr(E[2])，“”constr(E[3])，“”constr(E[4]) :=

hint E[1]; hint E[2]; hint(E[3]); hint(E[4] ).

(* ---------------------------------------------------------------------- *)

```

## jauto, a New Automation Tactic

    jauto is better at intuition eauto because it can open existentials
    from the context. In the same time, jauto can be faster than
    intuition eauto because it does not destruct disjunctions from the
    context. The strategy of jauto can be summarized as follows:

*   open all the existentials and conjunctions from the context

*   call esplit and split on the existentials and conjunctions in the goal

*   call eauto.

```

策略符号“jauto” :=

尝试解决 [ jauto_set; eauto ].

策略符号“jauto_fast” :=

尝试解决 [ auto | eauto | jauto ].

```

    iauto is a shorthand for intuition eauto

```

策略符号“iauto” := 尝试解决 [intuition eauto].

(* ---------------------------------------------------------------------- *)

```

## Definitions of Automation Tactics

    The two following tactics defined the default behaviour of
    "light automation" and "strong automation". These tactics
    may be redefined at any time using the syntax Ltac .. ::= ... 

    auto_tilde is the tactic which will be called each time a symbol
    ¬ is used after a tactic.

```

Ltac auto_tilde_default := auto.

Ltac auto_tilde := auto_tilde_default.

```

    auto_star is the tactic which will be called each time a symbol
    * is used after a tactic.

```

(* SPECIAL VERSION FOR SF *)

Ltac auto_star_default := try solve [ jauto ].

Ltac auto_star := auto_star_default.

```

    autos¬ is a notation for tactic auto_tilde. It may be followed
    by lemmas (or proofs terms) which auto will be able to use
    for solving the goal.  autos is an alias for autos¬

```

策略符号“autos” :=

auto_tilde.

策略符号“autos”“¬” :=

auto_tilde.

策略符号“autos”“¬”constr(E[1]) :=

lets: E[1]; auto_tilde.

策略符号“autos”“¬”constr(E[1]) constr(E[2]) :=

lets: E[1]; lets: E[2]; auto_tilde.

策略符号“autos”“¬”constr(E[1]) constr(E[2]) constr(E[3]) :=

lets: E[1]; lets: E[2]; lets: E[3]; auto_tilde.

```

    autos* is a notation for tactic auto_star. It may be followed
    by lemmas (or proofs terms) which auto will be able to use
    for solving the goal.

```

策略符号“autos” "*" :=

auto_star.

策略符号“autos” "*" constr(E[1]) :=

lets: E[1]; auto_star.

策略符号“autos” "*" constr(E[1]) constr(E[2]) :=

lets: E[1]; lets: E[2]; auto_star.

策略符号“autos” "*" constr(E[1]) constr(E[2]) constr(E[3]) :=

lets: E[1]; lets: E[2]; lets: E[3]; auto_star.

```

    auto_false is a version of auto able to spot some contradictions.
    There is an ad-hoc support for goals in ↔: split is called first.
    auto_false¬ and auto_false* are also available.

```

Ltac auto_false_base cont :=

尝试解决 [

intros_all; try match goal with ⊢ _ ↔ _ ⇒ split end;

解决 [ cont tt | intros_all; false; cont tt ] ].

策略符号“auto_false” :=

auto_false_base ltac:(fun tt ⇒ auto).

策略符号“auto_false”“¬” :=

auto_false_base ltac:(fun tt ⇒ auto_tilde).

策略符号“auto_false” "*" :=

auto_false_base ltac:(fun tt ⇒ auto_star).

(* NOT NEEDED FOR SF (incompatible with V[8].4) Tactic Notation "dauto" := dintuition eauto. *)

(* ---------------------------------------------------------------------- *)

```

## Parsing for Light Automation

    Any tactic followed by the symbol ¬ will have auto_tilde called
    on all of its subgoals. Three exceptions:

*   cuts and asserts only call auto on their first subgoal,

*   apply¬ relies on sapply rather than apply,

*   tryfalse¬ is defined as tryfalse by auto_tilde.

    Some builtin tactics are not defined using tactic notations
   and thus cannot be extended, e.g., simpl and unfold.
   For these, notation such as simpl¬ will not be available.

```

策略符号“equates”“¬”constr(E) :=

equates E; auto_tilde.

策略符号“equates”“¬”constr(n[1]) constr(n[2]) :=

equates n[1] n[2]; auto_tilde.

策略符号“equates”“¬”constr(n[1]) constr(n[2]) constr(n[3]) :=

equates n[1] n[2] n[3]; auto_tilde.

策略符号“equates”“¬”constr(n[1]) constr(n[2]) constr(n[3]) constr(n[4]) :=

equates n[1] n[2] n[3] n[4]; auto_tilde.

策略符号“applys_eq”“¬”constr(H) constr(E) :=

applys_eq H E; auto_tilde.

策略符号“applys_eq”“¬”constr(H) constr(n[1]) constr(n[2]) :=

applys_eq H n[1] n[2]; auto_tilde.

策略符号“applys_eq”“¬”constr(H) constr(n[1]) constr(n[2]) constr(n[3]) :=

applys_eq H n[1] n[2] n[3]; auto_tilde.

策略符号“applys_eq”“¬”constr(H) constr(n[1]) constr(n[2]) constr(n[3]) constr(n[4]) :=

applys_eq H n[1] n[2] n[3] n[4]; auto_tilde.

策略符号“apply”“¬”constr(H) :=

sapply H; auto_tilde.

策略符号“destruct”“¬”constr(H) :=

destruct H; auto_tilde.

策略符号“分解”“¬”constr(H)“作为”simple_intropattern(I) :=

destruct H as I; auto_tilde.

策略符号“f_equal”“¬”:=

f_equal; auto_tilde.

策略符号“归纳”“¬”constr(H) :=

归纳 H; auto_tilde.

策略符号“反演”“¬”constr(H) :=

反演 H; auto_tilde.

策略符号“分割”“¬”:=

分割; auto_tilde.

策略符号“替换”“¬”:=

替换; auto_tilde.

策略符号“右”“¬”:=

右; auto_tilde.

策略符号“左”“¬”:=

左; auto_tilde.

策略符号“构造”“¬”:=

constructor; auto_tilde.

策略符号“构造”“¬”:=

构造函数; auto_tilde.

策略符号“错误”“¬”:=

false; auto_tilde.

策略符号“错误”“¬”constr(E) :=

false_then E ltac:(fun _ ⇒ auto_tilde).

策略符号“错误”“¬”constr(E[0]) constr(E[1]) :=

false¬ (>> E[0] E[1]).

策略符号“错误”“¬”constr(E[0]) constr(E[1]) constr(E[2]) :=

false¬ (>> E[0] E[1] E[2]).

策略符号“错误”“¬”constr(E[0]) constr(E[1]) constr(E[2]) constr(E[3]) :=

false¬ (>> E[0] E[1] E[2] E[3]).

策略符号“错误”“¬”constr(E[0]) constr(E[1]) constr(E[2]) constr(E[3]) constr(E[4]) :=

false¬ (>> E[0] E[1] E[2] E[3] E[4]).

策略符号“尝试错误”“¬”:=

尝试解决 [ false¬ ].

策略符号“断言”“¬”simple_intropattern(H)“：”constr(E) :=

断言 H: E; [ auto_tilde | idtac ].

策略符号“断言”“¬”：constr(E) :=

让 H := fresh "H" in asserts¬ H: E.

策略符号“切割”“¬”simple_intropattern(H)“：”constr(E) :=

切割 H: E; [ auto_tilde | idtac ].

策略符号“切割”“¬”：constr(E) :=

切割: E; [ auto_tilde | idtac ].

策略符号“lets”“¬”simple_intropattern(I)“：”constr(E) :=

lets I: E; auto_tilde.

策略符号“lets”“¬”simple_intropattern(I)“：”constr(E[0])

constr(A[1]) :=

lets I: E[0] A[1]; auto_tilde.

策略符号“lets”“¬”simple_intropattern(I)“：”constr(E[0])

constr(A[1]) constr(A[2]) :=

lets I: E[0] A[1] A[2]; auto_tilde.

策略符号“lets”“¬”simple_intropattern(I)“：”constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

lets I: E[0] A[1] A[2] A[3]; auto_tilde.

策略符号“lets”“¬”simple_intropattern(I)“：”constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

lets I: E[0] A[1] A[2] A[3] A[4]; auto_tilde.

策略符号“lets”“¬”simple_intropattern(I)“：”constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

lets I: E[0] A[1] A[2] A[3] A[4] A[5]; auto_tilde.

策略符号“lets”“¬”：constr(E) :=

lets: E; auto_tilde.

策略符号“lets”“¬”：constr(E[0])

constr(A[1]) :=

lets: E[0] A[1]; auto_tilde.

策略符号“lets”“¬”：constr(E[0])

constr(A[1]) constr(A[2]) :=

lets: E[0] A[1] A[2]; auto_tilde.

策略符号“lets”“¬”：constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

lets: E[0] A[1] A[2] A[3]; auto_tilde.

策略符号“lets”“¬”：constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

lets: E[0] A[1] A[2] A[3] A[4]; auto_tilde.

策略符号 "lets" "¬" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

lets: E[0] A[1] A[2] A[3] A[4] A[5]; auto_tilde.

策略符号 "forwards" "¬" simple_intropattern(I) ":" constr(E) :=

forwards I: E; auto_tilde.

策略符号 "forwards" "¬" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) :=

forwards I: E[0] A[1]; auto_tilde.

策略符号 "forwards" "¬" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

forwards I: E[0] A[1] A[2]; auto_tilde.

策略符号 "forwards" "¬" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

forwards I: E[0] A[1] A[2] A[3]; auto_tilde.

策略符号 "forwards" "¬" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

forwards I: E[0] A[1] A[2] A[3] A[4]; auto_tilde.

策略符号 "forwards" "¬" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

forwards I: E[0] A[1] A[2] A[3] A[4] A[5]; auto_tilde.

策略符号 "forwards" "¬" ":" constr(E) :=

forwards: E; auto_tilde.

策略符号 "forwards" "¬" ":" constr(E[0])

constr(A[1]) :=

forwards: E[0] A[1]; auto_tilde.

策略符号 "forwards" "¬" ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

forwards: E[0] A[1] A[2]; auto_tilde.

策略符号 "forwards" "¬" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

forwards: E[0] A[1] A[2] A[3]; auto_tilde.

策略符号 "forwards" "¬" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

forwards: E[0] A[1] A[2] A[3] A[4]; auto_tilde.

策略符号 "forwards" "¬" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

forwards: E[0] A[1] A[2] A[3] A[4] A[5]; auto_tilde.

策略符号 "applys" "¬" constr(H) :=

sapply H; auto_tilde. (*todo?*)

策略符号 "applys" "¬" constr(E[0]) constr(A[1]) :=

applys E[0] A[1]; auto_tilde.

策略符号 "applys" "¬" constr(E[0]) constr(A[1]) :=

applys E[0] A[1]; auto_tilde.

策略符号 "applys" "¬" constr(E[0]) constr(A[1]) constr(A[2]) :=

applys E[0] A[1] A[2]; auto_tilde.

策略符号 "applys" "¬" constr(E[0]) constr(A[1]) constr(A[2]) constr(A[3]) :=

applys E[0] A[1] A[2] A[3]; auto_tilde.

策略符号 "applys" "¬" constr(E[0]) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

applys E[0] A[1] A[2] A[3] A[4]; auto_tilde.

策略符号 "applys" "¬" constr(E[0]) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

applys E[0] A[1] A[2] A[3] A[4] A[5]; auto_tilde.

策略符号 "specializes" "¬" hyp(H) :=

specializes H; auto_tilde.

策略符号 "specializes" "¬" hyp(H) constr(A[1]) :=

specializes H A[1]; auto_tilde.

策略符号 "specializes" hyp(H) constr(A[1]) constr(A[2]) :=

specializes H A[1] A[2]; auto_tilde.

策略符号 "specializes" hyp(H) constr(A[1]) constr(A[2]) constr(A[3]) :=

specializes H A[1] A[2] A[3]; auto_tilde.

策略 Notation "specializes" hyp(H) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

特化 H A[1] A[2] A[3] A[4]; auto_tilde.

策略 Notation "specializes" hyp(H) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

特化 H A[1] A[2] A[3] A[4] A[5]; auto_tilde.

策略 Notation "fapply" "¬" constr(E) :=

fapply E; auto_tilde.

策略 Notation "sapply" "¬" constr(E) :=

sapply E; auto_tilde.

策略 Notation "logic" "¬" constr(E) :=

logic_base E ltac:(fun _ ⇒ auto_tilde).

策略 Notation "intros_all" "¬" :=

全部引入; auto_tilde.

策略 Notation "unfolds" "¬" :=

展开; auto_tilde.

策略 Notation "unfolds" "¬" constr(F[1]) :=

展开 F[1]; auto_tilde.

策略 Notation "unfolds" "¬" constr(F[1]) "," constr(F[2]) :=

展开 F[1], F[2]; auto_tilde.

策略 Notation "unfolds" "¬" constr(F[1]) "," constr(F[2]) "," constr(F[3]) :=

展开 F[1], F[2], F[3]; auto_tilde.

策略 Notation "unfolds" "¬" constr(F[1]) "," constr(F[2]) "," constr(F[3]) ","

构造(F[4]) :=

展开 F[1], F[2], F[3], F[4]; auto_tilde.

策略 Notation "simple" "¬" :=

简化; auto_tilde.

策略 Notation "simple" "¬" "in" hyp(H) :=

简化 H; auto_tilde.

策略 Notation "simpls" "¬" :=

简化; auto_tilde.

策略 Notation "hnfs" "¬" :=

hnfs; auto_tilde.

策略 Notation "hnfs" "¬" "in" hyp(H) :=

hnf 在 H; auto_tilde.

策略 Notation "substs" "¬" :=

替换; auto_tilde.

策略 Notation "intro_hyp" "¬" hyp(H) :=

替换假设 H; auto_tilde.

策略 Notation "intro_subst" "¬" :=

引入替换; auto_tilde.

策略 Notation "subst_eq" "¬" constr(E) :=

替换等式 E; auto_tilde.

策略 Notation "rewrite" "¬" constr(E) :=

重写 E; auto_tilde.

策略 Notation "rewrite" "¬" "←" constr(E) :=

重写 ← E; auto_tilde.

策略 Notation "rewrite" "¬" constr(E) "in" hyp(H) :=

重写 E 在 H; auto_tilde.

策略 Notation "rewrite" "¬" "←" constr(E) "in" hyp(H) :=

重写 ← E 在 H; auto_tilde.

策略 Notation "rewrites" "¬" constr(E) :=

重写 E; auto_tilde.

策略 Notation "rewrites" "¬" constr(E) "in" hyp(H) :=

重写 E 在 H; auto_tilde.

策略 Notation "rewrites" "¬" constr(E) "in" "*" :=

重写 E 在 *; auto_tilde.

策略 Notation "rewrites" "¬" "←" constr(E) :=

重写 ← E; auto_tilde.

策略 Notation "rewrites" "¬" "←" constr(E) "in" hyp(H) :=

重写 ← E 在 H; auto_tilde.

策略 Notation "rewrites" "¬" "←" constr(E) "in" "*" :=

重写 ← E 在 *; auto_tilde.

策略 Notation "rewrite_all" "¬" constr(E) :=

重写全部 E; auto_tilde.

策略 Notation "rewrite_all" "¬" "←" constr(E) :=

重写全部 ← E; auto_tilde.

策略 Notation "rewrite_all" "¬" constr(E) "in" ident(H) :=

重写全部 E 在 H; auto_tilde.

策略 Notation "rewrite_all" "¬" "←" constr(E) "in" ident(H) :=

重写全部 ← E 在 H; auto_tilde.

策略 Notation "rewrite_all" "¬" constr(E) "in" "*" :=

重写全部 E 在 *; auto_tilde.

策略 Notation "rewrite_all" "¬" "←" constr(E) "in" "*" :=

重写全部 ← E 在 *; auto_tilde.

策略 Notation "asserts_rewrite" "¬" constr(E) :=

断言重写 E; auto_tilde.

Tactic Notation "asserts_rewrite" "¬" "←" constr(E) := 

asserts_rewrite ← E; auto_tilde.

Tactic Notation "asserts_rewrite" "¬" constr(E) "in" hyp(H) := 

asserts_rewrite E in H; auto_tilde.

Tactic Notation "asserts_rewrite" "¬" "←" constr(E) "in" hyp(H) := 

asserts_rewrite ← E in H; auto_tilde.

Tactic Notation "asserts_rewrite" "¬" constr(E) "in" "*" := 

asserts_rewrite E in *; auto_tilde.

Tactic Notation "asserts_rewrite" "¬" "←" constr(E) "in" "*" := 

asserts_rewrite ← E in *; auto_tilde.

Tactic Notation "cuts_rewrite" "¬" constr(E) := 

cuts_rewrite E; auto_tilde.

Tactic Notation "cuts_rewrite" "¬" "←" constr(E) := 

cuts_rewrite ← E; auto_tilde.

Tactic Notation "cuts_rewrite" "¬" constr(E) "in" hyp(H) := 

cuts_rewrite E in H; auto_tilde.

Tactic Notation "cuts_rewrite" "¬" "←" constr(E) "in" hyp(H) := 

cuts_rewrite ← E in H; auto_tilde.

Tactic Notation "erewrite" "¬" constr(E) := 

erewrite E; auto_tilde.

Tactic Notation "fequal" "¬" := 

fequal; auto_tilde.

Tactic Notation "fequals" "¬" := 

fequals; auto_tilde.

Tactic Notation "pi_rewrite" "¬" constr(E) := 

pi_rewrite E; auto_tilde.

Tactic Notation "pi_rewrite" "¬" constr(E) "in" hyp(H) := 

pi_rewrite E in H; auto_tilde.

Tactic Notation "invert" "¬" hyp(H) := 

invert H; auto_tilde.

Tactic Notation "inverts" "¬" hyp(H) := 

inverts H; auto_tilde.

Tactic Notation "inverts" "¬" hyp(E) "as" := 

inverts E as; auto_tilde.

Tactic Notation "injects" "¬" hyp(H) := 

injects H; auto_tilde.

Tactic Notation "inversions" "¬" hyp(H) := 

inversions H; auto_tilde.

Tactic Notation "cases" "¬" constr(E) "as" ident(H) := 

cases E as H; auto_tilde.

Tactic Notation "cases" "¬" constr(E) := 

cases E; auto_tilde.

Tactic Notation "case_if" "¬" := 

case_if; auto_tilde.

Tactic Notation "case_ifs" "¬" := 

case_ifs; auto_tilde.

Tactic Notation "case_if" "¬" "in" hyp(H) := 

case_if in H; auto_tilde.

Tactic Notation "cases_if" "¬" := 

cases_if; auto_tilde.

Tactic Notation "cases_if" "¬" "in" hyp(H) := 

cases_if in H; auto_tilde.

Tactic Notation "destruct_if" "¬" := 

destruct_if; auto_tilde.

Tactic Notation "destruct_if" "¬" "in" hyp(H) := 

destruct_if in H; auto_tilde.

Tactic Notation "destruct_head_match" "¬" := 

destruct_head_match; auto_tilde.

Tactic Notation "cases'" "¬" constr(E) "as" ident(H) := 

cases' E as H; auto_tilde.

Tactic Notation "cases'" "¬" constr(E) := 

cases' E; auto_tilde.

Tactic Notation "cases_if'" "¬" "as" ident(H) := 

cases_if' as H; auto_tilde.

Tactic Notation "cases_if'" "¬" :=

cases_if'; auto_tilde.

Tactic Notation "decides_equality" "¬" := 

decides_equality; auto_tilde.

Tactic Notation "iff" "¬" := 

iff; auto_tilde.

Tactic Notation "splits" "¬" := 

splits; auto_tilde.

Tactic Notation "splits" "¬" constr(N) := 

splits N; auto_tilde.

Tactic Notation "splits_all" "¬" := 

splits_all; auto_tilde.

Tactic Notation "destructs" "¬" constr(T) := 

destructs T; auto_tilde.

Tactic Notation "destructs" "¬" constr(N) constr(T) := 

destructs N T; auto_tilde.

Tactic Notation "branch" "¬" constr(N) := 

branch N; auto_tilde.

Tactic Notation "branch" "¬" constr(K) "of" constr(N) :=

branch K of N；auto_tilde。

Tactic Notation "branches" "¬" constr(T) :=

branches T；auto_tilde。

Tactic Notation "branches" "¬" constr(N) constr(T) :=

branches N T；auto_tilde。

Tactic Notation "exists" "¬" :=

∃；auto_tilde。

Tactic Notation "exists___" "¬" :=

exists___；auto_tilde。

Tactic Notation "exists" "¬" constr(T[1]) :=

∃T[1]；auto_tilde。

Tactic Notation "exists" "¬" constr(T[1]) constr(T[2]) :=

∃T[1] T[2]；auto_tilde。

Tactic Notation "exists" "¬" constr(T[1]) constr(T[2]) constr(T[3]) :=

∃T[1] T[2] T[3]；auto_tilde。

Tactic Notation "exists" "¬" constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4]) :=

∃T[1] T[2] T[3] T[4]；auto_tilde。

Tactic Notation "exists" "¬" constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4])

constr(T[5]) :=

∃T[1] T[2] T[3] T[4] T[5]；auto_tilde。

Tactic Notation "exists" "¬" constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4])

constr(T[5]) constr(T[6]) :=

∃T[1] T[2] T[3] T[4] T[5] T[6]；auto_tilde。

(* ---------------------------------------------------------------------- *)

```

## Parsing for Strong Automation

    Any tactic followed by the symbol * will have auto* called
    on all of its subgoals. The exceptions to these rules are the
    same as for light automation.

    Exception: use subs* instead of subst* if you
    import the library Coq.Classes.Equivalence.

```

Tactic Notation "equates" "*" constr(E) :=

equates E；auto_star。

Tactic Notation "equates" "*" constr(n[1]) constr(n[2]) :=

equates n[1] n[2]；auto_star。

Tactic Notation "equates" "*" constr(n[1]) constr(n[2]) constr(n[3]) :=

equates n[1] n[2] n[3]；auto_star。

Tactic Notation "equates" "*" constr(n[1]) constr(n[2]) constr(n[3]) constr(n[4]) :=

equates n[1] n[2] n[3] n[4]；auto_star。

Tactic Notation "applys_eq" "*" constr(H) constr(E) :=

applys_eq H E；auto_star。

Tactic Notation "applys_eq" "*" constr(H) constr(n[1]) constr(n[2]) :=

applys_eq H n[1] n[2]；auto_star。

Tactic Notation "applys_eq" "*" constr(H) constr(n[1]) constr(n[2]) constr(n[3]) :=

applys_eq H n[1] n[2] n[3]；auto_star。

Tactic Notation "applys_eq" "*" constr(H) constr(n[1]) constr(n[2]) constr(n[3]) constr(n[4]) :=

applys_eq H n[1] n[2] n[3] n[4]；auto_star。

Tactic Notation "apply" "*" constr(H) :=

sapply H；auto_star。

Tactic Notation "destruct" "*" constr(H) :=

destruct H；auto_star。

Tactic Notation "destruct" "*" constr(H) "as" simple_intropattern(I) :=

destruct H as I；auto_star。

Tactic Notation "f_equal" "*" :=

f_equal；auto_star。

Tactic Notation "induction" "*" constr(H)：

induction H；auto_star。

Tactic Notation "inversion" "*" constr(H) :=

inversion H；auto_star。

Tactic Notation "split" "*" :=

split；auto_star。

Tactic Notation "subs" "*" :=

subst；auto_star。

Tactic Notation "subst" "*" :=

subst；auto_star。

Tactic Notation "right" "*" := 

right；auto_star。

Tactic Notation "left" "*" :=

left；auto_star。

Tactic Notation "constructor" "*" :=

constructor；auto_star。

Tactic Notation "constructors" "*" :=

constructors；auto_star。

Tactic Notation "false" "*" :=

false；auto_star。

Tactic Notation "false" "*" constr(E) :=

false_then E ltac:(fun _ ⇒ auto_star)。

Tactic Notation "false" "*" constr(E[0]) constr(E[1]) :=

false* (>> E[0] E[1])。

Tactic Notation "false" "*" constr(E[0]) constr(E[1]) constr(E[2]) :=

false* (>> E[0] E[1] E[2])。

策略符号 "false" "*" constr(E[0]) constr(E[1]) constr(E[2]) constr(E[3]) :=

false* (>> E[0] E[1] E[2] E[3]).

策略符号 "false" "*" constr(E[0]) constr(E[1]) constr(E[2]) constr(E[3]) constr(E[4]) :=

false* (>> E[0] E[1] E[2] E[3] E[4]).

策略符号 "tryfalse" "*" :=

尝试解决 [ false* ].

策略符号 "asserts" "*" simple_intropattern(H) ":" constr(E) :=

asserts H: E; [ auto_star | idtac ].

策略符号 "asserts" "*" ":" constr(E) :=

让 H := fresh "H" in asserts* H: E.

策略符号 "cuts" "*" simple_intropattern(H) ":" constr(E) :=

cuts H: E; [ auto_star | idtac ].

策略符号 "cuts" "*" ":" constr(E) :=

cuts: E; [ auto_star | idtac ].

策略符号 "lets" "*" simple_intropattern(I) ":" constr(E) :=

让 I: E; auto_star.

策略符号 "lets" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) :=

让 I: E[0] A[1]; auto_star.

策略符号 "lets" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

让 I: E[0] A[1] A[2]; auto_star.

策略符号 "lets" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

让 I: E[0] A[1] A[2] A[3]; auto_star.

策略符号 "lets" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

让 I: E[0] A[1] A[2] A[3] A[4]; auto_star.

策略符号 "lets" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

让 I: E[0] A[1] A[2] A[3] A[4] A[5]; auto_star.

策略符号 "lets" "*" ":" constr(E) :=

让: E; auto_star.

策略符号 "lets" "*" ":" constr(E[0])

constr(A[1]) :=

让: E[0] A[1]; auto_star.

策略符号 "lets" "*" ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

让: E[0] A[1] A[2]; auto_star.

策略符号 "lets" "*" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

让: E[0] A[1] A[2] A[3]; auto_star.

策略符号 "lets" "*" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

让: E[0] A[1] A[2] A[3] A[4]; auto_star.

策略符号 "lets" "*" ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

让: E[0] A[1] A[2] A[3] A[4] A[5]; auto_star.

策略符号 "forwards" "*" simple_intropattern(I) ":" constr(E) :=

forwards I: E; auto_star.

策略符号 "forwards" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) :=

forwards I: E[0] A[1]; auto_star.

策略符号 "forwards" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) :=

forwards I: E[0] A[1] A[2]; auto_star.

策略符号 "forwards" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) :=

forwards I: E[0] A[1] A[2] A[3]; auto_star.

策略符号 "forwards" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

forwards I: E[0] A[1] A[2] A[3] A[4]; auto_star.

策略符号 "forwards" "*" simple_intropattern(I) ":" constr(E[0])

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

forwards I: E[0] A[1] A[2] A[3] A[4] A[5]; auto_star.

策略符号“forwards”“*”：“constr(E)” :=

forwards: E; auto_star.

策略符号“forwards”“*”：“constr(E[0])”

constr(A[1]) :=

forwards: E[0] A[1]; auto_star.

策略符号“forwards”“*”：“constr(E[0])”

constr(A[1]) constr(A[2]) :=

forwards: E[0] A[1] A[2]; auto_star.

策略符号“forwards”“*”：“constr(E[0])”

constr(A[1]) constr(A[2]) constr(A[3]) :=

forwards: E[0] A[1] A[2] A[3]; auto_star.

策略符号“forwards”“*”：“constr(E[0])”

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

forwards: E[0] A[1] A[2] A[3] A[4]; auto_star.

策略符号“forwards”“*”：“constr(E[0])”

constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

forwards: E[0] A[1] A[2] A[3] A[4] A[5]; auto_star.

策略符号“applys”“*”constr(H) :=

sapply H; auto_star. (*todo?*)

策略符号“applys”“*”constr(E[0]) constr(A[1]) :=

applys E[0] A[1]; auto_star.

策略符号“applys”“*”constr(E[0]) constr(A[1]) :=

applys E[0] A[1]; auto_star.

策略符号“applys”“*”constr(E[0]) constr(A[1]) constr(A[2]) :=

applys E[0] A[1] A[2]; auto_star.

策略符号“applys”“*”constr(E[0]) constr(A[1]) constr(A[2]) constr(A[3]) :=

applys E[0] A[1] A[2] A[3]; auto_star.

策略符号“applys”“*”constr(E[0]) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

applys E[0] A[1] A[2] A[3] A[4]; auto_star.

策略符号“applys”“*”constr(E[0]) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

applys E[0] A[1] A[2] A[3] A[4] A[5]; auto_star.

策略符号“specializes”“*”hyp(H) :=

specializes H; auto_star.

策略符号“specializes”“¬”hyp(H) constr(A[1]) :=

specializes H A[1]; auto_star.

策略符号“specializes”hyp(H) constr(A[1]) constr(A[2]) :=

specializes H A[1] A[2]; auto_star.

策略符号“specializes”hyp(H) constr(A[1]) :=

specializes H A[1] A[2] A[3]; auto_star.

策略符号“specializes”hyp(H) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) :=

specializes H A[1] A[2] A[3] A[4]; auto_star.

策略符号“specializes”hyp(H) constr(A[1]) constr(A[2]) constr(A[3]) constr(A[4]) constr(A[5]) :=

specializes H A[1] A[2] A[3] A[4] A[5]; auto_star.

策略符号“fapply”“*”constr(E) :=

fapply E; auto_star.

策略符号“sapply”“*”constr(E) :=

sapply E; auto_star.

策略符号“logic”constr(E) :=

logic_base E ltac:(fun _ ⇒ auto_star).

策略符号“intros_all”“*” :=

intros_all; auto_star.

策略符号“unfolds”“*” :=

unfolds; auto_star.

策略符号“unfolds”“*”constr(F[1]) :=

unfolds F[1]; auto_star.

策略符号“unfolds”“*”constr(F[1])，“constr(F[2])” :=

展开 F[1], F[2]; auto_star.

策略符号“unfolds”“*”constr(F[1])，“constr(F[2])”，“constr(F[3])” :=

unfolds F[1], F[2], F[3]; auto_star.

策略符号“unfolds”“*”constr(F[1])，“constr(F[2])”，“constr(F[3])”，

constr(F[4]) :=

unfolds F[1], F[2], F[3], F[4]; auto_star.

策略记法 "simple" "*" :=

simpl; auto_star.

策略记法 "simple" "*" "in" hyp(H) :=

simpl in H; auto_star.

策略记法 "simpls" "*" :=

simpls; auto_star.

策略记法 "hnfs" "*" :=

hnfs; auto_star.

策略记法 "hnfs" "*" "in" hyp(H) :=

hnf in H; auto_star.

策略记法 "substs" "*" :=

substs; auto_star.

策略记法 "intro_hyp" "*" hyp(H) :=

subst_hyp H; auto_star.

策略记法 "intro_subst" "*" :=

intro_subst; auto_star.

策略记法 "subst_eq" "*" constr(E) :=

subst_eq E; auto_star.

策略记法 "rewrite" "*" constr(E) :=

rewrite E; auto_star.

策略记法 "rewrite" "*" "←" constr(E) :=

rewrite ← E; auto_star.

策略记法 "rewrite" "*" constr(E) "in" hyp(H) :=

rewrite E in H; auto_star.

策略记法 "rewrite" "*" "←" constr(E) "in" hyp(H) :=

rewrite ← E in H; auto_star.

策略记法 "rewrites" "*" constr(E) :=

rewrites E; auto_star.

策略记法 "rewrites" "*" constr(E) "in" hyp(H):=

rewrites E in H; auto_star.

策略记法 "rewrites" "*" constr(E) "in" "*":=

rewrites E in *; auto_star.

策略记法 "rewrites" "*" "←" constr(E) :=

rewrites ← E; auto_star.

策略记法 "rewrites" "*" "←" constr(E) "in" hyp(H):=

rewrites ← E in H; auto_star.

策略记法 "rewrites" "*" "←" constr(E) "in" "*":=

rewrites ← E in *; auto_star.

策略记法 "rewrite_all" "*" constr(E) :=

rewrite_all E; auto_star.

策略记法 "rewrite_all" "*" "←" constr(E) :=

rewrite_all ← E; auto_star.

策略记法 "rewrite_all" "*" constr(E) "in" ident(H) :=

rewrite_all E in H; auto_star.

策略记法 "rewrite_all" "*" "←" constr(E) "in" ident(H) :=

rewrite_all ← E in H; auto_star.

策略记法 "rewrite_all" "*" constr(E) "in" "*" :=

rewrite_all E in *; auto_star.

策略记法 "rewrite_all" "*" "←" constr(E) "in" "*" :=

rewrite_all ← E in *; auto_star.

策略记法 "asserts_rewrite" "*" constr(E) :=

asserts_rewrite E; auto_star.

策略记法 "asserts_rewrite" "*" "←" constr(E) :=

asserts_rewrite ← E; auto_star.

策略记法 "asserts_rewrite" "*" constr(E) "in" hyp(H) :=

asserts_rewrite E; auto_star.

策略记法 "asserts_rewrite" "*" "←" constr(E) "in" hyp(H) :=

asserts_rewrite ← E; auto_star.

策���记法 "asserts_rewrite" "*" constr(E) "in" "*" :=

asserts_rewrite E in *; auto_tilde.

策略记法 "asserts_rewrite" "*" "←" constr(E) "in" "*" :=

asserts_rewrite ← E in *; auto_tilde.

策略记法 "cuts_rewrite" "*" constr(E) :=

cuts_rewrite E; auto_star.

策略记法 "cuts_rewrite" "*" "←" constr(E) :=

cuts_rewrite ← E; auto_star.

策略记法 "cuts_rewrite" "*" constr(E) "in" hyp(H) :=

cuts_rewrite E in H; auto_star.

策略记法 "cuts_rewrite" "*" "←" constr(E) "in" hyp(H) :=

cuts_rewrite ← E in H; auto_star.

策略记法 "erewrite" "*" constr(E) :=

erewrite E; auto_star.

策略记法 "fequal" "*" :=

fequal; auto_star.

策略记法 "fequals" "*" :=

fequals; auto_star.

策略记法 "pi_rewrite" "*" constr(E) :=

pi_rewrite E; auto_star.

策略符号“pi_rewrite”“*”constr(E)“in”假设(H) :=

pi_rewrite E in H; auto_star.

策略符号“invert”“*”假设(H) :=

invert H; auto_star.

策略符号“inverts”“*”假设(H) :=

inverts H; auto_star.

策略符号“inverts”“*”假设(E)“as” :=

inverts E as; auto_star.

策略���号“injects”“*”假设(H) :=

injects H; auto_star.

策略符号“inversions”“*”假设(H)“as” :=

inversions H; auto_star.

策略符号“cases”“*”constr(E)“as”标识符(H) :=

cases E as H; auto_star.

策略符号“cases”“*”constr(E) :=

cases E; auto_star.

策略符号“case_if”“*” :=

case_if; auto_star.

策略符号“case_ifs”“*” :=

case_ifs; auto_star.

策略符号“case_if”“*”“in”假设(H) :=

case_if in H; auto_star.

策略符号“cases_if”“*” :=

cases_if; auto_star.

策略符号“cases_if”“*”“in”假设(H) :=

cases_if in H; auto_star.

策略符号“destruct_if”“*” :=

destruct_if; auto_star.

策略符号“destruct_if”“*”“in”假设(H) :=

destruct_if in H; auto_star.

策略符号“destruct_head_match”“*” :=

destruct_head_match; auto_star.

策略符号“cases'”“*”constr(E)“as”标识符(H) :=

cases' E as H; auto_star.

策略符号“cases'”“*”constr(E) :=

cases' E; auto_star.

策略符号“cases_if'”“*”“as”标识符(H) :=

cases_if' as H; auto_star.

策略符号“cases_if'”“*” :=

cases_if'; auto_star.

策略符号“decides_equality”“*” :=

decides_equality; auto_star.

策略符号“iff”“*” :=

iff; auto_star.

策略符号“iff”“*”simple_intropattern(I) :=

iff I; auto_star.

策略符号“splits”“*” :=

splits; auto_star.

策略符号“splits”“*”constr(N) :=

splits N; auto_star.

策略符号“splits_all”“*” :=

splits_all; auto_star.

策略符号“destructs”“*”constr(T) :=

destructs T; auto_star.

策略符号“destructs”“*”constr(N) constr(T) :=

destructs N T; auto_star.

策略符号“branch”“*”constr(N) :=

branch N; auto_star.

策略符号“branch”“*”constr(K)“of”constr(N)：

branch K of N; auto_star.

策略符号“branches”“*”constr(T) :=

branches T; auto_star.

策略符号“branches”“*”constr(N) constr(T) :=

branches N T; auto_star.

策略符号“exists”“*” :=

∃; auto_star.

策略符号“exists___”“*” :=

exists___; auto_star.

策略符号“exists”“*”constr(T[1]) :=

∃T[1]; auto_star.

策略符号“exists”“*”constr(T[1]) constr(T[2]) :=

∃T[1] T[2]; auto_star.

策略符号“exists”“*”constr(T[1]) constr(T[2]) constr(T[3]) :=

∃T[1] T[2] T[3]; auto_star.

策略符号“exists”“*”constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4]) :=

∃T[1] T[2] T[3] T[4]; auto_star.

策略符号“exists”“*”constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4])

constr(T[5]) :=

∃T[1] T[2] T[3] T[4] T[5]; auto_star.

策略符号“exists”“*”constr(T[1]) constr(T[2]) constr(T[3]) constr(T[4])

constr(T[5]) constr(T[6]) :=

∃T[1] T[2] T[3] T[4] T[5] T[6]; auto_star.

(* ********************************************************************** *)

```

# Tactics to Sort Out the Proof Context

```

(* ---------------------------------------------------------------------- *)

```

## Hiding Hypotheses

```

(* 实现 *)

定义 ltac_something (P:Type) (e:P) := e。

符号“Something” :=

(@ltac_something _ _)。

引理 ltac_something_eq: ∀(e:Type),

e = (@ltac_something _ e)。

Proof using. auto. Qed。

引理 ltac_something_hide: ∀(e:Type),

e → (@ltac_something _ e)。

Proof using. auto. Qed。

引理 ltac_something_show: ∀(e:Type),

(@ltac_something _ e) → e。

Proof using. auto. Qed。

```

    hide_def x and show_def x can be used to hide/show
    the body of the definition x.

```

策略符号“hide_def”假设(x) :=

让 x' := constr:(x)。

让 T := eval unfold x in x' in

在 x 中将 T 更改为(@ltac_something _ T)。

策略符号“show_def”假设(x) :=

让 x' := constr:(x)。

让 U := eval unfold x in x' in

匹配 U 与@ltac_something _ ?T ⇒

在 x 中将 U 更改为 T。

```

    show_def unfolds Something in the goal

```

策略符号“show_def” :=

展开 ltac_something。

策略符号“show_def”“in”假设(H) :=

在 H 中展开 ltac_something。

策略符号“show_def”“in”“*” :=

在*中展开 ltac_something。

```

    hide_defs and show_defs applies to all definitions

```

策略符号“hide_defs” :=

重复匹配目标中的 H := ?T ⊢ _ ⇒

匹配 T 与

| @ltac_something _ _ ⇒ 失败 1

| _ ⇒ 在 H 中更改 T 为(@ltac_something _ T)

end

end。

策略符号“show_defs” :=

重复匹配目标中的 H := (@ltac_something _ ?T) ⊢ _ ⇒

在 H 中更改 T 为(@ltac_something _ T)。

```

    hide_hyp H replaces the type of H with the notation Something
    and show_hyp H reveals the type of the hypothesis. Note that the
    hidden type of H remains convertible the real type of H.

```

策略符号“show_hyp”假设(H) :=

在 H 中应用 ltac_something_show。

策略符号“hide_hyp”假设(H) :=

在 H 中应用 ltac_something_hide。

```

    hide_hyps and show_hyps can be used to hide/show all hypotheses
    of type Prop.

```

策略符号“show_hyps” :=

重复匹配目标中的

H: @ltac_something _ _ ⊢ _ ⇒ show_hyp H end。

策略符号“hide_hyps” :=

重复匹配目标中的 H: ?T ⊢ _ ⇒

匹配 T 的类型为

| Prop ⇒

匹配 T 与

| @ltac_something _ _ ⇒ 失败 2

| _ ⇒ 隐藏假设 H

end

| _ ⇒ 失败 1

end

end。

```

    hide H and show H automatically select between
    hide_hyp or hide_def, and show_hyp or show_def.
    Similarly hide_all and show_all apply to all.

```

策略符号“hide”假设(H) :=

首先[hide_def H | hide_hyp H]。

策略符号“show”假设(H) :=

首先[show_def H | show_hyp H]。

策略符号“hide_all” :=

隐藏假设；隐藏定义。

策略符号“show_all” :=

在*中展开 ltac_something。

```

    hide_term E can be used to hide a term from the goal.
    show_term or show_term E can be used to reveal it.
    hide_term E in H can be used to specify an hypothesis.

```

策略符号“hide_term”constr(E) :=

更改 E 为(@ltac_something _ E)。

策略符号“show_term”constr(E) :=

在 x 中更改(@ltac_something _ E)为 E。

策略符号“show_term” :=

展开 ltac_something。

策略符号“hide_term”constr(E)“in”假设(H) :=

在 H 中更改 E 为(@ltac_something _ E)。

策略符号“show_term”constr(E)“in”假设(H) :=

在 H 中将(@ltac_something _ E)更改为 E��

策略符号“show_term”“in”假设(H) :=

在 H 中展开 ltac_something。

```

    show_unfold R unfolds the definition of R and
    reveals the hidden definition of R. —todo:test, 
    and implement using unfold simply

```

(* todo: 更改 "unfolds" *)

策略符号“show_unfold”constr(R[1]) :=

展开 R[1]；show_def。

策略符号“show_unfold”constr(R[1])，“constr(R[2])” :=

展开 R[1]，R[2]；show_def。

(* ---------------------------------------------------------------------- *)

```

## Sorting Hypotheses

    sort sorts out hypotheses from the context by moving all the
    propositions (hypotheses of type Prop) to the bottom of the context.

```

Ltac 排序策略 :=

尝试匹配目标中的 H: ?T ⊢ _ ⇒

匹配 T 的类型为 Prop ⇒

泛化 H；（尝试排序策略）；介绍

end end。

策略符号“sort” :=

排序策略。

(* ---------------------------------------------------------------------- *)

```

## Clearing Hypotheses

    clears X[1] ... XN is a variation on clear which clears
    the variables X[1]..XN as well as all the hypotheses which
    depend on them. Contrary to clear, it never fails.

```

策略标记 "清除" 标识符(X[1])：=

让 rec doit _ :=

匹配目标

| H:context[X[1]] ⊢ _ ⇒ 清除 H; 尝试（做 tt）

| _ ⇒ 清除 X[1]

end in doit tt。

策略标记 "清除" 标识符(X[1]) 标识符(X[2])：=

清除 X[1]; 清除 X[2]。

策略标记 "清除" 标识符(X[1]) 标识符(X[2]) 标识符(X[3])：=

清除 X[1]; 清除 X[2]; 清除 X[3]。

策略标记 "清除" 标识符(X[1]) 标识符(X[2]) 标识符(X[3]) 标识符(X[4])：=

清除 X[1]; 清除 X[2]; 清除 X[3]; 清除 X[4]。

策略标记 "清除" 标识符(X[1]) 标识符(X[2]) 标识符(X[3]) 标识符(X[4])

标识符(X[5])：=

清除 X[1]; 清除 X[2]; 清除 X[3]; 清除 X[4]; 清除 X[5]。

策略标记 "清除" 标识符(X[1]) 标识符(X[2]) 标识符(X[3]) 标识符(X[4])

标识符(X[5]) 标识符(X[6])：=

清除 X[1]; 清除 X[2]; 清除 X[3]; 清除 X[4]; 清除 X[5]; 清除 X[6]。

```

    clears (without any argument) clears all the unused variables
    from the context. In other words, it removes any variable
    which is not a proposition (i.e., not of type Prop) and which
    does not appear in another hypothesis nor in the goal.

```

（* todo: 重命名为清除变量？*）

Ltac 清除策略：=

匹配目标 H: ?T ⊢ _ ⇒

匹配 T 的类型为

| 命题 ⇒ 概括 H;（尝试清除策略）；引入

| ?TT ⇒ 清除 H;（尝试清除策略）

| ?TT ⇒ 概括 H;（尝试清除策略）；引入

end end。

策略标记 "清除"：=

清除策略。

```

    clears_all clears all the hypotheses from the context
    that can be cleared. It leaves only the hypotheses that
    are mentioned in the goal.

```

Ltac 清除或概括所有核心：=

重复匹配目标 H: _ ⊢ _ ⇒

首先 [清除 H | 概括 H] end。

策略标记 "清除所有"：=

generalize ltac_mark;

清除或概括所有核心；

intro_until_mark。

```

    clears_but H[1] H[2] .. HN clears all hypotheses except the
    one that are mentioned and those that cannot be cleared.

```

Ltac 清除但核心 cont：=

generalize ltac_mark;

cont tt;

清除或概括所有核心；

intro_until_mark。

策略标记 "清除但"：=

清除但保留核心 ltac:(fun _ ⇒ idtac)。

策略标记 "清除但" 标识符(H[1])：=

清除但核心 ltac:(fun _ ⇒ gen H[1])。

策略标记 "清除但" 标识符(H[1]) 标识符(H[2])：=

清除但核心 ltac:(fun _ ⇒ gen H[1] H[2])。

策略标记 "清除但" 标识符(H[1]) 标识符(H[2]) 标识符(H[3])：=

清除但核心 ltac:(fun _ ⇒ gen H[1] H[2] H[3])。

策略标记 "清除但" 标识符(H[1]) 标识符(H[2]) 标识符(H[3]) 标识符(H[4])：=

清除但核心 ltac:(fun _ ⇒ gen H[1] H[2] H[3] H[4])。

策略标记 "清除但" 标识符(H[1]) 标识符(H[2]) 标识符(H[3]) 标识符(H[4]) 标识符(H[5])：=

清除但核心 ltac:(fun _ ⇒ gen H[1] H[2] H[3] H[4] H[5])。

引理 demo_clears_all_and_clears_but：

∀x y:nat, y < 2 → x = x → x ≥ 2 → x < 3 → True。

Proof using。

introv M[1] M[2] M[3]。dup 6。

（* 清除所有假设。*）

清除所有。自动。

（* 清除但 H 清除除 H 外的所有 *）

清除但 M[3]。自动。

清除但 y。自动。

清除但 x。自动。

清除但 M[2] M[3]。自动。

清除但 x y。自动。

Qed。

```

    clears_last clears the last hypothesis in the context.
    clears_last N clears the last N hypotheses in the context.

```

策略标记 "清除最后"：=

匹配目标 H: ?T ⊢ _ ⇒ 清除 H end。

Ltac 清除最后基础 N：=

匹配 nat_from_number N with

| 0 ⇒ idtac

| S ?p ⇒ 清除最后; 清除最后基础 p

end。

策略标记 "清除最后" 构造(N)：=

清除最后的基础 N。

（* ********************************************************************** *）

```

# Tactics for Development Purposes

```

（* ---------------------------------------------------------------------- *）

```

## Skipping Subgoals

    DEPRECATED: the new "admit" tactics now works fine.

    The skip tactic can be used at any time to admit the current
    goal. Using skip is much more efficient than using the Focus
    top-level command to reach a particular subgoal.

    There are two possible implementations of skip. The first one
    relies on the use of an existential variable. The second one
    relies on an axiom of type False. Remark that the builtin tactic
    admit is not applicable if the current goal contains uninstantiated
    variables.

    The advantage of the first technique is that a proof using skip
    must end with Admitted, since Qed will be rejected with the message
    "uninstantiated existential variables". It is thereafter clear
    that the development is incomplete.

    The advantage of the second technique is exactly the converse: one
    may conclude the proof using Qed, and thus one saves the pain from
    renaming Qed into Admitted and vice-versa all the time.
    Note however, that it is still necessary to instantiate all the existential
    variables introduced by other tactics in order for Qed to be accepted.

    The two implementation are provided, so that you can select the one that
    suits you best. By default skip' uses the first implementation, and
    skip uses the second implementation.

```

Ltac 跳过带有存在性的 :=

匹配目标 ⊢ ?G ⇒

令 H := fresh in evar(H:G); eexact H end。

（* TO BE DEPRECATED：*）

参数 skip_axiom : False。

（* 为了获得安全的开发，更改为 skip_axiom：True *）

Ltac skip_with_axiom :=

消除假设假设 False; apply skip_axiom。

策略符号“skip” :=

skip_with_axiom。

策略符号“skip'” :=

skip_with_existential。

（* SF 不需要此 (* 为了向后兼容 *) 策略符号“admit” := skip. *)

```

    demo is like admit but it documents the fact that admit is intended

```

策略符号“demo” :=

skip。

```

    skip H: T adds an assumption named H of type T to the
    current context, blindly assuming that it is true.
    skip: T and skip H_asserts: T and skip_asserts: T
    are other possible syntax.
    Note that H may be an intro pattern.
    The syntax skip H[1] .. HN: T can be used when T is a
    conjunction of N items.

```

策略符号“skip” simple_intropattern(I)：“:” constr(T) :=

asserts I: T; [ skip | ]。

策略符号“skip”：“:” constr(T) :=

让 H := fresh in skip H: T。

策略符号“skip”、“¬”、“:” constr(T) :=

skip: T; auto_tilde。

策略符号“skip”“*”：“:” constr(T) :=

skip: T; auto_star。

策略符号“skip” simple_intropattern(I[1])

simple_intropattern(I[2])：“:” constr(T) :=

skip [I[1] I[2]]: T。

策略符号“skip” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])：“:” constr(T) :=

skip [I[1] [I[2] I[3]]]: T。

策略符号“skip” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4])：“:” constr(T) :=

skip [I[1] [I[2] [I[3] I[4]]]]: T。

策略符号“skip” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4]) simple_intropattern(I[5])：“:” constr(T) :=

skip [I[1] [I[2] [I[3] [I[4] I[5]]]]]: T。

策略符号“skip” simple_intropattern(I[1])

simple_intropattern(I[2]) simple_intropattern(I[3])

simple_intropattern(I[4]) simple_intropattern(I[5])

simple_intropattern(I[6])：“:” constr(T) :=

skip [I[1] [I[2] [I[3] [I[4] [I[5] I[6]]]]]]: T。

策略符号“skip_asserts” simple_intropattern(I)：“:” constr(T) :=

skip I: T。

策略符号“skip_asserts”：“:” constr(T) :=

skip: T。

```

    skip_cuts T simply replaces the current goal with T.

```

策略符号“skip_cuts” constr(T) :=

切割: T; [ skip | ]。

```

    skip_goal H applies to any goal. It simply assumes
    the current goal to be true. The assumption is named "H".
    It is useful to set up proof by induction or coinduction.
    Syntax skip_goal is also accepted.

```

策略符号“skip_goal” ident(H) :=

匹配目标 ⊢ ?G ⇒ skip H: G end。

策略符号“skip_goal” :=

让 IH := fresh "IH" in skip_goal IH。

```

    skip_rewrite T can be applied when T is an equality.
    It blindly assumes this equality to be true, and rewrite it in
    the goal.

```

策略符号“skip_rewrite” constr(T) :=

让 M := fresh in skip_asserts M: T; rewrite M; clear M。

```

    skip_rewrite T in H is similar as rewrite_skip, except that
    it rewrites in hypothesis H.

```

策略符号“skip_rewrite” constr(T)“in” hyp(H) :=

让 M := fresh in skip_asserts M: T; rewrite M in H; clear M。

```

    skip_rewrites_all T is similar as rewrite_skip, except that
    it rewrites everywhere (goal and all hypotheses).

```

策略符号“skip_rewrite_all” constr(T) :=

让 M := fresh in skip_asserts M: T; rewrite_all M; clear M。

```

    skip_induction E applies to any goal. It simply assumes
    the current goal to be true (the assumption is named "IH" by
    default), and call destruct E instead of induction E.
    It is useful to try and set up a proof by induction
    first, and fix the applications of the induction hypotheses
    during a second pass on the Proof using.

```

（* TODO：已弃用 *）

策略符号“skip_induction” constr(E) :=

让 IH := fresh "IH" in skip_goal IH; destruct E。

策略符号“skip_induction” constr(E)“as” simple_intropattern(I) :=

让 IH := fresh "IH" in skip_goal IH; destruct E as I。

（* ********************************************************************** *）

```

# Compatibility with Standard Library

    The module Program contains definitions that conflict with the
    current module. If you import Program, either directly or indirectly
    (e.g., through Setoid or ZArith), you will need to import the
    compability definitions through the top-level command:
    Import LibTacticsCompatibility.

```

模块 LibTacticsCompatibility。

策略符号“apply” * constr(H) :=

sapply H; auto_star。

策略符号“subst”“*” :=

替换; auto_star。

结束 LibTacticsCompatibility。

打开范围 nat_scope。

（* /DROP *）

```

```

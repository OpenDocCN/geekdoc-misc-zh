# 使用 curl

# 使用 curl

以前的章节描述了 curl 的一些基本细节以及有关基本命令行的一些内容。您使用命令行选项，并传递要处理的 URL。

在这一章中，我们将深入探讨 curl 能够做什么以及如何告诉 curl 使用这些功能的各种不同概念。您应该将所有这些功能都视为不同的工具，这些工具可以帮助您尽可能方便地执行文件传输任务。

## 支持的协议

curl 支持或可以支持（如果构建）以下协议。

DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、POP3、POP3S、RTMP、RTSP、SCP、SFTP、SMB、SMTP、SMTPS、TELNET 和 TFTP

# 详细

## 详细模式

如果您的 curl 命令未执行或未返回您期望的结果，您的第一反应应该始终是使用 `-v / --verbose` 选项运行命令以获取更多信息。

启用详细模式时，curl 会变得更健谈，并会解释和显示更多的操作。它将添加信息性测试，并用 '*' 前缀标记它们。例如，让我们看看在尝试一个简单的 HTTP 示例时 curl 可能会说些什么（将下载的数据保存在名为 'saved' 的文件中）：

```
$ curl -v http://example.com -o saved
* Rebuilt URL to: http://example.com/ 
```

Ok，所以我们使用一个 URL 调用 curl，它认为这个 URL 不完整，所以它帮助我们，在移动之前在其后添加一个尾随斜杠。

```
*   Trying 93.184.216.34... 
```

这告诉我们 curl 现在尝试连接到这个 IP 地址。这意味着名称 'example.com' 已经解析为一个或多个地址，这是 curl 将尝试连接的第一个（可能是唯一的）地址。

```
* Connected to example.com (93.184.216.34) port 80 (#0) 
```

成功了！curl 连接到了站点，这里解释了名称是如何映射到 IP 地址上以及它连接到了哪个端口。'(＃0)' 部分是 curl 给这个连接分配的内部编号。如果您在同一条命令行中尝试多个 URL，您可以看到它使用更多的连接或重复使用连接，因此连接计数器可能会增加或不增加，这取决于 curl 决定需要做什么。

如果我们使用 HTTPS:// URL 而不是 HTTP，还将有一大堆行解释 curl 如何使用 CA 证书来验证服务器的证书以及来自服务器证书的一些详细信息等。包括选择了哪些密码以及更多的 TLS 详细信息。

除了从 curl 内部添加的信息外，-v 详细模式还将使 curl 显示它发送和接收的所有标头。对于没有标头的协议（如 FTP、SMTP、POP3 等），我们可以将命令和响应视为标头，因此它们也将在 -v 中显示。

如果我们继续上面命令看到的输出（但忽略实际的 HTML 响应），curl 将显示：

```
> GET / HTTP/1.1
> Host: example.com
> User-Agent: curl/7.45.0
> Accept: */*
> 
```

这是发送到站点的完整 HTTP 请求。此请求在默认 curl 7.45.0 安装中的样子，当然，它可能在不同的发布版本之间略有不同，特别是如果您添加了命令行选项，它将发生变化。

HTTP 请求标头的最后一行是空的，确实如此。它表示标头和主体之间的分隔，在此请求中没有要发送的 "主体"。

接着假设一切顺利进行，发送的请求将会从服务器获得相应，并且 HTTP 响应在响应体之前会以一组标头开始：

```
< HTTP/1.1 200 OK
< Accept-Ranges: bytes
< Cache-Control: max-age=604800
< Content-Type: text/html
< Date: Sat, 19 Dec 2015 22:01:03 GMT
< Etag: "359670651"
< Expires: Sat, 26 Dec 2015 22:01:03 GMT
< Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT
< Server: ECS (ewr/15BD)
< Vary: Accept-Encoding
< X-Cache: HIT
< x-ec-custom-error: 1
< Content-Length: 1270
< 
```

对你来说，这可能大部分看起来像胡言乱语，但这是关于响应的一组正常的 HTTP 标头元数据。第一行的 "200" 可能是其中最重要的信息，表示 "一切正常"。

收到的标头的最后一行是空的，正如你所见，这是 HTTP 协议用来标志标头结束的标记。

在标头之后就是实际的响应体，即数据有效载荷。常规的 -v 详细模式不会显示该数据，只显示

```
{ [1270 bytes data] 
```

那 1270 字节应该在 'saved' 文件中。你还可以看到响应中有一个名为 Content-Length 的头，其中包含确切的文件长度（它不会总是出现在响应中）。

### --trace 和 --trace-ascii

有时候 `-v` 是不够的。特别是当你想要存储完整的流，包括实际传输的数据时。

对于使用 HTTPS、FTPS 或 SFTP 等协议进行加密文件传输的情况，其他网络监控工具（如 Wireshark 或 tcpdump）将无法像此工具那样轻松地为您执行此任务。

对此，curl 提供了另外两个选项，你可以使用它们代替 `-v`。

`--trace [filename]` 将在给定的文件名中保存完整的跟踪。你也可以使用 '-'（一个减号）代替文件名，将其传递到标准输出。你可以像这样使用它：

```
$ curl --trace dump http://example.com 
```

完成后，会有一个 'dump' 文件，它可能相当大。在这种情况下，转储文件的前 15 行看起来是这样的：

```
== Info: Rebuilt URL to: http://example.com/
== Info:   Trying 93.184.216.34...
== Info: Connected to example.com (93.184.216.34) port 80 (#0)
=> Send header, 75 bytes (0x4b)
0000: 47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a GET / HTTP/1.1..
0010: 48 6f 73 74 3a 20 65 78 61 6d 70 6c 65 2e 63 6f Host: example.co
0020: 6d 0d 0a 55 73 65 72 2d 41 67 65 6e 74 3a 20 63 m..User-Agent: c
0030: 75 72 6c 2f 37 2e 34 35 2e 30 0d 0a 41 63 63 65 url/7.45.0..Acce
0040: 70 74 3a 20 2a 2f 2a 0d 0a 0d 0a                pt: */*....
<= Recv header, 17 bytes (0x11)
0000: 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d HTTP/1.1 200 OK.
0010: 0a                                              .
<= Recv header, 22 bytes (0x16)
0000: 41 63 63 65 70 74 2d 52 61 6e 67 65 73 3a 20 62 Accept-Ranges: b
0010: 79 74 65 73 0d 0a                               ytes.. 
```

每一个发送和接收的字节都以十六进制数单独显示。

如果你觉得十六进制并没有帮助，你可以尝试使用 `--trace-ascii [filename]`，同时也接受使用 '-' 表示标准输出，这样跟踪的前 15 行看起来会是这样的：

```
== Info: Rebuilt URL to: http://example.com/
== Info:   Trying 93.184.216.34...
== Info: Connected to example.com (93.184.216.34) port 80 (#0)
=> Send header, 75 bytes (0x4b)
0000: GET / HTTP/1.1
0010: Host: example.com
0023: User-Agent: curl/7.45.0
003c: Accept: */*
0049:
<= Recv header, 17 bytes (0x11)
0000: HTTP/1.1 200 OK
<= Recv header, 22 bytes (0x16)
0000: Accept-Ranges: bytes
<= Recv header, 31 bytes (0x1f)
0000: Cache-Control: max-age=604800 
```

### --trace-time

这个选项将所有详细/跟踪输出的每一行都以高分辨率计时器作为前缀，用于打印行时。它与常规的 `-v / --verbose` 选项以及 `--trace` 和 `--trace-ascii` 一样有效。

一个例子可能是这样的：

```
$ curl -v --trace-time http://example.com
23:38:56.837164 * Rebuilt URL to: http://example.com/
23:38:56.841456 *   Trying 93.184.216.34...
23:38:56.935155 * Connected to example.com (93.184.216.34) port 80 (#0)
23:38:56.935296 > GET / HTTP/1.1
23:38:56.935296 > Host: example.com
23:38:56.935296 > User-Agent: curl/7.45.0
23:38:56.935296 > Accept: */*
23:38:56.935296 >
23:38:57.029570 < HTTP/1.1 200 OK
23:38:57.029699 < Accept-Ranges: bytes
23:38:57.029803 < Cache-Control: max-age=604800
23:38:57.029903 < Content-Type: text/html
---- snip ---- 
```

所有行都是本地时间，格式为小时：分钟：秒，然后是该秒内的微秒数。

### HTTP/2

当使用 HTTP 协议的第二个版本，HTTP/2 进行文件传输时，curl 发送和接收 **压缩** 标头。因此，为了以可读和可理解的方式显示出站和入站的 HTTP/2 标头，curl 实际上会显示未压缩版本，样式类似于 HTTP/1.1。

### --write-out

这是 curl 命令行选项库中经常被遗忘的一项宝藏之一。`--write-out` 或简写为 `-w`，在传输完成后输出信息，它具有一系列大量的变量，您可以在输出中包含这些变量，这些变量已经被设置为来自传输的值和信息。

通过将该字符串传递给此选项，您可以告诉 curl 写入一个字符串：

```
curl -w "formatted string" http://example.com/ 
```

…而且，如果你在字符串前加上 '@'，你还可以让 curl 从给定文件中读取该字符串：

```
curl -w @filename http://example.com/ 
```

…或者甚至让 curl 从标准输入读取字符串，如果您将文件名指定为 '-'：

```
curl -w @- http://example.com/ 
```

可通过在字符串中写入 `%{variable_name}` 来访问可用的变量，然后该变量将被正确的值替换。要输出普通的 '%'，只需将其写为 '%%'。您还可以通过使用 '\n' 输出换行符，使用 '\r' 输出回车符，使用 '\t' 输出制表符。

（在 Windows 命令行上，'%' 符号是特殊字符，在使用该选项时，所有出现的 % 必须加倍。）

举个例子，我们可以输出 HTTP 传输的 Content-Type 和响应代码，用换行符和一些额外的文本分隔，如下所示：

```
curl -w "Type: %{content_type}\nCode: %{response_code}\n" http://example.com 
```

此功能将输出写入 stdout，因此您可能希望确保您不将下载的内容也发送到 stdout，否则您可能很难分离数据。

#### 可用的 --write-out 变量

其中一些变量在非常旧的 curl 版本中不可用。

+   %{content_type} 显示请求文档的 Content-Type（如果有的话）。

+   %{filename_effective} 显示 curl 写出的最终文件名。只有在 curl 被告知使用 `--remote-name` 或 `--output` 选项写入文件时，这才有意义。与 `--remote-header-name` 选项结合使用时最有用。

+   %{ftp_entry_path} 显示 curl 登录到远程 FTP 服务器时所处的初始路径。

+   %{response_code} 显示在最后一次传输中找到的数字响应代码。

+   %{http_connect} 显示在 curl CONNECT 请求的最后响应（来自代理）中找到的数字代码。

+   %{local_ip} 显示最近完成的连接的本地端 IP 地址，可以是 IPv4 或 IPv6

+   %{local_port} 显示最近建立连接的本地端口号

+   %{num_connects} 显示最近传输中进行的新连接数。

+   %{num_redirects} 显示请求中遵循的重定向数量。

+   %{redirect_url} 显示在没有 `-L` 跟随重定向时，HTTP 请求实际上会将您重定向到的 URL。

+   %{remote_ip} 显示最近建立连接的远程 IP 地址，可以是 IPv4 或 IPv6。

+   %{remote_port} 显示最近建立连接的远程端口号。

+   %{size_download} 显示已下载的总字节数。

+   %{size_header} 显示已下载标头的总字节数。

+   %{size_request} 显示了在 HTTP 请求中发送的总字节数。

+   %{size_upload} 显示了上传的总字节数。

+   %{speed_download} 显示了 curl 测量的完成下载的平均下载速度（以字节每秒为单位）。

+   %{speed_upload} 显示了 curl 测量的完成上传的平均上传速度（以字节每秒为单位）。

+   %{ssl_verify_result} 显示了请求的 SSL 对等证书验证结果。0 表示验证成功。

+   %{time_appconnect} 显示了从开始到 SSL/SSH 等连接/握手到远程主机完成的时间（以秒为单位）。

+   %{time_connect} 显示了从开始到 TCP 连接到远程主机（或代理）完成所花费的时间（以秒为单位）。

+   %{time_namelookup} 显示了从开始到名称解析完成所花费的时间（以秒为单位）。

+   %{time_pretransfer} 显示了从开始到文件传输即将开始所花费的时间（以秒为单位）。这包括与涉及的特定协议相关的所有预传输命令和协商。

+   %{time_redirect} 显示了所有重定向步骤的时间（包括名称查找、连接、预传输和传输），直到最终事务开始的时间（以秒为单位）。time_redirect 显示了多次重定向的完整执行时间。

+   %{time_starttransfer} 显示了从开始到第一个字节即将传输的时间（以秒为单位）。这包括 time_pretransfer，以及服务器计算结果所需的时间。

+   %{time_total} 显示了完整操作持续的总时间（以秒为单位）。时间将以毫秒分辨率显示。

+   %{url_effective} 显示了最后获取的 URL。如果您已经告诉 curl 跟随 Location: 标头（使用 `-L` 参数），这将特别有意义。

### 沉默

与冗长相反，当然也可以让 curl 更加沉默。使用 `-s`（或 `--silent`）选项，您可以让 curl 关闭进度条，并且不输出任何错误消息（当发生错误时）。它会变得静音。它仍然会输出您要求的已下载数据。

使用激活沉默状态，您可以要求在失败时仍然输出错误消息，方法是添加 `-S` 或 `--show-error`。

# 持久连接

## 持久连接

当设置 TCP 连接到站点时，curl 会保持旧连接一段时间，以便如果下一个传输是到同一主机，则可以再次重用相同的连接，从而节省大量时间。我们称之为持久连接。curl 将始终尝试保持连接活动，并尽可能重用现有连接。

然而，curl 命令行工具只能在运行时保持连接处于活动状态，所以一旦退出回到你的命令行，它就必须关闭所有当前打开的连接（并且释放和清理它用来减少后续操作时间的所有其他缓存）。我们将活动连接池称为"连接缓存"。

如果你想对同一主机或同一基本 URL 执行 N 次传输或操作，那么尽量用尽可能少的 curl 命令行来尝试它们，而不是反复使用一个 URL 调用 curl。

# 下载

## 下载

"下载" 意味着从网络上的服务器获取数据，服务器显然被认为是"在上面"。这是从服务器加载数据到你正在运行 curl 的机器上。

下载可能是 curl 的最常见用法 —— 将 URL 指向的特定数据下载到你的计算机上。

### 到底是什么在下载？

你可以通过给 curl 一个 URL 来指定要下载的资源。curl 默认会下载一个 URL，除非另有指示，而 URL 标识了要下载的内容。在这个例子中，要下载的 URL 是 "[`example.com`](http://example.com)"：

```
curl http://example.com 
```

URL 被分解为其各个组件（如其他地方所述），正确的服务器被联系，然后被要求传送特定资源 —— 通常是一个文件。然后服务器传送数据，或者拒绝，或者客户端请求错误的数据，然后交付该数据。

对资源的请求是协议特定的，因此 FTP:// URL 的工作方式与 HTTP:// URL 或 SFTP:// URL 不同。

没有路径部分的 URL，即只有主机名部分的 URL（就像上面的 "[`example.com`](http://example.com)" 示例），将在内部附加一个斜杠('/')，然后这就是 curl 将要从服务器请求的资源。

如果你在命令行上指定了多个 URL，curl 将逐个下载每个 URL。它不会在第一个传输完成之前开始第二个传输，以此类推。

### 存储下载

如果你尝试像上一节那样执行示例下载，你会注意到 curl 会将下载的数据输出到 stdout，除非被告知做其他事情。将数据输出到 stdout 在你想要将其导入到另一个程序或类似情况时非常有用，但这并不总是处理下载的最佳方式。

给 curl 一个特定的文件名来保存下载内容，使用 `-o [filename]`（`--output` 是该选项的长版本），其中 filename 可以是文件名、相对路径到文件名或文件的完整路径。

还要注意，你可以将 `-o` 放在 URL 之前或之后；这没有区别：

```
curl -o output.html http://example.com/
curl -o /tmp/index.html http://example.com/
curl http://example.com -o ../../folder/savethis.html 
```

当然，这不仅限于 http:// URL，无论你下载哪种类型的 URL，它都以相同的方式工作：

```
curl -o file.txt ftp://example.com/path/to/file-name.ext 
```

如果你要求 curl 将输出发送到终端，它会尝试检测并阻止二进制数据发送到那里，因为那可能严重破坏你的终端（有时甚至会导致终端基本停止工作）。你可以通过使用`-o -`来覆盖 curl 的二进制输出防止机制，并强制输出发送到标准输出。

curl 有几种其他存储和命名下载数据的方式。详情见下文！

### 下载到由 URL 命名的文件

然而，许多 URL 已经包含了右端的文件名部分。curl 允许你使用这个作为快捷方式，所以你不必用 `-o` 重复它。所以，不是：

```
curl -o file.html http://example.com/file.html 
```

你可以用以下方式将远程 URL 资源保存到本地文件'file.html'中：

```
curl -O http://example.com/file.html 
```

这是 `-O`（大写字母 o）选项，或者长名称版本的 `--remote-name`。-O 选项通过选择你提供的 URL 的文件名部分来选择本地文件名。这很重要。你指定 URL，curl 从这个数据中选择名称。如果网站进一步重定向 curl（如果你告诉 curl 跟随重定向），它不会更改 curl 用于存储此数据的文件名。

### 从服务器获取目标文件名

HTTP 服务器在响应中提供了一个名为`Content-Disposition:`的头部选项。该头部可能包含一个建议的文件名，用于传送内容，并且 curl 可以被告知使用该提示来命名其本地文件。`-J / --remote-header-name`启用了这个选项。如果你还使用了`-O`选项，它会让 curl 默认使用 URL 中的文件名，并且*仅在*确实有有效的 Content-Disposition 头部可用时，才切换到使用该名称保存。

-J 有一些与之相关的问题和风险，用户需要注意：

1.  它将只使用建议文件名的最右端部分，因此服务器建议的任何路径或目录都将被剥离。

1.  由于文件名完全由服务器选择，如果服务器提供了这样的文件名，curl 当然会覆盖当前目录中的任何现有本地文件。

1.  文件名编码和字符集问题。curl 不以任何方式解码名称，所以你可能会得到一个 URL 编码的文件名，而浏览器否则会使用合理的字符集将其解码为更可读的东西。

### HTML 和字符集

curl 将下载服务器发送的确切二进制数据。这对你可能很重要，例如，你下载一个 HTML 页面或其他文本数据，该数据使用特定的字符编码，然后你的浏览器按预期显示。curl 将不会转换到达的数据。

一个常见的例子，这会导致一些令人惊讶的结果，是当用户下载一个网页，比如：

```
curl https://example.com/ -o storage.html 
```

…当事后检查 `storage.html` 文件时，用户意识到一个或多个字符看起来很奇怪或者完全错误。这很可能是因为服务器使用字符集 X 发送了字符，而你的编辑器和环境使用字符集 Y。在理想的情况下，我们都应该在所有地方使用 UTF-8，但不幸的是，情况仍然没有改变。

一个常见的解决方法是使用常见的 `iconv` 实用程序将文本文件在不同字符集之间进行转换。

### 压缩

curl 允许你要求 HTTP 和 HTTPS 服务器提供数据的压缩版本，然后在到达时对其进行自动解压缩。在带宽比 CPU 更有限的情况下，这将帮助你在更短的时间内接收更多的数据。

HTTP 压缩可以使用两种不同的机制来完成，一种可能被认为是“正确的方式”，另一种是每个人实际使用的方式，也是普遍和流行的方式！压缩 HTTP 内容的常见方式是使用 **Content-Encoding** 头。你可以让 curl 使用 `--compressed` 选项来使用它：

```
curl --compressed http://example.com/ 
```

启用此选项（如果服务器支持）会以压缩方式传送数据，curl 将在保存或发送到 stdout 之前对其进行解压缩。这通常意味着作为用户，你实际上并没有看到或体验到压缩，除非可能注意到传输速度更快。

`--compressed` 选项请求使用受支持的压缩算法进行 Content-Encoding 压缩。还有更罕见的 **Transfer-Encoding** 方法，这是为这种自动化方法创建的标头，但实际上从未真正被广泛采用。你可以告诉 curl 使用 `--tr-encoding` 来请求 Transfer-Encoded 压缩：

```
curl --tr-encoding http://example.com/ 
```

理论上，你可以在同一命令行中同时使用两种方式，但在实践中，你可能会发现一些服务器在被要求以两种不同方式压缩时会有些混乱。通常最安全的做法是选择其中一种。

### Shell 重定向

当你从 shell 或其他命令行提示系统调用 curl 时，该环境通常会为你提供一组输出重定向功能。在大多数 Linux 和 Unix shell 中，以及 Windows 的命令提示符中，你可以使用 `> filename` 将 stdout 重定向到文件。当然，使用这种方法使得使用 -o 或 -O 成为多余。

```
curl http://example.com/ > example.html 
```

将输出重定向到文件会将 curl 的所有输出都重定向到该文件，因此，即使你要求将多个 URL 传输到 stdout，重定向输出也会将所有 URL 的输出存储在单个文件中。

```
curl http://example.com/1 http://example.com/2 > files 
```

Unix shell 通常允许你单独重定向 *stderr* 流。stderr 流通常是在终端中显示的流，但你可以将其与 stdout 流分开重定向。stdout 流用于数据，而 stderr 是元数据和错误等，并非数据。你可以像这样使用 `2>file` 重定向 stderr：

```
curl http://example.com > files.html 2>errors 
```

### 多个下载

由于 curl 可以在单个命令行中告知下载许多 URL，当然也有时候您希望将这些下载存储在命名合理的本地文件中。

理解这一点的关键是每个下载 URL 都需要自己的“存储指令”。如果没有这样的“存储指令”，curl 将默认将数据发送到标准输出。如果您请求两个 URL 并且只告诉 curl 如何保存第一个 URL，那么第二个 URL 就会发送到标准输出。就像这样：

```
curl -o one.html http://example.com/1 http://example.com/2 
```

“存储指令”按照下载 URL 的顺序读取和处理，因此它们不必与 URL 相邻。您可以首先、最后或与 URL 交错地收集所有输出选项。由您决定！

这些示例都是相同的工作方式：

```
curl -o 1.txt -o 2.txt http://example.com/1 http://example.com/2
curl http://example.com/1 http://example.com/2 -o 1.txt -o 2.txt
curl -o 1.txt http://example.com/1 http://example.com/2 -o 2.txt
curl -o 1.txt http://example.com/1 -o 2.txt http://example.com/2 
```

`-O` 同样只是针对单个下载的指令，因此如果您下载多个 URL，请使用更多：

```
curl -O -O http://example.com/1 http://example.com/2 
```

### 对所有 URL 使用 URL 的文件名部分

为了应对在使用一百个 URL 时添加一百个 `-O` 选项的情况，我们引入了一个称为 `--remote-name-all` 的选项。这使 `-O` 成为所有给定 URL 的默认操作。您仍然可以为 URL 提供单独的“存储指令”，但是如果您在下载 URL 时没有提供其中一个的指令，那么默认操作就会从标准输出切换到 -O 样式。

### “我的浏览器显示其他内容”

非常常见的用例是使用 curl 获取一个 URL，当您将 URL 粘贴到浏览器的地址栏中时，您可以在浏览器中获取该 URL。

但是浏览器获取 URL 的方式和 curl 完全不同，curl 在终端输出中显示的内容可能与您在浏览器窗口中看到的完全不同。

#### 客户端差异

Curl 只会获取您要求获取的内容，它从不解析服务器传送的实际内容——数据。浏览器会获取数据并根据其认为获取的内容类型激活不同的解析器。例如，如果数据是 HTML，浏览器将解析它以显示网页，并可能下载其他子资源，如图像、JavaScript 和 CSS 文件。当 curl 下载 HTML 时，它只会获取该单个 HTML 资源，即使在浏览器解析时，它可能会触发大量其他下载。如果您希望 curl 也下载任何子资源，您需要将这些 URL 传递给 curl，并要求它获取这些资源，就像获取任何其他 URL 一样。

客户端在发送请求时也有所不同，请求资源的一些方面包括格式偏好、请求压缩数据，或者只是告诉服务器我们是从哪个先前的页面“跳转”过来的。curl 的请求方式可能与您的浏览器发送请求的方式有很大差异。

#### 服务器差异

接收请求并提供数据的服务器通常会根据它认为在与其通信的客户端的类型进行设置。有时候只是试图为客户端提供最佳内容，有时候是为了隐藏某些内容，有时甚至是为了尝试解决特定浏览器中已知的问题。当然，还有各种各样的登录系统，可能依赖于 HTTP 认证、cookies 或客户端来自预验证的 IP 地址范围。

有时候，使用 curl 从服务器得到与浏览器相同的响应是一项非常困难的工作。用户通常会使用浏览器的网络工具记录他们的浏览器会话，然后将该记录与 curl 的 `--trace-ascii` 选项记录的数据进行比较，并开始修改 curl 的请求（通常是使用 `-H / --header`），直到服务器开始对两者都做出相同的响应为止。

这种工作可能既耗时又烦琐。你应该始终征得服务器所有者或管理员的许可。

#### 中介的操纵

中介是代理，明确或隐式的。有些环境会强制你使用一个，或者出于各种原因你可能选择使用一个，但也有透明的中介，它们会在你不知情的情况下截取你的网络流量并为你代理，不管你想要什么。

代理是“中间人”，它终止流量然后代表你向远程服务器执行操作。这可能会引入各种显式的过滤，并“保存”你不希望访问的某些内容，甚至“保护”远程服务器免受你试图发送给它的数据的影响，但更重要的是，它引入了另一个软件对协议工作方式及正确操作的观点。

干扰性的中介往往是许多头痛和神秘的根源，甚至可能导致对内容进行明显恶意的修改。

我们强烈建议您使用 HTTPS 或其他手段验证您正在下载或上传的内容是否确实是远程服务器发送给您的数据，并且您宝贵的字节最终原样到达预期目的地。

### 速率限制

当 curl 传输数据时，它会尽可能快地进行。这适用于上传和下载。实际传输速度取决于几个因素，包括您的计算机性能、您自己的网络连接带宽、您正在传输数据到/从的远程服务器的负载以及与该服务器的延迟。此外，您的 curl 传输还可能与数据传输的网络上的其他传输竞争，这些传输可能来自其他用户或仅仅是同一用户的其他应用程序。

然而，在许多设置中，您可能会发现您几乎可以使用单个 curl 命令行饱和您自己的网络连接。如果您的互联网连接速度为每秒 10 兆比特，那么 curl 可能会使用所有这 10 兆比特来传输数据。

对于大多数用例来说，尽可能使用尽可能多的带宽是一件好事。它使传输更快，使 curl 命令更早完成，并且它将使传输在较短的时间内使用服务器资源。

有时你会发现，让 curl 在你的本地网络连接上饿死其他网络功能是不方便的。在这些情况下，你可能想告诉 curl 减慢速度，以便其他网络用户也有更好的机会通过。使用 `--limit-rate [speed]` 可以告诉 curl 不要超过每秒给定的字节数。速率限制值可以用 K、M 和 G 中的一个字母后缀给出，分别表示千字节、兆字节和千兆字节。

为了让 curl 下载数据不超过每秒 200 千字节：

```
curl https://example.com/ --limit-rate 200K 
```

给定的限制是在整个传输过程中允许的最大*平均速度*，在整个传输过程中计算。这意味着 curl 可能会在短时间内使用更高的传输速度，但随着时间的推移，它不会超过给定的速率。

另外要注意，curl 永远不知道最大可能的速度是多少——它只会尽可能快地下载，并且是被允许的速度。你可能知道你的连接的最大速度，但 curl 不知道。

### 最大文件大小

当你想确保你的 curl 命令行不会尝试下载一个太大的文件时，你可以在传输开始之前告诉 curl 在那之前停止，如果它在传输开始之前就知道文件大小的话！也许那会占用太多带宽，花费太长时间，或者你的硬盘空间不够：

```
curl --max-filesize 100000 https://example.com/ 
```

给 curl 一个你将接受的最大下载字节数，如果 curl 在传输开始之前能够确定大小，它将在尝试下载较大文件之前中止。

在许多情况下，curl 在传输开始时无法确定大小，此选项不会影响这些传输，即使它们可能最终比指定的数量大。

### Metalink

Metalink 是一个文件描述标准，告诉客户端同一内容的多个位置。然后客户端可以选择从这些位置中的一个或多个传输该内容。

当使用 `--metalink` 选项询问时，curl 支持 Metalink 格式。然后给定的 URL 应该指向一个 Metalink 文件。例如：

```
curl --metalink https://example.com/example.metalink 
```

如果出现错误（如文件或服务器不可用），curl 将使用文件中列出的镜像进行故障转移。下载完成后，它还将验证文件的哈希值。Metalink 文件本身在内存中下载和处理，并不存储在本地文件系统中。

### 在文件系统中存储元数据

当使用 curl 将下载保存到文件时，`--xattr` 选项告诉 curl 也在“扩展文件属性”中存储某些文件元数据。这些扩展属性基本上是标准化的名称/值对，存储在文件系统中，假设使用了其中一个受支持的文件系统和操作系统。

目前，URL 存储在 `xdg.origin.url` 属性中，对于 HTTP，内容类型存储在 `mime_type` 属性中。如果在设置此选项时文件系统不支持扩展属性，则会发出警告。

### 原始

当使用 `--raw` 时，它禁用所有内部 HTTP 内容或传输编码的解码，而是使 curl 传递未经更改的原始数据。

这通常用于您正在编写某种中间软件，并且希望将内容传递给可能是另一个 HTTP 客户端，并允许其进行解码。

### 重试失败的尝试

通常，curl 只会尝试执行一次传输，并在不成功时返回错误。使用 `--retry` 选项，您可以告诉 curl 重新尝试某些失败的传输。

如果 curl 尝试执行传输时返回瞬时错误，则在放弃之前将重试此次数。将数字设置为 0 使 curl 不进行重试（这是默认值）。瞬时错误意味着：超时、FTP 4xx 响应代码或 HTTP 5xx 响应代码。

当 curl 准备重试传输时，它将首先等待一秒钟，然后在所有接下来的重试中将等待时间加倍，直到达到 10 分钟，这将是其余重试之间的延迟。使用 `--retry-delay` 可以禁用此指数回退算法，并设置尝试之间的自定义延迟。使用 `--retry-max-time` 您可以限制重试的总时间。`--max-time` 选项仍将指定单个传输允许花费的最长时间。

### 继续和范围

恢复下载意味着首先检查本地已经存在的内容大小，然后要求服务器发送其余部分以便附加。curl 还允许在实际上本地没有任何内容的情况下从自定义点恢复传输。

curl 支持在多个协议上恢复下载。使用 `-C, --continue-at` 选项告诉它从哪里开始传输，可以是纯数字字节计数偏移量，也可以是字符串`-`，让 curl 根据自身所知自行确定。使用 `-` 时，curl 将使用目标文件名来确定本地已经存在多少数据，并将其作为从服务器请求更多数据时的偏移量。

要从字节偏移量为 100 的 FTP 文件开始下载：

```
curl --continue-at 100 ftp://example.com/bigfile 
```

继续下载先前中断的下载：

```
curl --continue-at - http://example.com/bigfile -O 
```

如果您只想从远程资源转移特定的字节范围，可以仅请求该范围。例如，当您只想要从偏移量为 100 的位置获取 1000 字节，以避免下载整个庞大的远程文件时：

```
curl --range 100-1999 http://example.com/bigfile 
```

# 上传

## 上传

上载是将数据发送到远程服务器的术语。每个协议的上传方式都不同，甚至几个协议可能允许以不同的方式上传数据。

### 允许上传的协议

你可以使用以下协议之一上传数据：FILE、FTP、FTPS、HTTP、HTTPS、IMAP、IMAPS、SCP、SFTP、SMB、SMBS、SMTP、SMTPS 和 TFTP。

### HTTP 提供了几种“上传”方式

HTTP（及其更大的兄弟 HTTPS）提供了将数据上传到服务器的几种不同方式，curl 提供了简单的命令行选项来进行这三种最常见的方式，如下所述。

HTTP 的一个有趣细节是，上传也可以是下载，在同一个操作中，事实上许多下载都是通过 HTTP POST 启动的。

#### POST

POST 是发明用于将数据发送到接收 Web 应用程序的 HTTP 方法，例如，这是 Web 上大多数常见 HTML 表单的工作方式。它通常向接收方发送相对较小量的数据块。

上传类型通常使用 `-d` 或 `--data` 选项进行，但也有一些其他的改变。

阅读关于如何使用 curl 进行此操作的详细描述，在 HTTP POST with curl 章节中。

#### 多部分表单提交

多部分表单提交也用于 Web 站点上的 HTML 表单；通常涉及文件上传时。这种类型的上传也是一个 HTTP POST，但它按照一些特殊规则格式化数据，这就是“多部分”的含义。

由于它发送的数据格式完全不同，你无法随心所欲地选择要使用的 POST 类型，而是完全取决于接收服务器端期望和能够处理的内容。

HTTP 多部分表单提交使用 `-F` 完成。请参阅 HTTP 多部分表单提交 章节中的详细描述。

#### PUT

HTTP PUT 是一种上传类型，旨在发送一个完整的资源，以原样放置在远程站点上，甚至替换那里的现有资源。话虽如此，这也是今天 Web 上最不常用的 HTTP 上传方法，并且许多，如果不是大多数，Web 服务器甚至没有启用 PUT。

使用 -T 选项发送 HTTP 上传，并附上要上传的文件：

```
curl -T uploadthis http://example.com/ 
```

### FTP 上传

在使用 FTP 时，你将看到你将要访问的远程文件系统。你告诉服务器确切地你希望将上传放置在哪个目录中以及使用哪个文件名。如果你在上传 URL 中指定了一个斜杠结尾的 URL，curl 将把本地使用的文件名附加到 URL 中，然后在远程存储时将使用该文件名：

```
curl -T uploadthis ftp://example.com/this/directory/ 
```

如果你喜欢在远程端选择一个与本地使用不同的文件名，你可以在 URL 中指定：

```
curl -T uploadthis ftp://example.com/this/directory/remotename 
```

在 Using curl/FTP 部分了解更多关于使用 curl 进行 FTP 的信息。

### SMTP 上传

你可能不认为发送电子邮件是“上传”，但对于 curl 而言是的。你将邮件正文上传到 SMTP 服务器。使用 SMTP，你还需要在邮件正文中包含所有你需要的电子邮件头部（收件人、发件人、日期等），因为 curl 不会添加任何内容。

```
curl -T mail smtp://mail.example.com/ --mail-from user@example.com 
```

在 Using curl/SMTP 部分了解更多关于使用 curl 进行 SMTP 的信息。

### 上传的进度条

curl 提供的通用进度表（请参阅进度表部分）对上传也有效。需要记住的是，当您将输出发送到 stdout 时，进度表会自动禁用，curl 支持的大多数协议甚至可以为上传输出一些内容。

因此，您可能需要显式地将下载的数据重定向到一个文件（使用 shell 重定向 '>', `-o` 或类似的）以便上传时显示进度表。

### 速率限制

速率限制对上传和下载完全相同，而 curl 实际上只有一个限制，它会限制两个方向的速度。

请参阅下载速率限制部分以获取更多详细信息。

# 连接

# 连接

您使用 curl 时大多数协议都会使用 TCP 进行通信。使用 TCP 时，如 curl 等客户端必须首先找出您要通信的主机的 IP 地址，然后连接到它。"连接到它" 意味着执行 TCP 协议握手。

对于普通的命令行使用，对 URL 进行操作，这些都是在幕后处理的细节，你大多数时候可以忽略这些。但有时您可能会发现自己想要微调细节...

## 名称解析技巧

### 编辑 hosts 文件

也许你希望命令 `curl http://example.com` 连接到你的本地服务器而不是实际的服务器。

你可以通过编辑你的 `hosts` 文件（Linux 和 Unix 系统上的 `/etc/hosts`）并添加，例如，`127.0.0.1 example.com` 来将主机重定向到你的 localhost。然而，这种编辑需要管理员访问权限，并且它的缺点是同时影响所有其他应用程序。

### 更改 Host: 标头

Host: 标头是 HTTP 客户端告诉 HTTP 服务器它要与哪个服务器通信的正常方式，因为通常一个 HTTP 服务器使用同一软件实例为许多不同的名称提供服务。

因此，通过传递一个自定义修改的 Host: 标头，即使您实际上没有连接到该主机名，您也可以让服务器响应站点的内容。

例如，您在本地机器上运行主站的测试实例`www.example.com`，并且您希望 curl 请求索引 html：

```
curl -H "Host: www.example.com" http://localhost/ 
```

在设置自定义 Host: 标头并使用 cookie 时，curl 将提取自定义名称并将其用作与发送 cookie 匹配的主机。

在与 HTTPS 服务器通信时，Host: 标头是不够的。对于 HTTPS，TLS 协议中有一个名为 SNI（服务器名称指示）的独立扩展字段，它允许客户端告诉服务器它想要与哪个服务器通信。curl 将仅从给定的 URL 中提取 SNI 名称以发送。

### 为名称提供自定义 IP 地址

你是否比域名解析器更清楚 curl 应该去哪里？那么你可以自己给 curl 提供一个 IP 地址！如果你想将对`example.com`端口 80 的访问重定向到你的本地主机：

```
curl --resolve example.com:80:127.0.0.1 http://example.com/ 
```

您甚至可以指定多个 `--resolve` 开关来提供这种类型的多个重定向，如果您处理的 URL 使用 HTTP 重定向或者只想使您的命令行与多个 URL 一起工作，则这将非常方便。

`--resolve` 将地址插入 curl 的 DNS 缓存中，因此它将有效地使 curl 相信这是它在解析名称时得到的地址。

在使用 HTTPS 时，这将为 URL 中的名称发送 SNI，并且 curl 将验证服务器的响应，以确保它为 URL 中的名称提供服务。

### 提供一个替换名称

作为 `--resolve` 选项的近亲，`--connect-to` 选项提供了一个微小的变化。它允许您在特定名称和端口号用于连接时，在底层为 curl 指定一个替换名称和端口号。

例如，假设您有一个名为 `www.example.com` 的单个站点，实际上它由三个不同的独立 HTTP 服务器提供服务：load1、load2 和 load3，用于负载平衡目的。在典型的正常过程中，curl 解析主站点并与负载平衡服务器中的一个进行通信（因为它返回一个列表，只需选择其中一个），一切都很好。如果您想向负载平衡集合中的一个特定服务器发送一个测试请求（例如 `load1.example.com`），您可以指示 curl 这样做。

如果您知道 load1 的特定 IP 地址，仍然可以使用 `--resolve` 来完成此操作。但是，您可以告诉 curl 而不必首先分别解析和修复 IP 地址：

```
curl --connect-to www.example.com:80:load1.example.com:80 http://www.example.com 
```

它将重定向从一个源名称 + 源端口到一个目标名称 + 目标端口。然后 curl 将解析 `load1.example.com` 名称并连接，但在所有其他方面仍然假设它正在与 `www.example.com` 通信。

### 使用 c-ares 的名称解析技巧

如本书的其他地方详细说明的那样，curl 可能会构建具有几种不同名称解析后端的不同版本。其中之一的后端由 c-ares 库提供动力，当 curl 构建为使用 c-ares 时，它获得了一些其他名称解析后端构建的 curl 没有获得的额外超级能力。也就是说，它可以更具体地指示要使用哪些 DNS 服务器以及该 DNS 流量如何使用网络。

使用 `--dns-servers`，您可以指定 curl 应该使用的确切 DNS 服务器，而不是默认的 DNS 服务器。这样可以让您运行自己的实验服务器以提供不同的回答，或者在您的常规服务器不可靠或死机时使用备用服务器。

使用 `--dns-ipv4-addr` 和 `--dns-ipv6-addr`，您要求 curl 将其 DNS 通信的本地端绑定到特定的 IP 地址，并使用 `--dns-interface`，您可以指示 curl 使用特定的网络接口来进行 DNS 请求。

这些 `--dns-*` 选项非常高级，只适用于知道自己在做什么并且了解这些选项作用的人。但它们提供了非常可定制的 DNS 名称解析操作。

## 连接超时

curl 通常会在其网络传输的初始阶段向主机建立一个 TCP 连接。如果存在不稳定的网络条件或有故障的远程服务器，此 TCP 连接可能会失败或非常缓慢。

为了减少对你的脚本或其他用途的影响，你可以设置 curl 允许连接尝试的最大时间（以秒为单位）。使用 `--connect-timeout`，你告诉 curl 允许连接的最大时间，并且如果在那个时间内 curl 还没有连接，它将返回一个失败。

连接超时只限制 curl 允许花费的时间，直到它连接，所以一旦 TCP 连接建立，可能需要更长的时间。有关通用 curl 超时的更多信息，请参见超时部分。

如果你指定一个低超时时间，你实际上禁用了 curl 连接到远程服务器、慢服务器或你通过不可靠网络访问的服务器的能力。

连接超时可以指定为小数值，以实现亚秒精度。例如，允许 2781 毫秒连接：

```
curl --connnect-timeout 2.781 https://example.com/ 
```

## 网络接口

在具有多个连接到多个网络的网络接口的机器上，存在这样的情况：你可以决定你希望出站网络流量使用哪个网络接口。或者在通信中使用哪个起始 IP 地址（在你拥有的多个 IP 地址中选择）。

使用 `--interface` 选项告诉 curl 哪个网络接口、哪个 IP 地址甚至主机名，你想要"绑定"你的通信的本地端点到哪里：

```
curl --interface eth1 https://www.example.com/

curl --interface 192.168.0.2 https://www.example.com/

curl --interface machine2 https://www.example.com/ 
```

## 本地端口号

TCP 连接在本地端点的 IP 地址和端口号之间以及远程端点的 IP 地址和端口号之间创建。远程端口号可以在 URL 中指定，通常有助于识别你所针对的服务。

本地端口号通常由网络堆栈随机分配给你的 TCP 连接，你通常不需要进一步考虑它。然而，在某些情况下，你会发现自己身处网络设备、防火墙或类似设置后面，这些设置对可以设置的出站连接的源端口号施加了限制。

对于这样的情况，你可以指定 curl 应该绑定连接到哪些本地端口。你可以指定要使用的单个端口号，或者一系列端口。我们建议使用一系列端口，因为端口是稀缺资源，你想要的确切端口可能已经被使用了。如果你请求一个 curl 无法为你获取到的本地端口号（或范围），它将以失败退出。

此外，在大多数操作系统上，你不能绑定到低于 1024 的端口号，除非你有更高的特权级别（root），我们通常建议尽量避免以 root 权限运行 curl。

当获取此 HTTPS 页面时，请 curl 使用一个在 4000 到 4200 之间的本地端口号：

```
curl --local-port 4000-4200 https://example.com/ 
```

## 保持连接活动

当 TCP 连接未被使用时，可以在任一方向上完全没有流量。因此，完全空闲的连接无法与因网络或服务器问题而完全失效的连接清楚地区分开来。

与此同时，许多网络设备（如防火墙或 NAT 设备）如今都在跟踪 TCP 连接，以便它们可以转换地址、阻止“错误”的传入数据包等。这些设备通常在 N 分钟后将完全空闲的连接视为死连接，其中 N 的值因设备而异，但有时甚至只有 10 分钟或更短的时间。

帮助避免将一个真正缓慢的连接（或者是一个空闲的连接）错误地视为死连接并杀掉的一种方法是确保使用 TCP keepalive。TCP keepalive 是 TCP 协议中的一项功能，使其在完全空闲时发送 “ping 帧” 来回传输。它有助于空闲连接在没有流量传输时检测到断开，以及帮助中间系统不将连接视为死连接。

curl 默认使用 TCP keepalive，原因在这里已经提到。但是可能会有一些时候你想要 *禁用* keepalive 或者你可能想要改变 TCP “ping” 之间的间隔（curl 默认为 60 秒）。你可以通过以下方法关闭 keepalive：

```
curl --no-keepalive https://example.com/ 
```

或将间隔更改为 5 分钟（300 秒）：

```
curl --keepalive-time 300 https://example.com/ 
```

# 超时

# 超时

网络操作由于其本质而相当不可靠或者说是脆弱的操作，因为它们依赖于一组服务和网络的正常工作。这些服务的可用性可能时好时坏，它们的性能也可能随时变化。

TCP 的设计甚至允许网络在长时间内完全断开连接，而不会被传输过程中的参与者注意到。

结果是有时互联网传输需要很长时间。此外，curl 中的大多数操作默认没有超时！

## 允许花费的最长时间

通过 `-m / --max-time` 告诉 curl 允许命令行花费的最长时间（以秒为单位），在此时间之后，curl 将退出并显示超时错误代码（28）。当经过设定的时间后，curl 将退出，无论此时发生了什么情况——包括是否正在传输数据。这确实是允许的最长时间。

给定的最大时间可以使用小数精度指定；`0.5` 表示 500 毫秒，`2.37` 等于 2370 毫秒。

例子：

```
curl --max-time 5.5 https://example.com/ 
```

## 不要花费超过此时间来连接

`--connect-timeout` 限制了 curl 尝试连接到主机的时间。连接被视为完成之前必须在给定的时间范围内完成所有必要的步骤。连接在给定时间内未能建立将导致 curl 退出，并显示超时退出代码（28）。

给定的最大连接时间可以使用小数精度指定；`0.5` 表示 500 毫秒，`2.37` 等于 2370 毫秒：

```
curl --connect-timeout 2.37 https://example.com/ 
```

## 慢于这个传输速度意味着退出

对 curl 操作设置固定的最大时间可能很麻烦，特别是如果您例如进行脚本传输，文件大小和传输时间变化很大。 然后，需要将固定超时值设置得过高以涵盖最坏情况。

作为固定超时的替代方案，您可以告诉 curl 如果传输速度低于某个特定速度并在该阈值下保持一段时间，则放弃传输。

例如，如果传输速度在 15 秒内低于每秒 1000 字节，则停止传输：

```
curl --speed-time 15 --speed-limit 1000 https://example.com/ 
```

## 保持连接保持活动

curl 默认启用 TCP keep-alive。 TCP keep-alive 是一项功能，使 TCP 栈在没有流量时向另一端发送探测，以确保其仍然存在并且“活着”。通过使用 keep-alive，curl 更有可能发现 TCP 连接已断开。

使用 `--keepalive-time` 指定要多少秒发送一次探测到对等方。 默认值为 60 秒。

有时这种探测会干扰您正在进行的操作，然后您可以轻松地使用 `--no-keepalive` 禁用它。

# .netrc

## .netrc

Unix 系统长期以来一直提供一种方式让用户存储他们的远程 FTP 服务器的用户名和密码。 多年来，ftp 客户端已支持此功能，这种方式允许用户快速登录到已知服务器，而无需手动每次重新输入凭据。 `.netrc` 文件通常存储在用户的主目录中。 （在 Windows 上，curl 将使用名称 `_netrc` 查找它）。

由于这是一个广泛使用的概念，curl 也支持它——如果你要求的话。然而，curl 并不将此功能限制在 FTP 上，而是可以为任何协议的机器获取凭据。请参见下文了解详细信息。

### .netrc 文件格式

.netrc 文件格式很简单：您指定一个机器名称并在其后跟随与该机器关联的登录和密码的行。

**机器名称**

标识远程机器名称。 curl 在 .netrc 文件中搜索与 URL 中指定的远程机器匹配的机器令牌。 一旦找到匹配项，将处理后续的 .netrc 令牌，直到达到文件结尾或遇到另一个机器为止。

**登录名称**

远程机器的用户名字符串。

**密码字符串**

提供密码。 如果存在此令牌，则 curl 将在远程服务器要求密码作为登录过程的一部分时提供指定的字符串。 请注意，如果此令牌存在于 .netrc 文件中，确实应确保该文件除了用户之外没有其他人可以读取。

对于具有名为 'daniel' 的用户、使用密码 'qwerty' 的主机 example.com 的示例 .netrc 如下所示：

```
machine example.com
login daniel
password qwerty 
```

### 启用 netrc

`-n, --netrc` 告诉 curl 查找并使用 .netrc 文件。

`--netrc-file [file]` 与 `--netrc` 类似，只是您还提供要使用的实际文件的路径。当您想要在另一个目录或使用另一个文件名提供信息时，这非常有用。

`--netrc-optional` 与 `--netrc` 类似，但此选项使 .netrc 的使用成为可选项，而不是强制性的，如 `--netrc` 选项。

# 代理

## 代理

代理是一台机器或软件，代表您，即客户端，执行某些操作。

您还可以将其视为坐落在您和您想要处理的服务器之间的中间人，一个中间人，您连接到它而不是实际的远程服务器。您请求代理代替您执行所需的操作，然后它将运行并返回数据给您。

有几种不同类型的代理，我们将在本节中列出并讨论它们。

### 发现您的代理

一些网络设置要求您使用代理才能访问互联网或者您感兴趣的特定网络。代理的使用是由管理您的网络的人员和管理人员基于政策或技术原因引入到您的网络中的。

在网络空间中，有几种方法可以自动检测代理以及如何连接到它们，但这些方法都不是真正通用的，curl 不支持其中任何一种。此外，当您通过代理与外界通信时，这通常意味着您必须对代理放置大量信任，因为它能够查看和修改您通过它发送或接收的所有非安全网络流量。这种信任不容易自动假设。

如果您检查浏览器的网络设置，有时可以在高级设置选项卡下，您可以了解您的浏览器配置为使用哪个代理或代理。很大的机会是，当您使用 curl 时，您应该使用相同的一个或多个代理。

待定：如何在 Firefox 和 Chrome 中找到代理设置的截图？

### PAC

一些网络环境提供了几种不同的代理，应该在不同的情况下使用，浏览器支持的处理方式非常灵活。这称为“代理自动配置”，或 PAC。

PAC 文件包含一个 JavaScript 函数，该函数决定给定网络连接（URL）应该使用哪个代理，甚至是否根本不应该使用代理。浏览器最常读取 PAC 文件位于本地网络上的 URL。

由于 curl 没有 JavaScript 能力，因此不支持 PAC 文件。如果您的浏览器和网络使用 PAC 文件，最简单的前进路线通常是手动阅读 PAC 文件，并找出您需要指定以成功运行 curl 的代理。

### 捕获门户

（这些不是代理，而是在路上）

待定

### 代理类型

curl 支持几种不同类型的代理。

默认的代理类型是 HTTP，因此如果您指定一个代理主机名（或 IP 地址）而没有方案部分（通常写为“http://”的部分），curl 会假定它是一个 HTTP 代理。

curl 还允许设置代理类型的许多不同选项，而不是使用方案前缀。请参见下面的 SOCKS 部分。

### HTTP

HTTP 代理是客户端与之交谈以完成传输的代理。curl 将默认假设您用 `-x` 或 `--proxy` 指出的主机是 HTTP 代理，除非您还指定端口号，默认端口号是 3128（这个特定端口号的原因纯粹是历史原因）。

如果您想使用位于 192.168.0.1 端口 8080 上的代理请求 example.com 网页，命令行可能如下所示：

```
curl -x 192.168.0.1:8080 http:/example.com/ 
```

请回忆一下，代理接收到您的请求，将其转发给真实服务器，然后从服务器读取响应，然后将其返回给客户端。

如果您在与代理交谈时启用了详细模式（使用 `-v`），您将看到 curl 连接到代理而不是远程服务器，并且您将看到它使用略有不同的请求行。

### HTTPS 和代理

HTTPS 的设计是为了允许并提供安全的端到端隐私，从客户端到服务器（和返回）。为了在与 HTTP 代理通话时提供这一点，HTTP 协议有一个特殊的请求，curl 使用它来设置通过代理的隧道，然后可以加密和验证它。此 HTTP 方法称为 `CONNECT`。

当代理通过 CONNECT 方法设置加密数据传输到远程服务器之后，代理不能看到也不能修改流量而不破坏加密：

```
curl -x proxy.example.com:80 https://example.com/ 
```

### MITM 代理

MITM 意思是中间人攻击。MITM 代理通常由公司在“企业环境”和其他地方部署，网络所有者希望调查甚至是 TLS 加密流量。

为了做到这一点，它们要求用户在客户端安装一个自定义的“信任根”（CA 证书），然后代理终止来自客户端的所有 TLS 流量，冒充远程服务器并充当代理。代理然后发送回一个由自定义 CA 签名的生成的证书。这样的代理设置通常会透明地捕获来自客户端到远程机器的 TCP 端口 443 的所有流量。在这样的网络中运行 curl 也会捕获其 HTTPS 流量。

当然，这种做法允许中间人解密和窥探所有 TLS 流量。

### 通过 HTTP 代理发送非 HTTP 协议

“HTTP 代理”意味着代理本身使用 HTTP。HTTP 代理主要用于代理 HTTP，但它也相当常见地支持其他协议。特别是，FTP 相当常见。

在讨论 FTP “通过” HTTP 代理时，通常是通过更多或更少地假装另一个协议工作像 HTTP，并请求代理“获取此 URL”，即使 URL 没有使用 HTTP。这种区别很重要，因为这意味着当通过这样的 HTTP 代理发送时，curl 实际上并不会说 FTP，即使给定了 FTP URL；因此 FTP 特定的功能将不起作用：

```
curl -x http://proxy.example.com:80 ftp://ftp.example.com/file.txt 
```

那么，您可以做的是“通过”HTTP 代理隧道！

### HTTP 代理隧道

大多数 HTTP 代理允许客户端“隧道连接”到另一侧的服务器。这正是每次通过 HTTP 代理使用 HTTPS 时所做的。

你可以使用 `-p` 或 `--proxytunnel` 通过 curl 隧道连接 HTTP 代理。

当你通过代理进行 HTTPS 时，通常会连接到默认的 HTTPS 远程 TCP 端口号 443，因此你会发现大多数 HTTP 代理只会允许连接到该端口号上的主机，可能还有一些其他端口号。大多数代理会拒绝客户端连接到任意随机端口（只有代理管理员才知道的原因）。

依然假设 HTTP 代理允许，你可以要求它通过任何端口号隧道连接到远程服务器，这样即使在进行隧道连接时，你也可以“正常”使用其他协议。你可以这样进行 FTP 隧道连接：

```
curl -p -x http://proxy.example.com:80 ftp://ftp.example.com/file.txt 
```

你可以通过使用 `--proxy1.0 [proxy]` 而不是 `-x` 来告诉 curl 在其向 HTTP 代理发出的 CONNECT 请求中使用 HTTP/1.0。

### SOCKS 类型

SOCKS 是用于代理的协议，curl 支持它。curl 支持 SOCKS 版本 4 和版本 5，这两个版本都有两种类型。

你可以通过使用 `-x` 对给定代理主机使用正确的方案部分来选择要使用的特定 SOCKS 版本，或者你可以使用单独的选项指定它，而不是使用 `-x`。

SOCKS4 用于版本 4，而 SOCKS4a 用于版本 4，不会在本地解析主机名：

```
curl -x socks4://proxy.example.com http://www.example.com/

curl --socks4 proxy.example.com http://www.example.com/ 
```

SOCKS4a 版本：

```
curl -x socks4a://proxy.example.com http://www.example.com/

curl --socks4a proxy.example.com http://www.example.com/ 
```

SOCKS5 用于版本 5，而 SOCKS5-hostname 用于版本 5，不会在本地解析主机名：

```
curl -x socks5://proxy.example.com http://www.example.com/

curl --socks5 proxy.example.com http://www.example.com/ 
```

SOCKS5-hostname 版本。这将主机名发送到服务器，因此不会在本地执行名称解析：

```
curl -x socks5h://proxy.example.com http://www.example.com/

curl --socks5-hostname proxy.example.com http://www.example.com/ 
```

### 代理身份验证

HTTP 代理可能需要身份验证，所以 curl 需要提供适当的凭据给代理以允许使用它，而未能这样做只会使代理返回使用代码 407 的 HTTP 响应。

代理的身份验证与“正常”的 HTTP 身份验证非常相似，但是是单独的，以允许客户端独立使用正常主机身份验证以及代理身份验证。

使用 curl，你可以使用 `-U user:password` 或 `--proxy-user user:password` 选项为代理身份验证设置用户名和密码：

```
curl -U daniel:secr3t -x myproxy:80 http://example.com 
```

此示例将默认使用基本身份验证方案。有些代理需要另一种身份验证方案（当你收到 407 响应时返回的头信息将告诉你），然后你可以用 `--proxy-digest`、`--proxy-negotiate`、`--proxy-ntlm` 请求特定的方法。上面的示例命令再次，但要求使用代理进行 NTLM 身份验证：

```
curl -U daniel:secr3t -x myproxy:80 http://example.com --proxy-ntlm 
```

还有一个选项是让 curl 弄清楚代理想要和支持的方法，然后按照那种方法进行（可能会额外增加往返次数的开销），使用 `--proxy-anyauth`。要求 curl 使用代理想要的任何方法，就像这样：

```
curl -U daniel:secr3t -x myproxy:80 http://example.com --proxy-anyauth 
```

### HTTPS 到代理

所有先前提到的与代理通信的协议都是明文协议，包括 HTTP 和 SOCKS 版本。使用这些方法可能允许某人在你或代理所在的本地网络上窃听你的流量。

其中一个解决方案是通过 HTTPS 到代理，这样建立一个安全加密的连接，不易受���视。

目前 curl 不支持通过 HTTPS 到代理的连接，但我们正在进行相关工作，希望在未来的 curl 版本中实现这一功能。

### 代理环境变量

在运行之前，curl 会检查特定命名的环境变量是否存在，以确定是否需要使用代理。

通过设置一个名为`[scheme]_proxy`的变量来指定代理主机名（就像你使用`-x`指定主机一样）。因此，如果你想告诉 curl 在访问 HTTP 服务器时使用代理，你需要设置'http_proxy'环境变量。就像这样：

```
http_proxy=http://proxy.example.com:80
curl -v www.example.com 
```

尽管上面的示例展示了 HTTP，当然，你也可以设置 ftp_proxy、https_proxy 等。除了 http_proxy 之外，所有这些代理环境变量名称也可以使用大写形式，比如 HTTPS_PROXY。

为了设置一个控制*所有*协议的单个变量，存在 ALL_PROXY。如果存在特定协议变量，则该变量将优先。

当使用环境变量设置代理时，可能会出现一种情况，即需要排除一些主机名不通过代理。这可以通过设置 NO_PROXY 变量来实现。将其设置为一个逗号分隔的主机名列表，这些主机名在访问时不使用代理。你可以将 NO_PROXY 设置为单个星号（'*'）以匹配所有主机。

作为 NO_PROXY 变量的替代方案，还有一个`--noproxy`命令行选项，具有相同的目的并且工作方式相同。

### 代理头

--proxy-header

待定

# 退出状态

# 退出状态

项目已经付出了大量努力，使 curl 在出现问题时返回一个可用的退出代码，当操作顺利完成时，它将始终返回 0（零）。

如果你编写一个调用 curl 的 shell 脚本或批处理文件，你可以始终检查返回代码以检测调用命令中的问题。在下面，你将找到此时的返回代码列表。随着时间的推移，我们倾向于慢慢添加新的代码，因此如果你收到一个此处未列出的代码，请参考更更新的 curl 文档以获取帮助。

一个非常基本的 Unix shell 脚本可能看起来像这样：

```
#!/bin/sh
curl http://example.com
res=$?
if test "$res" != "0"; then
   echo "the curl command failed with: $res"
fi 
```

## 可用的退出代码

1.  不支持的协议。此 curl 版本不支持此协议。通常这是因为 URL 拼写错误，使用了一个在其前面有空格或拼写为"htpt"等的方案部分。另一个常见的错误是你使用了一个在构建时禁用了一个或多个协议的 libcurl 安装，现在要求 libcurl 使用其中一个在构建中禁用的协议。

1.  初始化失败。这主要是内部错误或 libcurl 安装或 libcurl 运行的系统中的问题。

1.  URL 格式错误。语法不正确。当您误输入 URL 以致它错误时，或者在罕见情况下，您使用的 URL 被另一个 curl 不支持的工具接受，只因为没有每个人都遵循的通用 URL 标准。

1.  执行所需请求的功能或选项未启用或在构建时显式禁用。要使 curl 能够执行此操作，您可能需要另一个 libcurl 的构建版本！

1.  无法解析代理。无法解析给定代理主机的地址。要么给定的代理名错误，要么 DNS 服务器的行为不当，在应该知道该名称的情况下却不知道，甚至您运行 curl 的系统可能被错误配置，以便找不到/使用正确的 DNS 服务器。

1.  无法解析主机。未解析给定远程主机的地址。无法解析给定服务器的地址。要么给定的主机名错误，要么 DNS 服务器的行为不当，在应该知道该名称的情况下却不知道，甚至您运行 curl 的系统可能被错误配置，以便找不到/使用正确的 DNS 服务器。

1.  连接主机失败。curl 成功获取了到达该主机的 IP 地址，并尝试设置到主机的 TCP 连接，但失败了。这可能是因为您指定了错误的端口号、输入了错误的主机名、使用了错误的协议，或者可能是因为存在防火墙或其他阻止流量通过的网络设备。

1.  未知的 FTP 服务器响应。服务器发送了 curl 无法解析的数据。这可能是因为 curl 中存在错误、服务器中存在错误，或者因为服务器正在使用 curl 不支持的 FTP 协议扩展。对此唯一真正的解决方法是调整 curl 选项，尝试使用其他可能不会收到此未知服务器响应的 FTP 命令。

1.  FTP 访问被拒绝。服务器拒绝了登录或拒绝了访问您想要访问的特定资源或目录。大多数情况下，您试图切换到服务器上不存在的目录。当然，该目录就是您在 URL 中指定的目录。

1.  FTP 接受失败。在使用主动 FTP 会话等待服务器连接回来时，控制连接或类似连接上发送了错误代码。

1.  FTP 异常 PASS 响应。Curl 无法解析发送到 PASS 请求的响应。curl 发送的命令 PASS 将密码发送到服务器，并且甚至匿名连接到 FTP 服务器实际上也发送一个密码 - 一个固定的匿名字符串。从此命令获得 curl 不理解的响应是一个强烈的指示，表明这根本不是一个 FTP 服务器，或者服务器严重损坏。

1.  在等待服务器连接期间的活动 FTP 会话（使用 PORT）时，超时已过期。服务器花费了太长时间才能回复。这通常是一个迹象，表明某些因素阻止服务器成功到达 curl。比如防火墙或其他网络设置。

1.  对 FTP PASV 命令的未知响应，Curl 无法解析发送到 PASV 请求的响应。这是一个奇怪的服务器。PASV 用于在被动模式下设置第二个数据传输连接，请参阅 FTP 使用两个连接部分了解更多信息。您可以尝试通过使用 `--ftp-port` 选项，改用 PORT 来解决此问题。

1.  未知的 FTP 227 格式。Curl 无法解析服务器发送的 227 行。这肯定是一个坏掉的服务器。当发送 FTP 服务器的响应时，227 是 FTP 服务器的响应，用于回送有关 curl 应如何连接回它的信息。您可以尝试通过使用 `--ftp-port` 选项改用 PORT 来解决此问题。

1.  FTP 无法获取主机。无法使用 227 行中获取的主机 IP 地址。这很可能是内部错误！

1.  HTTP/2 错误。在 HTTP2 帧层中检测到问题。这有点通用，可能是几个问题之一，请查看错误消息以获取详细信息。

1.  FTP 无法设置二进制。无法将传输方法更改为二进制。这个服务器坏了。curl 需要在启动之前将传输设置为正确的模式，否则传输无法工作。

1.  部分文件。只传输了文件的一部分。当传输被认为完成时，curl 将验证实际接收到的数据量是否与之前预告的相同。如果两个数字不匹配，则是错误代码。这可能意味着 curl 比广告的少接收了字节，或者比广告的多接收了字节。curl 本身无法知道哪个数字是错误的或哪个是正确的。如果有的话。

1.  FTP 无法下载/访问给定的文件。RETR（或类似）命令失败。当尝试下载文件时，curl 从服务器收到错误。

1.  **未使用**

1.  引号错误。引号命令从服务器返回了错误。curl 允许以多种不同的方式向 IMAP、POP3、SMTP 或 FTP 服务器发送自定义命令，并且具有通用检查以确保这些命令有效。当任何一个单独的命令失败时，会返回此退出状态。一般建议查看 FTP 通信中的头信息，以更好地理解到底发生了什么以及如何处理。

1.  未检索到 HTTP 页面。未找到请求的 URL 或返回了另一个 HTTP 错误，HTTP 错误代码为 400 或更高。仅在使用 `-f, --fail` 时才会出现此返回代码。

1.  写入错误。Curl 无法将数据写入本地文件系统或类似位置。curl 从网络逐块接收数据，并将其像在（或将其写入标准输出）一样存储，每次一块。如果写入操作出错，这是退出状态。

1.  **未使用**

1.  上传失败。服务器拒绝接受或存储 curl 尝试发送的文件。这通常是由于服务器上错误的访问权限引起的，但也可能是由于磁盘空间不足或其他资源限制引起的。此错误可能发生在许多协议中。

1.  读取错误。各种读取问题。与退出状态 23 相反。当 curl 向服务器发送数据时，它会从本地文件或 stdin 或类似地逐块读取数据，如果读取方式出现问题，则此退出状态是 curl 将返回的。

1.  内存不足。内存分配请求失败。curl 需要分配的内存超过了系统愿意提供的内存，因此必须退出。尝试使用较小的文件或确保 curl 获得更多的可用内存。

1.  操作超时。根据条件，达到了指定的超时时间。curl 提供了几个 超时，此退出代码表示其中一个超时限制已达到。延长超时时间或尝试更改其他允许 curl 更快完成操作的内容。通常，这是由于无法在本地影响的网络和远程服务器情况引起的。

1.  **未使用**

1.  FTP PORT 失败。PORT 命令失败。并非所有 FTP 服务器都支持 PORT 命令；尝试使用 PASV 进行传输！PORT 命令用于要求服务器通过*回连*到 curl 来创建数据连接。另请参阅 FTP uses two connections 部分。

1.  FTP 无法使用 REST。REST 命令失败。此命令用于恢复 FTP 传输。curl 需要发出 REST 命令以进行范围或恢复传输。服务器出现故障，请尝试不带范围/恢复的相同操作作为一个粗糙的解决方法！

1.  **未使用**

1.  HTTP 范围错误。范围请求未成功。不会明确承认或支持恢复的 HTTP 请求，因此此退出代码表示对于此服务器上的此资源，无法进行范围或恢复传输。

1.  HTTP post 错误。内部发布请求生成错误。如果遇到此错误，请向 curl 项目报告确切的情况！

1.  TLS/SSL 连接错误。SSL 握手失败。SSL 握手可能由于许多不同原因而失败，因此错误消息可能会提供一些额外的线索。也许各方无法就 SSL/TLS 版本、适合的密码套件或类似事项达成一致。

1.  错误的下载恢复。无法继续先前中断的下载。当请求恢复一个然后不可能执行的传输时，会返回此错误。适用于 FILE、FTP 或 SFTP。

1.  使用 FILE:// 方案时无法读取给定的文件。打开文件失败。该文件可能不存在，或者可能是权限问题？

1.  LDAP 无法绑定。LDAP "bind" 操作失败，这是 LDAP 操作中必要的一步，因此这意味着无法执行 LDAP 查询。这可能是因为用户名或密码错误，或者其他原因。

1.  LDAP 搜索失败。给定的搜索条件导致 LDAP 搜索返回错误。

1.  **未使用**

1.  **未使用**

1.  通过回调中止。应用程序告诉 libcurl 中止操作。此错误代码通常不向用户显示，也不向 curl 工具的用户显示。

1.  函数参数错误。调用函数时使用了错误的参数-此返回代码存在是为了帮助应用程序作者理解为什么 libcurl 无法执行某些操作，并且永远不应由 curl 工具返回。如果发生这种情况，请向 curl 项目提交错误报告！

1.  **未使用**

1.  界面错误。无法使用指定的出站网络接口。curl 通常会自行决定出站网络和 IP 地址，但当明确要求使用 curl 无法使用的特定接口时，可能会出现此错误。

1.  **未使用**

1.  重定向次数过多。在遵循 HTTP 重定向时，libcurl 达到了应用程序设置的最大数量。libcurl 的重定向次数上限由 libcurl 无限制，但是默认情况下由 curl 工具设置为 50。该限制存在是为了阻止无限重定向循环。使用`--max-redirs`更改限制。

1.  指定给 libcurl 的选项未知。如果您使用的 curl 版本与底层 libcurl 版本不同步，可能会发生这种情况。也许您较新的 curl 尝试使用较旧的 libcurl 中未引入的选项，但是对您的 curl 工具代码来说是较新的。为了减少这种情况发生的风险并确保不会发生：使用相同版本号的 curl 和 libcurl。

1.  格式错误的 telnet 选项。您提供给 curl 的 telnet 选项未使用正确的语法。

1.  **未使用**

1.  服务器的 SSL/TLS 证书或 SSH 指纹验证失败。curl 随后无法确定服务器是否是其声称的那样。请参阅使用 TLS 与 curl 部分了解更多 TLS 详细信息和使用 curl 进行 SCP 和 SFTP 以获取更多 SSH 特定详细信息。

1.  服务器未回复任何内容，在此上下文中被视为错误。当 HTTP(S)服务器响应 HTTP(S)请求时，只要它处于活动和正常状态，它就会始终返回*某些内容*。所有有效的 HTTP 响应都有状态行和响应标头。根本没有得到任何回复表明服务器存在故障，或者可能有些事情阻止了 curl 访问正确的服务器，或者您试图连接到错误的端口号等。

1.  未找到 SSL 加密引擎。

1.  无法将 SSL 加密引擎设置为默认。

1.  发送网络数据失败。在大多数 curl 操作中，发送数据到网络是至关重要的一部分，当 curl 从最低网络层收到发送失败的错误时，将返回此退出状态。要找出发生这种情况的原因，通常需要进行严格的挖掘。首先启用详细模式，进行跟踪，如果可能的话使用诸如 Wireshark 之类的工具检查网络流量。

1.  接收网络数据失败。从网络接收数据是大多数 curl 操作的关键部分，当 curl 从最低网络层收到数据接收失败的错误时，将返回此退出状态。要找出原因，通常需要进行深入挖掘。首先启用详细模式，进行跟踪，如果可能的话，使用 Wireshark 或类似工具检查网络流量。

1.  **未使用**

1.  本地证书存在问题。客户端证书存在问题，因此无法使用。权限？密码错误？

1.  无法使用指定的 SSL 密码。

1.  对等证书无法使用已知 CA 证书进行身份验证。

1.  无法识别的传输编码。

1.  无效的 LDAP URL。

1.  超过最大文件大小限制。

1.  请求的 FTP SSL 级别失败。

1.  发送数据需要失败的倒带。

1.  无法初始化 SSL 引擎。

1.  用户名、密码或类似信息未被接受，curl 登录失败。

1.  在 TFTP 服务器上找不到文件。

1.  TFTP 服务器上的权限问题。

1.  TFTP 服务器上的磁盘空间不足。

1.  非法的 TFTP 操作。

1.  未知的 TFTP 传输 ID。

1.  文件已存在（TFTP）。

1.  不存在此用户（TFTP）。

1.  字符转换失败。

1.  需要字符转换函数。

1.  读取 SSL CA 证书时出现问题

1.  URL 中引用的资源不存在。

1.  SSH 会话期间发生未指定的错误。

1.  无法关闭 SSL 连接。

1.  **未使用**

1.  无法加载 CRL 文件，缺失或格式错误

1.  TLS 证书颁发者检查失败

1.  FTP PRET 命令失败

1.  RTSP：CSeq 数字不匹配

1.  RTSP：会话标识符不匹配

1.  无法解析 FTP 文件列表

1.  FTP 块回调报告错误

1.  没有可用连接，会将会话排队

1.  SSL 公钥与固定公钥不匹配

## 错误消息

当 curl 以非零代码退出时，它还将输出错误消息（除非使用 `--silent`）。该错误消息可能会为退出状态数字本身添加一些额外信息或情况，因此相同的错误号可能会有不同的错误消息。

## "未使用"

上面的退出代码列表中包含一些标记为“未使用”的值。这些是在现代版本的 curl 中未使用的退出状态代码，但在过去曾被使用或打算使用。它们很可能会在未来的 curl 版本中使用。

此列表中使用的最高错误状态是 90，但不能保证未来的 curl 版本不会决定在该数字之后添加更多的退出代码。

# FTP

# FTP

FTP，文件传输协议，可能是 curl 支持的最古老的网络协议 —— 它是在 1970 年代初创建的。仍然是首选文档的官方规范是 [RFC 959](http://www.ietf.org/rfc/rfc959.txt)，于 1985 年发布，比第一个 curl 发布版本早十多年。

FTP 是在互联网和计算机不同时代创建的，因此它的工作方式与大多数其他协议有些不同。这些差异通常可以忽略，事情会正常运行，但在计划外情况下，了解这些差异也很重要。

## Ping-pong

FTP 协议是一种命令和响应协议；客户端发送一个命令，服务器响应。如果您使用 curl 的`-v`选项，您将在传输过程中看到所有命令和响应。

对于普通的传输，通常需要 5 到 8 个命令来发送，以及同样数量的响应需要等待和读取。也许不用说，如果服务器在远程位置，那么在实际文件传输开始之前，会有很多时间等待 ping pong 通过。对于小文件来说，初始命令可能比实际数据传输花费的时间还要长。

## 传输模式

当 FTP 客户端准备传输数据时，它会告诉服务器希望使用哪种“传输模式”进行即将到来的传输。curl 支持的两种传输模式是'ASCII'和'BINARY'。ASCII 基本上用于文本，通常意味着服务器将发送转换后的换行符文件，而二进制意味着发送未更改的数据，并假定文件不是文本。

curl 在 FTP 上默认使用二进制传输模式，您可以使用`-B, --use-ascii`要求使用 ASCII 模式，或者确保 URL 以`;type=A`结尾。

## 身份验证

FTP 是您通常不会在没有用户名和密码的情况下访问的协议之一。恰好对于允许“匿名”FTP 访问的系统，您可以使用几乎任何名称和密码登录。当在 FTP URL 上使用 curl 进行没有给定用户名或密码的传输时，它将使用名称`anonymous`和密码`ftp@example.com`。

如果您想提供另一个用户名和密码，可以使用`-u, --user`选项将它们传递给 curl，或者将信息嵌入在 URL 中：

curl --user daniel:secret ftp://example.com/download

curl ftp://daniel:secret@example.com/download

# 两个连接

## FTP 使用两个连接

FTP 使用两个 TCP 连接！第一个连接由客户端在连接到 FTP 服务器时建立，称为*控制连接*。作为初始连接，它负责身份验证和切换到远程服务器上的正确目录等。当客户端准备传输文件时，将建立第二个 TCP 连接，并通过该连接传输数据。

建立第二个连接会因为几个原因而引起麻烦和头痛。

### 活动连接

客户端可以选择要求服务器连接到客户端以进行设置，这称为“主动”连接。这是通过 PORT 或 EPRT 命令完成的。允许远程主机连接到客户端上打开的端口需要确保中间没有防火墙或其他网络设备拦截，并且这种情况并不总是发生。您可以使用 `curl -P [arg]`（也称为长格式的 `--ftp-port`）请求主动传输，尽管该选项允许您指定要使用的确切地址，但将其设置为与您来自的地址相同几乎总是正确的选择，您可以这样请求文件：

```
curl -P - ftp://example.com/foobar.txt 
```

您还可以使用 `--no-eprt` 命令行选项显式要求 curl 不要使用 EPRT（比 PORT 稍新的命令）。

### 被动连接

Curl 默认使用“被动”连接，这意味着它向服务器发送一个 PASV 或 EPSV 命令，然后服务器会打开一个新端口用于第二个连接，然后 curl 连接到该端口。向新端口的出站连接对终端用户和客户端来说通常更容易、更不受限制，但这要求服务器端的网络允许它。

被动连接默认启用，但如果之前已经开启了主动连接，可以使用 `--ftp-pasv` 切换回被动连接。

您还可以使用 `--no-epsv` 命令行选项显式要求 curl 不要使用 EPSV（比 PASV 稍新的命令）。

有时服务器运行的设置有点奇怪，以至于当 curl 发出 PASV 命令时，服务器会用一个 IP 地址响应 curl 连接，但该地址是错误的，然后 curl 无法设置数据连接。对于这种（希望很少见的）情况，您可以要求 curl 忽略 PASV 响应中提到的 IP 地址（`--ftp-skip-pasv-ip`），而是使用与控制连接相同的 IP 地址，即使是第二个连接也是如此。

### 防火墙问题

使用主动或被动传输，网络路径中的任何现有防火墙基本上都必须对 FTP 流量进行状态检查，以确定要打开的新端口，并接受第二个连接。

# 目录遍历

## 如何遍历目录

在执行 FTP 命令以遍历远程文件系统时，curl 可以采取几种不同的方式来达到目标文件，即用户要传输的文件。

### multicwd

对于文件树层次结构中的每个单独目录，curl 可以执行一个更改目录（CWD）命令。如果完整路径是 `one/two/three/file.txt`，那么该方法意味着在要传输 `file.txt` 文件之前执行三个 `CWD` 命令。如果路径级别很深，则该方法会创建相当多的命令。这种方法是由早期规范（RFC 1738）规定的，也是 curl 默认的操作方式：

```
curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt 
```

这就等同于这个 FTP 命令/响应序列（简化版）：

```
> CWD one
< 250 OK. Current directory is /one
> CWD two
< 250 OK. Current directory is /one/two
> CWD three
< 250 OK. Current directory is /one/two/three
> RETR file.txt 
```

### nocwd

对每个目录部分执行一个 CWD 的相反方法是根本不更改目录。此方法一次性使用整个路径询问服务器，因此非常快速。偶尔服务器可能会有问题，而且它并非纯粹符合标准：

```
curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt 
```

这等于这个 FTP 命令/响应序列（简化）：

```
> RETR one/two/three/file.txt 
```

### 单个目录

这是其他两种 FTP 方法之间的中间方法。它对目标目录执行单个 `CWD` 命令，然后请求给定的文件：

```
curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt 
```

这等于这个 FTP 命令/响应序列（简化）：

```
> CWD one/two/three
< 250 OK. Current directory is /one/two/three
> RETR file.txt 
```

# 高级 FTP 使用

# 更高级的 FTP

## FTP 目录列表

您可以通过确保 URL 以斜杠结尾来使用 curl 列出远程 FTP 目录。如果 URL 以斜杠结尾，curl 将假定您要列出的是目录。如果实际上不是目录，您很可能会得到一个错误。

```
curl ftp://ftp.example.com/directory/ 
```

使用 FTP 时，对于使用标准 FTP 命令 `LIST` 的此类命令返回的目录输出，没有标准语法。列表通常是可读的和易于理解的，但您会发现不同的服务器会以稍微不同的方式返回列表。

要获取目录中所有名称的列表，从而避免常规目录列表的特殊格式化，一种方法是告诉 curl 使用 `--list-only`（或者只用 `-l`）。curl 然后发出 `NLST` FTP 命令：

```
curl --list-only ftp://ftp.example.com/directory/ 
```

尽管如此，NLST 也有其自己的怪癖，因为一些 FTP 服务器在响应 NLST 时仅列出实际的 *文件*；它们不包括目录和符号链接！

## 使用 FTP 上传

要上传到 FTP 服务器，您在 URL 中指定整个目标文件路径和名称，并使用 `-T, --upload-file` 指定要上传的本地文件名。可选地，您可以在目标 URL 末尾加上斜杠，然后 curl 将附加本地路径的文件组件，并将其用作远程文件名。

像这样：

```
curl -T localfile ftp://ftp.example.com/dir/path/remote-file 
```

或者将本地文件名用作远程文件名：

```
curl -T localfile ftp://ftp.example.com/dir/path/ 
```

curl 还支持在 `-T` 参数中使用 通配符，因此您可以选择轻松上传一系列文件或文件：

```
curl -T image[1-99].jpg ftp://ftp.example.com/upload/ 
```

或

```
curl -T '{Huey,Dewey,Louie}.jpg' ftp://ftp.example.com/nephews/ 
```

## 自定义 FTP 命令

待定

## FTPS

待定

## 常见的 FTP 问题

待定

# SCP 和 SFTP

## SCP 和 SFTP

如果使用正确的先决条件第三方库 [libssh2](https://www.libssh2.org/) 构建，curl 支持 SCP 和 SFTP 协议。

SFTP 和 SCP 都是构建在 SSH 之上的协议，SSH 是一种安全的加密数据协议，类似于 TLS，但在某些重要方面有所不同。例如，SSH 不使用任何证书，而是使用公钥和私钥。当正确使用时，SSH 和 TLS 都提供强大的加密和安全传输。

两者中的 SCP 协议通常被认为是黑羊，因为它不太可移植，通常只在 Unix 系统之间工作。

### 网址

SFTP 和 SCP 的 URL 与其他 URL 类似，您可以像使用其他协议一样使用这些协议下载文件：

```
curl sftp://example.com/file.zip -u user 
```

和：

```
curl scp://example.com/file.zip -u user 
```

当 URL 以斜杠结尾时，SFTP（但不包括 SCP）支持返回文件列表：

```
curl sftp://example.com/ -u user 
```

请注意，这两种协议都与“用户”一起工作，您不会匿名请求文件或使用标准通用名称。大多数系统将要求用户进行身份验证，如下所述。

当从 SFTP 或 SCP URL 请求文件时，除非您明确要求相对于用户主目录的路径，否则给定的文件路径被视为远程服务器上的绝对路径。您可以通过确保路径以`/~/`开头来做到这一点。这与 FTP URL 的工作方式完全相反，这是用户常常感到困惑的常见原因。

对于用户`daniel`从他的主目录传输`todo.txt`，看起来类似于这样：

```
curl sftp://example.com/~/todo.txt -u daniel 
```

### 认证

待定

### 已知主机

安全的网络客户端需要确保远程主机确实是它认为正在通信的主机。对于基于 TLS 的协议，客户端通过验证服务器的证书来实现这一点。

使用 SSH 协议时没有服务器证书，而是每个服务器可以提供其唯一的密钥。与 TLS 不同，SSH 没有证书颁发机构或任何东西，因此客户端只需确保主机的密钥与其已知的（通过其他方式）相匹配即可。

通常使用密钥的匹配是使用密钥和客户端存储已知服务器哈希的文件的哈希来完成的，该文件通常称为`known_hosts`，并放在专用的 SSH 目录中。在 Linux 系统上，通常称为`~/.ssh`。

当 curl 连接到 SFTP 和 SCP 主机时，它将确保主机的密钥哈希已经存在于已知主机文件中，否则它将拒绝继续操作，因为它无法信任服务器是否正确。一旦正确的哈希存在于`known_hosts`中，curl 就可以执行传输。

要强制 curl 跳过检查并遵守`known_hosts`文件，您可以使用`-k / --insecure`命令行选项。您必须非常小心地使用此选项，因为它使得无法检测到中间人攻击。

# IMAP 和 POP3

# 阅读电子邮件

互联网上有两种主要的协议用于从服务器读取/下载电子邮件（至少在我们不考虑基于 Web 的阅读时），它们是 IMAP 和 POP3。前者是稍微现代化的选择。curl 支持两者。

## POP3

要列出消息编号和大小：

```
curl pop3://mail.example.com/ 
```

要下载消息 1：

```
curl pop3://mail.example.com/1 
```

要删除消息 1：

```
curl --request DELE pop3://mail.example.com/1 
```

## IMAP

待定

# SMTP

# SMTP

SMTP 代表 [简单邮件传输协议](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol)。

curl 支持将数据发送到 SMTP 服务器，结合正确的一组命令行选项，可以将电子邮件发送到您选择的一组接收者。

使用 curl 发送 SMTP 时，有两个必须使用的命令行选项。

+   你需要使用`--mail-rcpt`告诉服务器至少一个收件人。你可以多次使用此选项，然后 curl 将告诉服务器所有这些电子邮件地址都应该收到邮件。

+   你需要告诉服务器哪个电子邮件地址是邮件的发送者，使用`--mail-from`。重要的是要意识到，这个电子邮件地址不一定与邮件文本中的`From:`行显示的相同。

然后，你需要提供实际的电子邮件数据。这是一个按照[RFC 5322](https://tools.ietf.org/html/rfc5322.html)格式化的（文本）文件。它是一组标头和一个正文。标头和正文都需要正确编码。标头通常包括`To:`、`From:`、`Subject:`、`Date:`等。

发送邮件的基本命令：

```
curl smtp://mail.example.com --mail-from myself@example.com --mail-rcpt
receiver@example.com --upload-file email.txt 
```

## 示例邮件.txt

```
From: John Smith <john@example.com>
To: Joe Smith <smith@example.com>
Subject: an example.com example email
Date: Mon, 7 Nov 2016 08:45:16

Dear Joe,
Welcome to this example email. What a lovely day. 
```

## 安全邮件传输

一些邮件提供商允许或要求使用 SSL 进行 SMTP。它们可能会使用专用的 SSL 端口，也可能允许在明文连接上升级 SSL。

如果你的邮件提供商有一个专用的 SSL 端口，你可以使用 smtps:// 而不是 smtp://，它默认使用 SMTP SSL 端口 465，并且需要整个连接都是 SSL。例如 smtps://smtp.gmail.com/。

但是，如果您的提供商允许从明文升级到安全传输，则可以使用以下选项之一：

```
--ssl           Try SSL/TLS (FTP, IMAP, POP3, SMTP)
--ssl-reqd      Require SSL/TLS (FTP, IMAP, POP3, SMTP) 
```

你可以通过在命令中添加`--ssl`来告诉 curl *尝试* 但不要求升级到安全传输：

```
curl --ssl smtp://mail.example.com --mail-from myself@example.com
     --mail-rcpt receiver@example.com --upload-file email.txt 
```

你可以通过在命令中添加`--ssl-reqd`来告诉 curl *需要* 升级到使用安全传输：

```
curl --ssl-reqd smtp://mail.example.com --mail-from myself@example.com
     --mail-rcpt receiver@example.com --upload-file email.txt 
```

## SMTP URL

SMTP 请求的路径部分指定了在与邮件服务器通信期间要呈现的主机名。如果省略了路径，则 curl 将尝试找出本地计算机的主机名并使用该主机名。但是，这可能不会返回一些邮件服务器所需的完全限定域名，并且指定此路径允许您设置另一个名称，例如您的机器的完全限定域名，您可能已经从 gethostname 或 getaddrinfo 等外部函数获取到。

连接到`mail.example.com`的邮件服务器，并在 HELO / EHLO 命令中发送你本地计算机的主机名：

```
curl smtp://mail.example.com 
```

当然，你始终可以使用 `-v` 选项来查看客户端和服务器的通信。

相反，如果要 curl 在`HELO` / `EHLO` 命令中发送`client.example.com`到`mail.example.com`的邮件服务器，请使用：

```
curl smtp://mail.example.com/client.example.com 
```

## 没有 MX 查找！

当你使用普通邮件客户端发送邮件时，它首先会检查你要发送邮件到的特定域的 MX 记录。如果你发送邮件给 joe@example.com，客户端将获取`example.com`的 MX 记录，以了解发送邮件给 example.com 用户时要使用哪些邮件服务器。

curl 本身不执行 MX 查找。如果你想弄清楚发送邮件给特定域名的服务器，我们建议你先弄清楚这一点，然后调用 curl 使用这些服务器。获取 MX 记录的有用命令行工具包括 'dig' 和 'nslookup'。

# TELNET

## TELNET

待定

# TLS

# TLS

TLS 代表传输层安全性，是以前称为 SSL 的技术的名称。虽然 SSL 这个术语并没有真正消失，但如今 TLS 和 SSL 这两个术语通常可互换使用，用来描述相同的事物。

TLS 是 TCP 的加密安全层，使数据防篡改，并基于强大的公钥密码学和数字签名保证服务器的真实性。

## 密码

当 curl 连接到 TLS 服务器时，它会协商如何使用协议，这个协商涉及到双方需要达成一致的几个参数和变量。其中一个参数是使用哪些加密算法，即所谓的密码。随着时间的推移，安全研究人员发现了现有密码的缺陷和弱点，并逐渐淘汰了它们。

使用详细选项 `-v`，你可以获取关于协商了哪种密码和 TLS 版本的信息。通过使用 `--ciphers` 选项，你可以更改协商中首选的密码，但请注意，这是一个强大的功能，需要知道如何使用，以避免让事情变得更糟。

## 启用 TLS

curl 支持许多协议的 TLS 版本。HTTP 有 HTTPS，FTP 有 FTPS，LDAP 有 LDAPS，POP3 有 POP3S，IMAP 有 IMAPS，SMTP 有 SMTPS。

如果服务器端支持，你可以使用 curl 来使用这些协议的 TLS 版本。

有两种一般方法来使用协议进行 TLS。其中一种是在第一次连接握手时就开始使用 TLS，而另一种是使用协议特定的指令将连接从纯文本升级到 TLS。

使用 curl，如果在 URL 中明确指定了协议的 TLS 版本（以 'S' 字符结尾的版本），curl 将尝试从一开始就使用 TLS 连接，而如果在 URL 中指定了非 TLS 版本，则通常可以使用 `--ssl` 选项将连接升级到基于 TLS 的版本。

支持表格如下：

| 清除 | TLS 版本 | --ssl |
| --- | --- | --- |
| HTTP | HTTPS | 否 |
| LDAP | LDAPS | 否 |
| FTP | FTPS | **是** |
| POP3 | POP3S | **是** |
| IMAP | IMAPS | **是** |
| SMTP | SMTPS | **是** |

所有可以使用 `--ssl` 的协议都倾向于使用该方法。使用 `--ssl` 意味着 curl 将尝试将连接升级到 TLS，但如果失败，它仍将继续使用协议的纯文本版本进行传输。要使 `--ssl` 选项**要求**使用 TLS 继续，而不是继续传输，可以使用 `--ssl-reqd` 选项，如果 curl 无法成功协商 TLS，则传输将失败。

要求 FTP 传输使用 TLS 安全性：

```
curl --ssl-reqd ftp://ftp.example.com/file.txt 
```

建议使用 TLS 来进行 FTP 传输：

```
curl --ssl ftp://ftp.example.com/file.txt 
```

直接使用 TLS 进行连接（到 HTTPS://、LDAPS://、FTPS:// 等）意味着 TLS 是强制性的，如果 TLS 没有被协商，curl 将返回错误。

获取 HTTPS 上的文件：

```
curl https://www.example.com/ 
```

## SSL 和 TLS 版本

SSL 是在 90 年代中期发明的，并一直在发展。SSL 版本 2 是第一个广泛用于互联网的版本，但很久以前就被认为不安全了。SSL 版本 3 接替了它，但也被认为不够安全，不能再使用了。

TLS 版本 1.0 是第一个“标准”。RFC 2246 于 1999 年发布。此后，TLS 1.1 出现了，在 2016 年 11 月，TLS 1.2 成为了黄金标准。TLS 1.3 正在制定中，我们预计在 2017 年某个时候将其定稿并发布为标准。

curl 默认使用“安全版本”的 SSL/TLS。这意味着它不会默认协商 SSLv2 或 SSLv3，除非明确告知，事实上，一些 TLS 库不再支持这些协议，因此在许多情况下，curl 甚至无法与这些协议版本通信，除非您做出认真的努力。

| 选项 | 用法 |
| --- | --- |
| --sslv2 | SSL 版本 2 |
| --sslv3 | SSL 版本 3 |
| --tlsv1 | TLS >= 版本 1.0 |
| --tlsv1.0 | TLS 版本 1.0 |
| --tlsv1.1 | TLS 版本 1.1 |
| --tlsv1.2 | TLS 版本 1.2 |
| --tlsv1.3 | TLS 版本 1.3 |

**注意：**TLS 版本 1.3 仅在某些非常新的开发版本的特定 TLS 库中受支持，并且需要 curl 7.52.0 或更高版本。

## 验证服务器证书

如果不能确信自己正在与**正确**的主机通信，那么与服务器建立安全连接就没有多大意义。如果我们不知道这一点，我们可能会与一个冒充者交谈，他只是*看起来*像我们认为的那个人。

为了检查它是否与正确的 TLS 服务器通信，curl 使用一组本地存储的 CA 证书来验证服务器证书的签名。所有服务器都会在 TLS 握手的一部分向客户端提供证书，所有公共 TLS 服务器都从已建立的证书颁发机构获得该证书。

经过一些应用密码学的魔法，curl 知道服务器实际上是为 curl 用于连接的主机名获取了该证书的正确证书。未能验证服务器的证书是 TLS 握手失败，curl 将以错误退出。

在极少数情况下，您可能会决定即使证书验证失败也要与 TLS 服务器通信。然后您接受这样一个事实，即您的通信可能会受到中间人攻击的影响。您可以使用 `-k` 或 `--insecure` 选项降低您的警惕。

## CA 存储

curl 需要一个“CA 存储”，即一组 CA 证书，来验证其所通信的 TLS 服务器。

如果 curl 构建为使用与您的平台“本机”相对应的 TLS 库，则该库很可能也会使用本机 CA 存储。如果不是，则 curl 必须已经构建以了解本地 CA 存储的位置，或者在调用 curl 时用户需要提供 CA 存储的路径。

您可以使用 `--cacert` 命令行选项指定要在 TLS 握手中使用的特定 CA 捆绑包。该捆绑包必须采用 PEM 格式。您还可以将环境变量 `CURL_CA_BUNDLE` 设置为完整路径。

### Windows 上的 CA 存储

在 Windows 上构建的 curl 如果没有使用本机 TLS 库（Schannel），则有一个额外的序列来确定和使用 CA 存储库。

curl 将按照以下顺序在这些目录中搜索名为 "curl-ca-bundle.crt" 的 CA 证书文件：

1.  应用程序目录

1.  当前工作目录

1.  Windows 系统目录（例如 `C:\windows\system32`）

1.  Windows 目录（例如 `C:\windows`）

1.  沿着 `%PATH%` 的所有目录

## 证书固定

TLS 证书固定是一种验证服务器证书签名所使用的公钥是否已更改的方法。它被"固定"。

在协商 TLS 或 SSL 连接时，服务器会发送一个指示其身份的证书。从此证书中提取公钥，如果它与提供给此选项的公钥不完全匹配，则 curl 将在发送或接收任何数据之前中止连接。

您可以告诉 curl 从文件名中读取 sha256 值，或者您可以直接在命令行中使用"sha256//"前缀指定 base64 编码的哈希。您可以使用分号（;）分隔这样的一个或多个哈希。

```
curl --pinnedpubkey "sha256//83d34tasd3rt..." https://example.com/ 
```

此功能并非所有 TLS 后端都支持。

## OCSP Stapling

这使用称为证书状态请求的 TLS 扩展，要求服务器在握手中提供来自 CA 的新的 "证明"，以确保其返回的证书仍然有效。这是确保服务器证书未被吊销的一种方式。

如果服务器不支持此扩展，则测试将失败，curl 将返回错误。而且服务器不支持这种情况仍然非常普遍。

请求握手使用状态请求的方式如下：

```
curl --cert-status https://example.com/ 
```

此功能仅由 OpenSSL、GnuTLS 和 NSS 后端支持。

## 客户端证书

TLS 客户端证书是客户端向服务器加密证明其为正确对等方的一种方式。使用客户端证书的命令行指定证书和相应的密钥，然后它们将与服务器的 TLS 握手一起传递。

在执行此操作时，您需要已经将客户端证书存储在文件中，并且您应该已经通过其他渠道获得了正确实例的证书。

该密钥通常由您提供或交互式提示输入的密码保护。

curl 提供了选项，让您指定一个单独的文件，该文件既是客户端证书又是私钥，使用 `--cert`，或者您可以独立指定密钥文件使用 `--key`：

```
curl --cert mycert:mypassword https://example.com
curl --cert mycert:mypassword --key mykey https://example.com 
```

对于某些 TLS 后端，您还可以使用不同类型的密钥和证书传入：

```
curl --cert mycert:mypassword --cert-type PEM \
     --key mykey --key-type PEM https://example.com 
```

## TLS 身份验证

待定

## 不同的 TLS 后端

待定

## 多个 TLS 后端

待定

# 调试

## 当事情不像您想象的那样运行时

待定

# 以 curl 形式复制

# 以 curl 形式复制

使用 curl 执行用户刚刚在浏览器中完成的操作是人们经常请求帮助的更常见的请求和领域之一。

如何获得一个 curl 命令行来获取资源，就像浏览器获取它一样，简单而轻松？Chrome 和 Firefox 已经提供了这个功能很长一段时间了！

## 来自 Firefox

使用 Firefox 的网络工具显示网站。然后，在您看到 HTTP 流量时，在“Web Developer->Network”工具中右键单击您要重复的特定请求，并在出现的菜单中选择“Copy as cURL”。就像下面的屏幕截图所示。然后，该操作将生成一个 curl 命令行到您的剪贴板中，然后您可以将其粘贴到您喜爱的 shell 窗口中。该功能在所有 Firefox 安装中默认可用。

![使用 Firefox 的 copy as curl](img/firefox-copy-as-curl.png)

## 来自 Chrome

当您在 Chrome 中弹出“更多工具->开发者模式”，并选择“Network”选项卡时，您会看到用于获取站点资源的 HTTP 流量。在您感兴趣的特定资源的行上，您用鼠标右键单击，然后选择“Copy as cURL”，它将为您在剪贴板中生成一个命令行。将其粘贴到 shell 中以获取使传输的 curl 命令行。该功能在所有 Chrome 和 Chromium 安装中默认可用。

![使用 Chrome 的 copy as curl](img/chrome-copy-as-curl.png)

## 在 Firefox 中，不使用 devtools

如果这是您经常要完成的事情，您可能会发现使用开发者工具有点不方便和繁琐，只是为了复制命令行。然后 [cliget](https://addons.mozilla.org/en-US/firefox/addon/cliget/) 是您的理想选择，因为它为您提供了右键菜单中的新选项，因此您可以快速生成一个命令行，就像我在 Firefox 中右键单击图像时的这个示例一样：

![使用 Firefox 的 cliget](img/firefox-cliget.png)

## 不完美

这些方法都会给你一个命令行来重现它们的 HTTP 传输，但是您还会了解到，它们通常仍然不是您问题的完美解决方案。为什么？嗯，主要是因为这些工具被编写为重新运行您复制的 *完全相同* 的请求，而您通常希望重新运行相同的逻辑，但不发送完全相同的 cookie 和文件内容等。

这些工具将为您提供具有静态和固定 cookie 内容的命令行，以在请求中发送，因为这是浏览器请求中发送的 cookie 内容。您很可能希望重写命令行，以动态适应服务器在先前响应中告诉您的 cookie 内容等任何内容。等等。

复制作为 curl 功能也经常在使用 `-F` 时表现糟糕，而是提供手工制作的 `--data-binary` 解决方案，包括 mime 分隔符字符串等。

# curl 示例

# curl 示例

待定

## 获取 URL 的许多变体

待定

## 自动跟随重定向

待定

## 冒充特定的网络浏览器

待定

## 发起网络搜索

待定

## 告诉服务器你来自哪里

待定

## 使用 cookies 维护状态

待定

## 使用 POST 登录到一个网络服务

待定

## 上传文件就像使用 HTML 表单一样

待定

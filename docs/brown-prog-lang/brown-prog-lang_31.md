# 31Mutation：结构和变量

|     31.1 将含义与符号分离 |
| --- |
|     31.2 变异和闭包 |
|     31.3 可变结构 |
|       31.3.1 扩展语言表示 |
|       31.3.2 方框的解释 |
|       31.3.3 环境是否有助于？ |
|       31.3.4 欢迎来到商店 |
|       31.3.5 解释方框 |
|       31.3.6 实现变异：微妙和变化 |
|     31.4 变量 |
|       31.4.1 变量赋值的语法 |
|       31.4.2 解释变量 |
|       31.4.3 引用参数传递 |
|     31.5 有状态语言操作的设计 |
|     31.6 键入状态 |
|       31.6.1 变异和多态 |
|       31.6.2 键入初始值 |

## 31.1 将含义与符号分离

这些中哪一个是相同的？

> +   f = 3
> +   
> +   o.f = 3
> +   
> +   f = 3

假设这三者都在 Java 中，则第一种和第三种可能会完全像第二种一样，也可能会完全像第二种一样：这完全取决于 f 是局部标识符（例如参数）还是对象的字段（即，代码实际上是 this.f = 3）。

在任一情况下，我们都要求评估器永久更改绑定到 f 的值。 这对其他观察者有重要的影响。 到目前为止，对于给定的输入集，计算总是返回相同的值。 现在，答案取决于何时调用它：在上面，它取决于在 f 的值更改之前还是之后调用了它。 时间的引入对于预测程序行为具有深远的影响。

然而，在上述统一语法中实际上有两种完全不同的变化概念。 更改字段的值（o.f = 3 或 this.f = 3）与更改标识符的值极为不同（f = 3 其中 f 是方法内的参数或本地绑定，而不是由对象绑定）。 我们将依次探讨这些。 我们将在下面处理字段，并在变量中返回标识符。

为了研究这两个特性，我们通常会编写解释器。然而，为了确保我们暴露它们的本质，我们将写这些解释器而不使用状态。也就是说，我们将做一些非常了不起的事情：编写无突变的解释器，其忠实地模拟了具有突变的语言。这其中的关键是一种特殊的计算中传递信息的模式。

## 31.2 突变和闭包

在我们继续之前，请确保你已经理解了 boxes（A Canonical Mutable Structure），特别是突变和闭包之间的交互（Interaction of Mutation with Closures: Counters）。

与闭包（及其近亲对象[REF]）的交互尤其微妙。考虑以下情况：这个例子是由 Corky Cartwright 描述给我的。你正在编写一个 GUI 程序来实现一个计算器。与每个计算器按钮对应的 GUI 元素需要一个回调——实质上是一个闭包——当调用时，它将报告该特定按钮被按下。因此，很容易这样初始化：

| for(var i = 0; i < 10; i++) { |
| --- |
|   button[i] = function() { return i; } |
| } |

这个伪代码几乎不需要任何改变就可以转换成任意数量的语言，包括有静态类型和没有静态类型的语言，从 Python 到 Swift 都可以。（假设 button 已经被适当初始化。）请注意，上面创建的所有闭包都在它们的环境中具有 i。现在让我们试着检查这些闭包的行为：

| for(var i = 0; i < 10; i++) { |
| --- |
|   println(button[i]()) |
| } |

也就是说，我们从 button 中提取第 i 个闭包，并将其应用到无参数上。这会评估返回 i 语句。

我们可能希望这会产生 0、1、2 等值的序列，一直到 9。但实际上，它产生了十个相同的输出：10。

> 现在开始！
> 
> > 你看明白了吗？你会如何修复这个问题？

问题在于 for 循环中的 i 只分配一次。因此，所有的闭包共享相同的 i。因为那个值必须变成 10 才能让 for 循环终止，所以所有的闭包都报告值为 10。

使用传统的 for 循环，这个问题并没有明显的解决方法。这种看似令人困惑的行为经常让那些刚接触闭包语言的程序员感到困惑。因为他们无法改变 for 循环的行为，所以许多语言都引入了新版本的 for（或者 for 内部的新关键字）来解决这个问题。解决方案始终是在每次迭代时分配一个新的 i，这样每个闭包就都是对不同的变量进行操作；循环结构会将上一个 i 的值复制为新的 i 的初始值，然后应用更新器（在本例中为 i++），然后执行比较和循环体。

注意，在函数式编程时，期望的行为是免费的。例如：

```
funs =
  for map(i from range(0, 10)):
    lam(): i end
  end

check:
  map(lam(c): c() end, funs)
    is range(0, 10)
end
```

|     Box<Integer> b1 = new Box<Integer>(1); |

```
funs =
  map(
    lam(i):
      lam():
        i
      end
    end,
    range(0, 10))
```

注意，在 setboxC 表达式中，盒位置和其新值都是表达式。后者并不奇怪，但前者可能会。这意味着我们可以在相应的 Pyret 中编写这样的程序：

## | where: |

装备了这些例子，现在让我们回到以可变结构的形式向语言添加突变（这也是可变对象的一个很好的基础[REF]）。

> |   index(l, 0)!{v : 1} |
> 
> > |   l = [list: b0, b1] |
> > 
> > | public static void main (String[] args) { |
> > 
> 这个顺序很重要吗？
> 
> > |   b1 = box(1) |

这是解糖非规范性质的一个很好的例证。我们选择向核心添加一个构造，这个构造确实是不必要的。如果我们的目标是缩小解释器的大小—<wbr>也许以某种对输入程序大小的代价—<wbr>我们不会做出这个选择。但我们这里的目标是理解语言中的关键思想，因此我们选择组合最具教学意义的功能。即使可以消除 begin 作为语法糖，但它将证明对理解突变的工作方式非常有用。因此，我们将向核心添加一个简单的两项版本的序列（seqC）。反过来，由于我们的核心语言变得难以操纵，我们将放弃布尔值和条件值，除非它们的存在使事情更有趣：在这里并不是。

### 将 funs 的定义写得更加明确以更好地理解其工作原理是更容易的：

首先，让我们扩展我们的核心语言数据类型：

```
data ExprC:
  | numC(n :: Number)
  | plusC(l :: ExprC, r :: ExprC)
  | multC(l :: ExprC, r :: ExprC)
  | idC(s :: String)
  | appC(f :: ExprC, a :: ExprC)
  | fdC(arg :: String, body :: ExprC)
  | boxC(v :: ExprC)
  | unboxC(b :: ExprC)
  | setboxC(b :: ExprC, v :: ExprC)
  | seqC(b1 :: ExprC, b2 :: ExprC)
end
```

除了可变结构本身之外，注意我们有时必须以组的形式执行突变（例如，从一个银行账户中取钱并将其存入另一个账户）。因此，能够按顺序对一组可变操作进行排序是很有用的。我们将其称为开始：它按顺序评估其子项项，并返回最后一个的值。

> | 为什么开始要按特定的顺序评估其子项项呢？ |
> | --- |
> | end |
> | 练习 |
> | 因此，我们可以看到，在每次迭代中，外部 lam(i): ... 被应用，分配一个新的 i，这是内部 lam(): ... 所闭合的 i。 |
> |   l = make-box-list() |
> | 这将评估为一个包含 1 和第二个包含 2 的盒子列表。注意，在每个突变语句中，我们都使用了一个复杂的表达式—<wbr>例如，index(l, 0)—<wbr>而不是一个字面值或标识符来获取盒子并进行突变（!{v : 1}）。这正是类似于 Java 的语言，其中可以（在某种类型上采取自由）编写 |
> |   b0 = box(0) |
> | fun make-box-list(): |
> | 31.3 可变结构 |
> |   index(l, 0)!v is 1 |
> |     Box<Integer> b0 = new Box<Integer>(0); |
> | 31.3.1 扩展语言表示 |

|   index(l, 1)!v is 2 |

|   index(l, 1)!{v : 2} |
| --- |
| 练习 |
| 通过将 begin 解糖为 let（因此解糖为匿名函数）来定义 begin。 |
|   l |
|     ArrayList<Box<Integer>> l = new ArrayList<Box<Integer>>(); |
|     l.add(b0); |
|     l.add(b1); |
|  |
|     l.get(0).set(1); |
|     l.get(1).set(2); |
| } |

注意 l.get(0)是一个复合表达式，用于找到适当的盒子，并评估为调用 set 的盒子对象。

为了方便起见，我们将假设我们已经实现了解糖以提供（a）let 和（b）如果需要，一个序列中超过两个术语的解糖（可以解糖为嵌套序列）。我们有时也会用原始的 Pyret 语法编写表达式，既为了简洁（因为核心语言术语可能会变得相当庞大和笨重），也为了让你能够在 Pyret 中运行相同的术语并观察它们产生的答案。正如这意味着的那样，我们正在以 Pyret 中的行为为参考行为，其中可变结构的行为类似于几乎所有主流语言中可变对象和结构的行为。

### 31.3.2 盒子的解释

首先，因为我们引入了一种新的值，即盒子，我们必须更新值的集合：<mut-str-value/1> ::=

|   data Value: |
| --- |
|     &#124; numV(n :: Number) |
|     &#124; closV(f :: ExprC%(is-fdC), e :: Env) |
|     &#124; boxV(v :: Value) |
|   end |

现在让我们开始重现我们当前的解释器：<mut-str-interp/1> ::=

|   fun interp(e :: ExprC, nv :: Env) -> Value: |
| --- |
|     cases (ExprC) e: |
|       &#124; numC(n) => numV(n) |
|       &#124; plusC(l, r) => plus-v(interp(l, nv), interp(r, nv)) |
|       &#124; multC(l, r) => mult-v(interp(l, nv), interp(r, nv)) |
|       &#124; idC(s) => lookup(s, nv) |
|       &#124; fdC(_, _) => closV(e, nv) |
|       &#124; appC(f, a) => |
|         clos = interp(f, nv) |
|         arg-val = interp(a, nv) |
|         interp(clos.f.body, |
|           xtnd-env(bind(clos.f.arg, arg-val), clos.e)) |
|       <mut-str-interp/1-boxC> |
|       <mut-str-interp/1-unboxC> |
|       <mut-str-interp/1-seqC> |
|     end |
|   end |

(很快你就会明白为什么缺少 setboxC 的情况。这两种情况应该很容易。当我们得到一个盒子表达式时，我们只需评估内容并将其包装在盒子 V 中返回：<mut-str-interp/1-boxC> ::=

|   &#124; boxC(v) => boxV(interp(v, nv)) |
| --- |

类似地，从盒子中提取值很容易：<mut-str-interp/1-unboxC> ::=

|   &#124; unboxC(b) => interp(b, nv).v |
| --- |

到目前为止，你应该正在构建一组健康的测试用例，以确保它们的行为符合你的期望。

当然，我们还没有做任何艰苦的工作。所有有趣的行为，大概都隐藏在 setboxC 的处理中。因此，也许会让你惊讶的是，我们将首先看 seqC 而不是 setboxC（你将看到为什么我们将其包含在核心中）。

让我们采用最自然的两条指令序列的实现：<mut-str-interp/1-seqC> ::=

|   &#124; seqC(b1, b2) => |
| --- |
|     b1-value = interp(b1, nv) |
|     b2-value = interp(b2, nv) |
|     b2-value |

这意味着，我们先评估第一个表达式，然后再评估第二个，并返回第二个的结果。你应该立即发现了一些令人不安的地方。我们绑定了评估第一个表达式的结果，但随后没有对其进行任何操作。没关系：可能第一个表达式包含了某种变异表达式，它的值是无趣的。因此，等价的实现可能是这样的：<mut-str-interp/1-seqC/2> ::=

|   &#124; seqC(b1, b2) => |
| --- |
|     interp(b1, nv) |
|     interp(b2, nv) |

这不仅略显不满，因为它只使用了 Pyret 的顺序行为，而且肯定是错误的！只有当变异的结果被存储在某个地方时，这才能起作用。但是因为我们的解释器只计算值，并且不执行任何变异本身——因为那样就是作弊——interp(b1, nv) 中的任何变异都完全丢失了。这显然不是我们想要的。（因此，我们甚至不打算定义在 setbox 情况下该怎么办。）

### 31.3.3 环境能起到帮助作用吗？

这是一个可以帮助的输入示例：

| (let ([b (box 0)]) |
| --- |
|   (begin (begin (set-box! b (+ 1 (unbox b))) |
|                 (set-box! b (+ 1 (unbox b)))) |
|          (unbox b))) |

在 Racket 中，这个求值结果为 2。

> 练习
> 
> > 在 ExprC 中表示此表达式。

让我们考虑内部序列的评估。在两种情况下，表达式（即 (set-box! ...) 的表示）完全相同。但是底层发生了一些变化，因为这导致箱子的值从 0 变为 2！如果我们改为评估以下表达式，我们可以更清楚地“看到”这一点

| (let ([b (box 0)]) |
| --- |
|   (+ (begin (set-box! b (+ 1 (unbox b))) |
|             (unbox b)) |
|      (begin (set-box! b (+ 1 (unbox b))) |
|             (unbox b)))) |

这将评估为 3。在这里，对加法规则中的两次 interp 调用在两种情况下都评估完全相同的文本表达式。但是不知何故，左分支的效果在右分支中产生了影响。远程神秘作用。

如果解释器被给予完全相同的表达式，它如何可能避免产生完全相同的答案？最明显的方法是，如果解释器的另一个参数，即环境，在某种程度上是不同的。到目前为止，完全相同的环境被发送到序列的两个分支和加法的两个分支，因此我们的解释器——在给定输入时每次产生相同的输出——无法产生我们想要的答案。

到目前为止，我们所知道的是：

1.  我们必须确保解释器在调用时得到不同的参数，以期望产生不同的结果。

1.  我们必须返回解释器在评估其参数表达式时所做的变异的记录。

因为表达式是什么样子的，第一个观点表明我们可以尝试使用环境来反映调用之间的差异。反过来，第二个观点表明解释器的每次调用也应该返回环境，以便可以传递给下一次调用。因此，解释器应该被修改为同时返回值和更新后的环境。也就是说，解释器接受一个表达式和环境；它在该环境中进行评估，并随着过程的进行更新它；当表达式完成评估时，解释器返回答案（就像以前一样），以及一个更新后的环境，然后将其发送到解释器的下一次调用。而且，对 setboxC 的处理应该以某种方式影响环境以反映变化。然而，在我们深入实施之前，我们应该考虑这种变化的后果。环境已经发挥了重要作用：它保存了延迟替换。在这方面，它已经具有了精确的语义——由替换给出——我们必须小心不要改变它。与替换的联系的一个结果是它也是词法作用域信息的存储库。例如，如果我们允许扩展环境从一个加法分支逃逸并在另一个分支中使用，那么考虑以下程序的等效物的影响：

| (+ (let ([b (box 0)]) |
| --- |
|      1) |
|    b) |

显然，这个程序有一个错误：加法的右分支中的 b 是未绑定的（左分支中 b 的作用域在 let 结束时结束——如果这不明显，请将上述表达式去糖以使用函数）。但在解释 let 结束时，扩展环境中明显有 b 绑定。

> 练习
> 
> > 详细解决上述问题并确保你理解它。

你可以尝试各种其他相关的提案，但它们很可能都存在类似的缺陷。例如，你可能会决定，由于问题涉及到环境中的附加绑定，你将在返回的环境中删除所有添加的绑定。听起来不错？你还记得我们有闭包吗？

> 练习
> 
> > 考虑以下程序的表示：
> > 
> > | (let ([a (box 1)]) |
> > | --- |
> > |   (let ([f (fun x (+ x (unbox a)))]) |
> > |     （开始 |
> > |       (set-box! a 2) |
> > |       (f 10)))) |
> > 
> > 这个例子引起了什么问题？

相反，我们应该注意到，虽然上述描述的约束都是有效的，但我们提出的解决方案并不是唯一的解决方案。请注意，实际上，这两个条件都不要求环境成为负责的代理。事实上，很明显环境不能是主要的代理。我们需要其他东西。

### 31.3.4 欢迎来到商店

前面的讨论告诉我们，我们需要两个存储库来陪伴表达式，而不是一个。其中一个，环境，继续负责维护词法范围。但环境不能直接将标识符映射到它们的值，因为值可能会改变。相反，需要有其他东西负责维护突变框的动态状态。这后一个数据结构称为存储器。

像环境一样，存储器是一个部分映射。其定义域可以是任何抽象名称集合，但自然地将其视为数字，表示内存位置。这是因为语义中的存储器直接映射到（抽象化的）机器物理内存，传统上由数字地址寻址。因此，环境将名称映射到位置，而存储器将位置映射到值：

```
data Binding:
  | bind(name :: String, location :: Number)
end

type Env = List<Binding>
mt-env = empty
xtnd-env = link

data Storage:
  | cell(location :: Number, value :: Value)
end

type Store = List<Storage>
mt-sto = empty
xtnd-sto = link
```

我们还将配备一个函数来在存储器中查找值，就像我们已经为环境配备了一个函数一样（它现在返回位置而不是值）：

```
fun lookup(s :: String, nv :: Env) -> Number: ...
fun fetch(n :: Number, st :: Store) -> Value: ...
```

> 练习
> 
> > 填写查找和提取的主体。

有了这个，我们可以将值的概念精确化为正确的：<mut-str-value> ::=

|   data Value: |
| --- |
|     &#124; numV(n :: Number) |
|     &#124; closV(f :: ExprC, e :: Env) |
|     &#124; boxV(l :: Number) |
|   end |

### 31.3.5 解释框箱

现在我们有了解释器可以返回的东西，经过更新，反映了在表达式评估过程中的突变，而不需要以任何方式更改环境。因为函数只能返回一个值，我们将使用一个具有两个字段的特设对象：v 用于值（它将（有效地）与解释器最初返回的值相同），st 用于（潜在地）更新的存储器。我们将使用以下辅助函数来组装结果：

```
fun ret(v :: Value, st :: Store): {v : v, st : st} end
```

> 练习
> 
> > 为什么我们在上面说“有效地”和“潜在地”？
> > 
> > “有效地”的提示：看闭包。

因此，我们的解释器变成了：<mut-str-interp> ::=

|   fun interp(e :: ExprC, nv :: Env, st :: Store): |
| --- |
|     cases (ExprC) e: |
|       <mut-str-interp/numC> |
|       <mut-str-interp/plusC> |
|       <mut-str-interp/idC> |
|       <mut-str-interp/fdC> |
|       <mut-str-interp/appC> |
|       <mut-str-interp/boxC> |
|       <mut-str-interp/unboxC> |
|       <mut-str-interp/setboxC> |
|       <mut-str-interp/seqC> |
|     end |
|   end |

最容易分配的是数字。记住，我们必须返回反映在评估给定表达式时发生的所有突变的存储。因为数字是一个常数，所以不可能发生突变，所以返回的存储与传入的存储相同：<mut-str-interp/numC> ::=

|   &#124; numC(n) => ret(numV(n), st) |
| --- |

对于闭包的创建也适用类似的论点；请注意我们正在讨论闭包的创建，而不是使用：<mut-str-interp/fdC> ::=

|   &#124; fdC(_, _) => ret(closV(e, nv), st) |
| --- |

标识符几乎和数字一样简单，但是如果你太简单化了，你会得到一个类型错误，提示你要获取一个值，你现在必须在环境和存储中查找：<mut-str-interp/idC> ::=

|   &#124; idC(s) => ret(fetch(lookup(s, nv), st), st) |
| --- |

注意查找和提取如何组合以产生与之前仅使用查找产生的相同结果。

现在事情变得有趣起来了。

让我们来谈谈序列。显然，我们需要解释这两个项。<mut-str-interp/seqC/alt> ::=

|   &#124; seqC(b1, b2) => |
| --- |
|     interp(b1, nv, st) |
|     interp(b2, nv, st) |

哦，等等。整个重点是评估由第一个返回的存储中的第二项——否则所有这些变化就没有意义。因此，相反地，我们必须评估第一项，捕获结果存储，并使用它来评估第二项。（评估第一项还产生它的值，但是顺序忽略了这个值，并假定第一项纯粹是为了其潜在的突变而运行。）因此：<mut-str-interp/seqC> ::=

|   &#124; seqC(b1, b2) => |
| --- |
|     b1-value = interp(b1, nv, st) |
|     interp(b2, nv, b1-value.st) |

这里要解释第一项：interp(b1, nv, st)；给产生的值，其中包含 v 和 st 字段，命名为 b1-value；并在第一个存储中评估第二项：interp(b2, nv, b1-value.st)。结果将是第二项返回的值和存储，这是我们预期的。因为我们从未使用 b1-value.v，所以第一项的影响仅仅是在存储上，这可以从代码中看出。

> 现在开始！
> 
> > 花一会儿时间思考上面的代码。你很快就需要调整你的眼睛来流畅地阅读这种模式。

现在让我们继续讨论二进制算术原语。这些与序列相似，因为它们有两个子项，但在这种情况下，我们确实关心每个分支的值。像往常一样，我们只看 plusC，因为 multC 几乎相同。<mut-str-interp/plusC> ::=

|   &#124; plusC(l, r) => |
| --- |
|     lv = interp(l, nv, st) |
|     rv = interp(r, nv, lv.st) |
|     ret(plus-v(lv.v, rv.v), rv.st) |

请注意，我们重复了这个模式，因为我们有两个子表达式要评估，我们希望使用它们的值。因此，第一个存储（lv.st）用于解释第二个表达式，并且总体结果返回第二个表达式的结果（rv.st）。

这是一个重要的区别。当我们评估一个术语时，通常根据语言的作用域规则为其所有子术语使用相同的环境。因此，环境以递归下降模式流动。相反，存储是经过线程化的：我们不是在所有分支中使用相同的存储，而是从一个分支获取存储，然后传递给下一个分支，并将结果发送回去。这种模式称为存储传递风格。

现在一切都水到渠成了。我们看到，传递存储的风格是我们的秘密武器：它使环境能够保留词法范围，同时仍然提供可以反映更改的绑定结构。我们的直觉告诉我们，环境必须以某种方式参与获取相同语法表达式的不同结果，现在我们可以看到它是如何做到的：不是直接通过自身更改，而是间接地通过引用存储，然后更新。现在我们只需要看看存储本身是如何“改变”的。

让我们从盒子开始。要将值存储在盒子中，我们首先必须在存储中分配一个新的位置，该值将驻留在其中。然后，与盒子对应的值将记住此位置，以供盒子变异时使用。为了每次都能获得新值，我们将使用我们之前见过的有状态计数器示例（突变与闭包的相互作用：计数器
```

有了这个，我们现在可以定义盒子创建的解释：<mut-str-interp/boxC> ::=

|   &#124; boxC(v) => |
| --- |
|     val = interp(v, nv, st) |
|     loc = new-loc() |
|     ret(boxV(loc), |
|       xtnd-sto(cell(loc, val.v), st)) |

> 现在动手！
> 
> > 请注意，我们在上面依赖了 new-loc，它本身是基于盒子实现的！这是彻头彻尾的作弊。您将如何修改解释器，以便我们不再需要突变来处理这一小段状态？

要消除 new-loc，最简单的选项是向解释器添加另一个参数，并从解释器返回值，表示到目前为止使用的最大地址。每个在存储中分配的操作都将返回一个递增的地址，而所有其他操作都将保持不变。换句话说，这正是存储传递模式的另一个应用。以这种方式编写解释器将使其非常笨重，并可能掩盖更重要的存储传递模式的使用，这就是我们没有这样做的原因。但是，重要的是要确保我们可以做到：这告诉我们，我们不依赖状态来向语言添加状态。

现在盒子记录了内存中的位置，获取与之对应的值就很容易了。<mut-str-interp/unboxC> ::=

|   &#124; unboxC(b) => |
| --- |
|     val = interp(b, nv, st) |
|     ret(fetch(val.v.l, val.st), val.st) |

这与我们之前看到的模式相同，我们必须使用 fetch 来获取实际驻留在该位置的值。请注意，我们依赖于 Racket 在底层值实际上不是 boxV 时出错停止；否则，不检查将是危险的，因为这等同于对任意内存进行解引用[REF memory safety]。

现在让我们看看如何更新盒子中保存的值。首先，我们必须评估盒子表达式以获得一个盒子，以及值表达式以获得要存储在其中的新值。盒子的值将是一个包含位置的盒子 V。

原则上，我们希望“更改”或覆盖存储中该位置的值。我们可以通过两种方式实现这一点。

1.  其中一个是遍历存储，找到该位置的旧绑定，并用新的替换它，同时保持所有其他存储绑定不变。

1.  另一个更懒惰的选择是简单地为该位置扩展存储，这在我们总是获得位置的最新绑定时有效（这就是环境中查找的工作方式，因此获取可以在存储中执行相同的操作）。请注意，后一种选择迫使我们承诺使用列表而不是集合。

下面的代码是独立于这些选项的编写：<mut-str-interp/setboxC> ::=

|   &#124; setboxC(b, v) => |
| --- |
|     b-val = interp(b, nv, st) |
|     v-val = interp(v, nv, b-val.st) |
|     ret(v-val.v, |
|       xtnd-sto(cell(b-val.v.l, v-val.v), v-val.st)) |

如果我们像上面的链接一样实现了 xtnd-sto，实际上我们已经采取了更懒惰的（稍微更危险，因为它依赖于 fetch 实现）选择。

> 练习
> 
> > 实现存储更改的另一版本，通过更新现有绑定来避免在存储中为位置创建多个绑定。
> > 
> 练习
> 
> > 当我们寻找要覆盖其存储的值的位置时，该位置可能不存在吗？如果是这样，请编写一个演示此情况的程序。如果不是，请解释解释器的不变性防止这种情况发生。

好了，除了应用程序之外，我们现在已经完成了一切！大部分应用程序应该已经很熟悉了：评估函数位置，评估参数位置，在扩展闭包环境中解释闭包体...但存储如何与此交互？<mut-str-interp/appC> ::=

|   &#124; appC(f, a) => |
| --- |
|     clos = interp(f, nv, st) |
|     clos-v :: Value = clos.v |
|     clos-st :: Store = clos.st |
|     arg-val = interp(a, nv, clos-st) |
|     <mut-str-interp/appC/core> |

让我们从考虑扩展闭包环境开始。我们要扩展的名称显然是函数形式参数的名称。但我们将它绑定到哪个位置呢？为了避免与已使用位置混淆（我们稍后将明确介绍的混淆！—<wbr>参考参数传递），让我们只分配一个新位置。此位置在环境中使用，并且参数的值驻留在存储器中的此位置：<mut-str-interp/appC/core> ::=

|   new-loc = new-loc() |
| --- |
|   interp(clos-v.f.body, |
|     xtnd-env(bind(clos-v.f.arg, new-loc), clos-v.e), |
|     xtnd-sto(cell(new-loc, arg-val.v), arg-val.st)) |

因为我们没有说函数参数是可变的，所以没有必要以这种方式实现过程调用。我们可以像以前一样遵循相同的策略。事实上，观察到这个位置的可变性永远不会被使用：只有 setboxC 改变了已存在存储位置中的内容（上面的 xtnd-sto 在技术上是一个存储器初始化），而且只有在它们被 boxVs 引用时才这样做，但上面没有分配任何盒子。你可以称之为无用的应用存储器。然而，我们选择以这种方式实现应用程序是为了统一性，并减少我们需要处理的情况的数量。

> 练习
> 
> > 尝试将存储位置的使用限制在盒子中是一种有用的练习。你需要做多少改变？

### 31.3.6 实现突变：微妙和变化

即使我们已经完成了实现，仍然有许多微妙之处和见解需要讨论。

1.  我们实现中的一个微妙而重要的决定是评估顺序。例如，为什么我们没有这样实现加法呢？

    <mut-str-interp/plusC/alt> ::=

    |   &#124; plusC(l, r) => |
    | --- |
    |     rv = interp(r, nv, st) |
    |     lv = interp(l, nv, rv.st) |
    |     ret(plus-v(lv.v, rv.v), lv.st) |

    这样做也完全一致。同样，存储传递模式中体现出的是在评估函数位置之前评估参数的决定。观察到：

    1.  以前，我们将这些决定委托给底层语言实现。现在，传递存储已经迫使我们将计算序列化，并因此自行做出这个决定（无论我们是否意识到了这一点）。

    1.  更重要的是，这个决定现在是一个语义决定。在没有变异之前，例如，加法的一个分支不能影响另一个分支产生的值。它们唯一的影响是停止并出现错误或���法终止——<wbr>这确实是可观察的效果，但在更粗略的层面上。程序不会因为评估顺序的不同而以两个不同的答案终止。因为每个分支都可能有影响其他分支值的变异，所以我们必须选择某种顺序，以便程序员可以预测他们的程序将要做什么！被迫编写一个传递存储的解释器已经让这一点变得清楚。

1.  注意，在应用规则中，我们传递了动态存储，即从评估函数和参数得到的存储。这恰恰与我们对环境的要求相反。这种区别至关重要。存储实际上是“动态作用域的”，因为它反映了计算的历史，而不是其词法形状。然而，由于我们已经使用术语“作用域”来指代标识符的绑定，因此说“动态作用域”来指代存储会令人困惑。相反，我们只是说它是持久的。

    有时语言会危险地混淆这两者。例如，在 C 语言中，绑定到本地标识符的值（默认情况下）是在堆栈上分配的。然而，堆栈与环境匹配，因此在调用完成后会消失。然而，如果调用返回对这些值的引用，这些引用现在指向未使用或甚至被覆盖的内存：这是 C 程序中严重错误的真正来源。问题在于程序员希望值本身保持持久；但是为这些值分配的存储与标识符的存储混为一谈，后者随着词法范围的出现和消失而变化。

1.  我们已经讨论了覆盖存储的两种策略：简单地扩展它（并依赖于提取最新存储的 fetch）或“搜索和替换”。后一种策略的优点是不保留永远无法再次获得的无用存储绑定。

    然而，这并不能覆盖所有浪费的内存。随着时间的推移，我们将无法访问某些盒子：例如，如果它们仅绑定到一个标识符，而该标识符不再在作用域内。这些位置被称为垃圾。从更概念上来看，垃圾位置是那些消除对程序产生的值没有任何影响的位置。通常有许多自动识别和回收垃圾位置的策略，通常称为垃圾收集[REF]。

1.  对于每个表达式位置进行评估并穿插结果存储非常重要。例如，考虑 unboxC 的另一种实现（与<mut-str-interp/unboxC>进行比较）：<mut-str-interp/unboxC/alt-1> ::=

    |   &#124; unboxC(b) => |
    | --- |
    |     val = interp(b, nv, st) |
    |     ret(fetch(val.v.l, st), val.st) |

    你注意到了吗？我们从`st`而不是`val.st`中提取了位置。但是`st`反映了`unboxC`表达式评估之前但在其中之前的突变，而不是其中的任何突变。可能有吗？当然有！

    | (let ([b (box 0)]) |
    | --- |
    |   (unbox (begin (set-box! b 1) |
    |                 b))) |

    在上述错误的代码中，这将评估为 0 而不是 1。

1.  这是另一个类似的错误（再次与<mut-str-interp/unboxC>比较）：<mut-str-interp/unboxC/alt-2> ::=

    |   &#124; unboxC(b) => |
    | --- |
    |     val = interp(b, nv, st) |
    |     ret(fetch(val.v.l, val.st), st) |

    我们如何打破这个？最后我们返回旧存储，即在`unboxC`中的任何突变之前的存储。因此，我们只需要外部上下文依赖于其中一个。

    | (let ([b (box 0)]) |
    | --- |
    |   (+ (unbox (begin (set-box! b 1) |
    |                    b)) |
    |      (unbox b))) |

    这应该评估为 2，但因为返回的存储是一个其中`b`的位置绑定到 0 的表示，所以结果是 1。

    如果我们将上述两个错误结合起来——即，在最后一行中两次使用`st`而不是两次使用`s-a`——这个表达式将评估为 0 而不是 2。

    > 练习
    > 
    > > 通过解释器；将每个对更新后存储的引用替换为对更新前存储的引用；确保你的测试用例捕获所有引入的错误！

1.  注意这些对“旧”存储的使用使我们能够执行一种时间旅行：因为突变引入了时间的概念，所以这使我们能够回到突变尚未发生的时间。这听起来既有趣又反常；它有用吗？

    它确实做到了！想象一下，我们不是直接突变存储，而是引入了一个关于存储预期更新的日志的概念。日志以与真实存储本身完全相同的线程方式流动。某些指令创建一个新的日志；在那之后，所有查找首先检查日志，只有当日志找不到位置的绑定时才在实际存储中查找。还有两个新指令：一个是丢弃日志（即，回到过去），另一个是提交日志（即，所有编辑都应用于实际存储）。

    这就是软件事务内存的本质。每个线程维护自己的日志。因此，一个线程在提交之前不会看到其他线程所做的编辑（因为每个线程只看到自己的日志和全局存储，而不看其他线程的日志）。同时，每个线程都得到了自己一致的世界视图（它看到了自己所做的编辑，因为这些编辑记录在日志中）。如果事务成功结束，所有线程都会原子地看到更新后的全局存储。如果事务中止，则丢弃的日志会带走所有更改，线程的状态会恢复（除了其他线程提交的全局更改）。

    软件事务内存提供了解决多线程编程困难的最明智方法之一，如果我们坚持使用共享可变状态进行编程。然而，由于大多数计算机只有一个全局存储器，因此维护日志可能会很昂贵，而且需要大量的工作来对其进行优化。作为一种替代方案，一些硬件架构已经开始通过提供直接支持事务内存来使创建、维护和提交日志像使用全局存储一样高效，消除了采用这一想法的一个重要障碍。

    > 练习
    > 
    > > 增加语言的软件事务内存日志功能。
    > > 
> 练习
> 
> > 另一种实现策略是将环境映射名称到装箱的值。我们在这里不这样做是因为：(a) 这将是作弊，(b) 不会告诉我们如何在没有装箱的语言中实现相同的功能，(c) 不一定适用于其他变异操作，以及 (d) 最重要的是，这并没有真正让我们了解这里发生了什么。
> > 
> > 尽管如此，理解这一点仍然是有用的，至少因为当您实现自己的语言时，您可能会发现这是一个有用的策略。因此，修改实现以遵守这一策略。您是否仍然需要存储传递样式？为什么或为什么不？

## 31.4 变量

现在我们已经解决了结构变异，让我们考虑另一种情况：变量变异。我们已经讨论过（从标识符到变量）我们术语选择，并在 Pyret 中看到了它们的使用示例。特别是，其他语言会重载变异语法，正如我们所见（将含义与表示分离），在 Pyret 中它们保持不同：! 变异对象的字段，而 := 变异变量。这迫使 Pyret 程序员面对我们在将含义与表示分离开头介绍的区别。当然，在我们的核心语言中，我们将通过使用不同的构造来避开这些语法问题，用于箱子和变量。

### 31.4.1 变量赋值的语法

关于变量变异的第一件事是，尽管它也有两个子项，就像箱子变异（setboxC）一样，但其语法基本上是不同的。要理解为什么，让我们回到我们的 Java 片段：

| x = 3; |
| --- |

在这种情况下，我们不能在 x 的位置写入任意表达式：我们必须直接写入标识符本身的名称。这是因为，如果它是一个表达式位置，那么我们可以对其进行求值，得到一个值：例如，如果 x 先前绑定到 1，这将等同于写入以下语句：

| 1 = 3; |
| --- |

但这显然是荒谬的！我们不能将新值赋给 1，实际上 1 几乎就是不可变的定义。我们真正想要的是找到 x 在存储中的位置，并更改那里保存的值。另一种看待这个问题的方式是，假设在 Java 中，局部变量 o 已经绑定到某个 String 对象上：

| o = new String("一个初始字符串"); |
| --- |

假设程序现在执行

| o = new String("一个新字符串"); |
| --- |

它是在尝试改变原始字符串的内容（"一个初始字符串"）吗？当然不是：第二个赋值意图保持原始字符串不变；它只想要改变 o 所引用的值，以便随后的引用计算出这个新字符串（"一个新字符串"）对象。

### 31.4.2 解释变量

我们将首先在我们的语法中反映这一点：

```
data ExprC:
  | numC(n :: Number)
  | plusC(l :: ExprC, r :: ExprC)
  | multC(l :: ExprC, r :: ExprC)
  | varC(s :: String)
  | appC(f :: ExprC, a :: ExprC)
  | fdC(arg :: String, body :: ExprC)
  | setC(v :: String, b :: ExprC)
  | seqC(b1 :: ExprC, b2 :: ExprC)
end
```

请注意，我们已经放弃了盒子操作，但保留了顺序执行，因为它在突变时很方便。重要的是，我们现在添加了 setC 情况，它的第一个子项不是表达式，而是一个变量的文字名称。我们还将 idC 重命名为 varC。因为我们摆脱了盒子，所以也可以摆脱特殊的盒子值。当你只有一种突变类型时，你不需要新的值种类。

```
data Value:
  | numV (n :: Number)
  | closV (f :: ExprC, e :: List<Binding>)
end
```

正如你所想象的那样，要支持变量，我们需要与之前所见的相同的存储传递风格（解释盒子）以及出于同样的原因。不同的是我们如何精确地使用它。因为顺序执行的方式与之前完全相同（请注意，它的动词不取决于盒子还是变量），这样我们就只剩下变量突变的情况需要处理了。

首先，我们可以评估值表达式并获得更新后的存储：<mut-var-interp/setC> ::=

|   &#124; setC(v, b) => |
| --- |
|     new-val = interp(b, nv, st) |
|     <mut-var-interp/setC/core> |

现在怎么办？记得我们刚刚说过我们不想完全评估变量，因为那只会给出它绑定的值。相反，我们想知道它对应哪个内存位置，并更新该内存位置存储的内容；后半部分与我们突变盒子时所做的事情完全相同：<mut-var-interp/setC/core> ::=

|   var-loc = lookup(v, nv) |
| --- |
|   ret(new-val.v, |
|     xtnd-sto(cell(var-loc, new-val.v), new-val.st)) |

我们这里有一个非常有趣的新模式。当我们添加了盒子时，在 idC 的情况下（<mut-str-interp/idC>），我们在环境中查找标识符（就像上面一样），然后立即从存储中获取该位置处的值；组合产生了一个值，就像我们在添加存储之前一样。然而，现在，我们有一个新的模式：在环境中查找标识符，而不是随后从存储中获取它的值，即，我们只有一个变量评估的“一半”。调用 lookup 的结果传统上称为左值，表示“赋值的左边值”。这是一种说“内存地址”的花哨方式，并且与存储产生的实际值形成对比：注意它与类型 Value 中的任何内容都没有直接对应。

我们做完了！我们在实现存储传递样式时做了所有的艰苦工作（并且在那个应用程序中为变量分配新位置时也是如此）。

### 31.4.3 引用参数传递

让我们回到上面的括号语句：每个应用程序为参数分配一个新的存储位置。

> 现在做！
> 
> > 这为什么重要？考虑以下 Pyret 程序：
> > 
> > ```
> > fun f(x):
> >   x := 3
> > end
> > 
> > var y = 5
> > f(y)
> > ```
> > 
> > 运行之后，我们期望 y 的值是多少？

在上面的例子中，y 的评估结果为 5，而不是 3。这是因为形式参数 x 的值保存在与实际参数 y 不同的位置，因此突变影响了 x 的位置，而 y 并未受到影响。

现在假设，相反地，应用程序的行为如下。当实际参数是一个变量时，因此在内存中有一个位置时，它不是为值分配一个新的位置，而是简单地传递变量的现有位置。现在形式参数引用的是与实际参数相同的存储位置：即，它们是变量别名。因此，对形式参数的任何突变都会泄漏到调用上下文中；上面的程序将评估为 3 而不是 5。这称为引用参数传递策略。相反，我们的解释器实现了按值调用，这是像 Java 这样的语言所遵循的相同策略。这会引起混淆，因为当值本身是可变的时，调用者会观察到在被调用者中对值所做的更改。然而，这只是可变值的一个副作用，而不是调用策略的副作用。请避免这种混淆！

多年来，这种方法被认为是一个好主意。这是有用的，因为程序员可以编写抽象，比如 swap，它交换调用者的两个变量的值。然而，缺点远远超过了优点：

+   一个粗心的程序员可以在调用者中创建一个变量的别名并修改它，而不知道他们已经这样做了，调用者甚至可能不会意识到发生了这种情况，直到一些隐晦的条件触发它。

+   有些人认为这是为了效率而必要的：他们认为替代方案是复制大型数据结构。然而，传值调用与仅传递数据结构的地址是兼容的。只有在（a）数据结构是可变的，（b）您不希望调用方能够对其进行变异，以及（c）语言本身没有提供不可变性注释或其他机制时，您才需要复制。

+   它可以强制进行非本地和因此非模块化的推理。例如，假设我们有以下过程：

    ```
    fun f(g):
      var x = 10
      g(x)
      ...
    end
    ```

    如果语言允许按引用传递参数，那么程序员不能在本地—<wbr>即仅从上述代码—<wbr>确定椭圆中 x 的值，因为它取决于被调用方（作为参数传递）将是谁，以及它可能会做什么，这反过来可能取决于动态条件（包括月相）。

最起码，如果语言要允许按引用传递参数，它应该让调用方确定是否传递引用—<wbr>即让被调用方共享调用方变量的内存地址—<wbr>或不传递。然而，即使这个选项听起来并不那么吸引人，因为现在被调用方面临着对称的问题，不知道它的参数是否被别名。在传统的、顺序的程序中，这不是那么值得关注，但如果过程是可重入的，被调用方面临着完全相同的困境。

因此，我们应该考虑是否值得进行所有这些麻烦。相反，想要被调用方执行变异的调用方只需将一个封装值发送给被调用方。这个盒子表示调用方接受—<wbr>实际上，邀请—<wbr>被调用方执行变异，调用方在完成时可以提取值。这确实取消了编写简单交换程序的能力，但这是为了真正的软件工程问题所付出的小代价。

## 31.5 有状态语言操作的设计

尽管大多数编程语言包括我们研究过的一种或两种状态，但它们的允许不应该被视为一个微不足道的或既定的问题。一方面，状态带来了一些重要的好处：

+   状态提供了一种模块化的形式。正如我们的解释器所展示的那样，如果没有显式的状态操作，要实现相同的效果：

    +   我们需要添加明确的参数和返回值，以传递等效于存储的内容。

    +   这些更改必须应用到可能涉及生产者和消费者之间通信路径的所有过程中。

    因此，思考编程语言中状态的另一种方式是，它是一个隐式参数，已经传递给所有过程并从中返回，而不会将这种负担加在程序员身上。这使得过程能够在“距离”上进行通信，而不需要所有中介都意识到通信。

+   状态使得可以构建动态、循环的数据结构，或者至少以相对直接的方式进行构建（图表）。

+   状态给予过程内存，例如上面的 new-loc。如果一个过程不能为自己记忆事物，调用者将需要代表其执行记忆，采用（至少是局部的）存储传递的道德等价物。这不仅笨拙，而且会为调用者干扰其内存提供潜在可能性，以用于其自身的邪恶目的（例如，调用者可能故意发送回旧存储，从而获取已授予其他一方的引用，通过这个引用可能发起正确性或安全性攻击）。

另一方面，状态对程序员和处理程序的程序（如编译器）都产生了实际成本。一个是“别名”，我们稍后会讨论[REF]。另一个是“引用透明性”，我也希望能够回到[REF]。最后，我们已经描述了状态如何提供一种模块化形式。然而，同样的描述也可以被视为中间人不知道且无法监视的后门通信。在某些（特别是安全和分布式系统）设置中，这种后门通信可能导致勾结，并因此极其危险和不可取。

因为没有最佳答案，所以可能明智的做法是包含变异运算符，但要仔细界定它们。例如，在标准 ML 中，没有变量变异，因为认为这是不必要的。相反，语言具有盒子的等效物（称为 refs）。可以使用盒子轻松模拟变量，因此不会丢失表现力，尽管这会比仅使用变量产生更多的别名潜在问题（[REF aliasing]），如果不小心使用盒子的话。

然而，开发者在此过程中获得了表现力强的类型：每个数据结构都被视为不可变，除非它包含一个 ref，并且 ref 的存在是对开发者和程序（如编译器）的警告，表明底层值可能会不断变化。同样的论点适用于 Pyret，在那里，缺少 ref 声明意味着字段是不可变的，缺少 var 声明意味着标识符是不可变的，即不是变量。因此，例如，假设 b 是一个盒子，并且 v 绑定到 b 的解箱。开发者应意识到，将所有解箱 b 的实例替换为对 v 的引用是不安全的，因为前者总是获取盒子中的当前值，而后者仅在计算 v 时保持值，并且现在可能不一致。字段可变的声明向开发者和编程工具（如编译器）提供了这些信息；特别是，缺少这样的声明允许缓存值，从而以计算时间换取空间。

## 31.6 类型化状态

向类型检查器添加有状态操作很容易：唯一安全的做法是确保新值的类型与旧值完全相同。如果是这样，程序的行为在突变之前和之后对类型系统来说是不可区分的。也就是说，最安全的做法是遵循不变性（替换原则）。

### 31.6.1 突变和多态性

后来，一旦我们遇到子类型（子类型），我们会发现在对突变进行类型化不再是微不足道的。但是，在多态性存在的情况下，突变已经很复杂了。让我们先给盒子赋予多态类型，其中 Box 是盒子的类型构造器：

```
box<T> :: T -> Box(T)
unbox<T> :: Box(T) -> T
set-box<T> :: Box(T), T -> Box(T)
```

（假设突变操作 set-box 将盒子作为其结果返回）。

> 练习
> 
> > 实现上述三个函数。

现在让我们考虑一个使用这些方法的简单示例：

```
let f = box(lam(x): x end):
  set-box(f, lam(x): x + 5 end)
  unbox(f)(true)
end
```

最初，f 的类型是 Box((A -> A))，其中(A -> A)表示多态身份函数的类型。在进行推断时，该类型的副本肯定与 Number -> Number 统一，这是 lam(x): x + 5 end 的类型。另一个副本用于应用位置；参数类型与 true 的类型统一，给整个表达式赋予 Boolean 类型。然而，当实际函数被应用时，它尝试将 true 加到 5 上，导致运行时错误。如果编译器假设类型系统是合理的，并且没有编译检查，这个程序甚至可能导致分段错误。

有许多方法可以尝试理解这个问题，这超出了本研究的范围。最简单的方法是多态性和突变不太搭配。多态的本质是想象一个量化类型在每次使用时被实例化；然而，突变的本质是在程序的一部分和另一部分之间悄悄传递值。因此，在两个不同位置统一的值只保证与 let-bound 标识符兼容，而不是彼此兼容。这通常不是问题，因为两者不直接通信，除非涉及突变。因此，在这种情况下的一个简单解决方案是防止对可变 let-bound 标识符进行多态泛化。

### 31.6.2 初始值的类型化

有一个问题与突变有关，我们应该解决：创建循环的类型化，特别是处理过早评估的问题。我们已经讨论了处理初始值的几种方法；每种方法都会影响到类型化：

1.  使用标准类型的固定初始值意味着随后突变到位的值可能不兼容类型，从而违反不变性。

1.  使用最终将放入可变对象的类型的不同初始值存在一个问题，即过早观察它甚至更加致命，因为它可能无法与最终值区分开来。

1.  使用一个新值仅适用于这种情况，前提是每种类型都有一个。否则，我们再次违反了不变性。但是每种类型都有一个本身就是一个问题，因为现在运行时系统必须检查所有这些类型。

1.  在语法上将递归限制为函数是最安全的，因为初始值永远不会被看到。因此，不需要为其提供任何有意义的类型。

简而言之，这是一个我们不得不面对不可逾越的权衡的地方。第一种选择牺牲了可类型化性；第二种选择牺牲了程序的可靠性（因为虚拟值是正确类型的，因此可能在不知情的情况下被无意中使用）；第三种选择牺牲了运行时的简单性；第四种选择牺牲了程序员的灵活性。

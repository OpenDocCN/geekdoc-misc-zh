# 23 处理程序：解析

|     23.1 通过编写关于它们的程序来理解语言 |
| --- |
|     23.2 解析（我们将谈论的内容） |
|       23.2.1 解析器的轻量级内置前半部分 |
|       23.2.2 完成解析器 |
|       23.2.3 Coda |

## 23.1 通过编写关于它们的程序来理解语言

通过编写与它们相关的程序来理解语言的本质。这些程序将从不同的角度实现语言的许多有趣特性，体现在不同的行为中：

+   一个解释器会接受某种语言的程序，并产生它们应该产生的答案。

+   类型检查器会接受某种语言的程序，并根据程序是否具有一致的类型注释而产生真或假。

+   一个漂亮的打印程序会接受某种语言的程序并打印它们，以某种方式美化它们。

+   一个验证器会接受某种语言的程序，并检查它们是否满足某种规定的属性。

+   一个变换器会接受某种语言的程序，并产生相关但不同的程序，语言相同。

+   一个变换器的表兄弟，一个编译器，会接受某种语言的程序，并产生不同语言中的相关程序（然后可以被解释，类型检查，漂亮打印，验证，转换，甚至编译...）。

请注意，在这些情况下，我们都必须首先接受（表示）一个程序。我们将简要讨论如何快速轻松地做到这一点，以便在我们的学习的其余部分中，我们可以专注于每个这些操作的其余部分。

## 23.2 关于解析的一切（我们将要说的）

☛ 解析 是一种非常普遍的活动，其难度取决于输入的复杂性或模糊性，以及我们期望解析器输出的结构。对于我们的目的，我们希望解析器尽可能地提供后续阶段所需的结构。这迫使我们要么编写一个非常复杂的解析器，要么限制合法输入的形式。我们将选择后者。

解析的一个关键问题是管理歧义：当给定表达式可以以多种不同的方式解析时。例如，输入

| 23 + 5 * 6 |
| --- |

可以通过两种不同的方式解析：乘法应该首先执行，然后是加法，或者反之。虽然简单的消歧规则（你可能记得从中学）可以消除算术中的歧义，但对于全功能的编程语言来说，这个问题要困难得多。

最终，我们希望在处理程序的最开始就彻底消除歧义，而不是在每种处理方式中重复处理它。因此，如果我们遵循标准的算术规则，我们希望上述程序变成一个树，它的根部有一个（表示的）加法，它的左子树有一个（表示的）23，乘法作为它的右子树，等等。这被称为抽象语法树：它是“抽象的”，因为它代表了程序的意图，而不是其字面的语法结构（空格、缩进等）；它是“语法的”，因为它表示了给定的程序；它通常是一个“树”，但不总是。

正如我们所说，我们可以将消除歧义的问题推给解析器。这就是大多数真实语言所做的。因为解析不是我们的关注点，所以我们将要求程序的作者使用一个明确的语法。事实上，我们可以利用已经投入到☛ wire format 中的几十年工作来表示程序。例如，上面的表达式可能被写成——<wbr>避免由于不正确地给程序加上括号而引起的歧义——如下所示：

| <plus> |
| --- |
|   <args> |
|     <arg position="1"> |
|       <number value="23"/> |
|     </arg> |
|     <arg position="2"> |
|       <mult> |
|         <args> |
|           <arg position="1"> |
|             <number value="5"/> |
|           </arg> |
|           <arg position="2"> |
|             <number value="6"/> |
|           </arg> |
|         </args> |
|       </mult> |
|     </arg> |
|   <args> |
| </plus> |

在 XML 中，或者作为

| {plus: |
| --- |
|   [{number: "23"}, |
|    {mult: |
|      [{number: "5"}, |
|       {number: "6"}]}]} |

在 JSON 中。

### 23.2.1 解析器的轻量级内置前半部分

这两种都是值得注意的符号。但我们将使用一种相关的、甚至可以说更简单的格式，称为 s 表达式：这个名字来自于 Lisp。

| (+ 23 (* 5 6)) |
| --- |

Pyret 内置支持处理 s 表达式，因此您可以使用这种语法，并从语言中获得支持来处理它。

> 现在动手！
> 
> > 使用以下命令加载 s 表达式库
> > 
> > ```
> > import s-exp as S
> > ```
> > 
> > 然后尝试以下内容：
> > 
> > ```
> > S.read-s-exp("(+ 23 (* 5 6))")
> > ```
> > 
> > 确保你理解它产生的输出以及它为什么产生了那样的输出。

您应该已经看到了以下输出：

```
check:
  S.read-s-exp("(+ 23 (* 5 6))") is
    S.s-list([list:
      S.s-sym("+"),
      S.s-num(23),
      S.s-list([list:
        S.s-sym("*"),
        S.s-num(5),
        S.s-num(6)])])
end
```

在本书中，我们将使用 s 表达式来表示具体的语法。这是有帮助的，因为语法与 Pyret 的语法非常不同，我们几乎不会混淆我们正在阅读的语言。由于我们将编写用于处理程序的程序，因此将被处理的程序与进行处理的程序分开是特别有帮助的。对于我们来说，前者将用 s 表达式编写，后者将用 Pyret 编写。

### 23.2.2 完成解析器

原则上，我们可以将 read-s-exp 视为完整的解析器。但是，它的输出是通用的：它表示了令牌结构，而没有对其意图提供任何评论。相反，我们更希望有一个表示，告诉我们有关我们语言中术语意图的东西，就像我们在一开始写的那样：“（表示）乘法”，等等。

要做到这一点，首先让我们导入必要的库：

```
import s-exp as S
import lists as L
```

现在开始正题。我们必须首先引入一个捕获此表示的数据类型。我们将分别讨论（表示算术）如何以及为什么获得了此数据类型，但现在让我们假设它是给定的：

```
data ArithC:
  | numC(n :: Number)
  | plusC(l :: ArithC, r :: ArithC)
  | multC(l :: ArithC, r :: ArithC)
end
```

然后，我们需要一个函数，它将 s 表达式转换为此数据类型的实例。这是我们解析器的另一半：

```
fun parse(s :: S.S-Exp) -> ArithC:
  cases (S.S-Exp) s:
    | s-num(n) => numC(n)
    | s-list(shadow s) =>
      cases (List) s:
        | empty => raise("parse: unexpected empty list")
        | link(op, args) =>
          argL = L.get(args, 0)
          argR = L.get(args, 1)
          if op.s == "+":
            plusC(parse(argL), parse(argR))
          else if op.s == "*":
            multC(parse(argL), parse(argR))
          end
      end
    | else =>
      raise("parse: not number or list")
  end
end
```

这遵循以下测试：注意在测试块内部使用了一个辅助函数。

```
check:
  fun p(s): parse(S.read-s-exp(s)) end
  p("3") is numC(3)
  p("(+ 1 2)") is plusC(numC(1), numC(2))
  p("(* (+ 1 2) (* 2 5))") is
    multC(plusC(numC(1), numC(2)), multC(numC(2), numC(5)))
end
```

恭喜！你刚刚完成了你的第一个程序表示。从现在开始，我们可以完全专注于以递归树形式表示的程序，不再关注表面语法的变化以及如何将它们转换成树形式（尽管在实践中，我们将继续使用 s 表达式符号，因为它比所有这些构造器更容易输入）。我们终于准备好开始学习编程语言了！

> 练习
> 
> > 如果测试
> > 
> > ```
> > p("3") is numC(3)
> > ```
> > 
> > 而是写成
> > 
> > ```
> > p(3) is numC(3)
> > ```
> > 
> > 发生了什么？为什么？

### 23.2.3 结语

s 表达式语法可以追溯到 1960 年。约翰·麦卡锡在 ACM 通讯中发表的“递归符号表达式及其机器计算，第 I 部分”。这种语法在程序员中经常引起争议。然而，请注意它为我们提供的一些深层次的宝贵东西。尽管解析传统语言可能非常复杂，但解析此语法几乎是微不足道的。给定与输入相对应的一系列标记，将带括号的序列转换为 s 表达式绝对是直截了当的；同样直截了当（正如我们上面看到的），将 s 表达式转换为适当的语法树也是直截了当的。我喜欢将这种两级语言称为双院制，这与政府立法机构的松散类比相似：低层级执行基本的格式检查，而上层级执行更深入的有效性检查。（我们还没有做任何后者，但我们会[REF]。）

因此，这种语法的优点是多方面的。它所需的代码量很小，并且可以轻松嵌入到许多上下文中。通过将语法集成到语言中，程序可以轻松地操作程序的表示（正如我们将在[REF]中看到的那样）。因此，毫不奇怪，即使许多基于 Lisp 的语言——从 Lisp 1.5 到 Common Lisp 再到 Scheme 再到 Racket 再到 Clojure 等——具有完全不同的语义，它们都共享这种语法遗产。

当然，我们也可以使用 XML。那可能会更好。或者 JSON。因为那根本不像 s 表达式。

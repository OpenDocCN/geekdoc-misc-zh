# 控制操作

|     33.1 Web 上的控制 |
| --- |
|       33.1.1 程序分解成现在和以后 |
|       33.1.2 部分解决方案 |
|       33.1.3 实现无状态性 |
|       33.1.4 与状态的交互 |
|     33.2 转换为延续传递风格 |
|       33.2.1 通过展开实现 |
|       33.2.2 理解输出 |
|       33.2.3 通过转换的交互原语 |
|     33.3 核心中的实现 |
|       33.3.1 转换解释器 |
|       33.3.2 核心中的交互原语 |
|     33.4 生成器 |
|     33.5 延续和堆栈 |
|     33.6 尾调用 |

控制这个术语指的是任何导致评估继续进行的编程语言指令，因为它“控制”了计算机的程序计数器。从这个意义上说，指令的顺序执行是“控制”的，就像算术表达式一样（在存在状态的情况下，这种控制通过效果发生的顺序展现出来）；在所有普通编程语言中找到的其他形式的控制包括函数调用和返回。然而，在实践中，我们主要使用这个术语来指代那些导致控制的非局部转移超出了仅仅函数和过程的范围的操作，通常从异常开始。我们将在本章中研究这样的操作。

当我们学习以下控制操作符时，值得记住的是，即使没有它们，我们仍然有图灵完备的语言，因此这些控制操作并没有提供更多的“能力”。因此，控制操作的作用是改变并可能改善我们表达意图的方式，从而增强程序的结构。因此，我们开始学习时专注于程序结构是值得的。

## 控制在 Web 上

让我们从审视 Web 程序的结构开始学习。考虑以下程序：从此刻开始，我们将把它称为我们的“加法服务器”。当然，你应该将其理解为更复杂应用的替代品。例如，这两个提示可能会询问旅行的起点和终点，并且在加法的位置，我们可能会计算路线或航班价格。甚至可能在两个步骤之间进行计算：例如，在输入第一个城市后，航空公司可能会提示我们选择从那里飞往哪里。

```
print(read-number("First number")
  + read-number("Second number"))
```

这是基于一个假设的读取数字函数的假设，当运行时，会暂停程序执行，提示用户输入一个数字，当用户输入一个数字时，继续计算。你可能会觉得我提到了计算的暂停和恢复太啰嗦了，但这个细节将被证明对我们的研究至关重要，所以不要忽视这些步骤！

现在假设我们想在 Web 服务器上运行这个程序。我们立即遇到一个困难：服务器端 Web 程序的结构是这样的，它们生成一个单独的 Web 页面，比如要求输入第一个数字的页面，然后停止。因此，程序的其余部分——在这种情况下提示输入第二个数字，然后将两个数字相加，最后打印结果——都丢失了。

> 现在动手！
> 
> > 为什么 Web 服务器会以如此奇怪的方式行为？

这种行为至少有两个原因：一个可能是历史原因，另一个是技术原因。历史原因是 Web 服务器最初是设计用来提供页面，即静态内容。任何运行的程序都必须将其输出生成到一个文件中，服务器可以从中提供它。自然地，开发人员想知道为什么相同的程序不能按需运行。这使得 Web 内容具有动态性。在生成单个输出后终止程序是将 Web 从“页面”转变为“程序”的最简单的增量步骤。

更重要的原因——也是伴随我们的原因之一——是技术原因。想象一下，我们的加法服务器生成了第一个提示。待处理的计算不是琐碎的：它必须记住第一个响应，生成第二个提示，执行加法，然后显示结果。此计算必须暂停等待用户的输入。如果有数百万个用户，那么数百万个计算必须被暂停（想象一下在虚拟机中运行的线程，每个线程都消耗内存用于本地数据），这会造成巨大的性能问题。此外，假设一个用户实际上没有完成计算——类似于在在线书店或航空公司网站上搜索，但没有完成购买。服务器如何知道何时甚至是否终止计算？在它这样做之前，与该计算相关的资源仍在使用中。

因此，从概念上讲，Web 协议被设计为无状态：它不会在服务器上存储与中间计算相关的状态。相反，Web 程序开发人员将被迫在其他地方维护所有必要的状态，并且每个请求都需要能够完全恢复计算。实际上，Web 并未证明是无状态的，但它仍然朝着这个方向发展，并且研究这些程序的结构非常有益。

现在考虑客户端 Web 程序：那些在浏览器内运行的程序，使用 JavaScript 编写或编译而成。假设这样的计算需要与服务器通信。为此的原语称为 XMLHttpRequest。用户创建此原语的实例，并调用其 send 方法将消息发送到服务器。

与服务器通信并不是瞬时的：它需要一些时间；如果服务器面临重负载，可能需要很长时间；事实上，根据网络和服务器的状态，可能根本无法完成。（这与上述 get-number 面临的问题相同，只是将用户替换为服务器：用户可能需要很长时间才能输入数字，或者根本不输入。）如果 send 方法暂停程序执行，整个（客户端）应用程序将被无限期地阻塞。你不会想使用这样的程序。

为了保持应用程序的响应性，XMLHttpRequest 的设计者因此有了选择。他们可以使 JavaScript 多线程化，但由于语言也具有状态，程序员将不得不解决结合状态与并发性的所有问题。特别是，初学者将不得不处理一系列特性的组合，即使是经验丰富的程序员也无法很好地使用，这可能导致大量发生死锁的网站。

相反，JavaScript 是单线程的：也就是说，一次只能执行一个线程。由于这造成的结构问题，现在有各种提案，实际上是要向 JavaScript 中添加“安全”线程。本章描述的思想可以被视为提供类似结构化优势的另一种选择。当调用 send 方法时，JavaScript 会暂停当前计算，并将控制返回给事件循环，该循环现在可以调用其他被暂停的计算。开发者将回调与 send 关联起来。当（如果）返回响应时，此回调将被添加到被暂停计算的队列中，从而使其能够恢复。

此回调需要体现出该请求的其余处理过程。因此，基于完全不同的原因——不是性能，而是避免同步、非原子性和死锁问题——客户端 Web 已经演变成向开发者施加与服务器端 Web 本质上相同的程序结构问题。现在让我们更好地理解这种结构。

### 33.1.1 将程序分解为现在和以后

让我们考虑如何使我们的加法程序在无状态设置中工作，例如在 Web 服务器上。首先，我们必须确定第一个交互。这是第一个数字的提示，因为 Pyret 从左到右评估参数。将程序分为两部分很有启发性：生成第一个交互的操作（可以立即运行），以及之后需要发生的操作（必须以某种方式“记住”）。前者很容易：

```
read-number("First number")
```

我们已经用散文解释了剩下的部分，但现在是时候将其写成一个程序了。看起来像是这样：

```
print(<the result from the first interaction>
  + read-number("Second number"))
```

然而，Web 服务器无法执行上述操作，因为显然它不是一个程序。相反，我们需要一种将其写成一个程序的方法。让我们观察一下这个计算的一些特征：

+   它需要是一个语法上有效的程序。

+   它需要保持挂起状态，直到请求到来。

+   它需要一种方式—<wbr>比如一个参数—<wbr>来引用第一次交互的值。

将这些特征放在一起，我们有了一个清晰的表示—<wbr>一个函数：

```
fun(v1):
  print(v1 + read-number("Second number"))
end
```

### 33.1.2 部分解决方案

在 Web 上，还有一个额外的复杂问题：每个带有输入元素的 Web 页面都需要引用存储在 Web 上的程序，该程序将接收表单数据并处理它。这个程序在表单的 action 字段中命名。因此，想象一下，服务器生成一个新的标签，将上述函数存储在与该标签关联的表中，并在 action 字段中引用该标签。当（如果）客户端实际提交表单时，服务器提取关联的函数，提供表单的值，并恢复执行。

> 现在就去做吧！
> 
> > 上面的解决方案是无状态的吗？

让我们想象我们有一个维护上述表的自定义 Web 服务器。在这样一个服务器中，我们可能有一个特殊版本的 read-number—<wbr>称之为 read-number-suspend—<wbr>记录程序的其余部分：

```
read-number-suspend("First number",
  fun(v1):
    print(v1 + read-number("Second number"))
  end)
```

不幸的是，这还不够。当我们执行第二次读取数字时，我们又忘记了其余的计算。因此，第二次需要转换为使用 read-number-suspend。其余的计算是什么？

```
fun(v2):
  print(v1 + v2)
end
```

其中 v1 是第一次计算的值。将这些部分组合起来，完全翻译的程序是

```
read-number-suspend("First number",
  fun(v1):
    read-number-suspend("Second number",
      fun(v2):
        print(v1 + v2)
      end)
  end)
```

注意内部闭包如何依赖于嵌套在外部闭包中，以便 v1 在加法中绑定。还要注意加法和打印是如何从提供第一个数字后立即“启动”转移到等待第二个数字也可用的。

> 练习
> 
> > 为上述计算指定类型。还确定 Web 服务器的类型以及保存这些过程的表的类型。

### 33.1.3 实现无状态性

我们实际上还没有实现无状态性，因为我们在服务器上有一个大表，没有明确的方法来删除其中的条目。如果我们能够完全避免服务器状态将会更好。这意味着我们必须将相关状态移动到客户端。

服务器保存状态实际上有两种方式。一种是我们保留了随意创建哈希表中条目的权利。这使得服务器存储空间与交互数量成正比——一个动态值——而不是程序大小，一个具有明确边界的静态值。另一种是我们在表中存储的内容：真正的闭包，每个闭包可能是不同的，并且封闭了大量的状态。

让我们首先消除闭包。相反，让我们将每个函数命名并置于顶层（这立即迫使我们只能有固定数量的函数，其数量受程序大小的限制）：

```
read-number-stateless("First number", prog-1)

fun prog-1(v1):
  read-number-stateless("Second number", prog-2)
end

fun prog-2(v2):
  print(v1 + v2)
end
```

注意每个代码块只引用下一个过程的名称，而不是真正的闭包。参数的值来自于表单。只有一个问题：prog-2 中的 v1 是自由标识符！

修复这个问题的方法是，在一步之后不创建闭包，而是将 v1 发送给客户端存储在那里。我们将这个存储在哪里？浏览器提供了两种机制来做到这一点：cookies 和隐藏字段。我们使用哪一个？

### 33.1.4 与状态的交互

避免此问题的一种方法是找到第一个和第二个提示后面的通信渠道。回想一下我们已经注意到状态提供了这样一种通信渠道（有状态语言操作的设计）。因此，我们可以使用一个顶层变量来传递 v1 的值。为了具有启发性，我们将这个变量称为 cookie：

```
var cookie = "dummy initial value"

read-number-suspend("First number",
  fun(v1):
    cookie := v1
    read-number-suspend("Second number",
      fun(v2):
        print(cookie + v2)
      end)
  end)
```

我们可以轻松地消除闭包：

```
var cookie = "dummy initial value"

read-number-stateless("First number", prog-1)

fun prog-1(v1):
  cookie := v1
  read-number-stateless("Second number", prog-2)
end

fun prog-2(v2):
  print(cookie + v2)
end
```

不幸的是，这意味着每个中间计算都将共享相同的 cookie 变量。如果我们打开两个并发窗口并尝试添加不同的第一个数字，最新的第一个数字将始终驻留在 cookie 中，因此另一个窗口将看到不可预测的结果。

这当然就是网络上发生的事情。这些问题并非假设性的。例如，参见[模拟网络交互和错误](http://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/)第 2 节。浏览器的 cookies 仅仅是存储的客户端实现。因此，将信息存储在 cookies 中的网站会受到这个问题的影响：与网站的两个并发交互将相互干扰。因此，Web 网站普遍使用 cookies，这是由 Web 编程传统引起的，导致网站的可用性明显降低。

相比之下，网络提供了另一种在客户端存储信息的机制：隐藏字段。因为它们对于每个页面都是本地的，而每个页面对应一个闭包，它们与闭包的环境完全类似！因此，如果我们不是将 v1 的值存储在单个全局 cookie 中，而是将其存储在响应页面的隐藏字段中，那么两个不同的响应页面的隐藏字段将具有不同的值，并且在下一个请求中将发送回服务器——从而完全避免了干扰问题。

## 33.2 转换为延续传递风格

我们一直在编写的函数风格有一个名称。虽然我们以 Web 的术语提出了这些想法，但我们依赖于一个更古老的概念：这些函数被称为延续，程序的这种风格称为延续传递风格（CPS）。我们将自由使用 CPS 作为名词和动词：代码的特定结构和将代码转换为它的过程。这值得单独研究，因为它是研究各种其他非平凡控制操作的基础——例如生成器。

早些时候，我们将程序转换为不将 Web 输入操作嵌套在另一个内部。动机很简单：当程序终止时，所有嵌套的计算都会丢失。类似的论点在 XMLHttpRequest 的情况下在更局部的意义上也适用：任何依赖于来自 Web 服务器响应的结果的计算都需要驻留在与发送到服务器的请求相关联的回调中。

实际上，我们不需要转换每个表达式。我们只关心涉及实际 Web 交互的表达式。例如，如果我们计算的是比加法更复杂的数学表达式，我们就不需要转换它。但是，如果我们有一个函数调用，我们要么必须确保该函数内部没有任何 Web 调用，要么在它调用的函数中没有任何 Web 调用，或者它们调用的函数中没有任何 Web 调用...否则，为了保险起见，我们应该全部转换。因此，我们必须转换每个我们不能确定是否执行 Web 交互的表达式。

我们转换的核心是将每个函数 f 转换为一个带有额外参数的函数。这个额外参数是延续，它代表了剩余的计算过程。f 不再返回值，而是将它本来会返回的值传递给它的延续。因此，延续本身是一个带有一个参数的函数；这个参数代表了 f 本来会返回的值。一个函数返回一个值以“传递给剩余的计算过程”；CPS 使这一点明确，因为调用延续（而不是返回一个值）恰好将它传递给表示剩余计算过程的函数。

CPS 是一种通用转换，我们可以将其应用于任何程序。因为它是一个程序转换，我们可以将其视为一种特殊类型的解糖，它将程序从完整语言转换为一个更受限制的版本，遵循我们一直讨论的模式。因此，我们可以重用完整语言的评估器来评估 CPS 子集中的程序。

### 33.2.1 通过解糖实现

因此，让我们将 CPS 实现为源到源的转换。从函数的角度来看，它接受并返回 ExprC 表达式，但输出表达式将具有我们上面看到的特殊结构，因此将是所有 ExprC 表达式的严格子集。

> 练习
> 
> > 换句话说，上面关于“严格子集”的注释意味着某些 ExprC 表达式在 CPS 生成的输出中不合法。提供示例。

<cps-trans> ::=

|   fun cps(e :: ExprC) -> ExprC: |
| --- |
|     cases (ExprC) e: |
|       <cps-trans-numC> |
|       <cps-trans-plusC> |
|       <cps-trans-idC> |
|       <cps-trans-fdC> |
|       <cps-trans-appC> |
|     end |
|   end |

我们在 CPS 中的表示将是将每个表达式转换为一个带有一个参数的过程，即延续。转换后的表达式最终要么向延续提供一个值，要么将延续传递给将要——通过保持这个不变性的归纳——向它提供一个值的其他表达式。对于 Pyret，CPS 的所有输出都将以 fun (k): ... end 的形式呈现。因为我们将 CPS 应用于 Paret，所以它将呈现为 fdC("k", ...)。无论哪种方式，请注意，词法作用域都会防止这些 k 与相同名称的任何其他标识符发生冲突。

首先，让我们处理简单的情况，即原子值。因为我们已经有一个值了，我们准备“返回”它，通过将其提供给延续来实现：<cps-trans-numC> ::=

|   &#124; numC(_) => fdC("k", appC(idC("k"), e)) |
| --- |

类似地：<cps-trans-idC> ::=

|   &#124; idC(_) => fdC("k", appC(idC("k"), e)) |
| --- |

> 练习
> 
> > 将语言扩展到处理条件。
> > 
> 练习
> 
> > 扩展语言以支持可变状态。这对 CPS 过程有什么影响吗？即，它是否改变了转换的模式？

接下来，让我们处理二元运算符。我们之前已经见过这种转换的本质，应用于 Web：<cps-trans-plusC> ::=

|   &#124; plusC(l, r) => |
| --- |
|     fdC("k", |
|       appC(cps(l), |
|         fdC("l-v", |
|           appC(cps(r), |
|             fdC("r-v", |
|               appC(idC("k"), plusC(idC("l-v"), idC("r-v")))))))) |

这假设原始运算符，在这种情况下是加法，本身不需要转换；例如，在网络上，执行算术运算不涉及任何网络交互是安全的。当然，除非算术是密码算法的一部分，这种情况下可能需要通知 NSA 算法的结果。

最后，我们有函数定义和应用。

> 立即行动！
> 
> > 很容易认为，因为函数只是值，它们也可以不变地传递给延续。为什么这不成立？
> > 
> 练习
> 
> > 在继续之前，修改基础语言，也允许两个参数的函数定义和相应的应用。将定义命名为 fd2C，应用为 app2C。

对于一个应用，我们必须评估函数和参数表达式。一旦我们得到了这些，我们就准备好应用函数了。因此，很容易写出<cps-trans-appC-try-1> ::=

|   &#124; appC(f, a) => |
| --- |
|     fdC("k", |
|       appC(cps(f), |
|         fdC("f-v", |
|           appC(cps(a), |
|             fdC("a-v", |
|               appC(idC("k"), appC(idC("f-v"), idC("a-v")))))))) |

> 立即行动！
> 
> > 你明白这为什么是错误的吗？

问题在于，虽然函数是一个值，但该值是一个具有潜在复杂体的闭包：评估体可以导致进一步的网络交互，此时函数的其余部分体（即程序的其余部分）将全部丢失。为了避免这种情况，我们必须向函数的值提供 k，并让归纳不变量确保最终将调用 k 与将 f-v 应用于 a-v 的值：<cps-trans-appC> ::=

|   &#124; appC(f, a) => |
| --- |
|     fdC("k", |
|       appC(cps(f), |
|         fdC("f-v", |
|           appC(cps(a), |
|             fdC("a-v", |
|               app2C(idC("f-v"), idC("a-v"), idC("k"))))))) |

函数本身是一个值，所以应该返回给待处理的计算。然而，上述应用案例表明，我们必须将函数转换为接受额外参数，即在调用点处的延续。这让我们陷入了困境：我们应该向体提供哪种延续？

<cps-trans-fdC-try-1> ::=

|   &#124; fdC(v, b) => |
| --- |
|     fdC("k", |
|       appC(idC("k"), |
|         fd2C(v, "dyn-k", |
|           appC(cps(b), ???)))) |

也就是说，在 ??? 的位置，我们应该提供哪种延续：k 还是 dyn-k？

> 立即行动！
> 
> > 我们应该提供哪种延续？

前者是在闭包创建点的延续。后者是在闭包调用点的延续。换句话说，前者是“静态的”，后者是“动态的”。在这种情况下，我们需要使用动态延续，否则会发生非常奇怪的事情：程序将返回到创建闭包的地方，而不是使用它的地方！这将导致看似非常奇怪的程序行为，因此我们希望避免这种情况。请注意，我们有意选择动态延续，就像在作用域方面我们选择了静态环境一样，但在状态方面我们选择了“动态”（即最近的）存储。因此，延续更像状态而不是词法绑定，这是我们稍后将回顾的相似之处[REF]。

<cps-trans-fdC> ::=

|   &#124; fdC(v, b) => |
| --- |
|     fdC("k", |
|       appC(idC("k"), |
|         fd2C(v, "dyn-k", |
|           appC(cps(b), idC("dyn-k"))))) |

> 现在开始！
> 
> > 在你理解了这些材料之后，将 "dyn-k" 替换为 "k"，预测应该发生什么变化，并检查是否确实如此。

测试任何转换为 CPS 的代码都稍微麻烦，因为所有 CPS 项都期望一个延续。在真实环境中，初始延续只是简单地（a）消耗一个值并返回它，或者（b）消耗一个值并打印它，或者（c）消耗一个值，打印它，并准备好进行另一个计算（就像 REPL 中的提示一样）。这三者实际上只是不同形式的恒等函数。因此，以下定义对于测试很有帮助：

```
fun icps(e):
  id-cps = fdC("v", idC("v"))
  interp(appC(cps(e), id-cps), mt-env)
end
```

例如，

```
icps(plusC(numC(5), appC(quad, numC(3)))) is numV(17)
icps(multC(appC(c5, numC(3)), numC(4))) is numV(20)
icps(plusC(numC(10), appC(c5, numC(10)))) is numV(15)
```

### 33.2.2 理解输出

这种转换的输出需要一些时间来适应。考虑一个非常简单的例子：

```
cps(plusC(numC(1), numC(2)))
```

这将评估为

```
fdC("k",
  appC(fdC("k",
      appC(idC("k"), numC(1))),
    fdC("l-v",
      appC(fdC("k",
          appC(idC("k"), numC(2))),
        fdC("r-v",
          appC(idC("k"),
            plusC(idC("l-v"), idC("r-v"))))))))
```

为了（稍微）提高可读性，让我们将其从 Paret 转换为 Pyret 并给它一个名字：

```
f1 =
  lam(k):
    (lam(shadow k):
        k(1)
      end)(lam(l-v):
        (lam(shadow k):
              k(2)
          end)(lam(r-v):
              k(l-v + r-v)
          end)
      end)
  end
```

我们不得不插入影子声明来确认给 Pyret 确实意味着要遮蔽这些标识符。然后我们可以将其应用于恒等函数，以观察它是否产生预期的答案：

```
check:
  f1(lam(x): x end) is 3
end
```

我们还可以将不同的 ks 重命名以更好地区分它们：

```
f2 =
  lam(k):
    (lam(k1):
        k1(1)
      end)(lam(l-v):
        (lam(k2):
            k2(2)
          end)(lam(r-v):
            k(l-v + r-v)
          end)
      end)
  end

check:
  f2(lam(x): x end) is 3
end
```

诸如

```
(lam(k1): k1(1) end)(...)
```

看起来代码可读性显著降低，但只有在学会如何“阅读”这样的程序之后才会明白。这相当于说：“k1 代表在评估 1 后程序的其余部分。评估 1，并将其结果——值 1——发送给计算的其余部分，即 k1。” 这个值（1）绑定到 l-v，表示加法的左侧值的标识符...当然，这正是 1 所代表的。

目前有一项积极的研究工作正在创建更好的 CPS 转换，以产生更少的中间函数项；我们实际上使用了最古老且最不成熟的之一。在简化解糖的简单性与输出简单性之间存在权衡，两者大致呈反比关系。

### 33.2.3 通过转换的交互原语

在这一点上，我们已经确定了程序结构中的一个问题；我们假设了一个更好的 API；我们将一个示例转换为使用这样的 API；然后我们将该转换泛化。但现在我们有一个非常复杂的程序结构，不清楚它可能有什么用处。这种转换的重点是，每个子表达式都将有一个关联的继续，这是一个友好交互的原语可以使用的。让我们看看如何做到这一点。

为了实现这一点，我们现在将添加两个原语：read-numC 和 read-num-webC。想法是用户程序（预 CPS）将使用前者，而转换将其转换为对后者的使用。这是两种新语言形式：

```
| read-numC(p :: ExprC)
| read-num-webC(p :: ExprC, k :: ExprC)
```

假设 p 是一个表达式，它的求值结果是我们想要打印给用户的内容。在我们贫乏的语言中，这是一个数字，这对说明已经足够了。

我们将假设 cps 不需要处理 read-num-webC（因为预计最终用户不会直接编写它），而 interp 不需要处理 read-numC（因为我们希望此解释器即使在定期终止输入的设置中也能正常运行，因此它不能阻塞等待响应）。

在 cps 中将 read-numC 转换为 read-num-webC 现在很容易，因为续延参数现在正好给了我们所需的东西：

```
| read-numC(p) =>
  fdC("k",
    appC(cps(p),
      fdC("p-v",
        read-num-webC(idC("p-v"), idC("k")))))
```

现在让我们在解释器中构建一个正确模拟程序停止的 read-num-webC 实现。

首先，我们需要一种记录当前恢复点的方法。在真实系统中，这可能会被记在服务器上或者编组成一个值发送给客户端。有关如何将续延编组到客户端的更多信息，请参见[此论文](http://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/)。在这里，我们只是将其记录在一个全局变量中：

```
var web-continuation = "nothing here yet"
```

不出所料，一旦我们开始运行程序，肯定会有一些有趣的东西。现在让我们修改解释器：

```
| read-num-webC(p, k) =>
  prompt = num-to-string(interp(p, nv).n)
  cont = interp(k, nv)
  print('Web interaction: ' + prompt)
  web-continuation := cont
  raise('Program halted waiting for user input')
```

首先，我们评估提示表达式以获得实际提示。然后我们将其打印到屏幕上。关键是，我们然后将当前续延存储到全局变量中。最后，我们停止程序的执行；这一步在保持我们诚实方面是至关重要的，这样我们就不会意外地依赖 Pyret 来恢复我们的计算。

> 练习
> 
> > 在 cps 中引入一个错误，并展示如何通过停止程序来突出显示它，而不这样做则会默默掩盖它。

假设我们在以下输入程序上运行此程序：

```
icps(plusC(read-numC(numC(1)), read-numC(numC(2))))
```

Pyret 打印

| 网络交互：1 |
| --- |
| 错误： |
|  |
| "程序暂停等待用户输入" |

然后程序停止了。

此时，web-continuation 包含一个真正的运行时闭包（一个 closV 值）。这代表一个延续：一个代表计算剩余部分的程序值。由于当前实现中存在一个错误，你无法直接检查 web-continuation 的值；但你可以从一个闭包中访问它。用户现在在想象中的 Web 表单中提供一个输入；这作为延续的实际参数提供。

我们可以这样做。我们从闭包中提取函数和环境，并将函数应用于提供的参数，在闭包的上下文中评估这个过程：

```
fun run-wc(n):
  wc = web-continuation
  interp(appC(wc.f, numC(n)), wc.e)
end
```

确实，使用 3 作为第一个输入时产生：

| >  run-wc(3) |
| --- |
| 网络交互: 2 |
| 错误: |
|  |
| "程序等待用户输入时停止" |

哦，有希望！现在我们再试一次，比如，将 4 作为第二个输入，我们得到：

| > run-wc(4) |
| --- |
| numV(7) |

Et voilà!

因此，这是关键的教训。通过将程序转换为 CPS，我们能够编写一个看起来正常的程序—<wbr>read-numC(numC(1)), read-numC(numC(2))—<wbr>并在一个真正在每次交互后终止的解释器上运行它，并且仍然能够成功恢复计算，运行到完成而不会丢失计算或作用域错误。也就是说，我们可以以直接风格编写程序，具有正确嵌套的表达式，并且编译器—<wbr>在这种情况下，CPS 转换器—<wbr>负责使其与适当的底层 API 协同工作。这才是良好的编程语言应该做的事情！

> 练习
> 
> > 修改程序以存储每个先前的延续，并带有某种独特的标记。现在你可以访问多个延续，模拟不同的浏览器操作效果，比如重新加载页面（重新调用延续），返回（使用先前的延续），克隆页面（重用延续）等。你的实现还有效吗？

## 33.3 核心中的实现

现在我们已经看到 CPS 如何通过 desguaring 实现，我们应该问一下它是否可以放在核心中。

请记住我们曾说过 CPS 适用于所有程序。我们特别感兴趣的是一个程序：解释器。果然，我们可以对其应用 CPS 转换，使有效地使用相同的延续。

### 33.3.1 转换解释器

与盲目应用转换不同，这将导致一个非常笨拙（且难以阅读）的解释器，我们将在进行清理时稍微整理一下。首先请注意，解释器需要接受一个额外的参数，表示计算的剩余部分：<cps-interp> ::=

|   fun interp(e :: ExprC, nv :: List<Binding>, k): |
| --- |
|     cases (ExprC) e: |
|       <cps-interp-numC> |
|       <cps-interp-plusC> |
|       <cps-interp-idC> |
|       <cps-interp-fdC/fd2C> |
|       <cps-interp-appC> |
|       <cps-interp-app2C> |
|     end |
|   end |

> 练习
> 
> > 注意，我们没有标注 k，并且我们已经删除了 interp 的返回注释。补全它们。

当我们有值时，我们简单地通过续延 “返回” 它们：<cps-interp-numC> ::=

|   &#124; numC(n) => |
| --- |
|     k(numV(n)) |

<cps-interp-idC> ::=

|   &#124; idC(s) => |
| --- |
|     k(lookup(s, nv)) |

对于操作符为原始值的二元操作，我们必须遵循 CPS 模式：<cps-interp-plusC> ::=

|   &#124; plusC(l, r) => |
| --- |
|     interp(l, nv, |
|       lam(l-v): |
|         interp(r, nv, |
|           lam(r-v): |
|             k(plus-v(l-v, r-v)) |
|         end) |
|       end) |

注意，CPS 也最终强制执行评估顺序（在这种情况下是从左到右），就像突变一样。对于函数定义，我们必须小心。前面（<cps-trans-fdC>），我们向闭包添加了一个续延参数。但是，fdC 数据结构仅仅是数据；像 interp 这样的函数需要被赋予额外的参数。因此，我们可以将这些保持不变：<cps-interp-fdC/fd2C> ::=

|   &#124; fdC(_, _) => |
| --- |
|     k(closV(e, nv)) |
|   &#124; fd2C(_, _, _) => |
|     k(closV(e, nv)) |

最后，应用程序必须像我们之前看到的那样转换为 CPS：<cps-interp-appC> ::=

|   &#124; appC(f, a) => |
| --- |
|     interp(f, nv, |
|       lam(clos-v): |
|         interp(a, nv, |
|           lam(arg-v): |
|             interp(clos-v.f.body, |
|               xtnd-env(bind(clos-v.f.arg, arg-v), clos-v.e), |
|               k) |
|           end) |
|       end) |

类似地，当有两个参数时：<cps-interp-app2C> ::=

|   &#124; app2C(f, a1, a2) => |
| --- |
|     interp(f, nv, |
|       lam(clos-v): |
|         interp(a1, nv, |
|           lam(arg1-v): |
|             interp(a2, nv, |
|               lam(arg2-v): |
|                 interp(clos-v.f.body, |
|                   xtnd-env(bind(clos-v.f.arg1, arg1-v), |
|                     xtnd-env(bind(clos-v.f.arg2, arg2-v), |
|                       clos-v.e)), |
|                 k) |
|               end) |
|           end) |
|       end) |

将解释器转换为 CPS 后，我们为其增加了一个额外的参数：k，即解释器的续延。因为解释器的执行模仿了被解释程序的预期行为，解释器的续延反映了被解释程序的其余行为：即，将表达式 e 应用于续延 k 将导致 k 被赋予表达式 e 的值。因此，我们可以通过将其暴露给被解释的程序来利用 k。

### 33.3.2 核心中的交互式原语

现在，我们可以将之前的解决方案[通过转换实现的交互原语]提升到这个修改后的解释器中。这一次，不同于程序创建续延，而是解释器自己创建，而程序对此一无所知。因此：

```
| read-numC(p) =>
  interp(p, nv,
    lam(p-v):
      prompt = num-to-string(p-v.n)
      print('Web interaction: ' + prompt)
      web-continuation := k
      raise('Program halted waiting for user input')
    end)
```

请注意，我们必须首先评估提示表达式以获取其值。然而，现在，没有了要评估的续延表达式：解释器已经准备好了续延。就是这个续延，我们将其存储在 web-continuation 中。注意，该值现在是 Pyret 中的真正闭包，而不是我们构造的闭包数据结构。因此，要应用它，我们不再能提取其字段；相反，我们能做的唯一的事情就是应用它：

```
fun run-wc(n):
  web-continuation(numC(n))
end
```

在这个基础上，如果我们评估表达式

```
plusC(read-numC(numC(1)), read-numC(numC(2)))
```

我们观察到与之前相同的行为：

| Web 交互: 1 |
| --- |
| 错误: |
|  |
| "程序停止等待用户输入" |
| > run-wc(3) |
| Web 交互: 2 |
| 错误: |
|  |
| "程序停止等待用户输入" |
| > run-wc(4) |
| numV(7) |

尽管它们相似，但这两种策略之间存在两个主要区别：

1.  在使用 CPS 时，真正的工作实际上是在程序转换中完成的。整个解释器与以前基本上没有什么不同；事实上，解释器的主要添加实际上是调试支持，以暂停其执行，这样我们就可以确保续延策略是正确的。在这里，转换是对解释器本身的转换，一次完成，而解释器则工作以生成续延。

1.  特别是，续延现在围绕着行为的其余部分关闭，而不是解释程序的行为。然而，由于后者的工作是精确模仿前者的工作，我们无法观察到这种差异。

在后一种情况下，静态作用域（在 Pyret 中）确保正确的计算被恢复，即使我们存储了多个续延。这两种策略都隐含地指出续延本身是静态作用域的。

## 33.4 生成器

现在许多编程语言都有生成器的概念。生成器就像一个过程，可以在应用中调用它。而常规过程总是从头开始执行，生成器则从上次离开的地方继续执行。当然，这意味着生成器需要一个“在完成之前退出”的概念。这就是所谓的产出，即将控制返回给调用它的任何东西。

生成器之间存在许多变化。可预见的变化点与如何进入和退出生成器有关：

+   在一些语言中，生成器是一个像任何其他对象一样实例化的对象，通过调用方法（例如 Python 中的 next）来恢复其执行。在其他语言中，它就像一个过程一样，并且通过像函数一样应用它来重新进入。在除了常规过程之外还可以在应用中使用值的语言中，所有这些值都被统称为可应用值。

+   在一些语言中，yield 操作（例如 Python 的 yield）仅在生成器的语法体内部可用。在其他语言中，例如 Racket，yield 是绑定在体内的可应用值，但由于是值，它可以传递给抽象，存储在数据结构中等。

Python 的设计代表了一个极端点，即生成器只是包含其体中关键字 yield 的任何函数。此外，Python 的 yield 不能作为参数传递给另一个函数，该函数代表生成器执行 yield。还有一个小问题是命名。在许多具有生成器的语言中，yielder 自动称为 yield（如 Python 中）。另一种可能性是生成器的用户必须在生成器表达式中指示要给 yielder 的名称；例如，在 Racket 中，有趣的是，Python 希望用户确定在对象中称为 self 或 this，但它不提供相同的灵活性给 yield，因为它没有其他方法来确定哪些函数是生成器！

| (generator (yield) (from) |
| --- |
|            (rec (f (lambda (n) |
|                      (begin |
|                        (yield n) |
|                        (f (+ n 1))))) |
|              (f from))) |

但它可能等效地是

| (generator (y) (from) |
| --- |
|            (rec (f (lambda (n) |
|                      (begin |
|                        (y n) |
|                        (f (+ n 1))))) |
|              (f from))) |

如果 yielder 是一个实际值，用户还可以对 yield 进行抽象：

| (generator (y) (from) |
| --- |
|            (rec (f (lam (n) |
|                      (seq |
|                        ((yield-helper y) n) |
|                        (f (+ n 1))))) |
|              (f from))) |

其中 yield-helper 可能会执行实际的 yield 操作。实际上还有两个设计决策：

1.  yield 是一个语句还是表达式？在许多语言中，它实际上是一个表达式，意味着它有一个值：在恢复生成器时提供的值。这使得生成器更加灵活，因为生成器的用户可以使用参数来改变生成器的行为，而不是被迫使用状态来��达所需的更改。

1.  生成器执行结束时会发生什么？在许多语言中，生成器会引发异常来表示其完成。

要实现生成器，最好从我们的 CPS 解释器开始。为什么？记住生成器的工作方式：为了 yield，生成器必须

+   记住它当前执行的位置，并

+   知道在其调用者中应该返回到哪里。

当被调用时，它应该

+   记住它的执行在其调用者当前的位置，并且

+   知道在其体内应该返回到哪里。

观察调用和 yield 之间的对偶关系。

你可能会猜到，这些“where”对应于 continuations。

> 练习
> 
> > 向 CPS 解释器添加生成器。
> > 
> 练习
> 
> > 生成器与协程和线程有何不同？使用类似策略实现协程和线程。
> > 
> 练习
> 
> > 我们已经看到 Python 的生成器不允许在 yield 上进行任何抽象，而 Racket 的生成器则允许。假设这是有意的，Python 为什么会做出这样的设计决定？

## Continuations 和 Stacks

令人惊讶的是，CPS 转换实际上为程序执行栈的性质提供了巨大的洞察力。首先要理解的是，每个 continuation 其实都是栈本身。这可能看起来很奇怪，因为栈是低级机器原语，而 continuation 看似是复杂的过程。但实际上栈是什么？

+   它记录了计算中尚未完成的任务。continuation 也是如此。

+   它传统上被认为是一个栈帧列表。也就是说，每个帧都有一个引用指向它完成后剩余的帧。同样，每个 continuation 都是一个小过程，它引用——并因此关闭——自己的 continuation。如果我们选择了不同的程序指令表示结构，将其与闭包的数据结构表示结合起来，我们将获得一个基本与机器栈相同的 continuation 表示。

+   每个栈帧还存储过程参数。这由 continuation 的程序化表示隐式管理，而在数据结构表示中（使用 bind）则是显式完成的。

+   每个帧还有“局部变量”的空间。原则上，continuation 也有，尽管通过解糖本地绑定，我们实际上将一切都简化为了过程参数。但在概念上，其中一些是“真正的”过程参数，而其他一些是通过解糖将局部绑定转换为过程参数的本地绑定。

+   栈引用堆，但不关闭堆。因此，堆上的更改在栈帧之间是可见的。同样，闭包引用存储，但不关闭存储，因此对存储的更改在闭包之间是可见的。

因此，传统上栈负责维护词法作用域，我们自动获得这一点，因为我们在静态作用域语言中使用闭包。现在我们可以研究各种术语的转换以理解其与栈的映射。例如，考虑函数应用的转换。我们如何“读取”它？如下所示：

+   让我们使用 k 来引用在函数应用开始评估之前存在的栈。

+   当我们开始评估函数位置（f）时，创建一个新的堆栈帧（fdC("f-v")：...；。这个帧有一个自由标识符：k。因此，它的闭包需要记录环境的一个元素，即堆栈的其余部分。

+   堆栈帧的代码部分表示我们获得函数值后剩下要做的事情：评估参数，执行应用程序，并将结果返回给期望应用程序结果的堆栈：k。

+   当 f 的评估完成时，我们开始评估 a，这也创建了一个堆栈帧：fdC("a-v")：...；。这个帧有两个自由标识符：k 和 f-v。这告诉我们：

    +   我们不再需要用于评估函数位置的堆栈帧，但是

    +   现在我们需要一个临时记录值 ——<wbr>希望是一个函数值 ——<wbr>评估函数位置。

+   第二帧的代码部分表示剩下要做的事情：在期望应用程序的值的堆栈中调用函数值与参数。

类似地，检查条件的 CPS 转换会告诉我们，我们必须创建一个新的帧来评估条件表达式，我们必须创建一个新的堆栈帧。这个帧闭合在期望整个条件值的堆栈上。这个帧根据条件表达式的值做出决定，并调用其他表达式之一。一旦我们检查了这个值，创建用于评估条件表达式的帧就不再需要了，因此评估可以在原始的继续中进行。

通过这个视角看，我们可以更容易地为生成器提供一个操作性的解释。每个生成器都有自己的私有堆栈，当执行试图返回其末尾时，我们的实现会引发一个错误。在调用时，生成器存储对“程序的其余部分”的堆栈的引用，并恢复自己的堆栈。在产生时，系统交换堆栈的引用。协程、线程和生成器在概念上都是相似的：它们都是创建“许多小堆栈”的机制，而不是拥有单个全局堆栈。

## 33.6 尾调用

观察上面的堆栈模式会给当前堆栈添加一个帧，执行一些评估，最终总是返回到当前堆栈。特别是要注意，在应用程序中，我们需要堆栈空间来评估函数位置和参数，但一旦所有这些都评估完成，我们就会使用在应用之前启动的堆栈继续计算。换句话说，函数调用本身不需要消耗堆栈空间：我们只需要空间来计算参数。

然而，并不是所有的语言都观察或遵守这个特性。在观察到这一特性的语言中，程序员可以使用递归来获得迭代行为：即，一系列函数调用不会消耗比根本没有函数调用更多的栈空间。这消除了创建特殊循环结构的需要；实际上，循环可以简单地表示为一种语法糖。

当然，这个特性并不普遍适用。如果调用 f 来计算 g 调用的参数，那么相对于 g 周围的上下文，对 f 的调用仍然会消耗空间。因此，我们应该真正谈论表达式之间的关系：一个表达式相对于另一个表达式处于尾部位置，如果它的评估不需要额外的栈空间。在我们的 CPS 解糖中，每一个使用 k 作为其延续的表达式——比如在所有子表达式被评估之后的函数应用，或者条件语句的 then-和 else-分支——都相对于封闭的应用处于尾部位置（也许是递归地进一步上升）。相反，每一个必须创建新的栈帧的表达式都不处于尾部位置。

一些语言对尾递归有特殊支持：当一个过程在相对于其主体的尾部位置调用自身时。这显然很有用，因为它使递归能够有效地实现循环。然而，它对于无法压缩到单个递归函数中的“循环”是有害的。例如，在实现扫描器或其他状态机时，最方便的是有一组函数，每个函数代表一个状态，并通过进行（尾部）函数调用来过渡到其他状态。将它们转换为单个递归函数是繁琐的（并且失去了重点）。然而，如果一种语言识别尾调用作为这样的，它可以像内部函数调用一样优化这些跨函数调用。

Scheme 和 Racket 特别承诺在不分配额外栈空间的情况下实现尾调用。尽管有些人将这称为“尾调用优化”，但这个术语是误导性的：优化是可选的，而语言是否承诺正确实现尾调用是一个语义特性。开发人员需要知道语言将如何行为，因为它会影响他们的编程：他们需要知道如何构建他们的循环！

由于这个特性，在 CPS 转换之后，观察程序的一些有趣之处：它的所有函数应用本身都是尾调用！假设程序可能在任何调用处终止相当于根本不使用任何栈空间（因为栈会被清空）。

> 练习
> 
> > 任何消耗一些栈的程序，在转换为 CPS 并运行后，突然不再消耗任何栈空间。为什么？
> > 
> > 作为一个推论，转换为 CPS 是否减少了程序的整体内存占用？
> > 
> 练习
> 
> > Java 的本地安全模型采用一种称为堆栈检查的机制（如果您对此不熟悉，请查阅）。控制流保护（CPS）与堆栈检查之间有什么互动？也就是说，如果我们对程序进行 CPS，这会影响其安全行为吗？
> > 
> > 如果不会，为什么？
> > 
> > 如果会，那么如何以及在必要时应该采取什么措施来恢复安全性？

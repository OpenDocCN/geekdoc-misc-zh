# 处理程序：首次查看解释

|     24.1 表示算术 |
| --- |
|     24.2 撰写解释器 |
|     24.3 “语义学”的第一次尝试 |
|     24.4 去糖化：扩展语言而不扩大其规模 |
|       24.4.1 扩展：二元减法 |
|       24.4.2 扩展：一元取反 |
|     24.5 三阶段管道 |

现在我们准备好编写一个评估器——<wbr>一个将程序转换为答案的程序——<wbr>以解释器的形式，用于我们的算术语言。“评估”一词的含义是“将其简化为一个值”。我们首先选择算术有三个原因：（a）你已经知道它是如何工作的，因此我们可以专注于编写评估器的机制；（b）它包含在我们后来会遇到的每种语言中，因此我们可以从中构建并向外扩展；以及（c）它（令人惊讶地）足够复杂，以传达一些重要观点。

## 表示算术

让我们首先就如何表示算术表达式达成一致。假设我们只想支持两种操作——<wbr>加法和乘法——<wbr>除了原始数字。我们需要表示算术表达式。规定了什么样的规则来嵌套算术表达式？实际上，我们可以自由地将任何表达式嵌套在另一个表达式中。

> 现在就做吧！
> 
> > 为什么我们没有包括除法？这对上述评论有何影响？

我们忽略了除法，因为它迫使我们讨论哪些表达式我们可能认为是合法的：显然，1/2 的表示应该是合法的；1/0 的表示则更具争议；而 1/(1-1) 的表示似乎更具争议性。我们想暂时回避这个争议，并以后再回到它 [REF]。因此，我们想要一个表示数字和任意可嵌套的加法和乘法的表示。下面是一个我们可以使用的：

```
data ArithC:
  | numC(n :: Number)
  | plusC(l :: ArithC, r :: ArithC)
  | multC(l :: ArithC, r :: ArithC)
end
```

## 撰写解释器

现在让我们为这个算术语言编写一个解释器。首先，我们应该考虑它的类型是什么。它显然消耗一个 ArithC 值。它产生什么？嗯，一个解释器进行评估——算术表达式可能归约为什么样的值？当然是数字。因此，解释器将是一个从算术表达式到数字的函数。

> 练习
> 
> > 为你的解释器编写例子。

因为我们有一个递归数据类型，将我们的解释器构建为它的递归函数是很自然的。这是一个第一个模板：模板的详细说明见 [How to Design Programs](http://www.htdp.org/)。

```
fun interp(e :: ArithC) -> Number:
  cases (ArithC) e:
    | numC(n) => ...
    | plusC(l, r) => ...
    | multC(l, r) => ...
  end
end
```

你可能会直接跳到代码，你可以：

```
fun interp(e :: ArithC) -> Number:
  cases (ArithC) e:
    | numC(n) => n
    | plusC(l, r) => l + r
    | multC(l, r) => l * r
  end
where:
  interp(numC(3)) is 3
end
```

它运行得非常顺利，通过了测试。

> 现在就做吧！
> 
> > 你发现了错误吗？

相反，让我们将模板扩展出一步：

```
fun interp(e :: ArithC) -> Number:
  cases (ArithC) e:
    | numC(n) => ...
    | plusC(l, r) => ... interp(l) ... interp(r) ...
    | multC(l, r) => ... interp(l) ... interp(r) ...
  end
end
```

现在我们可以填写空白处了：

```
fun interp(e :: ArithC) -> Number:
  cases (ArithC) e:
    | numC(n) => n
    | plusC(l, r) => interp(l) + interp(r)
    | multC(l, r) => interp(l) * interp(r)
  end
end
```

后面（随处可用的函数），我们将希望我们返回的数据类型比仅仅是数字更复杂一些。但是现在，这就够了。

恭喜：你已经写下了你的第一个解释器！我知道，这几乎是一个令人失望的结局。但它们很快会变得更难——<wbr>非常困难——<wbr>我保证。

## 24.3A “语义”初尝试

我刚才在你面前溜走了一些东西：

> 现在就去做！
> 
> > 在这种新语言中，加法和乘法的“含义”是什么？

这是一个相当抽象的问题，不是吗？让我们把它具体化。我将问题提出如下。

这些哪个是相同的？

> +   1 + 2
> +   
> +   1 + 2
> +   
> +   ’1’ + ’2’
> +   
> +   ’1’ + ’2’

我们要讨论的是，在计算机科学中有许多种类的加法：

+   首先，有许多不同类型的数字：固定宽度（例如，32 位）整数，带符号的固定宽度（例如，31 位加一个符号位）整数，任意精度整数；在某些语言中，有理数；各种格式的固定和浮点数；在某些语言中，复数；等等。在选择了数字之后，加法可能仅支持其中的一些组合。

+   此外，一些语言允许添加诸如矩阵之类的数据类型。

+   此外，许多语言支持对字符串的“加法”（我们用引号括起来是因为我们并不真正指的是数学概念中的加法，而是指由具有语法+的运算符执行的操作）。在某些语言中，这总是意味着连接；在其他一些语言中，它可能会产生数值结果（或存储在字符串中的数字）。

这些都是不同的“加法含义”。语义是将语法（例如，+）映射到含义（例如，上述某些或全部）的过程。

回到我们的解释器，我们有什么语义？我们采用了 Pyret 提供的任何语义，因为我们将 + 映射到 Pyret 的 +。事实上，这甚至不完全正确：Pyret 可能（据我们所知）也使 + 适用于字符串（实际上确实是这样），所以我们选择了 Pyret 语义仅适用于数字的限制。

> 练习
> 
> > 我们是以何种方式限制了 + 只适用于数字？这种限制究竟在哪里？

如果我们想要不同的语义，我们将不得不明确地实现它。

> 练习
> 
> > 如果我们想让数字具有带符号的 32 位算术，我们需要更改什么？

一般来说，我们必须谨慎从宿主语言中借鉴。我们稍后会回到这个话题[REF]。但是，由于我们已经有了很多有趣的东西要研究，所以我们暂时将 Pyret 的数字作为我们的数字。

## 24.4 去糖化：扩展语言而不扩大它

我们选择了一个非常受限的第一语言，所以我们有很多方法可以扩展它。有些方法，比如表示数据结构和函数，显然会迫使我们向解释器本身添加新功能。其他方法，比如增加更多的算术本身，可能可以在不干扰核心语言及其解释器的情况下完成：这被称为添加语法糖，或简称为“糖”。让我们来研究一下。

### 24.4.1 扩展：二进制减法

首先，我们将添加减法。因为我们的语言已经有了数字、加法和乘法，所以很容易定义减法：\(a - b = a + -1 \times b\)。

好的，这很容易！但现在我们应该将其转化为具体的代码。为此，我们面临一个决定：这个新的减法运算符应该放在哪里？将其添加到现有的 ArithC 数据类型中似乎很诱人，也许似乎很自然。

> 现在做！
> 
> > 修改 ArithC 的负面后果是什么？

这带来了一些问题：

1.  第一个，显而易见的问题是，我们现在必须修改所有处理 ArithC 的程序。到目前为止，只有我们的解释器，它相当简单，但在更复杂的实现中，可能会有许多围绕数据类型构建的程序—<wbr>类型检查器、编译器等—<wbr>都必须进行更改，造成沉重的负担。

1.  其次，我们试图添加可以根据现有构造定义的新构造；以一种不模块化的方式做这件事似乎有点自我打击。

1.  第三，最微妙的是，修改 ArithC 有一些概念上的不必要性。这是因为 ArithC 代表了一个非常好的核心语言。在此基础上，我们可能想要包含任意数量的额外操作，使用户的生活更方便，但没有必要将这些操作放在核心中。相反，明智的做法是将概念上不同的想法记录在不同的数据类型中，而不是将它们硬塞到一个数据类型中。有时分离看起来可能有点笨拙，但这使得未来开发人员更容易阅读和维护程序。此外，出于不同的目的，您可能希望添加不同的扩展，将核心与表面分离使这成为可能。

因此，我们将定义一个新的数据类型来反映我们打算的表面语法术语：<arith-dt> ::=

|   数据 ArithExt: |
| --- |
|     &#124; numExt (n :: Number) |
|     &#124; plusExt (l :: ArithExt, r :: ArithExt) |
|     &#124; multExt (l :: ArithExt, r :: ArithExt) |
|     &#124; bminusExt (l :: ArithExt, r :: ArithExt) |
|     <uminus-dt> |
|   end |

这几乎与 ArithC 完全相同，除了添加的情况外，后者遵循熟悉的递归模式。请注意，每个节点的子节点都指向 ArithExt，而不是 ArithC。

> 现在做！
> 
> > 如果将子节点声明为 ArithC 而不是 ArithExt 会发生什么？

如果我们这样做，那么我们只能在顶层使用语法糖，而不能在任何子表达式中使用。

鉴于这个数据类型，我们应该做两件事。首先，我们应该修改我们的解析器以解析 - 表达式，并始终构造 ArithExt 项（而不是任何 ArithC 项）。其次，我们应该实现一个 desugar 函数，将 ArithExt 值转换为 ArithC 值。去糖化是去除语法糖的行为。

让我们写 desugar 的明显部分：<main> ::=

|   fun desugar(s :: ArithExt) -> ArithC: |
| --- |
|     cases (ArithExt) s: |
|       &#124; numExt(n) => numC(n) |
|       &#124; plusExt(l, r) => plusC(desugar(l), desugar(r)) |
|       &#124; multExt(l, r) => multC(desugar(l), desugar(r)) |
|       <bminus> |
|       <uminus> |
|     end |
|   end |

现在让我们将上面的减法的数学描述转换为代码：<bminus> ::=

|   &#124; bminusExt(l, r) => |
| --- |
|     plusC(desugar(l), multC(numC(-1), desugar(r))) |

> 现在做！
> 
> > 忘记在 l 和 r 上递归调用 desugar 是一个常见的错误。当你忘记它们时会发生什么？自己尝试一下看看。

### 24.4.2 扩展：一元否定

现在让我们考虑另一个扩展，这个扩展有点更有趣：一元否定。这会迫使你在解析器中做更多工作，因为根据你的表面语法，你可能需要向前查看以确定你是在一元还是二元情况下。但这甚至不是有趣的部分！

> 练习
> 
> > 修改解析器以处理一元减法。

我们可以有许多方法去去糖化一元否定。我们可以自然地定义它为 \(-b = 0 - b\)，或者我们可以通过这个展开来抽象化二元减法的去糖化：\(-b = 0 + -1 \times b\)。

> 现在做！
> 
> > 你更喜欢哪一个？为什么？

选择第一个展开是很诱人的，因为它更简单。想象一下，我们已经用一元否定的表示扩展了 ArithExt 数据类型：<uminus-dt> ::=

|   &#124; uminusExt (e :: ArithExtU) |
| --- |

现在在 desugar 中的实现很简单：<uminus> ::=

|   &#124; uminusExt(e) => desugar(bminusExt(numExt(0), e)) |
| --- |

让我们确保类型匹配。注意 e 是一个 ArithExt 项，因此可以作为参数传递给 bminusExt，并且整个项可以合法地传递给 desugar。因此，重要的是不要去糖化 e，而是直接嵌入到生成的项中。在去糖化工具中嵌入一个输入项到另一个项并递归调用 desugar 是一个常见的模式；这被称为宏（具体来说，在这里“宏”是 uminusExt 的定义）。然而，上面的定义有两个问题： 

1.  第一点是递归是生成的，这迫使我们额外小心。如果你以前没有听说过生成递归，请阅读[如何设计程序](http://www.htdp.org/)中关于它的章节。基本上，在生成递归中，子问题是输入的计算函数，而不是其结构的一部分。这是生成递归的一个特别简单的情况，因为“函数”很简单：它只是 bminusExt 构造器。我们可能会想通过使用不同的重写来修复这个问题：<uminus/alt> ::=

    |   &#124; uminusExt(e) => bminusExt(numExt(0), desugar(e)) |
    | --- |

    确实消除了生成性。

    > 现在动手！
    > 
    > > 不幸的是，这种展开转换根本行不通！你明白为什么吗？如果不明白，试着运行一下。

1.  第二点是，我们在隐含地依赖于 bminusExt 的确切含义；如果其含义发生变化，uminusExt 的含义也将发生变化，即使我们不希望如此。相比之下，定义一个函数抽象，它接受两个项并生成一个表示第一个项加上第二个项乘以-1 的结果，并使用这个函数来定义 uminusExt 和 bminusExt 的展开，会更加容错。

    你可能会说减法的含义永远不会改变，所以为什么要费心呢？是的和不是。是的，它的含义不太可能改变；但不是，它的实现可能会改变。例如，开发人员可能决定记录所有二元减法的用法。在第一个展开中，所有一元否定的用法也将被记录，但在第二个展开中不会。

幸运的是，在这种特殊情况下，我们有一个更简单的选择，即定义 \(-b = -1 \times b\)。这种展开使用我们拥有的基本操作，并且遵循结构递归。然而，我们之前走这条弯路的原因是提醒您这些问题，并警告您可能并不总是这么幸运。

## 24.5A 三阶段流水线

这就是我们第一次看到的标准流水线，我们将使用它。我们将首先解析程序以将其转换为抽象语法；然后，我们将对其进行解糖以消除不必要的结构。从现在开始，我们通常只关注结果核心语言，它不仅将受到解释，还将受到类型检查和其他操作的影响。

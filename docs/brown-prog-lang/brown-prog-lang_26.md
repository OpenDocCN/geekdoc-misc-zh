# 解释函数

|     26.1 向语言添加函数 |
| --- |
|       26.1.1 定义数据表示 |
|       26.1.2 增加解释器功能 |
|       26.1.3 替换 |
|       26.1.4 解释器，续 |
|       26.1.5 噢，等一下，还有更多！ |
|     26.2 从替换到环境 |
|       26.2.1 介绍环境 |
|       26.2.2 使用环境解释 |
|       26.2.3 正确推迟 |
|       26.2.4 作用域 |
|       26.2.5 有多糟糕？ |
|       26.2.6 顶级范围 |
|       26.2.7 暴露环境 |
|     26.3 函数随处可见 |
|       26.3.1 函数作为表达式和值 |
|       26.3.2 一个小改进 |
|       26.3.3 嵌套函数 |
|       26.3.4 嵌套函数和替换 |
|       26.3.5 更新值 |
|       26.3.6 糖化匿名 |
|     26.4 递归和非终止 |
|     26.5 函数与可预测性 |

## 26.1 向语言添加函数

现在我们有了基本的表达式和条件，让我们通过添加函数来发展成一个完整的编程语言。

### 26.1.1 定义数据表示

想象我们正在模拟一个简单的编程环境。开发人员在定义窗口中定义函数，并在交互窗口中使用它们。出于历史原因，交互窗口也称为 REPL 或“读取-求值-打印循环”。（在此处提供一个提示，以便他们可以运行表达式）。目前，让我们假设所有定义都只放在定义窗口中（我们很快会放宽这一点：函数随处可见），而所有独立表达式都只放在交互窗口中。因此，运行程序只需加载定义。我们的解释器将对应于交互窗口提示，并假设已提供一组定义。一组定义意味着没有顺序，这意味着，据推测，任何定义都可以引用任何其他定义。这是我在这里的意图，但是当你设计自己的语言时，请务必考虑这一点。

为了保持简单，让我们只考虑一个参数的函数。以下是一些 Pyret 示例：

```
fun double(x): x + x end

fun quad(x): double(double(x)) end

fun const5(_): 5 end
```

> 练习
> 
> > 当一个函数有多个参数时，什么简单但重要的标准控制着这些参数的名称？

函数定义的各个部分是什么？它有一个名字（如上所示，`double`，`quad` 和 `const5`），我们将其表示为一个字符串（"double"等）；它的形式参数或参数有一个名字（例如，`x`），我们也可以将其建模为一个字符串（"x"）；它还有一个主体。我们将逐步确定主体的表示方式，但让我们开始布置函数定义的数据类型：

```
data FunDefC:
  | fdC(name :: String, arg :: String, body :: ExprC)
end
```

主体是什么？显然，它具有算术表达式的形式，有时甚至可以使用现有的 `ArithC` 语言来表示：例如，`const5` 的主体可以表示为 `numC(5)`。但是表示 `double` 的主体需要更多：不仅仅是加法（我们已经有了），还有“x”。您可能习惯将其称为变量，但我们现在不会使用该术语。相反，我们将其称为标识符。我们已经在 从标识符到变量 中讨论过这个术语上的区别。

> 现在做！
> 
> > 还有其他的吗？

最后，让我们来看看 `quad` 的主体。它又有一个新的构造：函数应用。非常小心地区分函数定义（描述函数是什么）和应用（使用函数的地方）。在 `double` 的内部应用中，参数（或实际参数）是 `x`；在外部应用中，参数是 `double(x)`。因此，参数可以是任何复杂表达式。

让我们把所有这些都承诺成一个清晰的数据类型。显然，我们正在扩展之前的内容（因为我们仍然想要所有的算术）。我们将给我们的数据类型一个新的名字，以表示它正在成长：<datatype> ::=

|   data ExprC: |
| --- |
|     &#124; numC(n :: Number) |
|     &#124; plusC(l :: ExprC, r :: ExprC) |
|     &#124; multC(l :: ExprC, r :: ExprC) |
|     &#124; trueC |
|     &#124; falseC |
|     &#124; ifC(c :: ExprC, t :: ExprC, e :: ExprC) |
|     &#124; <appC-dt> |
|     &#124; <idC-dt> |
|   end |

标识符与形式参数密切相关。当我们通过为其参数给出一个值来应用一个函数时，实际上我们要求它用该值替换主体中的所有该形式参数的实例——即，与形式参数相同名称的标识符——将其替换为该值。请注意，我们对一些问题保持含糊： “值” 是什么样的[REF] 以及何时替换[REF]。为了简化这个搜索和替换的过程，我们可能会使用相同的数据类型来表示两者。我们已经选择了字符串来表示形式参数，所以：<idC-dt> ::=

|     &#124; idC(s :: String) |
| --- |

最后，应用程序。它们有两个部分：函数的名称和其参数。我们已经同意参数可以是任何完整的表达式（包括标识符和其他应用程序）。至于函数名，再次使用与在函数定义中给出函数名称时相同的数据类型是有意义的。因此：<appC-dt> ::=

|   &#124; appC(f :: String, a :: ExprC) |
| --- |

确定要应用的函数，并提供其参数。使用这些定义，编写上面定义的示例的表示是有益的：

+   fdC("double", "x", plusC(idC("x"), idC("x")))

+   fdC("quad", "x", appC("double", appC("double", idC("x"))))

+   fdC("const5", "_", numC(5))

我们还需要选择一种表示一组函数定义的方法。用列表表示这些是方便的。注意！你注意到我们谈到了一组函数定义，但选择了列表表示吗？这意味着我们使用有序的数据集表示无序的实体。至少，在测试时，我们应该使用所有排列组合的定义来确保我们没有在微妙地构建依赖于顺序。

> 练习
> 
> > 扩展 desugar 以支持标识符和应用程序。

### 26.1.2 扩展解释器

现在我们准备好处理解释器本身了。首先，让我们想想它需要消耗什么。以前，它只消耗要评估的表达式。现在，它还需要接受一个函数定义的列表：<fof-interp> ::=

|   fun interp(e :: ExprC, fds :: List<FunDefC>) -> Value: |
| --- |
|     cases (ExprC) e: |
|       <fof-interp-body> |
|     end |
|   end |

让我们重新审视一下我们的旧解释器。对于数字情况，显然我们仍然将数字作为答案返回。在加法和乘法情况下，我们仍然需要递归（因为子表达式可能很复杂），但是我们使用哪一组函数定义呢？因为评估表达式的行为既不添加也不删除函数定义，所以定义的集合保持不变，应该在递归调用中以不变的方式传递。条件也类似。<fof-interp-body> ::=

|   &#124; numC(n) => numV(n) |
| --- |
|   &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r, fds) |
|   &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r, fds) |
|   &#124; trueC => boolV(true) |
|   &#124; falseC => boolV(false) |
|   &#124; ifC(cnd, thn, els) => |
|     ic = interp(cnd, fds) |
|     if is-boolV(ic): |
|       if ic.b: |
|         interp(thn, fds) |
|       else: |
|         interp(els, fds) |
|       end |
|     else: |
|       raise('not a boolean') |
|     end |
|   <fof-interp-idC> |
|   <fof-interp-appC> |

> 练习
> 
> > 修改 arith-binop 以在递归调用中保持 fds 不变。

现在让我们来解决应用的问题。首先，我们必须查找函数定义，我们假设有这样一个可用的帮助函数：<get-fundef> ::=

|   fun get-fundef(name :: String, fds :: List<FunDefC>) |
| --- |
|       -> FunDefC: |
|     <get-fundef-body> |
|   end |

假设我们找到了给定名称的函数，我们需要评估其主体。但是，请记住我们关于标识符和参数的说法？我们必须“搜索和替换”，这是你在学校代数中见过的一个过程，称为替换。这是非常重要的，我们应该先讨论替换，然后再返回解释器（继续解释器）。

### 26.1.3 替换

替换是用一个表达式（在这种情况下是实际参数）替换表达式中的一个名称（在这种情况下是形式参数的名称）的行为。它的标头是：<subst> ::=

|   fun subst(w :: ExprC, at :: String, in :: ExprC) -> ExprC: |
| --- |
|     <subst-body> |
|   end |

第一个参数是我们要用来替换名称的内容；第二个是我们要执行替换的名称；第三个是我们要在其中执行替换的表达式。

> 现在做！
> 
> > 假设我们要在上述三个示例函数的主体中用 3 替换标识符 x。它应该产生什么？

对于 double，应该产生 3 + 3；对于 quad，应该产生 double(double(3))；对于 const5，应该产生 5（即，主体中没有 x 实例，因此不进行替换）。一个常见的错误是假设在 double 中用 3 替换 x 的结果是 fun double(x): 3 + 3 end。这是不正确的。我们只在应用函数时进行替换，在这时函数的调用被其主体所替换。标头使我们能够找到函数并确定其参数的名称；但只有其主体参与评估。检查解释器中替换的用法，看看返回函数定义如何导致类型错误。

这些示例已经告诉我们在几乎所有情况下应该做什么。给定一个数字，没有什么需要替换的。如果是标识符，我们必须替换标识符（如果它是我们尝试替换的标识符），否则保持不变。在其他情况下，进入子表达式，执行替换。

在我们将其转换为代码之前，有一个重要的情况需要考虑。假设我们要替换的名称恰好是函数的名称。那么应该发生什么？

> 现在做！
> 
> > 究竟应该发生什么？

有很多方法可以解决这个问题。一个是从设计的角度来看：函数名存在于它们自己的“世界”中，与普通程序标识符不同。一些语言（如 C 和 Common Lisp，稍微有些不同）采用这种观点，并根据标识符的使用方式将其划分到不同的命名空间中。在其他语言中，没有这样的区别；事实上，我们很快就会研究这样的语言（函数随处可见）。

目前，我们将采取实用主义的观点。如果我们评估一个函数名，它会得到一个数字或布尔值。然而，这些不能命名函数。因此，在那个位置进行替换是毫无意义的，无论它与要替换的变量的关系如何，我们都应该保持函数名不受影响。（因此，一个函数可以有一个名为 x 的参数，也可以引用另一个名为 x 的函数，这些将被区分开来。）

现在我们已经做出了所有的决定，我们可以提供主体了：<subst-body> ::=

|   cases (ExprC) in: |
| --- |
|     &#124; numC(n) => in |
|     &#124; plusC(l, r) => plusC(subst(w, at, l), subst(w, at, r)) |
|     &#124; multC(l, r) => multC(subst(w, at, l), subst(w, at, r)) |
|     &#124; trueC => trueC |
|     &#124; falseC => falseC |
|     &#124; ifC(cnd, thn, els) => |
|       ifC(subst(w, at, cnd), subst(w, at, thn), subst(w, at, els)) |
|     &#124; appC(f, a) => appC(f, subst(w, at, a)) |
|     &#124; idC(s) => |
|       if s == at: |
|         w |
|       else: |
|         in |
|       end |
|   end |

> 练习
> 
> > 注意，与 numC 情况不同，解释器返回 numV(n)，替换返回 in（即，在那一点上等价于编写 numC(n)的原始表达式）。为什么？

### 26.1.4 解释器，续

哦！现在我们已经完成了替换的定义（或者我们这样认为），让我们完成解释器吧。替换是一个繁重的步骤，但它也完成了应用函数所涉及的大部分工作。写出下面的代码是诱人的<fof-interp-appC/alt> ::=

|   &#124; appC(f, a) => |
| --- |
|     fd = get-fundef(f, fds) |
|     subst(a, fd.arg, fd.body) |

诱人，但是错误的。

> 现在做！
> 
> > 你明白了吗？

根据类型推理。解释器返回什么？值。替换返回什么？哦，对了，表达式！例如，当我们在 double 的主体中进行替换时，我们得到了 5 + 5 的表示。这对解释器来说不是一个有效的答案。相反，它必须被简化为一个答案。当然，这正是解释器所做的：<fof-interp-appC> ::=

|   &#124; appC(f, a) => |
| --- |
|     fd = get-fundef(f, fds) |
|     interp(subst(a, fd.arg, fd.body), fds) |

好了，现在只剩下一个情况了：标识符。它们可能有什么复杂的地方呢？它们应该和数字一样简单！然而，我们把它们留到了最后，这说明有什么微妙或复杂的事情正在发生。

> 现在做！
> 
> > 通过一些示例来理解解释器在标识符情况下应该做什么。

假设我们已经定义了 double 如下：

```
fun double(x): x + y end
```

当我们将 5 替换为 x 时，这将产生表达式 5 + y。到目前为止一切顺利，但剩下的是什么替换 y？事实上，从一开始就应该清楚，这个 double 的定义是错误的。标识符 y 被称为自由的，这个形容词在这个设置中具有负面含义。

换句话说，解释器不应该遇到标识符。所有标识符在解释器看到它们之前都应该是已经被替换的参数（这称为绑定的标识符—<wbr>这里，是一个积极的内涵）。因此，对于标识符只有一个可能的响应：<fof-interp-idC> ::=

|   &#124; idC(s) => raise("未绑定的标识符") |
| --- |

就是这样！

最后，为了完成我们的解释器，我们应该定义 get-fundef：<get-fundef-body> ::=

|   cases (List<FunDefC>) fds: |
| --- |
|     &#124; 空 => raise("找不到函数") |
|     &#124; link(f, r) => |
|       if f.name == name: |
|         f |
|       否则： |
|         get-fundef(name, r) |
|       结束 |
|   结束 |

### 等等，还有更多！

早些时候，我们声明了 subst 如下：

```
fun subst(w :: ExprC, at :: String, in :: ExprC) -> ExprC:
  ...
end
```

为了简洁起见，假设我们将 double 应用于 1 + 2。这将使 1 + 2 替换每个 x，从而产生以下表达式—<wbr>（1 + 2）+（1 + 2）—<wbr>用于解释。这一定是我们想要的吗？

当你在学校学习代数时，你可能被教导以不同的方式进行操作：首先将参数减少为一个答案（在这种情况下为 3），然后将答案替换为参数。这种替换概念可能具有以下类型：

```
fun subst(w :: Value, at :: String, in :: ExprC) -> ExprC:
  ...
end
```

实际上，我们甚至没有正确地理解替换！由于一个称为“名称捕获”的微妙问题，我们所拥有的替换版本无法扩展到此语言之外。修复替换是一个复杂而微妙的过程，也是一项令人兴奋的智力努力，但这不是我想要在这里进行的方向。在本书中，我们将避开这个问题。然而，如果你感兴趣，可以阅读关于[引用] λ演算的内容，它提供了正确定义替换的工具。

> 练习
> 
> > 修改你的解释器以将名称替换为答案，而不是表达式。

实际上，我们在编程语言中遇到了一个深刻的区别。在将参数在函数中替换之前评估参数的行为称为急切应用，而推迟评估的行为称为懒惰，<wbr>并且有一些变种。目前，我们实际上更喜欢急切的语义，因为这是大多数主流语言采用的方式。稍后[引用]，我们将重新讨论懒惰应用语义及其含义。

## 从替换到环境

尽管我们已经对函数有了一个可行的定义，你可能对此感到有些不安。当解释器看到一个标识符时，你可能感到它需要“查找”它。它不仅没有查找任何内容，而且我们定义了它的行为是一个错误！虽然绝对正确，但这也有点令人惊讶。更重要的是，我们编写解释器来理解和解释语言，而这种实现可能会让你觉得不太符合，因为它不符合我们的直觉。

使用替换存在另一个困难，那就是我们遍历源程序的次数。最好只需遍历实际上被评估的程序部分，而且只在必要时进行。但是替换会遍历一切——例如未访问的条件分支——并且强制程序进行替换一次，并再次进行解释。

> 练习
> 
> > 替换对评估的时间复杂度有什么影响吗？

替换还存在另一个问题，那就是它是根据程序源代码的表示定义的。显然，我们的解释器有并且需要访问源代码来解释它。然而，其他实现——例如编译器——不需要为此目的存储它。编译器可能为其他原因存储源代码的版本或信息，例如报告运行时错误，而 JIT 可能需要它以便根据需要重新编译。使用一种更适用于各种实现策略的机制将是不错的。

### 26.2.1 引入环境

解决第一个问题的直觉是让解释器在某种目录中“查找”标识符。解决第二个问题的直觉是延迟替换。幸运的是，这些直觉很好地融合在一起，也解决了第三个问题。目录记录了替换的意图，而不是立即重写程序源代码；通过记录意图，而不是立即替换，我们可以延迟替换；而由此产生的数据结构，称为环境，避免了源码重写的需要，并且很好地映射到底层机器表示。环境中的每个名称关联都称为绑定。这并不意味着我们对替换的研究是无用的；相反，许多在程序上运行的工具——例如编译器和分析器——都使用替换。只是不是为了在运行时进行评估。

请仔细观察，我们改变的是编程语言的实现策略，而不是语言本身。因此，我们用于表示程序的任何数据类型都不应改变，同样重要的是——<wbr>解释器提供的答案也不应该改变。因此，我们应该把之前的解释器看作是一个“参考实现”，我们即将编写的解释器应该与之匹配。实际上，我们应该创建一个生成器，生成大量的测试，运行它们通过两个解释器，并确保它们的答案相同：即，之前的实现是一个预言 (测试的预言)。理想情况下，我们应该证明这两个解释器的行为是相同的，这是一个高级研究课题。一个微妙之处在于精确定义“相同”的含义，特别是与失败相关的。

让我们首先定义我们的环境数据结构。环境是一组与...关联的名称集合是什么？

> 现在行动！
> 
> > 这里一个自然的问题可能会问到环境将名称映射到什么。但一个更好，更基本的问题是：如何确定“自然”问题的答案？

请记住我们的环境是为了推迟替换而创建的。因此，答案在于替换。因此，答案在于替换。我们之前讨论过 (哦，等等，还有更多！) 我们希望替换将名称映射到答案，对应于急切的函数应用策略。因此，环境应该将名称映射到答案。

```
data Binding:
  | bind(name :: String, value :: Value)
end

type Environment = List<Binding>
mt-env = empty
xtnd-env = link
```

### 26.2.2 使用环境进行解释

现在我们可以着手解释器了。有一个情况很简单，但我们应该重新审视所有其他情况：

<fof-env-interp> ::=

|   fun interp(e :: ExprC, nv :: Environment, fds :: List<FunDefC>) -> Value: |
| --- |
|     cases (ExprC) e: |
|       <fof-env-interp-arith> |
|       <fof-env-interp-cond> |
|       <fof-env-interp-idC> |
|       <fof-env-interp-appC> |
|     end |
|   end |

算术运算最简单。回想一下，以前，解释器在不执行任何新的替换的情况下进行了递归。因此，也没有新的延迟替换要执行，这意味着环境不会改变：<fof-env-interp-arith> ::=

|   &#124; numC(n) => numV(n) |
| --- |
|   &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r, nv, fds) |
|   &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r, nv, fds) |

条件语句同样很简单：<fof-env-interp-cond> ::=

|   &#124; trueC => boolV(true) |
| --- |
|   &#124; falseC => boolV(false) |
|   &#124; ifC(cnd, thn, els) => |
|     ic = interp(cnd, nv, fds) |
|     if is-boolV(ic): |
|       if ic.b: |
|         interp(thn, nv, fds) |
|       else: |
|         interp(els, nv, fds) |
|       end |
|     else: |
|       raise('not a boolean') |
|     end |

现在让我们处理标识符。显然，遇到标识符不再是一个错误：这正是这种变化的原因。相反，我们必须在目录中查找其值：<fof-env-interp-idC> ::=

|   &#124; idC(s) => lookup(s, nv) |
| --- |

> 现在行动！
> 
> > 实现 lookup。

最后是应用。注意，在替换解释器中，导致发生新替换的唯一情况是应用。因此，这应该是构建绑定的情况。让我们首先提取函数定义，就像以前一样：<fof-env-interp-appC> ::=

|   &#124; appC(f, a) => |
| --- |
|     fd = get-fundef(f, fds) |
|     <fof-env-interp-appC-rest> |

以前，我们替换，然后解释。因为我们没有替换步骤，所以我们可以继续解释，只要我们记录替换的推迟。让我们也评估参数：<fof-env-interp-appC-rest> ::=

|   arg-val = interp(a, nv, fds) |
| --- |
|   interp(fd.body, <fof-env-interp-appC-rest-xtnd>, fds) |

也就是说，函数定义集合保持不变；我们像以前一样解释函数体；但是我们必须在绑定形式参数的环境中执行它。现在让我们定义该绑定过程：<fof-env-interp-appC-rest-xtnd> ::=

|   xtnd-env(bind(fd.arg, arg-val), nv) |
| --- |

但是我们将会回到这里。被绑定的名称是形式参数（以前替换的相同名称）。它绑定到解释参数的结果（因为我们决定采用急切的应用语义）。最后，这扩展了我们已经有的环境。对此进行类型检查有助于确保我们将所有小细节都处理正确。一旦我们为查找定义了一个定义，我们就会有一个完整的解释器。所以这里是一个：<fof-env-interp-lookup> ::=

|   fun lookup(s :: String, nv :: Environment) -> Value: |
| --- |
|     cases (List) nv: |
|       &#124; empty => raise("未绑定的标识符：" + s) |
|       &#124; link(f, r) => |
|         if s == f.name: |
|           f.value |
|         else: |
|           lookup(s, r) |
|         end |
|     end |
|   end |

注意，查找自由标识符仍会产生错误，但是它已经从解释器移动到查找，后者无法单独确定标识符是否自由，而是根据环境的内容确定这一点。

现在我们有了一个完整的解释器。当然，您应该测试它以确保它按您的预期工作。让我们首先为测试设置一些支持代码：<fof-env-interp-tests-setup> ::=

|   check: |
| --- |
|     f1 = fdC("double", "x", plusC(idC("x"), idC("x"))) |
|     f2 = fdC("quad", "x", appC("double", appC("double", idC("x")))) |
|     f3 = fdC("const5", "_", numC(5)) |
|     f4 = fdC("f4", "x", s2p2d("(if x 1 0)")) |
|     funs = [list: f1, f2, f3, f4] |
|     fun i(e): interp(e, mt-env, funs) end |
|  |
|     <fof-env-interp-tests> |

例如，这些测试通过：<fof-env-interp-tests> ::=

|   i(plusC(numC(5), appC("quad", numC(3)))) is numV(17) |
| --- |
|   i(multC(appC("const5", numC(3)), numC(4))) is numV(20) |
|   i(plusC(numC(10), appC("const5", numC(10)))) is numV(10 + 5) |
|   i(plusC(numC(10), appC("double", plusC(numC(1), numC(2))))) |
|   is numV(10 + 3 + 3) |
|   i(plusC(numC(10), appC("quad", plusC(numC(1), numC(2))))) |
|   is numV(10 + 3 + 3 + 3 + 3) |
|   <fof-env-interp-another-test> |

所以我们完成了，对吗？

> 现在就去做吧！
> 
> > 找出 bug 所在。

### 26.2.3 正确推迟

这是另一个测试：引发的情况在此之前已经解释过：测试错误程序。<fof-env-interp-another-test> ::=

|   interp(appC("f1", numC(3)), mt-env, |
| --- |
|     [list: fdC("f1", "x", appC("f2", numC(4))), |
|       fdC("f2", "y", plusC(idC("x"), idC("y")))]) |
|   raises "unbound identifier: x" |

在我们的解释器中，这个表达式的结果是 numV(7)。应该是吗？翻译成 Pyret 时，这个测试对应以下两个定义和表达式：

```
fun f1(x): f2(4) end
fun f2(y): x + y end

f1(3)
```

这应该产生什么结果？f1(3)将 x 替换为 f1 主体中的 3，然后调用 f2(4)。但值得注意的是，在 f2 中，标识符 x 没有被绑定！Pyret 将产生错误。

实际上，我们的基于替换的解释器也会！

为什么替换过程会导致错误？这是因为，当我们将 x 的表示替换为 f1 的表示中的 3 的表示时，我们只在 f1 中执行这样的替换。这个“表示”的说法有点烦人，是吗？因此，我将不再这样说，但请确保您明白我为什么不得不这样说。这是一个重要的细微之处。（显然：x 是 f1 的参数；即使另一个函数有一个名为 x 的参数，那也是另一个 x。）因此，当我们开始评估 f2 的主体时，它的 x 还没有被替换，导致了错误。

当我们切换到环境时出了什么问题？仔细观察：这很微妙。我们可以专注于应用，因为只有它们会影响环境。当我们用实际值替换形式值时，我们通过扩展当前环境来执行。就我们的示例而言，我们要求解释器不仅在 f2 的主体中替换 f2 的替换，而且还要替换当前的替换（调用者 f1 的替换），以及所有过去的替换。也就是说，环境只增长而不会缩小。

因为我们同意环境只是替换的一种替代实现策略——<wbr>尤其是，语言的含义不应改变——<wbr>我们必须修改解释器。具体来说，我们不应该要求它携带所有过去的延迟替换请求，而应该让它为每个新函数重新开始，就像基于替换的解释器一样。这是一个简单的改变：<fof-env-interp-appC-rest-xtnd-2> ::=

|   xtnd-env(bind(fd.arg, arg-val), mt-env) |
| --- |

现在我们真正复制了替换解释器的行为。

### 26.2.4 作用域

上面的破环境解释器实现了所谓的动态作用域。这意味着环境在程序执行时累积绑定。因此，一个标识符是否绑定甚至取决于程序执行的历史。我们应该明确将这视为编程语言设计的一个缺陷。它对读取和处理程序的所有工具产生不利影响：编译器、集成开发环境和人类。

相比之下，替换——<wbr>和正确的环境——<wbr>给我们提供了词法作用域或静态作用域。“词法”在这个上下文中意味着“从源程序确定”，而计算机科学中的“静态”意味着“不运行程序”，所以这些对同样的直觉具有吸引力。当我们检查一个标识符时，我们想知道两件事：(1)它是否绑定了？(2)如果是的话，在哪里？所谓的“在哪里”是指：如果有多个相同名称的绑定，哪一个控制这个标识符？换句话说，哪一个的替换将给这个标识符赋值？总的来说，在动态作用域的语言中，这些问题通常无法静态回答：因此，例如，您的集成开发环境无法叠加箭头来显示这些信息（像 DrRacket 这样的集成开发环境）。另一种思考的方式是，在动态作用域的语言中，这些问题的答案对所有标识符都是相同的，并且简单地引用动态环境。换句话说，它不提供任何有用的信息。因此，即使随着名称空间变得更丰富（例如，对象、线程等），作用域规则变得更加复杂，我们仍应始终努力保持静态作用域的精神。

### 26.2.5 有多糟糕？

您可能会看着我们正在运行的例子，并想知道我们是否在小题大作。作为回报，你应该考虑两种情况：

1.  要理解程序的绑定结构，你可能需要查看整个程序。无论你将程序分解成多么小的、易于理解的片段，如果任何地方都有自由标识符，那都没有关系。

1.  理解绑定结构不仅取决于程序的大小，还取决于其控制流的复杂性。想象一下一个交互式程序，其中有大量的回调函数；你也需要跟踪每一个回调函数，才能知道哪个绑定控制一个标识符。

需要更多的启发吗？让我们用这个表达式替换我们示例程序的表达式：

```
if moon-visible():
  f1(10)
else:
  f2(10)
end
```

假设 moon-visible 是一个函数，它在新月夜评估为 false，在其他时间评估为 true。 那么，除了在新月夜，此程序将评估为一个答案，此时它将因未绑定的标识符错误而失败。

> 练习
> 
> > 多云的夜晚会发生什么？

### 26.2.6 顶层范围

当我们考虑许多语言中的顶层定义时，情况变得更加复杂。 例如，某些版本的 Scheme（它是词法作用域的典范）允许您编写这样的内容：

> | (define y 1) |
> | --- |
> | (define (f x) (+ x y)) |

这似乎非常清楚地表明 f 主体中的 y 将来自哪里，但是：

> | (define y 1) |
> | --- |
> | (define (f x) (+ x y)) |
> | (define y 2) |

是合法的，(f 10) 产生 12。 等等，你可能会想，总是取最后一个！ 但是考虑：

> | (define y 1) |
> | --- |
> | (define f (let ((z y)) (lambda (x) (+ x y z)))) |
> | (define y 2) |

在这里，z 绑定到 y 的第一个值，而内部的 y 绑定到第二个值。 大多数“脚本”语言都表现出类似的问题。 因此，在网络上，您会发现对于某种语言是静态作用域还是动态作用域存在巨大的混淆，而读者实际上是在比较函数内部（通常是静态的）与顶层（通常是动态的）的行为。 当心！实际上，有关此行为的一个有效解释是在词法作用域方面，但它可能会变得混乱，也许一个更明智的选择是阻止这种重新定义。 Pyret 正是这样做的，从而提供了顶层的便利性而不带来其痛苦。

### 26.2.7 暴露环境

如果我们正在构建供他人使用的实现，那么将只取一个表达式和函数定义列表，并用空环境调用我们定义的 interp，对于导出的解释器来说是明智的，也是一种礼貌。 这样既避免了用户了解实现细节，也避免了使用带有不正确环境的解释器。 但是，在某些情况下，公开环境参数可能会很有用。 例如，环境可以表示一组预定义的绑定：例如，如果语言希望自动将 pi 绑定为 3.2（在[印第安纳州](https://en.wikipedia.org/wiki/Indiana_Pi_Bill)）。

## 26.3 函数随处可见

Scheme 编程语言定义的介绍确立了这一设计原则：

> 编程语言的设计不应该通过堆叠功能来设计，而是通过消除使额外功能看起来必要的弱点和限制来设计。 [REF]

至于设计原则，这个原则很难反驳。（当然，某些限制是有充分理由存在的（函数和可预测性），但是这个原则迫使我们为它们辩护，而不是默认接受它们。）现在让我们把这个原则应用到函数中。

当我们介绍函数时（将函数添加到语言中），我们避而不谈的一件事情就是函数放在哪里。我们建议我们遵循理想化的编程环境模型，将定义和它们的用途分开。但是，受 Scheme 设计原则的启发，让我们看看这是否必要。

为什么函数定义不能是表达式？在我们当前以算术为中心的语言中，我们面临一个令人不安的问题：“函数定义代表什么值？”，对此我们实际上没有一个好的答案。但是一个真正的编程语言显然计算的不仅仅是数字和布尔值，因此我们不再需要以这种形式来回答问题；事实上，上面的答案也可以是，“一个函数值”。让我们看看这可能如何工作。

我们可以对函数值做什么？显然，函数是一种与数字不同的值，所以我们不能将它们相加。但是有一件明显的事情我们可以做：将它们应用于参数！因此，我们可以允许函数值出现在应用的函数位置上。自然地，行为将是应用函数。因此，我们提出了一种语言，以下内容将是一个有效的程序（我使用了括号以便我们可以轻松地识别函数，并为其编写了一个语法）：

> | (+ 2 ([deffun f x (* x 3)] 4)) |
> | --- |

这将计算为（+ 2 (* 4 3)），即 14。（你看到我刚刚使用了替换吗？）

### 26.3.1 表达式和值的函数

让我们首先定义核心语言，包括函数定义：<hof-named-dd> ::=

|   data ExprC: |
| --- |
|     &#124; numC(n :: Number) |
|     &#124; plusC(l :: ExprC, r :: ExprC) |
|     &#124; multC(l :: ExprC, r :: ExprC) |
|     &#124; trueC |
|     &#124; falseC |
|     &#124; ifC(c :: ExprC, t :: ExprC, e :: ExprC) |
|     &#124; idC(s :: String) |
|     <hof-named-dd-fdC/1> |
|     <hof-named-dd-appC> |
|   end |

现在，我们将简单地将函数定义复制到表达式语言中。如果有必要，我们可以随时更改这一点，但是现在至少可以让我们重用现有的测试用例。<hof-named-dd-fdC/1> ::=

|   &#124; fdC(name :: String, arg :: String, body :: ExprC) |
| --- |

这使我们现在可以摆脱 FunDef。我们还需要确定应用的样子。应用的函数位置是什么？我们想要允许整个函数定义，而不仅仅是其名称。因为我们将函数定义与所有其他表达式一起放在一起，所以我们需要注释为 ExprC，但是我们可以添加一个细化（参见（part“注释细化”））以明确它必须是函数定义：<hof-named-dd-appC> ::=

|   &#124; appC(f :: ExprC%(is-fdC), a :: ExprC) |
| --- |

有了这个应用定义，我们就不再需要按名称查找函数，因此解释器可以摆脱函数定义列表。如果需要，我们可以稍后恢复它，但现在让我们仅仅探索函数定义写在应用点上会发生什么：即所谓的即时函数。因此，我们的解释器看起来像这样：<hof-named-interp/1> ::=

|   fun interp(e :: ExprC, nv :: Environment): |
| --- |
|     # 移除值的返回注释，因为 fdC 不是值！ |
|     cases (ExprC) e: |
|       &#124; numC(n) => numV(n) |
|       &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r, nv) |
|       &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r, nv) |
|       &#124; trueC => boolV(true) |
|       &#124; falseC => boolV(false) |
|       &#124; ifC(cnd, thn, els) => |
|         ic = interp(cnd, nv) |
|         if is-boolV(ic): |
|           if ic.b: |
|             interp(thn, nv) |
|           else: |
|             interp(els, nv) |
|           end |
|         else: |
|           raise('not a boolean') |
|         end |
|       &#124; idC(s) => lookup(s, nv) |
|       <hof-named-interp-fun/1> |
|       <hof-named-interp-app/1> |

> 现在做！
> 
> > 注意我们没有在 interp 上留下返回注释。你觉得为什么呢？运行一些示例来弄清楚。

我们需要为解释器添加一个函数定义的情况，这是一个很好的选择：<hof-named-interp-fun/1> ::=

|   &#124; fdC(_, _, _) => e |
| --- |

现在解释器不再仅返回值；现在它也返回函数定义。我们可以更新我们对值的定义（从而恢复注释），但我们很快会发现我们需要更仔细地思考一下。当我们需要评估一个应用程序时，我们只需评估函数位置以获取函数定义，其余的评估过程可以保持不变：<hof-named-interp-app/1> ::=

|   &#124; appC(f, a) => |
| --- |
|     fun-val = interp(f, nv) |
|     arg-val = interp(a, nv) |
|     interp(fun-val.body, xtnd-env(bind(fun-val.arg, arg-val), mt-env)) |

有了这个，我们以前的示例就可以正常工作了：

```
check:
  f1 = fdC("double", "x", plusC(idC("x"), idC("x")))
  f2 = fdC("quad", "x", appC(f1, appC(f1, idC("x"))))
  f3 = fdC("const5", "_", numC(5))
  f4 = fdC("f4", "x", s2p2d("(if x 1 0)"))
  fun i(e): interp(e, mt-env) end

  i(plusC(numC(5), appC(f2, numC(3)))) is numV(17)
  i(multC(appC(f3, numC(3)), numC(4))) is numV(20)
  i(plusC(numC(10), appC(f3, numC(10)))) is numV(10 + 5)
  i(plusC(numC(10), appC(f1, plusC(numC(1), numC(2)))))
    is numV(10 + 3 + 3)
  i(plusC(numC(10), appC(f2, plusC(numC(1), numC(2)))))
    is numV(10 + 3 + 3 + 3 + 3)
end
```

### 26.3.2A 小的改进

> 现在做！
> 
> > 我们解释器定义中有哪一部分我们从未使用过？

是的，有的：函数定义的名称字段从未被使用。这是因为我们不再按名称查找函数：我们通过评估获得它们的定义。因此，一个更简单的定义就足够了：<hof-fun/2> ::=

|   &#124; fdC(arg :: String, body :: ExprC) |
| --- |

> 现在做！
> 
> > 你看到还需要改变什么吗？

除了测试案例之外，您还需要修改处理定义的解释器片段：<hof-interp-fun/2> ::=

|   &#124; fdC(_, _) => e |
| --- |

换句话说，我们的函数现在是匿名的。

### 26.3.3 嵌套函数

函数定义的主体是任意表达式。函数定义本身就是一个表达式。这意味着函数定义可以包含一个...函数定义。例如：

```
inner-fun = fdC("x", plusC(idC("x"), idC("x")))
outer-fun = fdC("x", inner-fun)
```

这评估为

```
fdC("x", fdC("x", plusC(idC("x"), idC("x"))))
```

将其应用于 numC(4)的结果是

```
fdC("x", plusC(idC("x"), idC("x")))
```

我们可能尝试将其应用于一个数字—<wbr>它应该加倍—<wbr>但我们违反了应用程序函数位置的精化注释，它只设想了即时函数，而不是可以评估为函数的表达式。因此，我们应该取消这个限制：

...

然而，假设我们使用一个略有不同的函数定义：

```
appC(fdC("x", fdC("y", plusC(idC("x"), idC("y")))), numC(4))
```

这评估为

```
fdC("y", plusC(idC("x"), idC("y")))
```

现在我们有一个明显的问题，因为 x 不再��定，即使在外部范围中显然是绑定的。实际上，如果我们将其应用于任何值，由于未绑定的标识符，我们会出现错误。

### 26.3.4 嵌套函数和替换

考虑最后两个例子，使用基于替换的解释器。如果我们评估应用

```
appC(fdC("x", fdC("x", plusC(idC("x"), idC("x")))), numC(4))
```

使用替换，内部绑定掩盖了外部绑定，因此不应进行任何替换，得到相同的结果：

```
fdC("x", plusC(idC("x"), idC("x")))
```

在另一个例子中—<wbr>

```
appC(fdC("x", fdC("y", plusC(idC("x"), idC("y")))), numC(4))
```

—<wbr>然而，替换会替换外部标识符，导致

```
fdC("y", plusC(numC(4), idC("y")))
```

因此，再次，如果我们以替换作为正确性的定义，我们会看到我们的解释器产生了错误的答案。

换句话说，我们再次未能忠实地捕捉替换会做什么。函数值需要记住已经应用于它的替换。因为我们使用环境表示替换，所以函数值需要与环境捆绑在一起。这个结果数据结构称为闭包。“保存环境！今天创建一个闭包！”—<wbr>Cormac Flanagan

### 26.3.5 更新值

换句话说，一个函数不能只评估其主体：它必须评估为一个闭包：<hof-value> ::=

|   data Value: |
| --- |
|     &#124; numV(n :: Number) |
|     &#124; boolV(b :: Boolean) |
|     &#124; closV(f :: ExprC%(is-fdC), e :: Environment) |
|   end |

精化注释反映了我们期望的一种非常特定的表达式—<wbr>表示函数定义—<wbr>在一个闭包中。解释器现在使用它。看，我们拿回了我们的返回值注释！大多数情况与以前相同：<hof-interp> ::=

|   fun interp(e :: ExprC, nv :: Environment) -> Value: |
| --- |
|     cases (ExprC) e: |
|       <hof-named-interp/1> |
|       <hof-interp-fdC> |
|       <hof-interp-appC> |
|     end |
|   end |

只有两种有趣的情况：闭包构造和闭包使用。

> 现在！
> 
> > 写出这两种情况。

在评估函数时，我们必须创建一个记录函数创建时环境的闭包：“[Closures]在 Java 使它们受欢迎之前，被 relagated 到相对默默无闻的地位。”—<wbr>[James Iry](http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)<hof-interp-fdC> ::=

|   &#124; fdC(_, _) => closV(e, nv) |
| --- |

这使得函数应用成为可能。现在函数位置可以是任何表达式，所以我们必须首先评估它。这产生了一个值，我们期望它是 closV 的一个实例。因此，我们可以从中提取函数的主体(.f.body)和参数名称(.f.arg)，并在从闭包获取的环境中评估主体(clos.e)：<hof-interp-appC> ::=

|   &#124; appC(f, a) => |
| --- |
|     clos = interp(f, nv) |
|     arg-val = interp(a, nv) |
|     interp(clos.f.body, xtnd-env(bind(clos.f.arg, arg-val), clos.e)) |

> 练习
> 
> > 注意，interp 的参数是 clos.e 而不是 mt-env。编写一个程序来说明这种差异。

这现在计算了我们通过替换得到的相同答案。

> 现在动手吧！
> 
> > 如果我们现在回到使用替换，会遇到任何问题吗？

是的，我们会的。我们已经定义了替换来替换其他程序文本中的程序文本。严格来说，我们不能再这样做了，因为 Value 术语不能包含在 ExprC 术语中。也就是说，替换是建立在答案类型是一种语法形式的假设上的。实际上，可以在这种假设下进行编程研究，但我们不会选择这条路线。

### 26.3.6 匿名性的简化

现在让我们回到给函数命名的概念上，这对于理解程序具有明显的价值。请注意，我们确实有一种命名事物的方式：通过将它们传递给函数，在那里它们获得一个局部名称（形式参数的名称）。在该函数体的任何地方，我们都可以使用形式参数名称引用该实体。

因此，我们可以使用另一个函数定义来命名函数定义。例如，Pyret 代码

```
fun double(x): x + x end
double(10)
```

首先可以重写为等价形式

```
double = lam(x): x + x end
double(10)
```

通过替换计算为(lam(x): x + x end)(10)或 20。事实上，这种模式是一种本地命名机制，几乎每种语言都以某种形式存在。在像 Lisp 和 ML 变种这样的语言中，它通常称为 let。请注意，在不同的语言中，let 具有不同的作用域规则：在某些情况下，它允许递归定义，在其他情况下则不允许。例如，在 Racket 中：

> | (let ([double (lambda (x) (+ x x))]) |
> | --- |
> |   (double 10)) |

在 Pyret 中，与 Java 等几种其他语言一样，没有明确命名的这种构造，但是任何定义块都允许这样的局部定义：

```
fun something():
  double = lam(x): x + x end
  double(10)
end
```

这是一个更复杂的例子，用 Racket 编写以说明作用域的一个要点：

> | (define (double x) (+ x x)) |
> | --- |
> | (define (quad x) (double (double x))) |
> | (quad 10) |

这可以重写为

> | (let ([double (lambda (x) (+ x x))]) |
> | --- |
> |   （let （[quad （lambda （x） （double （double x）））]） |
> |     （quad 10）） |

这样做起作用，就像我们期望的一样；但如果我们改变顺序，它就不再起作用了—<wbr>

> | （let （[quad （lambda （x） （double （double x）））]） |
> | --- |
> |   （let （[double （lambda （x） （+ x x））]） |
> |     （quad 10）） |

—<wbr>因为 quad 不能“看到” double。所以我们看到顶层绑定与局部绑定不同：基本上，顶层具有“无限范围”。这是其强大和问题的根源。

## 26.4 递归和非终止

希望您能说服自己，我们的纯表达式语言—<wbr>只有算术和条件—<wbr>不能创建非终止程序。为什么？因为其解释器是对非循环数据类型的纯结构化。相比之下，即使是我们的第一个函数解释器也是生成式的，这就打开了它可能有非终止计算的可能性。

> 现在就行动！
> 
> > 为该解释器构造一个非终止程序。

而且，确实可以。这是一个函数定义：

```
il = fdC("inf-loop", "x", appC("inf-loop", numC(0)))
```

我们只需要让它开始：

```
interp(appC("inf-loop", numC(0)), [list: il])
```

> 练习
> 
> > 精确定位使其成为可能的生成递归。
> > 
> 现在就行动！
> 
> > 这为什么有效？为什么这是一个无限循环？

这里发生的事情实际上有些微妙。对 interp 的初始调用导致解释器找到一个函数并解释其主体，这导致对 interp 的另一个调用：找到函数并解释其主体，这导致...等等。如果由于某种原因 Pyret 不支持递归（历史上有些语言确实没有！），那么这将无法工作。实际上，还有一些事情我们留给了 Pyret：

> 现在就行动！
> 
> > 这个程序真的会“永远”运行吗（意思是，只要计算机正常运行），还是会耗尽堆栈空间？

好的，这很简单。现在让我们考虑一下我们的最新解释器。它能做什么？

考虑一下在 Pyret 中的这个简单的无限循环：

```
fun loop-forever(): loop-forever() end
loop-forever()
```

让我们将其转换为使用匿名函数：

> | loop-forever = lam()：loop-forever() end |
> | --- |
> | loop-forever() |

看起来不错，对吧？使用上面的 let 语法糖：

> | （lam（loop-forever）：loop-forever() end）（lam()：loop-forever() end） |
> | --- |

现在，最后一行上的循环永远不会结束！

因此，Pyret 的 = 显然不仅仅是进行文本替换：它还“绑定了循环”以进行递归定义。

> 现在就行动！
> 
> > 我们可以尝试其他可能成功的方法吗？

实际上，我们可以。就是这样。为了使它更易读，我们首先给重要的中间术语起个名字（然后发现这个名字并不必要）：

```
little-omega = lam(x): x(x) end
```

鉴于此，我们可以然后定义：

```
omega = little-omega(little-omega)
```

> 练习
> 
> > 为什么这会永远运行？考虑使用替换来解释为什么。

请注意，我们完全可以毫无名称地写下整个内容：

```
(lam(x): x(x) end)(lam(x): x(x) end)
```

正如上面的名称所暗示的那样，函数通常被称为 ω（希腊语中的小欧米茄），而较大的术语 Ω（大欧米茄）。要了解我们如何得出这个神奇术语的，请参见[[EMPTY]](shrinking-the-language.html)。

#### 26.5 函数与可预测性

我们从一个语言开始(向语言中添加函数)，在所有应用点，我们都知道确切地将调用哪个函数（因为我们知道它的名称，而名称指的是一个固定的全局集合中的一个）。这些被称为一阶函数。相比之下，我们后来转向了一个语言(任意函数)，其中包含具有一阶函数相同状态的函数：这些函数与语言中的任何其他值具有相同的地位。

这个转变给了我们很大的灵活性。例如，我们发现(糖化匿名性)一些看似必要的语言特性可以被实现为语法糖；事实上，使用真正的一阶函数，我们可以定义所有的计算([[EMPTY]](shrinking-the-language.html))。那么有什么不好呢？

隐含的问题是，每当我们增加我们的表达能力时，我们相应地削弱了我们的预测能力。特别是，在程序中遇到特定的函数应用时，问题是，我们能否准确地确定在这一点上将调用哪个函数？对于一阶函数，是的；对于高阶函数，这是不可判定的。拥有这种预测能力有许多重要的后果：编译器可以选择内联(几乎)每个函数应用；编程环境可以在那一点给出关于调用哪个函数的实质性帮助；安全分析器可以明确地排除已知的坏函数，从而减少它生成的无用警报的数量。当然，对于高阶函数，所有这些操作有时仍然可能；但它们并不总是可能的，它们的可能性取决于程序的结构和工具的巧妙程度。

> 练习
> 
> > 使用高阶函数时，为什么确定应用中的精确函数是不可判定的？
> > 
> 练习
> 
> > 为什么上述关于内联的引用说“几乎”？

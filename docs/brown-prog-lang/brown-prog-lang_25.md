# 25 解释条件语句

|     25.1 条件语句的设计空间 |
| --- |
|     25.2 条件语句的执行计划 |
|       25.2.1 解释器的类型 |
|       25.2.2 更新算术 |
|       25.2.3 防御性编程 |
|       25.2.4 解释条件语句 |
|     25.3 Growing the Conditional Language |

现在我们的编程语言初露端倪，让我们稍微扩展一下。编程语言的核心包括控制——对执行指令的顺序的能力——以及数据——程序使用和产生的信息的表示。因此，我们将通过一种简单而重要的形式——条件语句——向我们的语言添加控制和数据。虽然这似乎（而且确实）是一个非常简单的概念，但它将迫使我们在语言和解释器管道的设计中解决几个设计问题，因此这个概念出奇地启发人。

## 25.1 条件语句的设计空间

即使是最简单的条件语句也会让我们接触到语言设计的许多变化。考虑一个形式为的条件语句之一：

| (如果测试表达式 那么然后部分 否则否则部分) |
| --- |

我们的意图是首先评估测试表达式；如果它导致一个真值，那么（仅）评估“然后部分”，否则（仅）评估“否则部分”。（我们通常将这两部分称为分支，因为程序的控制必须采取其中之一。）然而，即使这个简单的构造也会导致至少三个不同的、大多是独立的设计决策：

1.  测试表达式可以是什么样的值？在某些语言中，它们必须是布尔值（两个值，一个表示真，另一个表示假）。在其他语言中，此表达式可以评估为几乎任何值，其中一些集合——俗称为“真值”——表示为真（即，它们导致执行“然后部分”），而其余值为“假值”，意味着它们导致执行“否则部分”。

    起初，设计具有多个真值和假值的语言似乎很吸引人：毕竟，这似乎给了程序员更多的方便，允许在条件语句中使用非布尔值函数和表达式。然而，这可能会导致语言之间令人困惑的不一致性：

    | 值 |  | JS |  | Perl |  | PHP |  | Python |  | Ruby |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    | 0 |  | falsy |  | falsy |  | falsy |  | falsy |  | truthy |
    | "" |  | falsy |  | falsy |  | falsy |  | falsy |  | truthy |
    | NaN |  | falsy |  | truthy |  | truthy |  | truthy |  | truthy |
    | nil/null/None/undef |  | falsy |  | falsy |  | falsy |  | falsy |  | falsy |
    | "0" |  | truthy |  | falsy |  | falsy |  | truthy |  | truthy |
    | -1 |  | truthy |  | truthy |  | truthy |  | truthy |  | truthy |
    | [] |  | truthy |  | truthy |  | falsy |  | falsy |  | truthy |
    | empty map/object |  | truthy |  | falsy |  | falsy |  | falsy |  | truthy |

    当然，它不必如此复杂。例如，Scheme 只有一个虚假值：false 本身（写作 #f）。其他任何值都是真值。对于那些重视在条件语句中允许非布尔值的人来说，这代表了一个优雅的权衡：这意味着函数不必担心由计算产生的类型一致的值可能导致条件语句反转自身。（例如，如果一个函数返回字符串，它不必担心空字符串可能与每个其他字符串不同地对待。）在写这一章节时，我在 Pyret 中偶然发现了一个奇怪的错误：所有数值 s-表达式都解析为 s-num 值，除了 0，它解析为 s-sym。最终，Justin Pombrio 报告说：“这是一个愚蠢的错误，JavaScript 中的 if 得到 0 并认为它是 false。”注意，Ruby 和 Lua 的虚假值相对较少；它们的创造者受到了 Scheme 的深刻影响，可能这不是巧合。

1.  分支是什么类型的术语？某些语言区分语句和表达式；在这种语言中，设计者需要决定允许哪些。在某些语言中，甚至有两种条件语句的语法形式来反映这两种选择：例如，在 C 中，if 使用语句（并且不返回任何值），而“三元运算符”((...?...:...))允许表达式并返回一个值。

1.  如果分支是表达式，因此允许求值为值，那么这些值如何关联？许多（但不是所有）具有静态类型系统的语言期望两个分支具有相同的类型[REF]。没有静态类型系统的语言通常不会施加任何限制。

目前，我们假设条件表达式只能是布尔值；分支是表达式（因为这是我们语言中拥有的一切）；并且两个分支可以返回不同类型的值。

## 条件表达式的战略

要将条件添加到语言中，我们必须涵盖大量内容：

+   首先，我们需要定义语法。我们将使用

    | true |
    | --- |
    | false |
    | (if test-exp then-exp else-exp) |

    来表示两个布尔常量和条件表达式。

+   我们需要修改程序的表示方式以处理这些新构造。以下是我们的新表达语言（名称已调整以表示其超越纯算术的增长）：

    ```
    data ExprC:
      | trueC
      | falseC
      | numC(n :: Number)
      | plusC(l :: ExprC, r :: ExprC)
      | multC(l :: ExprC, r :: ExprC)
      | ifC(c :: ExprC, t :: ExprC, e :: ExprC)
    end
    ```

    我们还需要调整预解糖语言（ExprExt），以适应新的构造。

+   我们需要修改解析器和解糖器。

    > 练习
    > 
    > > 修改解析器和解糖器以处理扩展语言。根据需要调整数据类型。务必编写测试。
    > > 
> 现在做！
> 
> > 还有一个更大的改变是必要的。你看到是什么了吗？

### 解释器的类型

如果我们的术语不再纯粹是算术性质的，那么我们就不能再期望我们的解释器只产生数字答案！例如，评估以下程序的结果应该是什么：

```
trueC
```

（也就是，对应源文本 true 的程序）？注意：我给你呈现的实际上是对你品格的考验！“在医院走廊的那一天，一个不那么伟大的人可能会动摇，一个更弱的人可能会妥协，接受像 Drum Major、Minor Major、Sergeant Major 或 C. Sharp Major 这样出色的替代品，但 Major Major 的父亲等了十四年才等到这样的机会，他不是一个浪费机会的人。”—<wbr>约瑟夫·海勒 你可能会非常想要决定 true 应该评估为 1（并且，为了保险起见，false 应该评估为 0）。这样做会有什么后果？

+   这将使得无法拥有纯布尔值的语言成为可能。当我们涉及类型时，这将产生后果[REF]。

+   这意味着您可以对真值进行算术运算。这听起来可能并不那么令人惊讶：毕竟，合取（and）和析取（or）可以被视为算术。但是一旦您说真值是数字，您就无法再检测程序员意外从另一个真值中减去一个真值、除以它们等等。

+   甚至不清楚哪些数字应该代表哪些真值。从历史上看，一些语言使零代表真值；其他一些甚至选择使用非负数表示真值和负数表示虚假。这些选择中没有一个更明确“正确”于其他选择，这表明我们实际上只是在这里胡乱猜测。

+   最重要的是，我们不能继续通过黑客方式摆脱这种情况。我们将如何表示字符串或列表？使用[Gödel numbering](https://en.wikipedia.org/wiki/G%C3%B6del_numbering)吗？当我们涉及函数、协程、续延时会发生什么？

简而言之，避免编码！没有理由让数字承担双重任务：让布尔值成为它们自己的类型。在任何体面的实现中，这将几乎不会对程序执行造成额外成本，同时大大减少程序员的困惑。

这个决定的后果当然，您可以尝试不同的决定。编写小解释器的美妙之处在于您可以更改您想要的内容并探索这些更改的后果。是我们需要一种方法来表示解释器的所有可能结果。

> 现在就行动！
> 
> > 尝试为自己勾勒一个表示。

这是一个合理的表示：

```
data Value:
  | numV(n :: Number)
  | boolV(b :: Boolean)
end
```

目前，这自然是一个相当肤浅的表示：它只是帮助我们区分数字和布尔值。稍后，我们将添加具有更有趣结构的值。

### 25.2.2 更新算术

最后，我们准备增强我们的解释器。我们可以忽略算术行，这些行不应该改变（因为我们没有改变我们执行算术的方式），并关注语言的新部分。

> 现在就做！
> 
> > 对吗？

不对。因为我们已经改变了解释器产生的值的类型，所以我们必须更新算术规则，以反映这一点。我们可以很快地做到这一点，但我们会分几步来说明一个观点。

首先，我们来处理简单的情况：<ext-arith-cond-interp> ::=

|   fun interp(e :: ExprC) -> Value: |
| --- |
|     情况（ExprC）e： |
|       &#124; numC(n) => numV(n) |
|       <ext-arith-cond-arith-cases> |
|       <ext-arith-cond-bool-cases> |
|     end |
|   end |

现在让我们考虑加法和乘法。我们可以直接做：

```
| plusC(l, r) =>
  numV(interp(l).n + interp(r).n)
```

但这将会变得重复：对每个分支调用 interp，解引用数字字段，并将答案包装在 numV 中。最好将此抽象化，以便我们不必重复代码。

### 25.2.3 防御性编程

实际上，上述代码中隐藏着一个更严重的问题。在这个表达式中：

```
interp(l).n
```

（以及另一个类似的）。首先，它盲目地引用 n 字段，不管结果值是否真正表示一个数字；如果其他变体也有一个这个名称的字段，这将默默成功！（我们之前见过这个问题：（部分"危险字段访问"）。）因此，我们真的应该确保递归调用 interp 确实返回一个数字；现在逻辑显然比我们想要的要复杂得多，以致于我们不想在线上执行。相反，我们将定义一个帮助函数，它接受要执行的操作并执行其他所有操作：

```
fun arith-binop(op :: (Number, Number -> Number),
    l :: ExprC,
    r :: ExprC) -> Value:
  l-v = interp(l)
  r-v = interp(r)
  if is-numV(l-v) and is-numV(r-v):
    numV(op(l-v.n, r-v.n))
  else:
    raise('argument not a number')
  end
end
```

有了这个，我们现在可以展示算术操作的修订定义：<ext-arith-cond-arith-cases> ::=

|   &#124; plusC(l, r) => arith-binop(lam(x, y): x + y end, l, r) |
| --- |
|   &#124; multC(l, r) => arith-binop(lam(x, y): x * y end, l, r) |

> 现在就做！
> 
> > 在我们继续之前，让我们再考虑一个问题。假设我们可以确定没有其他变体会有一个名为 n 的字段。那么，检查每个值的 is-numV 和不检查的版本之间有什么区别吗？

表面上看，答案是否定的：如果没有 n 字段，访问 n 的版本将以 Pyret 发出的错误停止，就像 arith-binop 一样。然而，这两个版本之间存在重要的哲学差异：

+   在 arith-binop 中执行检查的版本提供了在实现的语言层面上的错误。它不依赖于 Pyret 执行任何检查；此外，它可以根据解释的语言给出一个错误，使用对该语言中的程序员有意义的术语。

+   相比之下，将检查委托给 Pyret 的版本允许元错误传播。这要求非常确定 Pyret 的工作方式，它是否会在正确的时间和地点执行检查，然后以适当的方式停止程序执行。此外，它产生的错误消息可能对程序员毫无意义：Pyret 可能会说“未找到字段 n”，但对于只有算术和条件语句的语言的使用者来说，“字段”这个术语可能毫无意义。

因此，在生产系统中，我们应该确保捕捉我们实现中的错误，而不是希望实现语言会做正确的事情。然而，在这项研究中，我们有时会对此放松，以使代码更简单、更易读。

### 25.2.4 解释条件

最后，我们准备处理这个练习的实际要点：条件。这两个常量很容易：<ext-arith-cond-bool-cases> ::=

|   &#124; trueC => boolV(true) |
| --- |
|   &#124; falseC => boolV(false) |
|   <ext-arith-cond-bool-if> |

条件表达式实际上并不难；它只是迫使我们思考。思考，毕竟，是整个研究的重点。这是我们编码真值/假值区别的地方；事实上，可以说有三种可能性：真值、假值和其他值！（在这里的第三种可能性等同于有一个返回除了真值和假值之外的任何东西的相等运算符。虽然非常不寻常，但既不是不可能也不是不存在：事实上，Pyret 就是这样做的[REF]！）然而，因为我们决定只处理布尔值，并且这些只有两种（至少因为我们选择用 Pyret 的布尔值来表示它们），这变得非常简单：<ext-arith-cond-bool-if> ::=

|   &#124; ifC(cnd, thn, els) => |
| --- |
|     ic = interp(cnd) |
|     if is-boolV(ic): |
|       if ic.b: |
|         interp(thn) |
|       else: |
|         interp(els) |
|       end |
|     else: |
|       raise('not a boolean') |
|     end |

就是这样。现在我们有了一个完整、可工作的条件解释器。

## 25.3 扩展条件语言

然而，要创建一个真正有用的条件语言，我们至少需要两样东西：

1.  一种计算布尔值的方法，而不仅仅是将它们写成常量。例如，我们应该对数字进行操作（如数值比较）。这相对容易，尤其是考虑到我们已经有了参数化执行操作并返回值（而不是数字）的 arith-binop。更大的麻烦是将其通过解析和去糖化。最好创建通用的一元和二元操作，并在表中查找。

1.  还有一种方法可以结合条件（否定、析取、合取）。

> 练习
> 
> > 将解析器和展开器泛化，以查找一张一元和二元运算的表，并统一地表示它们，而不是为每个运算创建不同的变种。

否定是直接的：它只是一个一元函数。然而，在编程语言中，析取（或）和合取（与）不应被视为函数。例如，在 Scheme 中，常见的写法是：

| (and (not (= x 0)) (/ 1 x)) |
| --- |

如果(not (= x 0))和(/ 1 x)都被视为参数并立即计算，那么我们试图防止的情况——<wbr>除以零——将立即发生。当然，在惰性语言中这不是问题[REF]。因此，最好将它们视为展开为级联条件：例如，上述表达式的一种可能的展开可能是

| (if (not (= x 0)) |
| --- |
|     false |
|     (/ 1 0)) |

> 练习
> 
> > 实现否定、合取和析取。
> > 
> 练习
> 
> > 定义一个多臂条件表达式，将其展开为嵌套的 if 语句。

# 12 示例、测试和程序检查

|     12.1 从示例到测试 |
| --- |
|     12.2 更精细的比较 |
|     12.3 当测试失败时 |
|     12.4 用于测试的神谕 |
|     12.5 测试错误的程序 |

当我们思考一个问题时，写下我们试图做的事情的示例通常是有用的。例如（看我做了什么？），如果我们被要求计算[FILL]

当然，有很多种方法可以写下示例。我们可以在板上写，纸上写，甚至可以作为计算机文档中的注释。这些都是合理的，而且通常是解决问题的最佳方法。然而，如果我们能够以计算机能理解的精确形式编写我们的示例，我们就可以实现两个目标：

+   当我们完成写我们假定的解决方案时，我们可以让计算机检查我们是否做对了。

+   在写下我们的期望的过程中，我们经常发现很难以计算机期望的精度来表达。有时这是因为我们还在形成细节，还没有把它们确定下来，但在其他时候，这是因为我们还没有理解这个问题。在这种情况下，精确度的力量实际上对我们有好处，因为它帮助我们理解我们理解的弱点。

## 12.1 从示例到测试

测试失败可能是由于

- 程序错误 - 示例本身错误

当我们发现一个错误时，我们

- 找到一个捕捉到错误的例子 - 将其添加到程序的测试套件中

如果我们再犯同样的错误[REF：我们会]，我们将立即发现它

## 12.2 更精细的比较

有时，通过 `is` 进行直接比较并不足以进行测试。在上一节中，我们看到了测试错误的 raises。然而，在做一些计算时，特别是涉及到近似数学的计算时，我们想问一个不同的问题。例如，考虑这些距离原点的测试：

```
check:
  distance-to-origin(point(1, 1)) is ???
end
```

在这里我们可以检查什么？在 REPL 中输入这个，我们可以发现答案打印为 1.4142135623730951。这是对真实答案的近似，Pyret 无法完全表示。但很难知道这个精确的答案，到这个小数位数，没有更多，是我们应该预期的，思考答案应该是我们做的第一件事！

由于我们知道我们得到的是一个近似值，我们实际上只能检查答案是否大致正确，而不是完全正确。如果我们可以检查到到达原点（point(1, 1)）的距离的答案大约是，比如说，1.41，并且可以对一些类似情况做同样的事情，那对于许多应用程序来说，这可能已经足够了，对于我们这里的目的也是如此。如果我们正在计算轨道动力学，我们可能会要求更高的精度，但请注意，我们仍然需要选择一个截止值！测试不精确结果是一项必要的任务。

让我们首先用一种最精确的方式来定义“around”，即一个函数：

```
fun around(actual :: Number, expected :: Number) -> Boolean:
  doc: "Return whether actual is within 0.01 of expected"
  num-abs(actual - expected) < 0.01
where:
  around(5, 5.01) is true
  around(5.01, 5) is true
  around(5.02, 5) is false
  around(num-sqrt(2), 1.41) is true
end
```

现在 is 形式帮了我们一个忙。有一种特殊的语法可以提供一个用户定义的函数来比较这两个值，而不仅仅是检查它们是否相等：

```
check:
  5 is%(around) 5.01
  num-sqrt(2) is%(around) 1.41
  distance-to-origin(point(1, 1)) is%(around) 1.41
end
```

在 is 后面添加 %(something) 会改变 is 的行为。通常，它会比较左右值是否相等。但是如果提供了 something，它会将左右值传递给提供的函数（在这个示例中是 around）。如果提供的函数返回 true，则测试通过，如果返回 false，则测试失败。这给了我们测试具有可预测近似结果的函数所需的控制权。

> 练习
> 
> > 扩展 distance-to-origin 的定义以包括极坐标点。
> > 
> 练习
> 
> > 这可能会省去你一次谷歌搜索的时间：[极坐标转换](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates)。使用设计配方编写 x-分量和 y-分量，它们返回点的 x 和 y 笛卡尔部分（例如，如果你要在图表上绘制它们）。阅读关于 num-sin 和其他你需要的函数在[Pyret 数字文档](http://www.pyret.org/docs/latest/numbers.html)。
> > 
> 练习
> 
> > 写一个名为 Pay 的支付类型的数据定义，其中包括按小时计算工资的员工，其支付类型包括每小时的工资率，以及按年计算工资的员工，其支付类型包括一年的总工资。使用设计配方编写一个名为 expected-weekly-wages 的函数，它接受一个 Pay，并返回预期的周工资：按小时计算员工的预期周工资假设他们工作 40 小时，按年计算员工的预期周工资是他们年薪的 1/52。

## 12.3 当测试失败时

假设我们写了一个函数 sqrt，用于计算给定数字的平方根。我们为这个函数写了一些测试。我们运行程序，发现一个测试失败了。这可能有两个明显的原因。

> 立刻做！
> 
> > 两个明显的原因是什么？

显然，这两个原因就是测试的“两面”：问题可能出在我们写的值上，也可能出在我们写的函数上。例如，如果我们写的是

```
sqrt(4) is 1.75
```

那么显然问题出在值上（因为 \(1.75²\) 显然不是 \(4\)）。另一方面，如果测试失败

```
sqrt(4) is 2
```

那么很可能是我们在 sqrt 的定义上出了错，这就是我们需要修正的地方。

请注意，计算机无法知道出了什么问题。当它报告测试失败时，它所说的只是程序和测试之间存在不一致。计算机不会对哪一个是“正确”的进行判断，因为它无法做到这一点。这是人类判断的事情。因此，我们一直在研究 [测试的同行评审](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/)，这样学生可以在开始编写程序之前相互帮助审查他们的测试。

其实...不要这么快下结论。我们没有考虑的还有一个可能性：测试失败的第三个，不那么明显的原因。回到这个测试：

```
sqrt(4) is 2
```

显然，输入和输出是正确的，但可能定义的 sqrt 也是正确的，但测试失败了。

> 现在就做！
> 
> > 你明白原因了吗？

根据我们编写 sqrt 的方式不同，它可能返回 -2 这个根，而不是 2。现在 -2 也是一个完全正确的答案。也就是说，函数和我们指定的特定测试值集都不是固有错误；只是函数恰好是一个关系，即它将一个输入映射到多个输出（也就是说，\(\sqrt{4} = \pm 2\））。现在的问题是如何正确编写测试。

## 12.4 用于测试的预言

换句话说，有时我们想要表达的不是具体的输入输出对，而是检查输出与输入之间的正确关系。具体来说，在 sqrt 的情况下可能是什么呢？我们之前曾暗示过，当我们说 1.75 明显不对时，因为它的平方不等于 4 时，这给了我们一个一般性的见解：如果平方后的数与原始数相等，则该数字是有效的根（请注意使用“a”而不是“the”）。也就是说，我们可能写出这样的一个函数：

```
fun is-sqrt(n):
  n-root = sqrt(n)
  n == (n-root * n-root)
end
```

然后我们的测试看起来像

```
check:
  is-sqrt(4) is true
end
```

不幸的是，这有一个尴尬的失败案例。如果 sqrt 未产生实际上是根的数字，我们将不会被告知实际值是多少；相反，is-sqrt 返回 false，测试失败只是说 false（is-sqrt 返回的值）不是 true（测试期望的值）—这既绝对正确又毫无用处。幸运的是，Pyret 有一种更好的方法来表达相同的检查。我们可以使用 satisfies 替代 is，然后左侧的值必须满足右侧的谓词。具体来说，看起来像这样：

```
fun check-sqrt(n):
  lam(n-root):
    n == (n-root * n-root)
  end
end
```

这让我们可以写成：

```
check:
  sqrt(4) satisfies check-sqrt(4)
end
```

现在，如果有失败，我们将得知 sqrt(4) 产生的实际值未能满足谓词。考虑以下问题：给定一个单词（例如一个名称），我们希望使用原子的符号来拼写它（忽略大小写）。这个函数，称之为 elemental，消耗一个字符串并产生一个字符串列表，使得

+   输出中的每个字符串都是一个原子符号，并且

+   输出中字符串的连接产生了输入。

例如，考虑我的名字；它可以拼写为 [list: "S", "H", "Ri", "Ra", "M"]（分别对应 [FILL]）。因此我们会写：

```
check:
  elemental("Shriram") is [list: "S", "H", "Ri", "Ra", "M"]
end
```

现在考虑另一个例子：[FILL]。我们可以清楚地看到，这个例子会分解为

```
check:
  elemental("...") is [list: ...]
end
```

## 12.5 测试错误程序

- 使用 RAISES 来检查错误代码

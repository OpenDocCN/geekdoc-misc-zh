# 35 术语表

☞ 带宽

> 两个网络节点之间的带宽是在单位时间内可以在节点之间传输的数据量。

☞ 缓存

> 缓存是☛ 空间-时间折衷的一个实例：它通过使用空间来避免重新计算答案，从而以时间换取空间。使用缓存的行为称为缓存。“缓存”这个词经常被泛泛地使用；我只用它来指代即使丢失了也可以完全重建的信息：这使得一个需要反向进行折衷的程序——即，以更少的空间换取更多时间的程序——可以安全地这样做，因为它不会丢失任何信息，因此不会损害正确性。

☞ 共同归纳

> 共同归纳是一种数学结构的证明原理，这些结构配备有观察方法而不是构造方法。相反，对归纳数据的函数会将其拆分；对共同归纳数据的函数会构造它们。关于这个主题的[经典教程](http://www.cs.ru.nl/~bart/PAPERS/JR.pdf)对数学上精通的读者很有用。

☞ 幂等性

> 幂等运算符是一种反复应用于其定义域中的任何值都会产生与单个应用相同结果的运算符（请注意，这意味着范围是定义域的子集）。因此，函数 \(f\) 如果对其定义域中的所有 \(x\) 都成立 \(f(f(x)) = f(x)\) （通过归纳法，这也适用于 \(f\) 的额外应用）。

☞ 不变量

> 不变量是关于程序的断言，旨在始终为真（“不变的”—<wbr>从不变化）。例如，排序例程可能具有的不变量是返回的列表已排序。

☞ 延迟

> 两个网络节点之间的延迟是数据包在节点之间传输所需的时间。

☞ 元句法变量

> 元句法变量是存在于语言之外的变量，并且范围限定在语法片段之内。例如，如果我写道“对于表达式 e1 和 e2，求和 e1 + e2”，我并不是指程序员在程序中真正写了“e1”；而是我使用 e1 来引用程序员可能在加法符号左边写的任何内容。因此，e1 是元语法。

☞ 紧凑表示

> 在机器级别，紧凑表示是指忽略传统的对齐边界（在旧的或较小的机器上为字节；在大多数现代机器上为字）以便让多个值适应或甚至溢出边界。
> 
> 例如，假设我们希望存储一个包含四个值的向量，每个值代表四个选项中的一个。传统表示法会在每个对齐边界存储一个值，因此会消耗四个内存单元。紧凑表示法会意识到每个值需要两位，四个值可以放入八位中，因此一个字节可以容纳所有四个值。假设我们希望存储四个值，每个值代表五个选项，因此每个值需要三位。字节或字对齐的表示方式不会发生根本性变化，但紧凑表示法会使用两个字节来存储十二位，甚至允许第三个值的三个字节跨越字节边界。
> 
> 当然，紧凑表示法也有成本。提取值需要更加谨慎和复杂的操作。因此，它们代表了经典的☛ 空间-时间权衡：使用更多时间来缩小空间消耗。更微妙的是，紧凑表示法可能会使某些运行时系统困惑，因为它们可能期望数据被对齐。

☞ 解析

> 解析广义上讲是将一种结构化输入内容转换为另一种内容的行为。这些结构可能非常相似，但通常它们是完全不同的。通常，输入格式很简单，而输出格式则预计捕捉输入内容的丰富信息。例如，输入可能是输入流上的字符线性序列，而输出可能预计是根据某种数据类型的丰富、树形结构：大多数程序和自然语言解析器都面临这个任务。

☞ 简化

> 简化是一对情况（问题、函数、数据结构等）之间的关系，其中一个是根据另一个定义的。简化 R 是一个从形式为 P 的情况到形式为 Q 的情况的函数，如果对于 P 的每个实例，R 都可以构造一个保留 P 意义的 Q 实例。请注意，反之不一定成立。

☞ 空间-时间权衡

> 假设你有一个昂贵的计算，对于给定的一组输入总是产生相同的答案。一旦你计算出答案，你现在有一个选择：存储答案，这样当你再次需要时可以简单地查找它，或者丢弃它，下次重新计算。前者使用更多空间，但节省时间；后者使用更少空间，但消耗更多时间。这就是空间-时间权衡的核心。记忆化[REF]，使用☛ 缓存，环境（从替换到环境），等等都是其实例。

☞ 类型变量

> 类型变量是类型语言中的标识符，通常涵盖实际类型。

☞ 传输格式

> 用于跨越而不是在封闭平台（如虚拟机）内部传输数据的一种表示法。这些表示法通常被期望相对简单，因为它们必须在许多语言和弱进程上实现。它们还应该是明确的，以帮助简单、快速和正确的解析。流行的例子包括 XML [REF]、JSON [REF] 和 s-表达式 [REF]。

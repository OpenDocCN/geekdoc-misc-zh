# 29 参数化多态性

|     29.1 Parameterized Types |
| --- |
|     29.2 Making Parameters Explicit |
|     29.3 Rank-1 Polymorphism |
|     29.4 Interpreting Rank-1 Polymorphism as Desugaring |
|     29.5 Alternate Implementations |
|     29.6 Relational Parametricity |

这些中哪个是相同的？

> +   List<String>
> +   
> +   List<String>
> +   
> +   List<String>

实际上，这些都不太一样。但是第一个和第三个非常相似，因为第一个是在 Java 中，第三个是在 ML 中，而第二个，在 C++ 中，是不同的。清楚了吗？没有？好的，继续读下去！

## 29.1 参数化类型

考虑在 Pyret 中 map 的预期类型是什么：

```
((A -> B), List<A> -> List<B>)
```

这说明对于所有类型 A 和 B，map 函数消耗一个从 A 值生成 B 值的函数，以及一个 A 值列表，并生成相应的 B 值列表。这里，A 和 B 不是具体的类型；相反，每个都是一个☛ 类型变量（在我们的术语中，这些应该适当地称为“类型标识符”，因为它们在实例化过程中不会改变；然而，我们将坚持传统的术语）。理解这一点的另一种方法是，实际上存在无限多个 map 函数。例如，有一个具有此类型的 map：

```
((Number -> String), List<Number> -> List<String>)
```

另一个具有此类型的 map（没有规定类型必须是基本类型）：

```
((Number -> (Number -> Number)),
 List<Number> -> List<(Number -> Number)>)
```

还有另一个具有此类型的 map（没有规定 A 和 B 不能是相同的）：

```
((String -> String), List<String> -> List<String>)
```

以此类推。因为它们有不同的类型，所以它们需要不同的名称：map-num-str，map-num-num-to-num，map-str-str 等等。但这将使它们成为不同的函数，所以我们必须始终引用特定的 map 而不是每个通用 map。

显然，不可能将所有这些函数加载到我们的标准库中：这些函数的数量是无限的！我们宁愿有一种方式按需获取每个这些函数。我们的命名约定提供了一个提示：就好像 map 除了它的两个常规值之外还需要两个类型参数。给定类型对作为参数，然后我们可以获得一个针对特定类型定制的 map。这种对类型的参数化称为参数多态性。不要与我们将单独讨论的对象“多态性”混淆[REF]。

## 29.2 使参数明确

换句话说，我们实际上是在说 map 实际上是一个函数，可能有四个参数，其中两个是类型，另外两个是实际值（函数和列表）。在具有显式类型的语言中，我们可能会尝试编写

```
fun map(A :: ???, B :: ???, f :: (A -> B), l :: List<A>)
    -> List<B>:
  ...;
```

但这带来了许多问题：

+   ???? 的位置应该填什么？这些是将在实际使用中取代 A 和 B 的类型。但如果 A 和 B 绑定到类型，那么它们的类型是什么？

+   我们真的想要每次调用 map 都带着四个参数吗？

+   我们想要在传递静态的类型的同时传递动态值吗？

+   如果这些是类型，但它们只在运行时调用时提供，那么我们如何为需要知道他们获得什么样的列表的客户端进行类型检查？

实际上，这些问题的答案导致了一个非常丰富的多态类型系统空间，其中大多数我们在这里不会探索。

请注意，一旦我们开始参数化，就会有比我们期望的更多的代码被参数化。例如，考虑普通链表的类型。它的类型实际上是关于列表中值类型的参数化（即使它实际上并不依赖于这些值！——稍后再说（关于关系参数化, List<A> -> List<B>)
```

由于“∀”是“对于所有”的逻辑符号，你可以将其读作：“对于所有类型 A 和 B，map 的类型是...”。

在一阶多态性中，类型变量只能被单态替换。（此外，这些只能是具体类型，因为没有剩余的类型变量可以替换。）因此，我们得到了类型变量参数和常规参数之间的明确分离。我们不需要为类型变量提供“类型注释”，因为我们确切地知道它们可以是什么样的东西。这产生了一种相对清洁的语言，仍然提供了相当大的表现力。非预测性语言消除了单态和多态之间的区别，因此类型变量可以用另一个多态类型来实例化。

请注意，因为类型变量只能被单态替换，它们彼此之间都是独立的。因此，所有类型参数都可以移到参数列表的前面。例如，在 Pyret 中，以下定义了一个多态的 identity 函数：<pyret-poly-id> :::

|   fun<T> id(x :: T) -> T: x; |
| --- |

在每次使用时，我们通过使用 <...> 表示类型参数，使用 (...) 表示值参数来区分提供类型参数和值参数。一般来说，我们可以将类型写成 ∀ tv, ... : t 的形式，其中 tv 是类型变量，t 是单态（可能引用这些变量）。这不仅证明了语法，还证明了“前束”的名称是合理的。在实现中，这也会被证明是有用的。

## 29.4 将 Rank-1 多态解释为展开

这个功能的最简单的实现方法是将其视为一种展开形式：这基本上是 C++ 所采用的解释。（换句话说，因为 C++ 有一个模板形式的宏系统，由于一种幸运的偶然，它通过使用模板获得了一种 rank-1 多态的形式。）考虑上面的多态 identity 函数。假设实现是，在每次对名称提供类型时，它都在主体中用给定类型替换类型变量：给定 T 的具体类型，它产生一个类型为 (T -> T) 的一个参数的过程（其中 T 被适当替换）。因此，我们可以在许多不同的类型上实例化 id—

```
id-num = id<Number>
id-str = id<String>
```

—因此我们可以获得每个类型的 identity 函数：

```
check:
  id-num(5) is 5
  id-str("x") is "x"
end
```

相反，像

```
id-num("x")
id-str(5)
```

正如我们所期望的那样，将无法通过类型检查（而不是在运行时失败）。

然而，这种方法有两个重要的局限性。

1.  让我们尝试定义一个递归的多态函数，比如 filter。早先我们已经说过，我们应该为每个多态值（比如 even cons 和 empty）实例化类型，但为了保持我们的代码简洁，我们将只关注 filter 的类型参数。以下是代码：

    ```
    fun<T> filter(pred :: (T -> Bool), l :: List<T>) -> List<T>:
      cases (List) l:
        | empty => empty
        | link(f, r) =>
          if pred(f):
            link(f, filter<T>(pred, r))
          else:
            filter<T>(pred, r);
      end
    end
    ```

    注意在 filter 的递归使用中，我们必须用适当的类型对其进行实例化。这是一个完全良好的定义。只有一个问题。如果我们试图使用它—比如，

    ```
    filter-num = filter<Number>
    ```

    实现将无法终止。这是因为 desugarer 在每次递归调用时都在重复尝试制作 filter 代码的新副本。

    > 练习
    > 
    > > 相反，如果我们定义一个执行递归的本地辅助函数，这个问题就可以消失了。你能想出那个版本吗？

1.  考虑两个 identity 函数的实例化。它们必然是不同的，因为它们是位于内存中不同位置的两段不同的代码。事实上，在 C++ 中使用参数多态性是以创建代码膨胀而著称的。然而，所有这些复制都是不必要的！事实上，id 的整个无限族函数可以共享同一个实现。简单的展开策略无法实现这一点。

换句话说，基于去糖化的策略，本质上是一种替换实现，与我们之前在参数实例化作为实现的替换方面看到的问题基本相同（从替换到环境）。然而，在其他情况下，替换也为我们提供了程序行为的基准真值。同样适用于多态性，我们很快就会看到。

请注意，去糖化策略的一个优点是它不需要我们的类型检查器“了解”多态性。相反，核心类型语言可以继续保持单态化，并且所有（秩-1）多态性完全通过扩展处理。这提供了一种廉价的策略，用于将多态性添加到语言中，尽管——<wbr>正如 C++所示——<wbr>它也引入了重大的开销。

最后，虽然我们只关注了函数，但前面的讨论同样适用于数据结构。

## 29.5 备用实现

还有其他不会遭受这些问题的实现策略。我们在这里不会详细介绍，但其核心是对扩展进行备忘录化（[REF]）。因为我们可以确定，对于给定的一组类型参数，我们总是会得到相同类型的体，所以我们永远不需要在相同类型的多态函数上进行实例化两次。这避免了无限循环。如果我们对实例化的体进行了类型检查一次，我们就可以避免在相同类型的其他实例化上进行检查（因为体不会发生变化）。此外，我们不需要保留实例化的源代码：一旦我们检查了扩展程序，我们就可以丢弃扩展术语并仅在运行时保留一个副本。这避免了上面展示的纯去糖化策略中讨论的所有问题，同时保留了优点。

实际上，我们有点太过轻率了。静态类型的一个好处是它们使我们能够选择更精确的运行时表示。例如，在大多数语言中，静态类型可以告诉我们是 32 位还是 64 位数字，或者是 32 位值还是 1 位值（实际上，布尔值）。然后，编译器可以为每个表示生成专门的代码，利用位的布局（例如，32 个布尔值可以使用紧凑的表示法来放入一个单独的 32 位字中）。因此，在每个使用的类型的类型检查之后，多态实例化器可以跟踪函数或数据结构使用的所有特殊类型，并将此信息提供给编译器用于代码生成。然后，这将导致函数的多个副本，但只有编译器可以生成不同、高效表示的那些副本，通常是固定的，并且远远少于程序可以使用的类型总数。此外，制作这些副本的决定反映了一种时空权衡。

## 关系参数化

关于多态性，我们必须解决的最后一个细节。

我们之前说过，像 cons 这样的函数并不依赖于其参数的具体值。map、filter 等函数也是如此。当 map 和 filter 想要操作单个元素时，它们将另一个函数作为参数，而这个函数又负责决定如何处理这些元素；map 和 filter 本身只是遵循其参数函数。

一个“测试”这是否正确的方法是在参数列表中替换一些不同的值，并相应地替换不同的参数函数。也就是说，想象我们有两组值之间的关系；我们根据关系转换列表元素和参数函数。问题是，map 和 filter 的输出是否也可以通过关系来预测？如果对于某些输入，map 的输出不是由关系确定的，那么必须是 map 在某种程度上影响了值本身，而不仅仅是让函数来做。但事实上，这对于 map，或者标准多态函数中的大多数来说都不会发生。

遵守这种关系规则的函数被称为关系参数化函数。这是类型赋予我们的另一个非常强大的属性，因为它告诉我们，这些多态函数能执行的操作种类受到了很强的限制：基本上，它们可以删除、复制和重新排列元素，但不能直接检查并对其进行决策。

起初，这听起来非常令人印象深刻（而且确实如此！），但仔细检查后，您可能会意识到这与您的经验不符。例如，在 Java 中，多态方法仍然可以使用 instanceof 来检查在运行时获取的特定类型的值，并相应地更改其行为。这样的方法就不是关系参数化的！在 Web 上，您经常会发现这个属性被描述为函数无法检查参数——这并不完全正确。事实上，关系参数化也可以被看作是语言弱点的陈述：它只允许一组非常有限的操作。（您仍然可以检查类型——但不能根据所学内容采取行动，这使得检查无意义。因此，想要模拟关系参数化的运行时系统必须删除像 instanceof 这样的操作，以及各种代理：例如，对值添加 1 并捕获异常将会显示出值是否为数字。）尽管如此，这是一个非常优雅和令人惊讶的结果，并展示了丰富类型系统可能实现的程序推理的力量。

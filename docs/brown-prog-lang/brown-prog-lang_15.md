# 15 集合的吸引力

|     15.1 用列表表示集合 |
| --- |
|       15.1.1 表示选择 |
|       15.1.2 时间复杂度 |
|       15.1.3 在表示之间进行选择 |
|       15.1.4 其他操作 |
|     15.2 使集合在树上生长 |
|       15.2.1 将值转换为有序值 |
|       15.2.2 使用二叉树 |
|       15.2.3 微妙的平衡：树手术 |
|         15.2.3.1 左-左情况 |
|         15.2.3.2 左-右情况 |
|         15.2.3.3 还有其他情况吗？ |

之前[集合作为集体数据]我们介绍了集合。回想一下，集合的元素没有特定的顺序，并且忽略重复。如果这些概念对你不熟悉，请阅读集合作为集体数据，因为在讨论集合的表示时它们将是重要的。那时我们依赖于 Pyret 内置的集合表示。现在我们将讨论如何自己构建集合。在接下来的内容中，我们将只关注数字集合。

我们将首先讨论如何使用列表表示集合。直观地，使用列表来表示数据集似乎有问题，因为列表尊重顺序和重复。例如，

```
check:
  [list: 1, 2, 3] is [list: 3, 2, 1, 1]
end
```

失败。原则上，我们希望集合遵循以下接口：<set-operations> ::=

|   mt-set :: 集合 |
| --- |
|   is-in :: (T, Set<T> -> 布尔) |
|   insert :: (T, Set<T> -> Set<T>) |
|   union :: (Set<T>, Set<T> -> Set<T>) |
|   size :: (Set<T> -> 数字) |
|   to-list :: (Set<T> -> 列表<T>) |

我们还可能发现有些函数也很有用，比如

```
insert-many :: (List<T>, Set<T> -> Set<T>)
```

结合 mt-set，我们很容易得到一个 to-set 函数。

集合可以包含多种类型的值，但不一定是任何一种类型：我们需要能够检查两个值是否相等（这是集合的要求，但不是列表的要求！），这不能用所有值来做到[REF]；有时我们甚至可能希望元素服从一种排序[将值转换为有序值]。数字满足这两个特点。

## 15.1 用列表表示集合

在接下来的内容中，我们将看到多种不同的集合表示，因此我们需要名称来区分它们。我们将使用 LSet 来代表“以列表形式表示的集合”。

作为起点，让我们考虑使用列表作为基础表示的集合的实现。毕竟，集合似乎只是一个我们忽略元素顺序的列表。

### 15.1.1 表示选择

空列表可以代表空集—<wbr>

```
type LSet = List
mt-set = empty
```

—<wbr>我们可以假定将大小定义为

```
fun<T> size(s :: LSet<T>) -> Number:
  s.length()
end
```

但是，这种☛减少（将集合减少为列表）可能是危险的：

1.  列表和集合之间存在微妙的差异。列表

    ```
    [list: 1, 1]
    ```

    不同于

    ```
    [list: 1]
    ```

    因为第一个列表的长度为二，而第二个列表的长度为一。然而，将它们视为集合时，两者是相同的：它们都有大小为一。因此，如果我们不考虑重复项（在插入期间或计算大小时），我们上面的大小实现是不正确的。

1.  由于底层列表表示提供的顺序保证，我们可能会错误地假设从集合中检索元素的顺序。这可能会隐藏我们直到更改表示形式才发现的错误。

1.  我们可能选择了集合表示，因为我们不需要关心顺序，并且预期会有大量重复项。列表表示可能会存储所有重复项，导致内存使用量（和程序速度）比我们预期的要多得多。

为了避免这些危险，我们必须准确地说明我们将如何使用列表来表示集合。一个关键问题（但不是唯一的问题，正如我们很快将看到的[REF]）是如何处理重复项。一种可能性是插入检查元素是否已经在集合中，如果是，则保持表示形式不变；这在插入期间会产生成本，但避免了不必要的重复，并使我们可以使用长度来实现大小。另一种选择是将插入定义为链接—<wbr>字面上，

```
insert = link
```

—<wbr>并让其他过程执行重复项的过滤。

### 15.1.2 时间复杂度

这种集合表示的复杂度是多少？让我们只考虑插入、检查和大小。假设集合的大小是 \(k\)（为了避免歧义，我们让 \(k\) 表示不同元素的数量）。这些操作的复杂性取决于我们是否存储重复项：

+   如果我们不存储重复项，则大小只是长度，它的时间复杂度是 \(k\) 的线性时间。同样，检查只需要遍历列表一次来确定元素是否存在，这也需要 \(k\) 的线性时间。但是插入需要检查元素是否已经存在，这需要 \(k\) 的线性时间，然后是最多的常数时间操作（链接）。

+   如果我们存储重复项，那么插入是常数时间：它只是链接到新元素而不考虑它是否已经在集合表示中。检查遍历列表一次，但是它需要访问的元素数量可能明显大于 \(k\)，这取决于已添加多少个重复项。最后，在计算大小之前，大小需要检查每个元素是否重复。

> 现在动手！
> 
> > 如果列表中有重复项，大小的时间复杂度是多少？

大小的一个实现是

```
fun<T> size(s :: LSet<T>) -> Number:
  cases (List) s:
    | empty => 0
    | link(f, r) =>
      if r.member(f):
        size(r)
      else:
        1 + size(r)
      end
  end
end
```

现在让我们计算函数体的复杂度，假设集合 s 中不同元素的数量为 \(k\)，但实际元素数量为 \(d\)，其中 \(d \geq k\)。要计算在 \(d\) 个元素上运行 size 的时间 \(T(d)\)，我们应该确定每个问题和答案中的操作数量。第一个问题有恒定数量的操作，第一个答案也是常数。第二个问题也有恒定数量的操作。它的答案是一个条件，其第一个问题 \(r.member(f)\) 需要遍历整个列表，因此具有 \(O([k \rightarrow d])\) 操作。如果成功，则我们递归处理大小为 \(T(d-1)\) 的东西；否则，我们执行相同的操作，但操作数量增加了一个常数。因此 \(T(0)\) 是一个常数，而递归（用大 O 表示）为

\begin{equation*}T(d) = d + T(d-1)\end{equation*}

因此 \(T \in O([d \rightarrow d²])\)。注意，这在列表中的元素数量上是二次的，这可能比集合的大小要大得多。

### 15.1.3 选择表示方式

现在我们有了两种不同复杂度的表示方式，值得考虑如何在它们之间进行选择。为此，让我们建立以下表格。表格区分接口（集合）和实现（列表），因为——<wbr>由于表示中的重复——<wbr>这两者可能不相同。在表格中，我们将考虑两种最常见的操作之一，插入和成员检查：

|  |  | 有重复 |  | 无重复 |
| --- | --- | --- | --- | --- |
|  |  | 插入 |  | 是否存在 |  | 插入 |  | 是否存在 |
| 集合大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |
| 列表大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |

一个朴素的理解会认为带有重复的表示方式更好，因为它有时是常数有时是线性，而没有重复的版本始终是线性的。然而，这掩盖了一个非常重要的区别：线性代表什么。当没有重复时，列表的大小与集合的大小相同。然而，有重复时，列表的大小可以比集合的大小任意大！基于此，我们可以得出几个结论：

1.  我们选择哪种表示方式取决于我们期望有多少重复。如果不会有太多重复，那么存储重复的版本将付出一小额外代价，以换取一些更快的操作。

1.  我们选择哪种表示形式也取决于我们预计每个操作将被执行的频率。没有重复的表示形式处于“中间”：每件事在最坏情况下都大致相同昂贵。有重复的是“极端”：非常便宜的插入，可能非常昂贵的成员资格。但如果我们大多数时候只插入而不检查成员资格，特别是如果我们知道成员资格检查只会在我们愿意等待的情况下发生，那么允许重复项实际上可能是明智的选择。（我们何时可能会处于这种情况？假设您的集合表示备份数据结构；然后我们添加大量数据，但很少——<wbr>实际上，只有在发生一些灾难的情况下——<wbr>需要在其中查找东西。）

1.  另一种表达这些见解的方式是我们的分析形式过于弱。在复杂性严重依赖于特定操作序列的情况下，大 O 是太宽松了，我们应该代替研究特定操作序列的复杂性。我们将稍后精确地解决这个问题（万圣节分析）。

此外，程序不应该只使用一种表示。它可能以一种表示开始，然后随着更好地理解其工作量而切换到另一种表示。要切换的唯一需要做的事情就是在表示之间转换所有现有数据。

这可能在上面如何发挥作用？注意，数据转换在一个方向上非常便宜：因为每个没有重复的列表自动也是一个（潜在的）重复列表，所以在那个方向上进行转换是微不足道的（表示保持不变，只是其解释发生变化）。另一个方向则更难：我们必须过滤重复项（这需要与列表中元素数量的平方成正比的时间）。因此，程序可以对其工作量进行初步猜测并选择相应的表示，但在运行过程中维护统计信息，并且当发现其假设错误时，切换表示——<wbr>并且可以根据需要多次切换。

### 15.1.4 其他操作

> 练习
> 
> > 在每个列表表示下，实现上面分类的剩余操作（<set-operations>）。
> > 
> 练习
> 
> > 实现操作
> > 
> > ```
> > remove :: (Set<T>, T -> Set<T>)
> > ```
> > 
> > 在每个列表表示下。你看到了什么不同吗？
> > 
> 现在就做！
> 
> > 假设要扩展集合以使用这些操作，作为“first”和“rest”的集合类比：
> > 
> > ```
> > one :: (Set<T> -> T)
> > others :: (Set<T> -> T)
> > ```
> > 
> > 你应该拒绝这样做！你明白为什么吗？

对于列表， “第一个” 元素是明确定义的，而集合被定义为没有顺序。事实上，为了确保您的集合的用户不会意外地假设您的实现有关的任何内容（例如，如果您使用“第一个”实现了一个，他们可能会注意到一个总是返回最近添加到列表中的元素），您确实应该在每次调用时返回集合的随机元素。

不幸的是，返回一个随机元素意味着上述接口无法使用。假设 s 绑定到一个包含 1、2 和 3 的集合。假设第一次调用 one(s) 时返回 2，第二次返回 1。（这已经意味着 one 不是一个函数——<wbr>这是我们在其他地方会解决的问题 [REF]。）第三次它可能再次返回 2。因此，others 必须记住上次调用 one 时返回的元素，并返回不包含该元素的集合。假设我们现在在调用 others 的结果上调用 one。这意味着我们可能会出现一种情况，其中 one(s) 产生与 one(others(s)) 相同的结果。

> 练习
> 
> > 为什么认为一个元素产生与一个元素的其他元素相同的结果是不合理的？
> > 
> 练习
> 
> > 假设你想要使用一个根据某个条件对集合进行分区的子集操作来扩展集合。它的类型会是什么？请参阅[REF join lists]以查看类似的操作。
> > 
> 练习
> 
> > 我们上面写的类型并不够清晰。定义一个无重复项的谓词，用它来细化相关的类型，并检查这些函数是否真正满足这个条件。

## 15.2 **使集合在树上增长**

让我们首先注意到，如果可能的话，最好避免存储重复项。重复项只在插入时会有问题，因为需要进行成员测试。但是如果我们可以使成员测试变得廉价，那么最好使用它来检查重复项，并且仅存储每个值的一个实例（这也节省了空间）。因此，让我们尝试改进成员测试的时间复杂度（并且，希望也能改进其他操作的时间复杂度）。

显然，用（无重复项的）列表表示集合，我们无法真正击败线性时间进行成员检查。这是因为在每一步中，我们只能排除一个元素，而在最坏的情况下，需要线性数量的工作来检查整个集合。相反，我们需要在每次比较中消除更多的元素——<wbr>不仅仅是一个常数。

在我们方便使用的递归集合中（解决递归），有一个是突出的：\(T(k) = T(k/2) + c\)。它表明，如果我们可以用恒定的工作量消除一半的输入，我们可以在对数时间内执行成员检查。这将是我们的目标。

在我们继续之前，值得将对数增长放在透视中。从渐近的角度来看，对数显然不如常数好。然而，对数增长非常愉快，因为它增长得如此缓慢。例如，如果一个输入从大小 \(k\) 增加到 \(2k\)，其对数—<wbr>因此资源使用—<wbr>仅增加了 \(\log 2k - \log k = \log 2\)，这是一个常数。实际上，对于几乎所有问题，从实际角度来看，输入大小的对数都受到一个常数的限制（甚至不是很大的常数）。因此，在实践中，对于许多程序来说，如果我们可以将资源消耗缩小到对数增长，那么现在可能是时候继续前进，专注于��进系统的其他部分了。

### 15.2.1 将值转换为有序值

我们实际上只是做了一个非常微妙的假设。当我们检查一个元素是否属于集合并将其排除时，我们只排除了一个元素。要排除多个元素，我们需要一个元素来“代表”几个元素。也就是说，排除那个值需要安全地排除其他几个元素，而无需再次查看它们。特别是，我们不能再仅仅比较相等性，这种比较一个集合元素与另一个元素的方式；我们需要一种比较方式，将一个元素与一组元素进行比较。

为了做到这一点，我们必须将任意数据转换为允许这种比较的数据类型。这就是所谓的哈希。哈希函数接受一个任意值并产生一个可比较的表示（其哈希值）—<wbr>最常见的（但不是绝对必要的）是一个数字。哈希函数必须自然是确定性的：一个固定值应该始终产生相同的哈希值（否则，我们可能会得出结论，集合中的元素实际上不在其中等等）。特定的用途可能需要额外的属性：例如，下面我们假设其输出是部分有序的。

现在让我们考虑如何计算哈希值。如果输入数据类型是一个数字，它可以作为自己的哈希值。比较简单地使用数字比较（例如，<）。然后，< 的传递性确保如果一个元素 \(A\) 小于另一个元素 \(B\)，那么 \(A\) 也小于所有比 \(B\) 大的其他元素。如果数据类型是字符串，则使用字符串不等比较。但如果我们被交付更复杂的数据类型呢？

在回答这个问题之前，考虑到实际上比较数字比比较字符串更有效率（因为比较两个数字几乎是常数时间）。因此，虽然我们可以直接使用字符串，但找到字符串的数值表示可能更方便。在这两种情况下，我们将把字符串的每个字符转换为一个数字—<wbr>例如，通过考虑其 ASCII 编码。基于此，这里有两个哈希函数：

1.  考虑一个与字符串一样长的素数列表。将每个素数提升到相应的数字，并相乘。例如，如果字符串由字符代码[6, 4, 5]表示（第一个字符的代码为 6，第二个字符为 4，第三个为 5），我们得到哈希

    ```
    num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)
    ```

    或 16200000。

1.  简单地将所有字符代码相加。对于上面的例子，这将对应于哈希

    ```
    6 + 4 + 5
    ```

    或 15。

第一个表示是可逆的，使用[算术基本定理](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)：给定结果数字，我们可以明确地重构输入（即，16200000 只能映射到上面的输入，没有其他）。第二个编码当然是不可逆的（例如，简单地排列字符，通过交换性，总和将是相同的）。

现在让我们考虑更一般的数据类型。哈希的原则将是类似的。如果我们有一个具有几个变体的数据类型，我们可以使用数字标签来表示变体：例如，素数将给我们可逆的标签。对于记录的每个字段，我们需要字段的排序（例如，词典顺序或“字母顺序”），并且必须递归地哈希它们的内容；这样做后，我们实际上得到了一串数字，我们已经展示了如何处理。

现在我们已经了解了如何确定性地将任意数据转换为数字，接下来，我们将假设表示集合的树是数字树。然而，值得考虑的是我们真正需要哈希的是什么。在通过哈希实现集合成员中，我们不需要部分排序。可逆性更加棘手。在下文中，我们假设找到一个哈希等同于找到集合元素本身，但如果多个值可以具有相同的哈希，则这并不正确。在这种情况下，最简单的方法是将所有哈希到它的值都存储在哈希旁边，我们必须搜索所有这些值以找到我们想要的元素。不幸的是，这意味着在一个特别恶劣的情况下，所需的对数复杂度实际上将变成线性复杂度！

在实际系统中，值的哈希通常由编程语言实现计算。这样做的好处是它们通常可以被做成唯一的。系统是如何实现这一点的呢？很简单：它基本上使用值的内存地址作为其哈希值。（嗯，不要那么快！有时内存系统可以并且确实移动值（部分“垃圾回收”）。在这些情况下，计算哈���值更加复杂。）

### 15.2.2 使用二叉树

因为对数来自树。

显然，列表表示不允许我们用恒定的工作量消除一半的元素；相反，我们需要一棵树。因此，我们定义一个二叉树（为简单起见）的数字：

```
data BT:
  | leaf
  | node(v :: Number, l :: BT, r :: BT)
end
```

给定这个定义，让我们定义成员检查器：

```
fun is-in-bt(e :: Number, s :: BT) -> Boolean:
  cases (BT) s:
    | leaf => false
    | node(v, l, r) =>
      if e == v:
        true
      else:
        is-in-bt(e, l) or is-in-bt(e, r)
      end
  end
end
```

等等。如果我们要查找的元素不是根节点，我们该怎么办？它可能在左子节点中，也可能在右子节点中；我们在检查完两者之前是无法确定的。因此，我们无法丢弃一半的元素；我们唯一能够丢弃的是根节点的值。此外，这个属性在树的每一层都成立。因此，成员检查需要检查整个树，而且我们仍然具有与集合大小线性相关的复杂度。

我们如何改进？比较需要帮助我们消除不仅是根节点而且是整个子树。只有当比较“代表”整个子树时才能做到这一点。如果一个子树中的所有元素都小于或等于根值，而另一个子树中的所有元素都大于或等于它，则可以这样做。当然，我们必须在哪一侧包含哪个子集方面保持一致；将较小的元素放在左边，较大的元素放在右边是传统的。这使我们的二叉树定义更精细，从而给我们一个二叉搜索树（BST）。

> 现在开始！
> 
> > 这里有一个识别二叉树实际上是否是二叉搜索树的候选谓词：
> > 
> > ```
> > fun is-a-bst-buggy(b :: BT) -> Boolean:
> >   cases (BT) b:
> >     | leaf => true
> >     | node(v, l, r) =>
> >       (is-leaf(l) or (l.v <= v)) and
> >       (is-leaf(r) or (v <= r.v)) and
> >       is-a-bst-buggy(l) and
> >       is-a-bst-buggy(r)
> >   end
> > end
> > ```
> > 
> > 这个定义正确吗？

不是。要实际丢弃一半的树，我们需要确保左子树中的所有元素都小于根值，同样，右子树中的所有元素都大于根。我们在上面使用了 <= 而不是 <，因为尽管在表示集合时我们不想允许重复，但在其他情况下我们可能不想那么严格；这样我们可以将上面的实现重用于其他目的。但是上面的定义只执行了一个“浅”比较。因此，我们可以有一个根节点 a，它有一个右子节点 b，使得 b > a；而 b 节点可以有一个左子节点 c，使得 c < b；但这并不保证 c > a。事实上，我们很容易构造一个通过此检查的反例：

```
check:
  node(5, node(3, leaf, node(6, leaf, leaf)), leaf)
    satisfies is-a-bst-buggy # FALSE!
end
```

> 练习
> 
> > 修复 BST 检查器。

通过修正的定义，我们现在可以定义一个更精细的二叉树版本，它是搜索树：

```
type BST = BT%(is-a-bst)
```

我们还可以提醒自己，这个练习的目的是定义集合，并定义 TSets 为树集：

```
type TSet = BST
mt-set = leaf
```

现在让我们在 BST 表示上实现我们的操作。首先我们将写一个模板：

```
fun is-in(e :: Number, s :: BST) -> Bool:
  cases (BST) s:
    | leaf => ...
    | node(v, l :: BST, r :: BST) => ...
      ... is-in(l) ...
      ... is-in(r) ...
  end
end
```

注意，BST 的数据定义为我们提供了关于两个子节点的丰富信息：它们各自都是 BST，所以我们知道它们的元素遵循排序属性。我们可以利用这一点来定义实际的操作：

```
fun is-in(e :: Number, s :: BST) -> Boolean:
  cases (BST) s:
    | leaf => false
    | node(v, l, r) =>
      if e == v:
        true
      else if e < v:
        is-in(e, l)
      else if e > v:
        is-in(e, r)
      end
  end
end

fun insert(e :: Number, s :: BST) -> BST:
  cases (BST) s:
    | leaf => node(e, leaf, leaf)
    | node(v, l, r) =>
      if e == v:
        s
      else if e < v:
        node(v, insert(e, l), r)
      else if e > v:
        node(v, l, insert(e, r))
      end
  end
end
```

在这两个函数中，我们严格假设 BST 的不变式，并在后一种情况下也确保它。确保你能够确定在哪里、为什么以及如何做到这一点。

现在你应该能够定义剩下的操作了。其中，size 显然需要线性时间（因为它必须计算所有元素），但是因为 is-in 和 insert 每次递归时都会丢弃两个子节点中的一个，所以它们花费对数时间。

> 练习
> 
> > 假设我们经常需要计算一个集合的大小。我们应该能够通过使每棵树☛缓存其大小来降低 size 的时间复杂度，以便 size 可以在常数时间内完成（注意树的大小显然符合缓存的标准，因为它总是可以重新构建的）。更新数据定义和所有受影响的函数，以正确跟踪此信息。

但等等。我们真的完成了吗？我们的递归的形式是\(T(k) = T(k/2) + c\)，但是我们的数据定义中什么保证了 is-in 所遍历的子树的大小是父节点的一半？

> 现在就行动！
> 
> > 构建一个例子—<wbr>由一系列插入到空树中的插入组成—<wbr>使得得到的树不平衡。证明在该树中搜索某些元素将花费线性时间，而不是对数时间。

想象一下从空树开始，按顺序插入值 1、2、3 和 4。结果得到的树将是

```
check:
  insert(4, insert(3, insert(2, insert(1, mt-set)))) is
  node(1, leaf,
    node(2, leaf,
      node(3, leaf,
        node(4, leaf, leaf))))
end
```

在这棵树中搜索 4 将不得不检查树中的所有集合元素。换句话说，这棵二叉搜索树是退化的—<wbr>它实际上是一个列表，我们回到了之前的复杂度。

因此，使用二叉树，甚至是 BST，并不能保证我们想要的复杂度：只有当我们的输入按照恰当的顺序到达时才会如此。然而，我们不能假设任何输入顺序；相反，我们希望一种在所有情况下都有效的实现。因此，我们必须找到一种方法来确保树始终保持平衡，以便 is-in 中的每个递归调用都实际上丢弃了一半的元素。

### 15.2.3 精密平衡：树手术

让我们定义一个平衡二叉搜索树（BBST）。显然它必须是一个搜索树，所以让我们专注于“平衡”部分。我们必须小心确切地理解这意味着什么：我们不能简单地期望两边的大小相等，因为这要求树（因而也要求集合）具有偶数个元素，甚至更严格地说，具有二的幂次的大小。

> 练习
> 
> > 定义一个 BBST 的谓词，它消耗一个 BT 并返回一个布尔值，指示它是否是平衡搜索树。

因此，我们将平衡的概念放宽到既宽容又足够的程度。我们使用节点的平衡因子来指代其左子树的高度减去其右子树的高度（其中高度是最深节点的深度，以边数表示）。我们允许 BBST 的每个节点具有-1、0 或 1 的平衡因子（但没有其他值）：即，左右两侧要么高度相同，要么一侧比另一侧高一。注意，这是一个递归属性，但它适用于所有级别，因此不平衡不能积累使整个树任意不平衡。

> 练习
> 
> > 给定 BBST 的定义，证明节点数与高度呈指数关系。因此，总是在一个分支上循环将在经过对数（节点数）步骤后终止。

这里有一个明显但有用的观察：每个 BBST 也是一个 BST（这是 BBST 的定义所决定的）。这为什么重要？这意味着对 BST 进行操作的函数同样适用于 BBST，而不会丢失正确性。

到目前为止，一切都很容易。唯一剩下的是创建 BBST 的方法，因为它负责确保平衡。很容易看出，常数空集是 BBST 的一个值。因此，只剩下插入。

这是我们在插入时的情况。假设我们从一个 BBST 开始，我们可以在对数时间内确定元素是否已经在树中，如果是，则忽略它。为了实现一个包，我们计算其中每个元素的数量，这不会影响树的高度。在插入元素时，鉴于平衡树，BST 的插入只需要对数时间来执行插入。因此，如果执行插入不会影响树的平衡，我们就完成了。因此，我们只需要考虑执行插入会破坏平衡的情况。

请注意，因为 \(<\) 和 \(>\) 是对称的（同样适用于 \(<=\) 和 \(>=\)），我们可以考虑插入到树的一半，并且对另一半进行对称处理。因此，假设我们有一棵当前平衡的树，我们要向其中插入元素 \(e\)。假设 \(e\) 要插入左子树，并且由于被插入，将导致整棵树失衡。有些树，比如家谱树[REF]，代表着现实世界的数据。对于“平衡”家谱树是毫无意义的：它必须准确地模拟它所代表的现实。相比之下，这些代表集合的树是我们选择的，而不是由外部现实所规定的，因此我们可以自由地重新排列它们。

有两种方法可以继续。一种是考虑我们可能在其中插入 \(e\) 以导致失衡的所有位置，并确定在每种情况下该怎么做。

> 练习
> 
> > 枚举插入可能有问题的所有情况，并规定在每种情况下该怎么做。

案例的数量实际上是相当庞大的（如果你认为不是，那你可能漏掉了一些...）。因此，我们改变策略，等问题发生后再解决：允许现有的 BST 插入元素，假设我们有一棵失衡的树，并展示如何恢复其平衡。树可以自我平衡的这一洞察力是相当了不起的，现在有许多解决方案。这个特定的解决方案，是最古老的之一，归功于 G.M. Adelson-Velskii 和 E.M. Landis。为了纪念他们的首字母，它被称为 AVL 树，尽管树本身是相当明显的；他们的天才在于定义重新平衡。

因此，在接下来的内容中，我们从一个平衡的树开始；插入导致其失衡；我们假设插入发生在左子树中。特别地，假设一个（子）树的平衡因子为\(2\)（正因为我们假设左边由插入导致失衡）。恢复平衡的过程关键取决于以下属性：

> 练习
> 
> > 证明如果一棵树当前是平衡的，即每个节点的平衡因子为\(-1\)，\(0\)或\(1\)，那么插入操作最多会使平衡因子变为\(\pm 2\)。

插入返回递归时，即在从插入值返回到根的路径上应用下面的算法。由于该路径的长度是对数级别的（由于平衡属性），并且（正如我们将看到的）每一步只执行恒定数量的工作，因此它确保插入也仅需对数时间，从而完成我们的挑战。

为了可视化算法，让我们使用这个树的示意图：

|     p |
| --- |
|    / \ |
|   q   C |
|  / \ |
| A   B |

在这里，\(p\)是根元素的值（尽管我们还将滥用术语并使用根处的值来指代整个树），\(q\)是左子树根处的值（因此\(q < p\)），\(A\)、\(B\)和\(C\)分别命名了各自的子树。我们假设\(e\)正在被插入到左子树中，这意味着\(e < p\)。

假设\(C\)的高度为\(k\)。在插入之前，以\(q\)为根的树必须具有高度\(k+1\)（否则一个插入不可能造成失衡）。反过来，这意味着\(A\)必须具有高度\(k\)或\(k-1\)，\(B\)也是如此。

假设插入后，以\(q\)为根的树的高度为\(k+2\)。因此，\(A\)或\(B\)中的一个高度为\(k+1\)，另一个高度必须小于\(k+1\)（要么是\(k\)，要么是\(k-1\)）。

> 练习
> 
> > 为什么它们在插入后都不能同时具有高度\(k+1\)？

这给我们两种情况要考虑。

### 15.2.3.1 左-左情况

假设不平衡出现在\(A\)中，即其高度为\(k+1\)。让我们扩展该树：

|       p |
| --- |
|      / \ |
|     q   C |
|    / \ |
|   r   B |
|  / \ |
| A1  A2 |

我们知道子树中的数据如下。我们将使用\(T < a\)的符号，其中\(T\)是一个树，\(a\)是一个单值，表示\(T\)中的每个值都小于\(a\)。

+   \(A_1 < r\)。

+   \(r < A_2 < q\)。

+   \(q < B < p\)。

+   \(p < C\).

让我们也提醒自己一下大小：

+   \(A_1\)或\(A_2\)的高度为\(k\)（导致失衡的原因）。

+   其他\(A_i\)的高度为\(k-1\)（参见上面的练习[REF]）。

+   \(C\)的高度为\(k\)（初始假设；\(k\)是任意的）。

+   \(B\)的高度必须为\(k-1\)或\(k\)（上述论述）。

想象一下这棵树是一个移动的部件，它有点向左倾斜了。你自然会想把移动的部件稍微往左边悬挂一点，以恢复平衡。这实际上就是我们要做的事情：

|      q |
| --- |
|     / \ |
|   r     p |
|  / \   / \ |
| A1  A2 B  C |

观察到这保留了上述每个排序属性。此外，\(A\)子树相对于\(B\)和\(C\)的根被带到了更接近根的一个级别。这恢复了平衡（如果您计算出每个\(A_i\)、\(B\)和\(C\)的高度，您会看到的）。因此，我们也恢复了平衡。

### 15.2.3.2 左-右情况

不平衡可能在\(B\)中而不是\(B\)中。扩展：

|     p |
| --- |
|    / \ |
|   q   C |
|  / \ |
| A   r |
|    / \ |
|   B1  B2 |

再次，让我们记录一下我们对数据顺序的了解：

+   \(A < q\)。

+   \(q < B_1 < r\)。

+   \(r < B_2 < p\)。

+   \(p < C\)。

和大小：

+   假设\(C\)的高度为\(k\)。

+   \(A\)的高度必须为\(k-1\)或\(k\)。

+   \(B_1\)或\(B_2\)的高度必须为\(k\)，但不能同时为\(k\)（参见上面的练习[REF]）。另一个必须是\(k-1\)。

因此，我们必须以某种方式使\(B_1\)和\(B_2\)靠近树的根节点。通过使用上述数据排序知识，我们可以构造这棵树：

|       p |
| --- |
|      / \ |
|     r   C |
|    / \ |
|   q   B2 |
|  / \ |
| A   B1 |

当然，如果\(B_1\)是有问题的子树，这仍然不能解决问题。然而，我们现在回到了之前的（左-左）情况；旋转得到：

|       r |
| --- |
|    /    \ |
|   q      p |
|  / \    / \ |
| A   B1 B2  C |

现在观察我们已经准确地保持了数据的排序约束。此外，从根开始，\(A\)的最低节点位于高度\(k+1\)或\(k+2\)；\(B_1\)的也是如此；\(B_2\)的也是如此；\(C\)的高度为\(k+2\)。

### 15.2.3.3 其他情况？

我们之前是不是有点太轻率了？在左-右情况下，我们说\(B_1\)或\(B_2\)只能有一个是高度为\(k\)的（插入后）；另一个必须是高度为\(k-1\)的。实际上，我们唯一可以确定的是另一个必须至多为高度\(k-2\)。

> 练习
> 
> > +   另一个树的高度实际上可以是\(k-2\)而不是\(k-1\)吗？
> > +   
> > +   如果是这样，上面的解决方案是否成立？结果树中仍然存在两个不平衡吗？
> > +   
> > +   上述算法中实际上是否存在错误？

# 结构化数据的集合

|     8.1 列表作为集体数据 |
| --- |
|     8.2 集合作为集体数据 |
|       8.2.1 从集合中选取元素 |
|       8.2.2 使用集合进行计算 |
|     8.3 结构化和集体数据的组合 |

当我们看到结构化数据[结构化数据简介]时，我们遇到了几种情况，其中不是一个而是许多数据：不只是一首歌而是一个播放列表，不只是一个动物而是一个动物园，不只是一个通知而是几个，不仅仅是一条消息（我们多么希望！）而是我们收件箱中的许多消息等等。总的来说，我们很少只有一个结构化数据：一个显著的例外是：考虑系统的配置或首选项信息。这些信息可能存储在文件中，并通过用户界面进行更新。即使一次只有一个配置（通常情况下），它可能有很多部分，我们不想用大量的变量来混乱我们的程序；相反，我们可以创建一个表示配置的结构，并加载它的一个实例。实际上，原本是无关的变量现在变成了一组相互关联的字段。如果我们知道我们只有一个，我们可能只会有几个单独的变量来表示这些部分，而不需要费力地创建和拆解一个结构。因此，通常我们想要讨论结构化的集合。以下是更多的例子：

+   匹配标签的消息集合。

+   对话中的消息列表。

+   用户的朋友集合。

> 现在动手！
> 
> > 集体数据与结构化数据有何不同？

在结构化数据中，我们有一组可能不同种类的固定数量的值。在集体数据中，我们有一种值的可变数量。例如，我们不提前说明播放列表中必须有多少首歌或用户可以拥有多少页；但它们每一个都必须是一首歌或一页。（当然，页面可能是有条件地定义的，但最终集合中的每一项仍然是一个页面。）

请注意，我们上面提到了集合和列表。集合和列表之间的区别在于集合没有顺序，但列表有顺序。这个区别现在并不是很重要，但我们以后会再次回到它。

当然，集合和列表不是我们唯一可能拥有的集体数据种类。以下是更多的例子：

+   人类的家族谱。 

+   你电脑上的文件系统。

+   一次聚会上的座位图。

+   页面的社交网络。

等等。大多数情况下，一旦我们有了一些经验，这些都和之前的集体数据一样容易编程和操作，尽管其中一些可能涉及到更多的细微差别。

我们已经看过表格了[Introduction to Tabular Data], 这是一种集体的、结构化的数据形式。现在我们将看一些更多的例子，以及如何对它们进行编程。

## 8.1 列表作为集体数据

我们之前已经深入研究了一个集合的例子：列表。列表不仅限于数字或字符串；它可以包含任何类型的值，包括结构化的值。例如，使用我们之前的例子[Defining and Creating Structured Data], 我们可以制作一个歌曲列表：

```
song-list = [list: lver, so, wnkkhs]
```

这是一个包含三个元素的列表，每个元素都是一首歌曲：

```
check:
  song-list.length() is 3
  song-list.first is lver
end
```

因此，我们之前看到的关于在列表上构建函数的内容[Processing Lists] 在这里也适用。举例说明，假设我们希望编写函数 oldest-song-age，它接受一个歌曲列表并产生列表中最老的歌曲。（可能有多首来自同一年的歌曲；按照我们的标准，这些歌曲的年龄将是相同的。如果发生这种情况，我们只需从列表中选择一首歌曲。然而，由于这个原因，更准确地说“一个”而不是“最老的”歌曲。）

让我们通过例子来详细说明。为了使我们的例子易于编写，我们将仅通过它们的变量名来引用歌曲，而不是写出歌曲的完整数据。显然，我们列表中最老的歌曲是绑定到 lvar 的。

```
oldest-song([list: lver, so, wnkkhs]) is lvar
oldest-song([list:       so, wnkkhs]) is wnkkhs
oldest-song([list:           wnkkhs]) is wnkkhs
oldest-song([list:                 ]) is ???
```

在最后一种情况下我们写什么？回想一下我们之前看到这个问题[my-max: Examples]: 空情况下没有答案。实际上，这里的计算与 my-max 的计算非常相似，因为本质上是相同的计算，只是询问最小年份（这将使歌曲最老）。

从我们的例子中，我们可以看到一个解决方案结构与 my-max 相似。对于空列表，我们发出一个错误信号。否则，我们计算列表中其余歌曲中最老的歌曲，并将其年份与第一个歌曲的年份进行比较。年份较老的那首歌曲就是答案。

```
fun oldest-song(sl :: List<ITunesSong>) -> ITunesSong:
  cases (List) sl:
    | empty => raise("not defined for empty song lists")
    | link(f, r) =>
      cases (List) r:
        | empty => f
        | else =>
          osr = oldest-song(r)
          if osr.year < f.year:
            osr
          else:
            f
          end
      end
  end
end
```

请注意，不能保证只有最老的歌曲，这在 osr.year 可能等于 f.year 的情况中反映出来。然而，我们的问题陈述允许我们选择一首这样的歌曲，这就是我们所做的。

> 现在开始！
> 
> > 修改上面的解决方案为 oldest-song-age，计算最老歌曲的年龄。

哈哈，开玩笑的！你不应该修改之前的解决方案！相反，你应��保持不变—<wbr>它可能对其他目的有用—<wbr>而是构建一个新的函数来使用它：

```
fun oldest-song-age(sl :: List<ITunesSong>) -> Number:
  os = oldest-song(sl)
  song-age(os)
where:
  oldest-song-age(song-list) is 71
end
```

## 8.2 集合作为集体数据

正如我们已经看到的，对于一些问题，我们不关心输入的顺序，也不关心重复。以下是更多我们不关心顺序或重复的例子：

+   你的网络浏览器记录了你访问过的网页，一些网站利用这些信息将已访问的链接着色与未访问的链接区分开。这种颜色通常与你访问页面的次数无关。

+   在选举期间，一名投票代理可能会记录你已经投票，但不需要记录你投票的次数，并且不关心人们投票的顺序。

对于这样的问题，相对于列表，列表是一个不合适的选择。在这里我们将看到 Pyret 内置的集合是如何工作的。稍后我们将看到如何为自己构建集合。首先，我们可以像定义列表一样轻松地定义集合：

```
song-set = [set: lver, so, wnkkhs]
```

当然，由于语言语法的性质，我们必须以某种顺序列出元素。这重要吗？

> 现在就做！
> 
> > 我们如何判断 Pyret 是否在意顺序？

这是检查的最简单方法：

```
check:
  song-set2 = [set: so, wnkkhs, lver]
  song-set is song-set2
end
```

如果我们想要特别谨慎，我们可以写下所有其他元素的排序方式，并查看 Pyret 是否在意。

> 练习
> 
> > 有多少种不同的顺序？

对于重复的情况也是一样：

```
check:
  song-set3 = [set: lver, so, wnkkhs, so, so, lver, so]
  song-set is song-set3
  set-size(song-set3) is 3
end
```

我们可以再次尝试几种不同类型的重复，并确认集合会忽略它们。

### 8.2.1 从集合中选择元素

然而，这种无序性带来了一个问题。对于列表，谈论“第一个”和相应的“其余部分”是有意义的。根据定义，对于集合来说没有“第一个”元素。事实上，Pyret 甚至没有类似于 first 和 rest 的字段。取而代之的是一些更准确但复杂的东西。

函数 set-pick 返回集合的随机元素。它产生一个 Pick 类型的值（我们从 pick 库中获取）。当我们选择一个元素时，有两种可能性。一种是集合为空（类似于列表为空），这会给我们一个 pick-none 值。另一种选择是称为 pick-some，它给我们一个实际的集合成员。

Pick 的 pick-some 变体有两个字段，而不是一个。要理解原因需要花一点时间。让我们通过选择集合中的一个元素来探索一下：

```
fun an-elt(s :: Set):
  cases (Pick) set-pick(s):
    | pick-none => error("empty set")
    | pick-some(e, r) => e
  end
end
```

（注意，在 pick-some 情况下我们没有使用 r 字段。）

> 现在就做！
> 
> > 你能猜到为什么我们没有为 an-elt 写例子吗？
> > 
> 现在就做！
> 
> > 运行 an-elt(song-set)。你得到了什么元素？
> > 
> > 再次运行。再运行五次。
> > 
> > 每次都得到相同的元素吗？

不，你没有！嗯，实际上，无法确定你没有。有极小的可能性你在六次运行中每次都得到完全相同的元素。如果这种情况发生在你身上，继续运行更多次！Pyret 设计为在从集合中选择时不总是返回相同的元素。这是有意为之的：它是为了强调从集合中选择的随机性，并防止你的程序意外依赖 Pyret 可能使用的特定顺序。

> 现在就做！
> 
> > 鉴于 an-elt 不返回可预测的元素，我们能为它写什么测试呢？

注意，虽然我们无法预测 an-elt 将产生哪个元素，但我们知道它将产生集合的一个元素。因此，我们可以编写测试来确保生成的元素是集合的成员——虽然在这种情况下，这并不特别令人惊讶。

### 8.2.2 使用集合进行计算

一旦我们从集合中选择了一个元素，通常有用的是获得由剩余元素组成的集合。我们已经看到，选择 pick-some 的第一个字段类似于取一个集合的“第一个”。因此，我们希望一种方法来获取集合的“剩余部分”。但是，我们希望在排除特定的“第一个”之后获得剩余的部分。这就是 pick-some 的第二个字段的作用：剩下的是什么。

有了这个基础，我们可以编写关于集合的函数，看起来与列表的函数大致类似。例如，假设我们想计算集合的大小。这个函数看起来类似于 my-len [一些示例练习]:

```
fun my-set-size(shadow s :: Set) -> Number:
  cases (Pick) s.pick():
    | pick-none => 0
    | pick-some(e, r) =>
      1 + my-set-size(r)
  end
end
```

尽管推导这一过程类似于我们用于 my-len 的过程，但选择元素的随机性使得编写与实际函数行为相匹配的示例更加困难。

## 8.3 结合结构化和集合数据

正如上面的例子所示，程序的数据组织通常涉及多种复合数据类型，通常是密切相关的。让我们首先以成对的方式考虑这些。

> 练习
> 
> > 想出结合以下内容的示例：
> > 
> > +   结构化和条件性数据，
> > +   
> > +   结构化和集合数据，并且
> > +   
> > +   条件性和集合数据。
> > +   
> > 你实际上已经在上面看到了这些示例。识别它们。

最后，我们甚至可能同时具有这三种。例如，文件系统通常是文件和文件夹（条件性）的列表（集合），其中每个文件都有几个属性（结构化）。类似地，社交网络具有一组页面（集合），其中每个页面都是为个人、组织或其他事物（条件性）而设立的，每个页面都有几个属性（结构化）。因此，正如你所看到的，这些组合在我们日常处理的各种应用程序中自然而然地出现。

> 练习
> 
> > 选择你喜欢的三个网站或应用程序。识别它们呈现的数据类型。将这些分类为结构化、条件性和集合性。它们如何组合这些数据？

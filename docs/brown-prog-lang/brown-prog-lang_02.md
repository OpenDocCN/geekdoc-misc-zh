# 2 基本数据和表达式

|     2.1 数字 |
| --- |
|     2.2 表达式与值 |
|     2.3 变量来命名值 |
|     2.4 字符串 |
|       2.4.1 多行字符串 |
|       2.4.2 字符串操作 |
|     2.5 布尔值 |
|       2.5.1 其他比较 |
|       2.5.2 其他布尔值产生操作 |
|       2.5.3 组合布尔值 |
|       2.5.4 使用布尔值 |
|     2.6 通过简化表达式来评估 |
|     2.7 图片 |
|     2.8 Roughnums |

让我们考虑一些我们使用的程序。我们可能会使用谷歌，一个搜索引擎：它消耗一个搜索查询并生成搜索结果。我们可能会使用 Facebook，一个社交网络：它消耗关于我们友谊的信息并生成我们朋友的更新。我们可能会使用亚马逊，一个商店：它消耗我们感兴趣的事物的描述并生成与我们描述相匹配的产品列表。有时我们会使用 Weather.com，一个天气网站：它消耗我们的位置并为该位置生成天气预报。实际上，这些系统消耗和产生更多信息：它们消耗我们过去的偏好历史，并产生广告，相关产品的推荐 [REF 协同过滤]，等等。简而言之，程序消耗和产生信息。

信息是一个模糊的术语；计算机实际上消耗和产生的是我们称之为数据的东西。区别微妙但重要。“我们的位置”是一个模糊的概念，但一个天气网站实际消耗的是一个非常具体的表示，比如一个城市的名称（如“Providence, RI, USA”）或其 GPS 坐标（如“41.8236 N, 71.4222 W”）。甚至可能存在多种选择来表示该信息。例如，一些系统可能会将普罗维登斯的 GPS 坐标表示为我们上面展示的方式：

| 41.8236 N, 71.4222 W |
| --- |

其他人可能选择使用正数和负数来表示半球：

| +41.8236, -71.4222 |
| --- |

你甚至可以想象通过一些巧妙的数值技巧将两者合并成一个数字 [REF 哥德尔编码]，等等。因此，这些是表示相同信息的不同数据类型。

因此，要编写程序，我们必须了解它们的数据。我们将从了解最基本的数据类型开始，并使用它们编写一些简单的程序。随着我们的程序变得更加复杂，我们将需要表示更多有趣的信息。我们的许多演示内容直接来自书籍《如何设计程序》，您可以在[`htdp.org/`](http://htdp.org/)找到。

## 2.1 数字

程序中最常见的一些数据是数字。它们可以表示像上面那样的 GPS 坐标，或者一个人的年龄，或者屏幕上图片的尺寸，或者搜索查询结果的数量。在 Pyret 中，数字易于表示；例如，这是布朗大学成立的年份：

```
1764
```

或者一个让[数论爱好者](https://en.wikipedia.org/wiki/1729_(number))兴奋的数字：

```
1729
```

不出所料，如果您向 Pyret 请求它们的值，Pyret 会将相同的值返回给您：

| > 1764 |
| --- |
| 1764 |
| > 1729 |
| 1729 |

已知值的程序有什么用？稍后你会发现答案：（part "values-for-tests"）。当然，您可以按照您熟悉的方式组合数字；我们称这些表达式为表达式，就像在代数中一样：是的，你必须在 + 等操作周围加上空格。

| > 1764 + 1729 |
| --- |
| 3493 |
| > 1764 - 1729 |
| 35 |
| > 1764 * 1729 |
| 3049956 |

如果您有先前的编程经验，您可能会担心大数相乘。别担心，尽情地：

| > 1764 * 1729 * 1764 * 1729 * 1764 * 1729 * 1764 * 1729 |
| --- |
| 86531512776056800758948096 |

> 现在做！
> 
> > 示例仅使用一个操作符。如果我们尝试组合多个不同的操作符会发生什么？

在 Pyret 中，如果您组合运算符，语言不会猜测您可能的意思（因为它可能猜错）：如果您写

```
3 - 2 + 1
```

你是指 3 - (2 + 1) 还是 (3 + 1) - 2？与其猜测，它要求你写括号（就像我们刚才做的那样）以明确你的意图。当然，我们可以对数字执行许多操作，并且我们并没有为所有这些操作都有特殊的符号。您可以使用 Pyret 的许多其他数字运算符，使用您从数学课程中熟悉的语法：数值平方根的运算符称为 num-sqrt，您可以按如下方式使用它：

| > num-sqrt(4) |
| --- |
| 2 |

如果您对运算符有多个参数，请用逗号分隔它们：

| > num-expt(2, 4) |
| --- |
| 16 |

其中，num-expt 计算指数。

> 练习
> 
> > 你可能会问的一个自然问题是，“我需要在参数之间的逗号后面加空格吗？”好问题！自己检查一下吧。

如果您有其他编程语言的经验，您现在可能会开始思考不同类型的数字。例如，在许多语言中，这个表达式

```
(1 / 3) * 3
```

不幸地导致零。别问。或者，好吧，以后再问。幸运的是，在 Pyret 中，这会产生 1。这是因为 Pyret 精确地表示 1 / 3 的结果为比例，就像您期望的那样。事实上，Pyret 会尽量保留比例：如果您计算

```
(1764 * 1729 * 1764) / (1764 * 1729 * 1764 * 1729)
```

Pyret 将产生一个等同于 1/1729 的答案。实际上，如果你点击 Pyret 产生的输出，你可以在不同的方式之间切换呈现相同的数据，其中之一就是 1/1729。

> 练习
> 
> > 当你尝试除以零会发生什么？
> > 
> > 1.  你期待什么？
> > 1.  
> > 1.  Pyret 会做什么？

## 2.2 表达式与值

在我们继续之前，我们必须介绍一个术语。一个值是表达式的结果：我们已经计算完了它，不能再做任何操作。因此，1764 * 1729 不是一个值，因为我们仍然可以执行乘法；但是 3049956 是一个值，因为它没有更多待处理的操作。

让我们看另一个表达式的例子。考虑一个访问月球的太空旅行者。在月球上，这位宇航员的重量只有地球上的六分之一。因此，如果他们的地球重量是 50 公斤，他们的月球重量（以公斤为单位）是

```
50 * 1/6
```

如果他们的地球重量是 150 磅，他们的月球重量（以磅为单位）是

```
150 * 1/6
```

一般来说，鉴于它们的地球重量，我们可以写一个表达式来计算它们的月球重量。我们很快会回到这个例子[REF]。请注意，Pyret 不关心 50 代表千克还是磅。这些是单位，单位不是编程语言的一部分。这使得创建单位错误变得容易，这在[臭名昭著的历史](http://spacemath.gsfc.nasa.gov/weekly/6Page53.pdf)中有所体现。稍后[REF]我们将看到如何在我们的程序中编写一些单位处理来减少这种错误。

> 现在就做！
> 
> > 你在我们在上一节和这一节写的分数中看到了什么奇怪的地方吗？

这是微妙的，如果你没有注意到，不要担心：我们写的是 1/1729 而不是 1 / 1729，以及 1/6 而不是 1 / 6。难道所有算术运算（如/）不应该被空格包围吗？

那是因为 1/1729 不是一个表达式，它是一个值—<wbr>具体来说，是一个数字—<wbr>本身。也就是说，1 / 1729 是一个表达式；还有工作需要完成（除法）才能得到一个值。相比之下，Pyret 写数字的方式允许直接写有理数：你可以写 1/1729，就像你可以写 1 和 1729 一样，它同样是一个值。

## 2.3 用变量命名值

通常更方便地引用某物的名称而不是其值。例如，六个月后，如果你在程序中看到 1764，你可能不记得那意味着什么；但是如果你看到 brown-founding，你可能有一个很好的概念。Pyret 让我们给值取名字：

```
brown-founding = 1764
this-year = 2016
```

然后我们可以在表达式中使用这些名称：

```
this-year - brown-founding
```

实际上，我们不仅可以给值取名字；我们甚至可以给表达式取名字：

```
brown-age = this-year - brown-founding
```

我们称这些名称为变量，就像代数中一样。我们将使用“绑定”这个词来指代名称与值的关联：也就是说，brown-founding 绑定到 1764。

## 2.4 字符串

当然，计算机处理的不仅仅是数字。我们可能想要记录城市的名称、人名、文档的部分等等。在 Pyret 中，字符串用于表示这样的文本：

```
"Providence, RI"
"Bangalore, India"
"the quick brown fox jumped over the lazy dog"
```

字符串以双引号开头和结尾；请注意，您必须使用键盘上的双引号（"），而不是文字处理器生成的开引号和闭引号（“和”）。您也可以使用单引号（'）代替：

```
'Providence, RI'
'Bangalore, India'
'the quick brown fox jumped over the lazy dog'
```

当然，您可能想知道 Pyret 如何知道字符串何时结束，如果字符串本身包含双引号：

| "这本书被称为“结构与解释”" |
| --- |

> 现在就试试吧！
> 
> > 当你输入这个时会发生什么？

这是两个字符串（“书名为”和“”）以及一些变量（如 Structure）和其他内容之间的内容吗？不用说，Pyret 感到困惑。那么你怎么输入呢？有两种简单的方法。首先，我们可以使用其他引号来避免混淆：

```
'The book was called "Structure and Interpretation"'
```

或者（当你注意到 Pyret 打印上面的值时可能会注意到），你可以告诉 Pyret “这个引号是字符串的一部分，不是它的结尾”：

```
"The book was called \"Structure and Interpretation\""
```

两者都可以正常工作；选择哪一个更易读和不太容易引起混淆。

### 2.4.1 多行字符串

有时，拥有一个跨越多行的字符串是很方便的。通常，超过一行的字符串代表程序中的错误（因为程序员忘记关闭字符串）。因此，如果您尝试在程序中编写多行字符串，Pyret 将产生错误：

| "让我们走吧，你和我， |
| --- |
| 当夜晚铺展在天空之上时" |

> 现在就试试吧！
> 
> > 尝试这个并查看生成的错误。熟悉它！

Pyret 使用完全不同的语法来表示多行字符串：

```
```让我们走吧，你和我，

当夜晚铺展在天空之上时```
```

使用三个反引号是你向 Pyret 发出信号的方式，“我真的希望这个跨越多行”。请注意，当 Pyret 打印此字符串时，它会用 \n 替换换行符。实际上，您可以将此多行字符串全部写在一行上：

```
"Let us go then, you and I,\nWhen the evening is spread out against the sky"
```

再次强调，这两者是等价的，您可以选择更方便的那个。

### 2.4.2 字符串操作

当然，我们不仅可以创建字符串，还可以对它们执行计算 —— 实质上是对字符串进行“算术运算”。例如，我们可以将它们连接起来：

| > "will." + "i." + "am" |
| --- |
| "will.i.am" |
| > "爱的歌曲 " + "of J. Alfred Prufrock"观察第一个字符串末尾的空格。 |
| "J·阿尔弗雷德·普鲁弗洛克的爱之歌" |

我们还可以测量字符串的长度，或者拆解它们：

| > s = "爱的歌曲" |
| --- |
| > string-length(s) |
| 12 |
| > string-substring(s, 0, 3) |
| "The" |

## 2.5 布尔值

我们已经多次谈论了两个值的等价性。现在我们相信我们的眼睛告诉我们它们是相等的，但我们可以做得更好：我们可以要求 Pyret 为我们检查。

在我们这样做之前，我们应该问自己 Pyret 如何能够报告它发现了什么。例如，如果我们询问两个字符串是否相等，答案可能是是也可能是否。Pyret 应该使用什么数据来指示答案？

> 练习
> 
> > 解释为什么数字和字符串不是表达答案的好方法。

Pyret 提供了两个值，true 和 false，来表示这样的答案。出于历史原因，这些被称为布尔值。以 [George Boole](https://en.wikipedia.org/wiki/George_Boole) 命名。我们可以用 == 比较两个值是否相等：关于等式，我们可以说的还有很多，我们以后会详细说明 [REF equality]。

| > 1 == 1 |
| --- |
| true |
| > 1 == 2 |
| false |

因此，回到我们之前的两个例子：请注意，我们不需要创建变量来执行比较，就像我们上面没有做的那样。变量只是为了让示例更容易阅读。

+   ```
    n1 = (1764 * 1729 * 1764) / (1764 * 1729 * 1764 * 1729)
    n2 = 1/1729
    n1 == n2
    ```

+   ```
    s1 = ```让我们一起去吧，你和我，

    当晚霞铺展在天空之上时```
    s2 = "Let us go then, you and I,\nWhen the evening is spread out against the sky"
    s1 == s2
    ```

我们期望这两者都会产生 true 结果，但实际上并非如此：

```
```让我们一起去吧，你和我，

当晚霞铺展在天空之上时``` ==
"Let us go then, you and I, When the evening is spread out against the sky"
```

（因为我们用空格替换了 \n）。

特别是，我们正在使用语言来确定何时相等，而不是使用我们（可能不太可靠的）视力。这是一个非常重要的观念，我们以后会更详细地讨论 [REF testing]。

### 2.5.1 其他比较

当然，我们可以做更多种类的比较。例如，

| > 1 <= 2 |
| --- |
| true |
| > 1 > 3 |
| false |

然而，如何比较字符串可能并不明显。有些比较是不足为奇的：

| > "a" < "b" |
| --- |
| true |
| > "a" >= "c" |
| false |
| > "that" < "this" |
| true |
| > "alpha" < "beta" |
| true |

这是我们习惯的字母顺序；但其他需要一些解释：

| > "a" >= "C" |
| --- |
| true |
| > "a" >= "A" |
| true |

这是因为 Pyret 字符串是使用称为 [ASCII](https://en.wikipedia.org/wiki/ASCII) 顺序进行比较的。

> 练习
> 
> > 你能比较真和假吗？试着将它们进行相等比较，然后进行不等比较（如<）。

通常情况下，您可以比较任意两个值是否相等（但请在 [REF equality] 中阅读更多）；例如：

| > "a" == 1 |
| --- |
| false |

如果您想比较特定类型的值，可以使用更具体的运算符：

| > num-equal(1, 1) |
| --- |
| true |
| > num-equal(1, 2) |
| false |
| > string-equal("a", "a") |
| true |
| > string-equal("a", "b") |
| false |

然而，这些运算符不会让你混合两种不同类型的值。

> 练习
> 
> > 试试看
> > 
> > | num-equal("a", 1) |
> > | --- |
> > | string-equal("a", 1) |
> > 
> > 并理解这些运算符与 == 的关系。

### 2.5.2 其他产生布尔值的操作

还有更多产生布尔值的运算符，比如：

| > wm = "will.i.am" |
| --- |
| > string-contains(wm, "will") |
| -   | true |
| > string-contains(wm, "Will")注意大写的 W。 |
| false |

实际上，几乎每一种数据都有一些布尔值运算符来进行比较。

### 2.5.3 组合布尔值

通常，我们希望根据不止一个布尔值做出决定。例如，如果你是某个国家的公民并且年龄超过一定年龄，你就可以投票。如果你有车票或者公交车是免费乘车日，你就可以搭乘公交车。我们甚至可以组合条件：如果你年龄超过一定年龄并且视力良好，且—<wbr>要么通过测试要么有临时许可证，你就可以驾驶。此外，如果你没有醉酒，你也可以驾驶。

与这些组合形式对应，Pyret 提供了三种主要操作：and、or 和 not。以下是它们的一些使用示例：

| > (1 < 2) and (2 < 3) |
| --- |
| 真 |
| > (1 < 2) and (3 < 2) |
| 假 |
| > (1 < 2) or (2 < 3) |
| 真 |
| > (3 < 2) or (1 < 2) |
| 真 |
| > not(1 < 2) |
| 假 |

### 2.5.4 使用布尔值

使用布尔值的一种方式是将它们组合以产生其他布尔值。然而，最终，我们希望根据布尔值产生其他类型的数据。在 Pyret 中有几种方法可以实现这一点，但现在我们只关注其中一种：条件表达式（因为它产生的值是其他值的“条件”）。

Pyret 中条件的结构如下：

```
if <Boolean expression to check>:
  <expression if true>
else:
  <expression if false>
end
```

例如，

```
brown-founding = 1764
rice-founding = 1912
if brown-founding < rice-founding:
  "Brown is older"
else:
  "Rice is older"
end
```

实际上，这个程序包含一个小的逻辑错误。假设布朗大学和莱斯大学是同一年成立的；那么，因为 brown-founding > rice-founding 会是假，它会宣布莱斯大学更老，尽管它们同龄。所以一个更准确的程序会检查它们是否相等，只有在真的更老的情况下才报告一个。我们可以使用条件的扩展版本来实现这一点，其语法是：

```
if <Boolean expression to check>:
  <expression if first expression is true>
else if <another Boolean expression to check>:
  <expression if first expression is false and second expression is true>
else:
  <expression if both expressions are false>
end
```

例如：

```
if brown-founding < rice-founding:
  "Brown is older"
else if brown-founding == rice-founding:
  "Both are the same age"
else:
  "Rice is older"
end
```

## 2.6 通过简化表达式进行评估

最后，让我们简要讨论 Pyret 如何生成值，即评估的过程（简化为值）。假设我们想要计算工人的工资。工人每小时工作 40 小时以内支付 $10，每额外工作一小时支付 $15。假设 hours 包含他们工作的小时数，假设为 45：

```
hours = 45
```

假设计算工资的公式为

```
if hours <= 40:
  hours * 10
else if hours > 40:
  (40 * 10) + ((hours - 40) * 15)
end
```

现在让我们看看这是如何产生答案的，使用一个逐步过程，这个过程应该与你在代数课上看到的相匹配：第一步是用 45 替换 hours。

```
if 45 <= 40:
  45 * 10
else if 45 > 40:
  (40 * 10) + ((45 - 40) * 15)
end
```

接下来，评估 if 表达式的条件部分，这种情况下是假。

```
=>  if false:
      45 * 10
    else if 45 > 40:
      (40 * 10) + ((45 - 40) * 15)
    end
```

由于条件为假，下一个分支被尝试。

```
=>  if false:
      45 * 10
    else if true:
      (40 * 10) + ((45 - 40) * 15)
    end
```

由于条件为真，表达式简化为该分支的主体。之后，这只是算术。

```
=>  (40 * 10) + ((45 - 40) * 15)
```

```
=>  400 + (5 * 15)
=>  475
```

这种简化风格是思考评估 Pyret 表达式（以及后来的函数）的最佳方式。整个表达式采取简化步骤，按照简单的规则进行。如果你想尝试手动（或心算）通过 Pyret 程序的评估，你可以自己使用这种风格。

## 2.7 图像

Pyret 不限制你只能使用数字和字符串；你还可以将图像视为数据。要使用图像，我们应该向 Pyret 请求图像操作：

```
include image
```

我们可以画一个红色的圆：

```
red-circ = circle(60, "solid", "red")
```

我们还可以画一个白色的矩形：

```
white-rect = rectangle(300, 200, "solid", "white")
```

正如我们可以组合数字、字符串和布尔值一样，我们也可以组合图像（即对图像进行“算术运算”）。例如，overlay 会将一个图像（第一个图像）覆盖在第二个图像上：

```
overlay(red-circ, white-rect)
```

要获得[日本国旗](https://en.wikipedia.org/wiki/Flag_of_Japan)。类似地，我们可以将三个圆放在彼此上方—<wbr>

```
sm-circ = circle(50, "outline", "black")
above(sm-circ, above(sm-circ, sm-circ))
```

—<wbr>以获得雪人的第一阶段（享受画剩下部分的乐趣！）。稍后回顾日本国旗，实际上有关于国旗不同尺寸之间比例的规定：上面的数字并不是随意选择的。例如，宽度和高度必须是 3:2 的比例（因此为 300 和 200），红色圆必须有整体高度的 3/5 的直径。如果我们现在想要绘制一个更大的国旗，我们将不得不小心地改变许多东西以保持这些规则！或者，我们可以使用一个变量来代表，比如说，一个“单位”大小，并从那里计算出其他所有内容：

```
unit = 100
bg-width = unit * 3
bg-height = unit * 2
circ-rad = 3/5 * 1/2 * bg-height
red-circ = circle(circ-rad, "solid", "red")
white-rect = rectangle(bg-width, bg-height, "solid", "white")
overlay(red-circ, white-rect)
```

这样现在很容易只改变一件事并自动更改其他所有内容：每次运行程序，旗帜的大小取决于 unit 的值。如果我们设为 200，我们得到一个两倍大的旗帜；如果我们设为 50，我们得到一半大小的旗帜。

当然，每次我们都必须运行程序以重新计算这些值，这是我们想要避免的问题；我们稍后会回到这一点[FILL]。稍后我们还会看到如何将图像与其他计算组合起来制作电影、动画和视频游戏[REF world]。

## 2.8Roughnums

在我们结束基本数据的讨论之前，我们必须再多说一些关于数字的事情。我们上面选择的数字示例之所以方便选择，是为了不暴露计算机对数字处理的某种丑陋性。尽管 Pyret 大部分时间都掩盖了这种丑陋，但出于各种原因（主要是与效率有关），它并没有完全掩盖它们。

最好的方法是寻找这个问题的平方根：num-sqrt(2)。这个数没有精确的有理表示。Pyret 仍然会计算一个答案，但是以一种奇怪的方式打印出来：

```
~1.4142135623730951
```

这里发生了什么？Pyret 想要确保你明白它所打印的—<wbr>1.4142135623730951—<wbr>绝对不可能是精确的答案（因为 \(\sqrt{2}\) 没有有理表示）。前缀~表示这是一个 roughnum：一个你应该谨慎对待的近似答案。在实践中，roughnums 使用 [浮点数](https://en.wikipedia.org/wiki/Floating_point) 来表示，这些数值是近似的但在现代计算机中实现得非常高效。Roughnums 具有普遍的特性：一旦一个计算涉及到 roughnum，其答案也将是 roughnum：

```
> ~1 + 1
~2
```

有时，这可能会让人感到惊讶：

```
> num-sqrt(2) - num-sqrt(2)
~0
```

你可能会认为“任何数减去自身必须精确地等于零”，但是 Pyret 并不“知道”你所知道的那么多，并且对结果保持谨慎。这事实证明是相当明智的。例如，考虑下面的计算：

```
> num-sqrt(2) + 1
~2.414213562373095
```

更仔细地查看小数点后的数字。你预计它们会与 num-sqrt(2)完全相同，但第一个似乎多了一个数字：

```
~1.4142135623730951
~2.414213562373095
```

实际上，从第二个数字减去 1 会产生与第一个数字略有不同的结果：

```
> (num-sqrt(2) + 1) - 1
~1.414213562373095
```

所以这个是或不是确切与 num-sqrt(2)相同？让我们问问 Pyret：

```
> ((num-sqrt(2) + 1) - 1) - num-sqrt(2)
~-2.220446049250313e-16
```

符号 e 表示指数表示法，因此这与大约\(2.2 \times 10^{-16}\)是相同的——<wbr>即，一个非常小的数字，但不是零！因此，从\(\sqrt{2}\)开始，加上一，减去一，然后减去\(\sqrt{2}\)会产生一个不完全是零的答案。

> 练习
> 
> > 粗糙数是否遵循算术运算符的公理，例如（在适当的情况下）分配性、结合性和交换性？

由于粗糙数（roughnums）非常脆弱，Pyret 不会让你被相等操作误导。

```
1 == ~1
```

Pyret 不确定：~1 表示大约是 1 的某个值，但它可能确切是那个值，也可能接近但不完全是它（就像我们看到的一个值接近但不完全是零，尽管在现实中我们知道它是零）。因此，Pyret 将其视为既不是真也不是假，而是一个错误。稍后[参考]我们将看到如何比较粗糙数。

浮点数的完整解释远远超出了本文档的范围；本节只是警告您必须注意的内容。感兴趣的读者应该找到 David Goldberg 的“每个计算机科学家都应该了解的浮点运算知识”一书的副本，例如，[见此处](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)。

# 从表格到列表

|     5.1 基本统计问题 |
| --- |
|     5.2 从表中提取列 |
|     5.3 理解列表 |
|       5.3.1 列表作为匿名数据 |
|       5.3.2 创建文字列表 |
|     5.4 列表操作 |
|       5.4.1 列表的内置操作 |
|       5.4.2 列表与表的组合 |

之前[介绍表格数据]，我们开始处理表格形式的集体数据。虽然我们看到了几个强大的操作，让我们能够快速轻松地对数据提出复杂的问题，但它们都有两个共同点。首先，所有的操作都是按行进行的。没有任何一个操作是针对整个列提出的问题。其次，所有的操作不仅消耗，而且产生表格。然而，我们已经知道[基本数据和表达式]，还有许多其他类型的数据，有时我们会想要计算其中的一个。我们现在将看到如何实现这两个目标，并在此过程中介绍一个重要的新数据类型。

## 5.1 基本统计问题

我们可能还想问很多其他问题。例如：

+   播放次数列中播放次数最多的歌曲，这相当于播放次数列中的最大值。

+   文件系统中最大的文件，这相当于文件大小列中的最大值。

+   人员表中最矮的人，这相当于身高列中的最小值。

+   播放列表中播放次数最多的歌曲，这相当于播放次数列中最小值的情况。

+   播放列表中的歌曲数量。（这可能是关于所有列合并的问题，而不是任何一个特定列的问题，因为它们都具有相同数量的条目。）

+   播放次数列中的所有不同条目。（显然，这是关于特定列的问题，因为不同条目的数量会根据列而异。）

+   播放次数列中不同条目的数量。

+   薪水列中的平均值。

+   身高列中的其他统计数据（中位数、众数、标准差等）。

注意我们谈论的操作类型：计算最大值、最小值、平均值、中位数和其他基本统计数据。Pyret 有几个内置的[统计函数](http://www.pyret.org/docs/latest/statistics.html)。

> 现在就行动！
> 
> > 想想你是否以及如何使用已经学过的操作来表达这些问题。

## 5.2 从表中提取列

希望你觉得 select 很有吸引力，因为它使我们能够单独获得一列：例如，

```
select play-count from songs end
select height from people end
```

但最终我们仍然卡在表格的一列上，并且其他操作都无法计算我们正在寻找的答案。因此，根本没有（直接的）方法来表达这些问题，因为它们要求我们执行一个计算，查看表格值相对于彼此而言，而不是孤立地。

原则上，我们可以在单个列上拥有一系列操作。在一些专注于表格的语言中，比如[SQL](https://en.wikipedia.org/wiki/SQL)，这就是你会找到的。然而，在 Pyret 中，我们拥有比列更多的数据类型（正如我们很快会看到的[REF]，我们甚至可以创建自己的！），所以迟早要离开表格的温柔茧。提取的列是一种更基本的数据类型，称为列表，它可以用来表示程序中的其他数据（正如我们在[REF]和其他地方看到的），而无需每次都创建表格。

因此，我们引入了另一种操作，提取（extract），它接受一个列名，并只给出该列的内容：

```
extract play-count from songs end
extract height from people end
```

现在我们可以回答关键问题——<wbr>选择和提取之间的区别是什么——<wbr>可以说选择生成一个表格，而提取生成一个列表。

## 5.3 理解列表

列表与单列表格有很多共同之处：

+   元素有一个顺序，因此谈论列表的“第一个”、“第二个”、“最后一个”——<wbr>等等——<wbr>元素是有意义的。

+   预期列表的所有元素都具有相同的类型。

关键区别在于列表没有“列名”；它是匿名的。也就是说，一个列表本身并不描述它代表什么；这个解释是由我们的程序完成的。

### 5.3.1 匿名数据列表

这听起来可能相当抽象——<wbr>确实如此——<wbr>但这实际上并不是我们编程经验中的新概念。考虑一个值，比如 3 或 -1：它是什么？这是同样类型的东西：一个匿名值，不描述它代表什么；解释是由我们的程序完成的。在一个环境中，3 可能代表一个年龄，在另一个环境中代表一个播放计数；在一个环境中，-1 可能是一个温度，在另一个环境中是几个温度的平均值。字符串也是如此："project" 是名词（一个或多个人执行的活动）还是动词（当我们在屏幕上显示某些内容时）？图片也是如此。事实上，到目前为止，表格在数据中具有描述的情况是一个例外，而不是由程序提供！

这种泛化既是一种优点，也是一个问题。因为，像其他匿名数据一样，列表不提供其用途的任何解释，如果我们不小心，我们可能会错误地解释这些值。另一方面，这意味着我们可以在几个不同的上下文中使用相同的数据，并且一个操作可以在许多环境中使用。

实际上，如果我们回顾一下之前提出的问题列表，我们会发现有几个常见操作——<wbr>最大值、最小值、平均值等等——<wbr>可以针对一个值列表进行询问，而不考虑列表代表的是什么（高度、年龄、播放次数）。事实上，一些操作是特定于数字的（例如平均值），而一些（例如最大值）可以针对我们可以进行比较的任何类型（例如字符串）进行询问。

### 5.3.2 创建文字列表

我们已经看到了如何从表格中创建列表，使用 extract。然而，正如你所预料的，我们也可以直接创建列表：

```
[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]
```

当然，列表是值，所以我们可以使用变量来命名它们——<wbr>

```
shopping-list = [list: "muesli", "fiddleheads"]
```

—<wbr>将它们传递给函数（我们很快就会看到），等等。

> 现在就做！
> 
> > 根据这些示例，你能想出如何创建一个空列表吗？

正如你可能已经猜到的那样，它是 [list:] （空格不是必需的，但它是一个有用的视觉提醒，表示空值）。

## 5.4 对列表进行操作

### 5.4.1 列表上的内置操作

Pyret 巧妙地提供了一组我们已经可以在列表上执行的有用操作。正如你可能已经猜到的那样，我们已经可以计算出我们之前提出的所有答案：

+   list-max 计算列表的最大元素。

+   list-min 计算列表的最小元素。

+   list-avg 计算列表的平均值。

+   list-distinct 计算列表的不同元素。

+   list-std-dev 计算列表中值的标准差。

因此：

```
pcs = extract play-count from songs end
most-played-count = list-max(pcs)
least-played-count = list-min(pcs)

hts = extract height from people end
tallest-height = list-max(hts)
shortest-height = list-min(hts)
```

### 5.4.2 合并列表和表格

注意，我们最初提出的问题略有不同：我们并没有询问最高的高度，而是最高的人，或者类似地最常播放的歌曲。因为我们剥离了高度和计数的上下文，所以无法确定这些值对应哪个人或歌曲。为此，我们必须回到表格。

> 现在就做！
> 
> > 你看到我们如何使用上面的值，比如最常播放次数或最短高度，来获取相应的歌曲或人了吗？

关键是编写一个查询，涉及到此值的相应表格。例如：

```
tallest-people = sieve people using height:
  height = tallest-height
end

most-played-songs = sieve playlist using play-count:
  play-count = most-played-count
end
```

我们小心翼翼地始终使用复数——<wbr>人、歌曲——<wbr>而不是单数，有其原因。这是因为我们无法确定只有一个人或一个歌曲具有这个高度或播放次数。也就是说，列表中有一个最大值或最小值，因为该值没有其他信息（因此来自两个不同人的相同高度，或者来自两首不同歌曲的相同播放次数，在列表中看起来是相同的）。但是当重新放回到原始表格的上下文中时，其他值可能会不同。简而言之，我们的整体答案非常简单地计算出来：

```
pcs = extract play-count from songs end
most-played-count = list-max(pcs)
keep-if playlist using play-count:
  play-count = most-played-count
end
```

和

```
hts = extract height from people end
tallest-height = list-max(hts)
keep-if people using height:
  height = tallest-height
end
```

> 练习
> 
> > 实现 基本统计问题 中提出的所有其他统计问题。

到目前为止，我们只看到了如何使用列表上的内置函数。接下来[处理列表]，我们将学习如何创建自己的函数来处理列表。一旦我们学会了，这些列表处理函数将会变得强大，但不再显得那么神奇，因为我们将能够自己构建它们！

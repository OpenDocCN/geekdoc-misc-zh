# 20 状态、变化和更多的等式

|     20.1 一个标准的可变结构 |
| --- |
|     20.2 什么是相同的含义 |
|     20.3 递归和突变的循环 |
|       20.3.1 部分定义 |
|       20.3.2 递归函数 |
|       20.3.3 过早评估 |
|       20.3.4 循环列表与流 |
|     20.4 从标识符到变量 |
|     20.5 突变与闭包的交互：计数器 |
|       20.5.1 使用盒子的实现 |
|       20.5.2 使用变量的实现 |
|     20.6 一个等价断言的家族 |
|       20.6.1 一个等级制度的等价 |
|       20.6.2 空间和时间复杂度 |
|       20.6.3 比较函数 |

## 20.1 一个标准的可变结构

正如我们所激发的（检查组件连通性），有时更改数据值而不仅仅是构造具有更新值的新数据是很好的。更改它的主要优势是每个引用它的值现在都可以看到这个更改。更改它的主要缺点是每个引用它的值现在都可以看到这个更改。因此，负责地使用这种能力是一项重要的编程挑战。

将这个想法简单化，让我们考虑最简单的可变数据的最简单的情况：只有一个字段的数据。我们称之为一个盒子，并将其视为一个新的容器类型。盒子将支持三个操作：

1.  盒子消耗一个值并创建一个包含该值的可变盒子。

1.  unbox 消耗一个盒子并返回盒子中包含的值。

1.  set-box 消耗一个盒子、一个新值，并将盒子更改为包含该值。该盒子的所有后续 unbox 将返回新值。 

在一个类型化的语言中，我们要求通过 set-box 放入盒子中的新值与之前放入的值在类型上一致。（即使在一个不是静态类型的语言中，我们可能也期望保持编程过程的理智。）因此，您可以将一个盒子看作是一个等价于具有参数化类型的 Java 容器类，它具有一个带有 getter 和 setter 的单个成员字段：盒子是构造函数，unbox 是 getter，set-box 是 setter。（因为只有一个字段，所以它的名称是无关紧要的。）

| class Box<T> { |
| --- |
|     private T the_value; |
|     Box(T v) { |
|         this.the_value = v; |
|     } |
|     T get() { |
|         return this.the_value; |
|     } |
|     void set(T v) { |
|         this.the_value = v; |
|     } |
| } |

相应地，这是 Pyret 中盒子的定义：

```
data Box:
  | box(ref v)
where:
  n1 = box(1)
  n2 = box(2)
  n1!{v : 3}
  n2!{v : 4}
  n1!v is 3
  n2!v is 4
end
```

请注意，在 Pyret 中，因为默认情况下值是不可变的，我们必须使用 ref 显式声明 v 字段为可变；可变字段必须使用!而不是.来访问，即点运算符。使用不同语法的原因是警告程序员，从该字段获取的值可能会随时间变化，因此他们不应该对其寿命做出假设。然而，由于 Pyret 是单线程的，他们可以假设该值在同一过程中的下一次变异之前，或者在另一个过程的下一次调用或从该过程返回之前保持不变，以最快到来的那个时间点。

> 现在！
> 
> > 为什么我们在上面说“类型一致”而不是“相同类型”？

这些值可能通过子类型关联（子类型）。

> 练习
> 
> > 对于寿命的评论是什么意思？这如何适用于重用从字段中提取的值？

## 20.2 什么是相同的含义

现在我们已经看到了变异，我们现在能够理解 Pyret 的相同操作的含义（重新审视相等性）。考虑对这两个盒子和对它们的三个引用的检查：<three-boxes> ::=

|   b0 = box("a value") |
| --- |
|   b1 = box("a value") |
|   b2 = b1 |

注意到 b1 和 b2 引用的是同一个盒子，而 b0 引用的是另一个盒子。我们可以看到这一点，因为以下测试通过：

```
check:
  b0!v == b1!v is true
  b0 is-not%(identical) b1
  b1 is%(identical) b2
  b1!v is b2!v
end
```

换句话说，b1 和 b2 是彼此的别名：它们是同一个值的两个不同名称。相反，没有一个名称是 b0 引用的值的别名。由于相同是传递的，根据上述两个检查，可以得出 b0 不等同于 b2。到目前为止，这种区别具有有限的相关性。然而，变异引入了一个问题：如果我们改变一个值，所有指向该值的别名都会检测到变化。我们将以稍微复杂的方式执行此变异，稍后我们将解释：<modify-b1> ::=

|   hold-b1-value = b1!v |
| --- |
|   b1!{v: "a different value"} |

请注意，如果您只是在编辑器中依次复制这些定义和测试，应该成功的测试将失败。这是因为 Pyret 将所有测试块移动到程序的末尾，因此检查不是在编写它们的源位置运行的。到目前为止，这没有任何区别。现在我们有了变异，这就有了很大的不同。因此，您需要在添加修改状态的新代码时擦除旧���试。因为这就是状态的目的：以前为真的陈述现在不再是真的。有了这个，我们现在有了：

```
check:
  b0!v == b1!v is false
  b0 is-not%(identical) b1
  b1 is%(identical) b2
  b1!v is b2!v
end
```

之后我们可以恢复值：

```
b1!{v: hold-b1-value}
```

继续这样做，对称地，我们也可以修改绑定到 b2 的值，并确保通过 b1 可见更改：

```
b2!{v: "yet another value"}

check:
  b0!v == b1!v is false
  b0 is-not%(identical) b1
  b1 is%(identical) b2
  b1!v is b2!v
end
```

相比之下，如果我们修改了由 b0 引用的盒子的内容，那么以前持有的唯一事实不再持有的是这个：

```
b0!{v: "yet another value"}
check:
  b0!v is-not b1!v
end
```

因此，尽管以前这两个盒子在结构上是相同的，但现在它们甚至都不是前者（但仍然不是后者）。

现在，我们为什么要保留并恢复值呢？这是因为在每个序列的末尾，所有值都已恢复，但是通过进行更改，我们已经能够观察到哪些其他名称检测到更改，哪些名称没有—<wbr>换句话说，哪些名称是别名，哪些不是—<wbr>换句话说，我们已经实现了 identical 的本质。

在实践中，identical 并不是这样行为：这将是太破坏性的—<wbr>例如，如果这个假值被保存到持久存储，然后系统崩溃—<wbr>而且如果系统有多个线程，它也是可观察到的。它也不是可能的最有效的实现。尽管如此，它确实展示了 identical 背后的基本思想：当你对一个值进行更改时，当你在“另一个”上看到更改时，两个值是相同的（即，实际上只有一个值）。

## 20.3 递归和变异循环

变异也可以帮助我们理解递归。让我们返回到我们之前尝试编写的例子（从非循环到循环）：

```
web-colors = link("white", link("grey", web-colors))
```

如我们所注意到的那样，这并不合规，因为 web-colors 没有绑定在=的右边。（为什么不呢？因为如果我们尝试在右边替换 web-colors，我们会陷入无限循环。）这件事情应该让你有点怀疑：我们一直能够毫无困难地编写递归函数。它们为什么不同？有两个原因：

+   第一个原因是我们正在定义一个函数。函数的主体不会立即评估—<wbr>只有当我们应用它时—<wbr>所以语言可以等待主体完成定义。（我们马上会看到这可能意味着什么。）

+   第二个原因实际上并不是原因：函数定义实际上是特殊的。但我们即将揭示它们的特殊之处—<wbr>它是使用了一个盒子！—<wbr>以便任何定义都可以利用它。

回到我们上面的例子，回想一下我们不能使用链接来制作我们的列表，因为我们希望列表永远不会终止。因此，让我们首先定义一个新的数据类型来保存循环列表。

```
data CList: clink(v, r) end
```

注意我们已经小心避免编写字段的类型定义；相反，我们会试着一边进行，一边弄清楚它们。但是，如此书写的定义却不能起作用。

> 现在动手！
> 
> > 你看明白了吗？

让我们将预期的无限列表分解为两部分：以白色开头的列表和以灰色开头的列表。白色之后是什么？灰色列表。灰色之后是什么？白色列表。很明显我们无法写下这两个定义，因为其中一个必须在另一个之前，但每一个又依赖于另一个。（这与尝试编写单个定义的问题相同。）

### 20.3.1 部分定义

相反，我们需要部分定义每个列表，然后使用另一个列表完成定义。然而，使用上述定义是不可能的，因为一旦构建就无法更改任何内容。因此，我们需要：

```
data CList: clink(v, ref r) end
```

请注意，这种数据类型缺少基本情况，这应该让你想起我们在从函数生成流中看到的定义。利用这一点，我们可以定义：

```
white-clink = clink("white", "dummy")
grey-clink = clink("grey", "dummy")
```

每个定义本身都相当无用，但它们代表了我们想要的内容，并且它们有一个可变字段用于其余部分，目前保存着一个虚拟值。因此，很明显我们接下来必须做的是：更新可变字段。

```
white-clink!{r: grey-clink}
grey-clink!{r: white-clink}
```

因为我们规定我们的颜色必须交替以白色开头，这就完成了我们的定义：

```
web-colors = white-clink
```

如果我们要求 Pyret 检查 web-colors 的值，我们会注意到它使用算法来防止遍历无限对象。我们可以定义一个辅助函数 take，我们之前看到的变体（从函数生成流），来检查无限列表的有限前缀：

```
fun take(n :: Number, il :: CList) -> List:
  if n == 0:
    empty
  else:
    link(il.v, take(n - 1, il!r))
  end
end
```

使得：

```
check:
  take(4, web-colors) is
  [list: "white", "grey", "white", "grey"]
end
```

### 20.3.2 递归函数

基于此，我们现在可以理解递归函数。考虑一个非常简单的例子，比如这个：

```
fun sum(n):
  if n > 0:
    n + sum(n - 1)
  else:
    0
  end
end
```

我们可能认为这等同于：

```
sum =
  lam(n):
    if n > 0:
      n + sum(n - 1)
    else:
      0
    end
  end
```

但如果你输入这个，Pyret 将抱怨 sum 没有绑定。我们必须改为写成

```
rec sum =
  lam(n):
    if n > 0:
      n + sum(n - 1)
    else:
      0
    end
  end
```

你认为 rec 做了什么？它将 sum 绑定到最初包含虚拟值的盒子中；然后在名称被绑定的环境中定义函数，解除名称的使用；最后，它用定义的函数替换盒子的内容，遵循我们之前为 web-colors 看到的相同模式。

### 20.3.3 过早的评估

注意上述描述揭示了在创建名称和为其赋值之间存在一段时间。这个中间状态能被观察到吗？当然可以！

通常有三种解决这个问题的方法：

1.  确保值足够模糊，以至于永远无法在有意义的上下文中使用。这意味着像 0 这样的值特别糟糕，实际上大多数常见的数据类型都应该避免使用。事实上，在此处已经使用的没有值可以在某些上下文中不会引起混淆。

1.  语言可能会为此创建一种新类型的值。例如，想象一下这个 CList 的定义：

    ```
    data CList:
      | undef
      | clink(v, ref r)
    end
    ```

    似乎 undef 是一个“基本情况”，因此使 CList 非常类似于 List。然而，事实上，undef 仅存在于第一次发生突变之前，之后将永远不会再次出现：意图是 r 仅包含对其他 clink 的引用。

    现在，语言可以使用未定义的值来检查循环列表的过早使用。然而，尽管从技术上讲这是可行的，但它会带来运行时的惩罚。因此，这种检查通常只由专注于教学的语言执行；假定专业程序员能够自行处理此类过早使用的后果。

1.  只允许在绑定函数的情况下使用递归构造函数，然后确保绑定的右侧在语法上是一个函数。这种解决方案排除了一些合理的程序，但肯定是安全的。

### 20.3.4 循环列表与流

如上所述，上述颜色列表示例非常类似于流示例。两种定义无限数据的方式之间有什么关系？

循环列表的简单性很有优势。上面使用的定义模式实际上可以通过解糖（解糖：扩展语言而不增大它 = y+3 中，我们说 y 是一个“变量”。之所以称其为变量，是因为它在调用之间变化；然而，在每次调用中，它在其范围内具有相同的值。到目前为止，我们的标识符对应于这种数学上的变量概念。如果标识符绑定到一个盒子，则它仍然绑定到相同的盒子值。变化的是盒子的内容，而不是标识符绑定到的盒子。相比之下，编程变量甚至在每次调用中也可以变化，就像上面的 Java 中的 x 一样。

从现在开始，当我们指的是其值可以在其范围内变化的标识符时，我们将使用“变量”，而当无法发生这种情况时，我们将使用“标识符”。如果有疑问，我们可能会保守地使用“变量”；如果差异并不真正重要，我们可能会同时使用两者。比起纠缠于这些具体术语，更重要的是理解它们代表了一个重要的区别（变异：结构和变量）。

## 20.5 变异与闭包的相互作用：计数器

假设我们想要创建一个计算自身被调用次数的函数。此外，让我们假设我们可以根据需要创建新的计数器。因此，`mk-counter`每次都会创建一个新的计数器，每个计数器都会保持其自己的计数历史记录。一个示例用法可能如下所示：

```
check:
  l1 = mk-counter()
  l1() is 1
  l1() is 2
  l2 = mk-counter()
  l2() is 1
  l1() is 3
  l2() is 2
end
```

注意，每次调用`mk-counter`都会创建一个新的计数器，因此两个单独调用所创建的计数器不会相互干扰。

现在我们看到了如何使用可变结构（具体来说是盒子）和变量来实现这一点。

### 20.5.1 使用盒子实现

这是实现：

```
fun mk-counter():
  ctr = box(0)
  lam():
    ctr!{v : (ctr!v + 1)}
    ctr!v
  end
end
```

这为什么有效？因为每次调用`mk-counter`都只创建一个盒子，并将其绑定到`ctr`上。闭包闭合在这个盒子上。所有后续的变异都影响同一个盒子。相比之下，交换两行会有很大的区别：

```
fun mk-broken-counter():
  lam():
    ctr = box(0)
    ctr!{v : (ctr!v + 1)}
    ctr!v
  end
where:
  l1 = mk-broken-counter()
  l1() is 1
  l1() is 1
  l2 = mk-broken-counter()
  l2() is 1
  l1() is 1
  l2() is 1
end
```

在这种情况下，每次调用时都会分配一个新的盒子，不是`mk-broken-counter`的调用，而是它返回的函数，因此每次的答案都是相同的（尽管过程内有变异）。我们的盒子实现应确保保留这种区别。

上述示例暗示了一个实现的必要性。显然，由`mk-counter`返回的过程中环境闭合的内容必须每次都引用同一个盒子。但是还需要确保该盒子中的值每次都不同！仔细看看：它在词法上必须相同，但在动态上不同。这种区别将成为实现状态的策略的核心（变异：结构和变量）。

### 20.5.2 使用变量实现

使用变量的实现几乎是相同的：

```
fun mk-counter():
  var ctr = 0
  lam():
    ctr := ctr + 1
    ctr
  end
where:
  l1 = mk-counter()
  l1() is 1
  l1() is 2
  l2 = mk-counter()
  l2() is 1
  l1() is 3
  l2() is 2
end
```

而且，如果我们交换同样关键的两行，我们会得到错误的行为：

```
fun mk-broken-counter():
  lam():
    var ctr = 0
    ctr := ctr + 1
    ctr
  end
where:
  l1 = mk-broken-counter()
  l1() is 1
  l1() is 1
  l2 = mk-broken-counter()
  l2() is 1
  l1() is 1
  l2() is 1
end
```

## 20.6A 一系列相等的谓词

到目前为止，我们已经看到了两种相等的概念：

+   二元运算符==，它也被用作等号比较在测试时。

+   identical，也写作<=>。

然而，我们还没有讨论==的确切含义，事实证明它有两种可能的含义，这使我们得到了三种不同的相等概念。要了解这一点，请刷新您对我们的三个盒子的记忆。我们已经涵盖了 identical 的含义。然而，还有一个直观层面，在那里它是不令人满意的：当我们的相等概念是，“在打印（作为输出）或写入（作为输入）时，这两个值看起来一样吗？”，其中 box("一个值")和 box("一个值")是“相同的”。也就是说，很好有一个等号运算符——叫它 E1——使得

```
check:
  E1(b0, b1) is true
  E1(b1, b2) is true
end
```

因为当作为值写出时，所有三个看起来都是一样的。然而，正如我们刚才看到的（相等的含义），这些等价关系可能是暂时的。当我们修改 b1 时（见上文），显然这些不再打印相同：

| > b0 |
| --- |
| box("一个值") |
| > b1 |
| box("不同的值") |
| > b2 |
| box("不同的值") |

因此我们会期望

```
check:
  E1(b0, b1) is false
  E1(b1, b2) is true
end
```

实际上，Pyret 中有这样一个运算符，它被称为 equal-now，并且以=~（~的意思是手指挥，因为值现在是相等的，但你不应该假设它将来也是这样）作为二元运算符编写。正如名称和视觉所暗示的，这是一个脆弱的运算符：如果值是可变的，你不应该写一些假设长期相等的值的程序。然而，知道是否在此时两个值实际上“打印相同”仍然是有用的。  

> 练习
> 
> > 确认 equal-now 确实具有上面 E1 所赋予的属性。

然而，这仍然不能让我们区分==和 identical：

```
check:
  (b0 == b1) is false
  (b1 == b2) is true
  identical(b0, b1) is false
  identical(b1, b2) is true
end
```

为此，有一个稍微丰富的结构会有所帮助：

```
b0 = box("a value")
b1 = box("a value")
b2 = b1
l0 = [list: b0]
l1 = [list: b1]
l2 = [list: b2]
```

注意，尽管其中两个共享相同的可变盒子，但我们正在分配三个不同的列表。现在我们发现了一些有趣的东西。毫不奇怪，以下内容是真实的：

```
check:
  identical(l0, l1) is false
  identical(l1, l2) is false
end
```

而

```
check:
  equal-now(l0, l1) is true
  equal-now(l1, l2) is true
end
```

然而：

```
check:
  (l0 == l1) is false
  (l1 == l2) is true
end
```

==可能代表什么与 identical 和 equal-now 有趣地不同？ 当它返回 true 时，是两个值“现在和将来都会“打印相同”。这是怎么可能的？这是因为==递归地检查两个参数是否结构相同，直到它到达一个可变字段为止；在那一点上，它检查它们是否是相同的。如果它们是相同的，那么对其中一个进行的任何更改都将反映在另一个上（因为它们实际上是同一个可变字段）。这意味着它们的内容也将始终“打印相同”。因此，我们现在可以揭示==的名称：它是 equal-always。

### 20.6.1A 相等的等级结构

注意，如果两个值 v1 和 v2 现在相等，则它们不一定总是相等；如果它们总是相等，则它们不一定相同。我们已经在上面看到了这两种情况的例子。

相反，如果两个值是相同的，那么它们肯定是总是相等的。这是因为它们的可变字段缩减为相同，而不可变部分——<wbr>将被结构性地遍历——<wbr>保证产生相等性，实际上是相同的值。反过来，如果它们满足总是相等，它们肯定是现在相等的，因为唯一的区别是现在相等结构性地遍历可变字段的内容，但如果这些字段是相同的（因为它们必须是总是相等的），它们肯定是结构上相等的。

在大多数语言中，通常会有两个相等运算符，对应于相同（称为引用相等）和现在相等（称为结构相等）。Pyret 是罕见的，它有第三个运算符，总是相等。对于大多数程序来说，这实际上是最有用的相等运算符：它不过分关注可能难以预测的别名细节；同时，它做出的决定经得起时间的考验，因此形成了各种优化的有用基础（甚至可能不意识到它们的时间假设）。这就是为什么在测试中默认使用总是相等，并迫使用户明确选择不同的原始操作符。

### 20.6.2 空间和时间复杂度

总是相同的时间始终为常数。实际上，一些程序正是因为它们想要常数时间的相等性，才使用相同的。它们精心构造程序，使应该被视为相等的值是对同一值的别名。当然，保持这种编程纪律是棘手的。

现在相等和总是相等都必须至少遍历数据的不可变部分。因此，它们的时间与较小的数据成正比（因为如果两个数据大小不同，则它们肯定不相等，因此没有必要访问额外的数据）。区别在于，总是相等将缩减到引用上的相同，因此执行的计算量比现在相等要少。

对于某些程序，检查相等性的成本可能相当大。这样的程序可以采用两种常见策略：

1.  使用快速检查，只在必要时使用较慢的检查。例如，假设我们想加速相等性检查，并且有理由相信我们经常比较相同的元素和/或被比较的值非常大。然后我们可以定义：

    ```
    fun my-eq(v1, v2) -> Boolean:
      identical(v1, v2) or equal-always(v1, v2)
    end
    ```

    其行为如下：

    ```
    check:
      my-eq(b0, b1) is false
      my-eq(b1, b2) is true
      my-eq(l0, l1) is false
      my-eq(l1, l2) is true
    end
    ```

    当可以使用相同的而不必遍历数据时，其行为与总是相等的行为完全相同，但速度更快。 （注意，这是一种安全的优化，因为相同意味着总是相等。）

1.  如果可能的话，完全使用不同的等价策略：参见哈希表重复利用的集合成员资格。

### 20.6.3 比较函数

我们实际上并没有提供关于等价性的全部真相，因为我们还没有讨论函数。定义函数的等价性——尤其是外延等价，即两个函数是否具有相同的图，即对于每个输入产生相同的输出——是复杂的（一种委婉说法是不可能的）由于停机问题[REF]。

因此，大多数语言都倾向于使用函数等价的近似值，最常见的是引用等价。然而，这是一个非常弱的近似值：即使在相同的环境中分配了完全相同的函数文本作为两个不同的闭包，它们也不会引用相等。至少当这是作为相同的定义的一部分时，这是有意义的；然而，如果其他运算符这样做，它们实际上是在撒谎，而这是等价运算符通常不会做的事情。

我们可以采取另一种方法：简单地禁止函数比较。这就是 Pyret 所做的：如果您尝试比较两个函数，所有三个等价性运算符将导致错误。 （但是，您可以与一个函数进行比较，并且您将得到错误答案。）这确保了语言的比较运算符永远不会被错误地信任。

Pyret 的选择是允许在相同情况下的函数引用相等，并且只在另外两种情况下出错。然而，如果这样做，它将违反上述链式推论（等价性的层次结构）。目前的设计可以说更加优雅。希望使用函数引用相等的程序员可以简单地将函数嵌入可变结构，如盒子。

当比较两个函数时出现一个问题：一个完全通用的比较两个任意值的程序必须要进行防御性编写。因为这很烦人，Pyret 提供了上述三个运算符的三值版本（identical3，equal-always3 和 equal-now3），它们都返回对应于真、假和无知（当两个参数都是函数时返回）的 EqualityResult 值。如果程序员对参数的类型不确定，可以使用这个版本替换布尔值比较运算符。

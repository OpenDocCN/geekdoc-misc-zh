# 32 对象：解释与类型

|     32.1 解释对象 |
| --- |
|     32.2 对象的展开 |
|       32.2.1 对象作为命名集合 |
|       32.2.2 构造函数 |
|       32.2.3 状态 |
|       32.2.4 私有成员 |
|       32.2.5 静态成员 |
|       32.2.6 带自引用的对象 |
|         32.2.6.1 使用突变的自引用 |
|         32.2.6.2 无突变的自引用 |
|       32.2.7 动态分派 |
|     32.3 成员访问设计空间 |
|     32.4 其他是什么？ |
|       32.4.1 类 |
|       32.4.2 原型 |
|       32.4.3 多重继承 |
|       32.4.4 超级棒！ |
|       32.4.5 混合和特性 |
|     32.5 对象分类和对象相等性 |
|     32.6 对象类型 |
|       32.6.1 子类型 |
|         32.6.1.1 子类型函数 |
|         32.6.1.2 子类型和信息隐藏 |
|         32.6.1.3 实现子类型 |
|       32.6.2 自引用的类型 |
|       32.6.3 名义类型 |

当一种语言接受函数作为值时，它提供给开发者最自然的方式来表示计算单元。假设一个开发者想要给一些函数 f 参数化。任何语言都允许 f 被被被动数据参数化，比如数字和字符串。但是往往会吸引人们用活跃数据来参数化它：一个能够计算答案的数据，也许是对某些信息的响应。此外，传递给 f 的函数可以——<wbr>假设词法作用域函数——引用调用者的数据，而不必将这些数据透露给 f，从而为安全性和隐私提供了基础。因此，词法作用域函数对于许多安全编程技术的设计至关重要。

虽然函数是一件很棒的事情，但它过于简洁。有时我们可能希望多个函数都闭合到相同的共享数据上；如果其中一些函数对其进行了变异并期望其他函数看到这些变异的结果，那么共享尤为重要。在这种情况下，仅发送一个函数作为参数变得难以控制；将一组函数发送更有用。接收者然后需要一种方法来在组中选择不同的函数。这些函数的分组以及从组中选择一个的方法是对象的本质。因此，我们在涵盖函数（任何地方的函数）、变异（变异：结构和变量）和递归（从变异中的递归和循环）之后，完全适合研究对象。

我无法对对象系统的巨大空间做出公正的评价。请阅读Éric Tanter 的[面向对象编程语言：应用与解释](http://users.dcc.uchile.cl/~etanter/ooplai/)，该书详细介绍了这个概念，并涵盖了这里忽略的主题。让我们将对象的这个概念添加到我们的语言中。然后我们将充实它并发展它，并探索对象设计空间中的许多维度。我们首先将展示如何将对象添加到核心语言中，但因为我们希望快速原型化许多不同的想法，我们很快就会转向基于 desguaring 的策略。您使用哪种取决于您是否认为理解它们对于理解您的语言的本质至关重要。衡量这一点的一种方法是您的 desguaring 策略变得多么复杂，以及通过添加一些关键的核心语言增强，您是否可以大大减少 desugaring 的复杂性。

## 32.1 解释对象

对象的最简单概念——几乎所有谈论对象的人都同意的唯一事情——是对象是

+   一个值，那

+   将名称映射到

+   东西：其他值或“方法”。

从极简主义的角度来看，方法似乎只是函数，而由于语言中已经有了这些函数，我们可以将这种区别放在一边。我们即将发现，“方法”与函数非常接近，但在它们被调用的方式和/或绑定在其中的内容方面有重要的区别。从具有变量的语言开始，让我们通过将其添加到核心语言中来定义对象的这个非常简单的概念。我们显然必须扩展我们对值的概念：

```
data Value:
  | numV(n :: Number)
  | closV(f :: ExprC, e :: List<Binding>)
  | objV(ns :: List<String>, vs :: List<Value>)
end
```

我们将扩展表达式语法以支持字面对象构造表达式：请注意，这已经是一个设计决策。在一些语言中，比如 JavaScript，开发人员可以编写字面对象：这个概念如此流行，以至于 JavaScript 中的一部分语法已经成为 Web 标准，即 JSON。在其他语言中，比如旧版本的 Java，对象只能通过在类上调用构造函数来创建。我们可以通过假设模拟后一种语言，必须按照一种风格化的约定在特殊位置写入对象字面量，就像我们在下面展开时所做的那样。

```
| objC(ns :: List<String>, vs :: List<ExprC>)
```

评估这样的对象表达式很容易：我们只需评估其每个表达式位置。然而，在存在状态的情况下，我们必须小心地传递存储：

```
| objC(ns, vs) =>
  obj-vs = eval-obj-vs(vs, nv, st)
  ret(objV(ns, obj-vs.exprs), obj-vs.final-store)
```

> 练习
> 
> > 编写 eval-obj-vs，它在传递存储的同时评估 vs 中的每个表达式。假设它返回一个具有两个字段的对象：exprs 是评估表达式的列表，而 final-store 是由这些评估产生的最终存储。

不幸的是，我们实际上无法使用对象，因为我们无法获取其内容。因此，我们应该添加一个操作来提取成员：<msgC-def> ::=

|   &#124; msgC(o :: ExprC, n :: String) |
| --- |

其行为是直观的：

```
| msgC(o, n) =>
  o-val = interp(o, nv, st)
  msg = lookup-msg(n, o-val.v)
  ret(msg, o-val.st)
```

> 练习
> 
> > 实现 lookup-msg。

原则上，msgC 可以用于获取任何类型的成员，但为简单起见，我们只需要假设我们有函数。要使用它们，我们必须将它们应用于值。直接编写这样的代码很麻烦，所以让我们假设解糖已经为我们处理了：也就是说，用户可以编写(msg o m v)—<wbr>其中 o 评估为一个对象，m 命名一个方法，v 评估为一个参数值—<wbr>这将解糖为使用 msgC 获取方法和常规应用来应用它。为了说明，我们假设方法只接受一个参数。这很容易放宽。请注意，在一个 Lispy 语言中，我们可以写成(define (msg o m . a) (apply (o m) a))，这样就可以让 msg 接受任意数量的参数。

有了这个，我们就有了一个完整的带有对象的第一语言。例如，这里是一个对象定义和调用：

| (let o (obj (add1 (lambda x (+ x 1))) |
| --- |
|             (sub1 (lambda x (+ x -1)))) |
|   (msg o sub1 2)) |

这将评估为(numV 1)。

## 32.2 通过解糖实现对象

在核心语言中定义对象是理解它们本质的好方法，但这是一个笨拙的学习方式。相反，我们将使用 Pyret 来表示对象，坚持使用我们已经知道如何在解释器中实现的语言部分。也就是说，我们假设我们正在看解糖的输出。（因此，我们也将坚持风格化的代码，可能会写入不必要的表达式，因为这是一个简单程序生成器会产生的内容。）

> 练习
> 
> > 接下来的代码基本上省略了类型注解。请回去添加尽可能多的注解；如果无法添加，请解释遇到的问题。参见对象类型。

### 32.2.1 对象作为命名集合

让我们从复制上面的对象语言开始。一个对象只是一个根据给定名称调度的值。为简单起见，我们将使用匿名函数来表示对象，并使用条件来实现调度。注意，基本对象是匿名函数的一般化，具有多个“入口点”。相反，匿名函数是具有只有一个入口点的对象，因此它不需要“方法名称”来消除歧义。\<obj-o-1> ::=

|   o-1 = |
| --- |
|     lam(m): |
|       if m == "add1": |
|         lam(x): x + 1 end |
|       else if m == "sub1": |
|         lam(x): x - 1 end |
|       else: |
|         raise("message not found: " + m) |
|       end |
|     end |

这是我们之前定义的同一个对象，并且我们以同样的方式使用它的方法：

```
check: o-1("add1")(5) is 6 end
```

当然，使用这些嵌套的函数调用来写方法调用是笨拙的（而且即将变得更加笨拙），所以最好给自己配备一个方便的语法来调用方法，我们可以在这里定义为一个函数：

```
fun msg(o, m, a): o(m)(a) end
```

这使我们能够重写我们的测试：

```
check: msg(o-1, "add1", 5) is 6 end
```

> 现在就行动吧！
> 
> > 当我们切换到解糖策略时，有一件非常重要的事情发生了变化。你看到了吗？

回想一下我们之前的语法定义：<msgC-def>。消息的“名称”位置非常明确地是一个语法字符串。也就是说，用户必须在那里写入方法的文字名称。在我们解糖的版本中，名称位置只是一个必须求值为字符串的表达式；这允许用户编写以下内容：

```
check: msg(o-1, "add" + "1", 5) is 6 end
```

这可能完全不是预期的行为（成员访问设计空间）。

解糖的一个普遍问题是：目标语言可能允许在源语言中没有对应物的计算，因此无法将其映射回去。幸运的是，我们通常不需要执行这种逆映射，尽管它在某些调试和程序理解工具中会出现。然而，更微妙的是，我们必须确保目标语言不会产生在源语言中没有对应等价物的值。

现在我们有了基本对象，让我们开始添加我们期望从大多数对象系统中看到的特性。但在继续之前，将对象定义为一个显式条件是不方便的；我们宁愿写一个更具声明性的映射，从名称到方法，然后将查找的实现留给语言。毕竟，这是每个面向对象定义提供的关键原语之一。也就是说，我们希望将先前的对象（<obj-o-1>）写成

```
o-1-1 = mk-object(
  [list:
    mtd("add1", lam(x): x + 1 end),
    mtd("sub1", lam(x): x - 1 end) ] )
```

并且为了支持这一点，我们定义了数据类型

```
data Mtd:
  | mtd(name :: String, value)
end
```

以及相应的函数

```
fun mk-object(n-vs):
  lam(m):
    fun lookup(locals):
      cases (List) locals:
        | empty => raise("message not found: " + m)
        | link(f, r) =>
          if f.name == m: f.value else: lookup(r) end
      end
    end
    lookup(n-vs)
  end
end
```

使用这种更简单的表示法——<wbr>甚至不需要解糖即可实现——<wbr>我们现在更能够处理对象系统特性的研究。

### 32.2.2 构造函数

构造函数简单地说就是在对象构造时调用的函数。我们目前缺少这样的函数。通过将对象从字面值转换为带有构造函数参数的函数，我们实现了这一效果：

```
o-constr-1 =
  lam(x):
    mk-object( [list: mtd("addX", lam(y): x + y end) ])
  end

check:
  msg(o-constr-1(5), "addX", 3) is 8
  msg(o-constr-1(2), "addX", 3) is 5
end
```

在第一个例子中，我们将 5 作为构造函数的参数传递，所以添加 3 得到 8。第二个例子类似，并且显示了两次构造函数调用不会相互干扰。

### 32.2.3 状态

许多人认为对象主要存在于封装状态。阿兰·凯（Alan Kay）为发明 Smalltalk 和现代对象技术而获得图灵奖的人不同意。在《Smalltalk 的早期历史》（The Early History of Smalltalk）中，他说：“[OOP 的小规模动机] 是找到一种更灵活的赋值版本，然后尝试完全消除它”。他补充道：“不幸的是，今天被称为‘面向对象编程’的许多东西只是带有更复杂结构的旧式编程。许多程序现在充斥着更昂贵的附加过程执行的‘赋值式’操作。”我们当然没有失去这种能力。如果我们将语言解糖为带有变量的语言（我们可以等效地使用箱子，作为稍微增加解糖开销的代价），我们可以很容易地让多个方法改变共同状态，比如构造函数参数：

```
o-state-1 =
  lam(count):
    var mut-count = count
    mk-object(
      [list:
        mtd("inc", lam(n): mut-count := mut-count + n end),
        mtd("dec", lam(n): mut-count := mut-count - n end),
        mtd("get", lam(_): mut-count end) ] )
  end
```

例如，我们可以测试一系列操作：

```
check:
  o = o-state-1(5)
  msg(o, "inc", 1)
  msg(o, "dec", 1)
  msg(o, "get", "dummy") is 5
end
```

还要注意，改变一个对象不会影响另一个对象：

```
check:
  o1 = o-state-1(5)
  o2 = o-state-1(5)
  msg(o1, "inc", 1)
  msg(o1, "inc", 1)
  msg(o1, "get", "dummy") is 7
  msg(o2, "get", "dummy") is 5
end
```

### 32.2.4 私有成员

另一个常见的对象语言特性是私有成员：仅在对象内部可见，而在外部不可见。除了在 Java 中，同一类型的其他类的实例可以访问“私有”成员。否则，你根本无法实现对抽象数据类型的近似。这些看起来可能是我们需要实现的附加功能，但我们已经通过局部作用域、词法绑定变量等形式拥有了必要的机制，比如上面的 mut-count：外部代码无法直接访问 mut-count，因为词法作用域确保它对世界保持隐藏。

### 32.2.5 静态成员

对象的另一个常用特性是静态成员：对于“相同”类型的所有实例都是共同的成员。我们用引号是因为对象的“相同性”有许多不同的概念。然后一些。然而，这仅仅是一个词法作用域的标识符（使其私有），它存在于构造函数之外（使其对构造函数的所有用法都是共同的），比如下面的 counter：

```
mk-bank-account =
  block:
    var counter = 0
    lam(amount):
      var balance = amount
      counter := counter + 1
      mk-object(
        [list:
          mtd("deposit", lam(m): balance := balance + m end),
          mtd("withdraw", lam(m): balance := balance - m end),
          mtd("balance", lam(_): balance end),
          mtd("how-many-accounts", lam(_): counter end) ])
    end
  end
```

我们已经将计数器增量写在了“构造函数”应该出现的地方，尽管它同样可以在方法内部操作。这遵循以下测试：

```
check:
  acc-1 = mk-bank-account(0)
  msg(acc-1, "how-many-accounts", "dummy") is 1
  acc-2 = mk-bank-account(100)
  msg(acc-1, "how-many-accounts", "dummy") is 2
  msg(acc-2, "how-many-accounts", "dummy") is 2
  msg(acc-1, "deposit", 100)
  msg(acc-1, "withdraw", 50)
  msg(acc-2, "deposit", 10)
  msg(acc-1, "balance", "dummy") is 50
  msg(acc-2, "balance", "dummy") is 110
  msg(acc-1, "how-many-accounts", "dummy") is 2
  msg(acc-2, "how-many-accounts", "dummy") is 2
end
```

请注意，不同的对象会影响到其他对象看到的结果。

### 32.2.6 具有自引用的对象

直到现在，我们的对象只是一组命名函数的打包，因此给定了不同的命名入口点。我们已经看到，在对象系统中被认为重要的许多特性实际上只是函数和作用域上的简单模式，而且确实已经被程序员使用了几十年，他们使用具有词法作用域的匿名函数（没有为它们分配名称）。

实际上区分对象系统的一个特征是，每个对象都自动配备了一个指向相同对象的引用，通常称为 self 或 this。我更喜欢这种略显干燥的表达方式，而不是对象倡导者经常采用的拟人化的“了解自己”术语。事实上，请注意，我们已经深入了解对象系统属性，而无需诉诸拟人化。我们能轻松实现这个吗？

### 32.2.6.1 使用变异的自引用

是的，我们可以，因为当我们实现递归时，我们已经看到了这个模式；我们只需将其调整为不引用相同的盒子或函数，而是引用相同的对象。

```
o-self =
  block:
    var self = "dummy"
    self :=
      mk-object(
          [list:
            mtd("first",
              lam(v): msg(self, "second", v + 1) end),
            mtd("second",
              lam(v): v + 1 end )])
    self
  end
```

请注意，这正是适当调整的递归模式（来自变异的递归和循环）。我们已经测试过它让"first"调用自己的"second"方法。果然，这产生了预期的答案：

```
check: msg(o-self, "first", 5) is 7 end
```

### 32.2.6.2 无变异的自引用

如果你知道如何在没有变异的情况下实现递归[REF]，你会注意到同样的解决方案在这里也适用。观察：

```
o-self-no-state =
  mk-object(
    [list:
      mtd("first",
        lam(self, v): smsg(self, "second", v + 1) end),
      mtd("second",
        lam(self, v): v + 1 end )])
```

现在每个方法都将 self 作为参数。这意味着方法调用必须修改以传递对象作为调用的一部分：

```
fun smsg(o, m, a): o(m)(o, a) end
```

也就是说，在 o 上调用方法时，我们必须将 o 作为参数传递给方法。显然，这种方法是危险的，因为我们可能会将不同的对象作为“self”传递。因此，向开发人员公开这一点可能是一个坏主意；如果使用这种实现技术，应该只在解糖时使用。尽管如此，Python 在其表面语法中确实公开了这一点。为了确保，我们可以使用基本上与之前相同的代码来检查这一点：

```
check: smsg(o-self, "first", 5) is 7 end
```

### 32.2.7 动态分派

最后，我们应该确保我们的对象能够处理对象系统的一个特征属性，即在调用方法时，调用者无需知道或决定哪个对象将处理调用。假设我们有一个二叉树数据结构，其中树由空节点或保存值的叶子组成。在传统函数中，我们被迫实现等效的某种形式的条件语句，以穷举列出并在不同类型的树之间进行选择。如果树的定义扩展到包括新类型的树，那么每个这些代码片段都必须被修改。动态分派通过将这个条件分支从用户程序中消除，而是通过语言内置的方法选择代码来处理它，解决了这个问题。这提供的关键功能是可扩展条件。这是对象提供的可扩展性的一个维度。这个属性——看起来使系统更加黑盒可扩展，因为系统的一部分可以增长而无需修改另一部分来适应这些变化——经常被誉为面向对象的一个关键优点。虽然这确实是对象相对于函数的一个优势，但函数相对于对象也有一个双重优势，事实上许多对象程序员最终会扭曲他们的代码——使用访问者模式——使其看起来更像是基于函数的组织。阅读[Synthesizing Object-Oriented and Functional Design to Promote Re-Use](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/)，了解一个完整的示例，它将详细阐述问题。尝试用你喜欢的语言解决它，并查看[Racket 解决方案](http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml)。

现在让我们定义我们的两种树对象：

```
mt =
  lam():
    mk-object(
      [list:
        mtd("add",
          lam(self, _): 0 end) ])
  end

node =
  lam(v, l, r):
    mk-object(
      [list:
        mtd("add",
          lam(self, _):
            v
              + smsg(l, "add", "dummy")
              + smsg(r, "add", "dummy") end) ] )
  end
```

有了这些，我们可以创建一个具体的树：

```
a-tree =
  node(10,
    node(5, mt(), mt()),
    node(15, node(6, mt(), mt()), mt()))
```

最后，测试它：

```
check: smsg(a-tree, "add", "dummy") is (10 + 5 + 15 + 6) end
```

注意，在测试和节点的“add”方法中，都有一个对“add”的引用，而不检查接收者是 mt 还是节点。相反，运行时系统提取接收者的“add”方法并调用它。系统自动提供的用户源程序中缺少的这个条件是动态分派的本质。

## 32.3 成员访问设计空间

当涉及成员名称的处理时，我们已经有了两个正交维度。一个维度是名称是静态提供的还是计算的，另一个维度是名称集合是固定的还是可变的：

|  | 名称是静态的 | 名称是计算的 |
| --- | --- | --- |
| 固定成员集合 | 如基本 Java。 | 如使用反射的 Java 来计算名称。 |
| 可变成员集合 | 很难想象（有什么用处呢？）。 | 大多数脚本语言。 |

只有一种情况不太合理：如果我们强制开发人员在源文件中明确指定成员名称，则将无法访问新成员（并且对先前存在但已删除的成员的某些访问将失败）。 然而，语言已经探索了此设计空间中的所有其他点。

右下象限与使用哈希表表示对象的语言密切对应。 然后名称只是哈希表的索引。 一些语言将此推向极端，甚至对数字索引使用相同的表示，从而（例如）将对象与字典甚至数组混为一谈。 即使对象仅处理“成员名称”，这种对象风格对类型检查[REF]造成了重大困难，因此并非自动理想。

因此，在本节的其余部分，我们将坚持使用具有固定名称集合甚至静态成员名称引用的“传统”对象（左上象限）。 即使如此，我们会发现还有很多要研究的地方。

## 32.4 其他是什么？

到目前为止，方法查找的“else 子句”（当前由 mk-object 实现）—即，当方法列表为空时该怎么办—已经发出了“未找到方法”错误。 可以发生的其他情况是什么？ 许多编程语言采用的一种可能性是将控制“链接”到一个或多个父对象。 这被称为继承。

让我们回到上面的去糖化对象模型。 要实现继承，对象必须被赋予“某物”，以便它可以委托它不认识的方法调用。 很大程度上将取决于那个“某物”是什么。

一个答案可能是它只是另一个对象：目前我们只有

```
| empty => raise("message not found: " + m)
```

我们可以选择

```
| empty => parent-object(m)
```

由于我们对对象的表示，该应用程序有效地在父对象中搜索方法（并且可能递归地在其父对象中搜索）。 如果找到与名称匹配的方法，则通过此链返回到最初寻找方法的原始调用。 如果找不到，则最终父对象可能会发出相同的“未找到消息”错误。

> 练习
> 
> > 注意应用程序父对象（m）类似于“半个消息”，就像 l 值是“半个”变量的评估一样（解释变量:
    ...
```

也就是说，我们将父对象传递给 node-size-ext 以及构造函数参数。由于父对象将是节点的一个实例，并且两个对象应该假定具有相同的参数值，这意味着我们必须两次指定这些值（这违反了 DRY 原则）。作为一种替代方案，我们可以简单地将父对象的构造器传递给 node-size-ext，让它构造父对象：

```
node-size-ext =
  lam(parent-maker, v, l, r):
    parent-object = parent-maker(v, l, r)
    mk-ext-object(parent-object,
      [list:
        mtd("size",
          lam(self, _):
            1
              + smsg(l, "size", "dummy")
              + smsg(r, "size", "dummy") end) ] )
  end
```

使用这个，我们可以为具有 size 方法的节点创建一个更用户友好的接口：

```
fun node-size(v, l, r): node-size-ext(node, v, l, r) end
```

> 现在就做！
> 
> > 你有没有注意到我们在上面使用了 mk-ext-object 而不是 mk-object？你注意到它多了一个额外的参数吗？试着自己定义它。

mk-ext-object 的整个区别在于，如果在当前对象中找不到方法，它会链到父对象：

```
fun mk-ext-object(parent, n-vs):
  lam(m):
    fun lookup(locals):
      cases (List) locals:
        | empty => parent(m)
        | link(f, r) =>
          if f.name == m: f.value else: lookup(r) end
      end
    end
    lookup(n-vs)
  end
end
```

有了这个，我们同样可以创建空树节点的扩展：

```
mt-size-ext =
  lam(parent-maker):
    parent-object = parent-maker()
    mk-ext-object(parent-object,
      [list:
        mtd("size",
          lam(self, _): 0 end) ])
  end

fun mt-size(): mt-size-ext(mt) end
```

最后，我们可以使用这些对象来构建一棵树：

```
a-tree-size =
  node-size(10,
    node-size(5, mt-size(), mt-size()),
    node-size(15, node-size(6, mt-size(), mt-size()), mt-size()))
```

在测试时，我们应该确保新旧行为都正常工作：

```
check:
  smsg(a-tree-size, "add", "dummy") is (10 + 5 + 15 + 6)
  smsg(a-tree-size, "size", "dummy") is 4
end
```

> 练习
> 
> > 早些时候，我们评论说，方法查找链接到父级，可能会在某种“空对象”上触底，它可能看起来像这样：
> > 
> > ```
> > fun empty-object(m):
> >   raise("message not found: " + m)
> > end
> > ```
> > 
> > 然而，尽管使用了 mk-ext-object，我们并没有需要定义或使用它。为什么会这样，你会如何修复呢？

我们所做的是捕捉类的本质。每个函数参数化到一个父类上...嗯，这有点棘手，真的。现在我们先称之为 blob 吧。一个 blob 对应于当 Java 程序员编写类时定义的内容：

```
class NodeSize extends Node { ... }
```

> 现在就做！
> 
> > 那么，为什么我们要绕过去不称它为“类”？

当开发人员调用 Java 类的构造函数时，实际上会沿着继承链构造对象（在实践中，编译器可能会将此优化为仅需要一个构造函数调用和一个对象分配）。这些是与父类对应的对象的私有副本（私有，即直到静态成员的出现）。然而，存在一个问题，即这些对象的多少是可见的。Java 选择了——<wbr>与我们上面的实现不同——<wbr>只有一个给定名称（和签名）的方法保留下来，无论继承链上可能有多少个，而每个字段都保留在结果中，并且可以通过强制转换访问。后者是有道理的，因为每个字段都可能有规定其行为的不变量，因此将它们分开（因此全部存在）是明智的。相比之下，很容易想象一个实现也使所有方法都可用，而不仅仅是继承层次结构中最低的（即最精细的）那些方法。许多脚本语言采用后一种方法。

> 练习
> 
> > 在上面的实现中，我们依赖自应用语义来递归访问对象，而不是使用状态。原因是因为如果我们简单地使用状态，继承的行为将会有微妙的错误，就像我们上面展示的那样。你能构造一个说明这一点的例子吗？

仔细检查值，你会注意到自引用始终指向最精细的对象。这展示了我们从传统对象中获得的另一种可扩展性形式：可扩展递归。可扩展条件可以被视为跨“空间”的自由扩展，即数据的不同变体，而可扩展递归可以被视为跨“时间”的自由扩展，即对代码的不同扩展。然而，正如[这篇论文](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/)所指出的，没有免费的午餐。

### 32.4.2 原型

在我们上面的描述中，我们为每个类提供了其父类的描述。然后，对象构造在沿着继承链向上移动时会实例化每个对象。还有另一种方法来考虑父类：不是作为一个要实例化的类，而是直接作为一个对象本身。然后，具有相同父类的所有子类都将观察到完全相同的对象，这意味着一个子类对象对其的更改将对另一个子类可见。共享的父对象被称为原型。

原型语言的典型代表是 [Self](http://selflanguage.org/)。尽管你可能已经读到过类似 JavaScript 这样的语言是“基于” Self 的，但从其源头学习这个概念还是有价值的，特别是因为 Self 以最纯粹的形式展现了这些思想。一些语言设计者认为，原型比类更原始，因为使用其他基本机制，如函数，可以从原型中恢复类，但反过来不行。这基本上就是我们上面所做的：每个“类”函数内部包含一个对象描述，因此类是一个返回对象的函数。如果我们将这两个操作暴露出来，并选择直接从一个对象继承，我们将得到类似原型的东西。

> 练习
> 
> > 修改上述继承模式以实现一个类似 Self 的、基于原型的语言，而不是基于类的语言。因为类为每个对象提供其父对象的独立副本，所以原型语言可能提供一个克隆操作，以简化在原型之上模拟类的操作的创建。

### 32.4.3 多重继承

现在你可能会问，为什么只有一个“fall-through”选项？很容易将这个概念泛化为有很多个选项，这自然会导致多重继承。实际上，我们有多个对象可以链式查找，这当然会引发一个问题，那就是我们应该按照什么顺序来查找。如果祖先被排列在树中，这已经够糟糕了，因为即使树也没有遍历的规范顺序：例如广度优先和深度优先遍历（每种都有令人信服的用途）。更糟糕的是，假设一个 blob A 继承了 B 和 C；但是现在假设 B 和 C 分别继承了 D。这个臭名昭著的情况称为“菱形继承”。如果你选择在你的语言中包含多重继承，你可能会花上几天的时间在这些设计决策上纠结。因为你很有可能找不到一个规范的答案，你的痛苦只会刚刚开始。现在我们不得不面对这个问题：在 A 的实例中会有一个还是两个 D 对象？只有一个可以节省空间，并且可能与我们的期望更好地交互，但是，我们会访问这个对象一次还是两次呢？访问两次不应该有任何区别，所以似乎是不必要的。但是访问一次意味着 B 或 C 中的一个的行为可能会改变。等等。结果，几乎每种支持多重继承的语言都伴随着一个微妙的算法来定义查找顺序，而每种语言的设计者都会争辩说他们的算法更直观。

多重继承只有在你仔细考虑过后才会变得有吸引力。

### 32.4.4 超级棒！

许多语言都有超级调用的概念，即能够在继承链中更高层次地调用方法或访问字段。请注意，我说的是“链”。当我们转换为多重继承时，这些概念将被更复杂的东西所替代。这包括在对象构造点这样做，其中通常有一个要求调用所有构造函数的要求，以确保对象被正确定义。

我们已经习惯于认为这些调用是“向上”链的，以至于我们可能忘记了是否这是最自然的方向。记住构造函数和方法被期望强制执行不变量。我们应该更信任谁：超类还是子类？一个论点会说子类最精细化，因此它对对象有最全面的视角。相反，每个超类都有一种对抗被无知的子类违反其不变量的权益。

这是两种根本相反的继承观点。向上链意味着我们将扩展视为替换父类。向下链意味着我们将扩展视为细化父类。因为我们通常将子类化与细化联系在一起，所以为什么我们的语言选择了“错误”的调用顺序呢？因此，一些语言默认探索了向下调用的方式。[gbeta](http://www.daimi.au.dk/~eernst/gbeta/)是一种支持内部以及许多其他有趣特性的现代编程语言。同时考虑[结合两个方向](http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf)也是很有意思的。

### 32.4.5 混合和特质

让我们回到我们的“blob”。

当我们在 Java 中编写一个类时，在大括号之间真正定义的是什么？它不是整个类：这取决于它扩展的父类，以及递归地等等。相反，在大括号内定义的是一个类扩展。它只有在我们在同一个地方标识父类时才变成一个全面的类。

自然地，我们应该问：为什么？为什么不把定义扩展的行为与将扩展应用到基类分开呢？也就是说，假设不是

| class C extends B { ... } |
| --- |

相反，我们写成：

| classext E { ... } |
| --- |

和分开

| class C = E(B); |
| --- |

其中 B 是某个已定义的类。这样我们就恢复了之前的内容，但是函数应用的语法意味着可以应用这个扩展到几个不同的基类。因此：

| class C1 = E(B1); |
| --- |
| class C2 = E(B2); |

等等。通过将 E 的定义与它扩展的类的定义分开，我们已经将类扩展从固定基类的暴政中解放出来。我们有一个对这些扩展的名称：它们被称为 mixins。术语“mixin”起源于 Common Lisp，它是一种使用多重继承的特定模式。给猪化妆。 

混合使类定义更具组合性。它们提供了多重继承的许多好处（重用多个功能片段），但在单一继承语言的保护下进行（即，没有关于查找顺序的复杂规则）。请注意，当进行解糖时，向语言添加混合实际上非常容易。混合主要是“对类的函数”；因为我们已经确定了如何解糖类，并且我们解糖的目标语言也具有函数，而类解糖为可以嵌套在函数内部的表达式，因此实现一个简单的混合模型几乎变得微不足道。这是目标语言的更大一般性可以将我们引向更好的构造的一个例子，如果我们将它反映回源语言。

在一个类型化的语言中，一个好的混合设计实际上可以改进面向对象编程实践。假设我们正在定义一个基于混合的 Java 版本。如果混合实际上是一个类到类的函数，那么这个“函数”的“类型”是什么？显然，混合应该使用接口来描述它期望和提供的内容。Java 已经（但不要求）实现了后者，但它没有实现前者：一个类（扩展）扩展另一个类——<wbr>所有成员对扩展可见——<wbr>而不是它的接口。这意味着它获得了父类的所有行为，而不是规范。反过来，如果父类发生变化，类可能会出问题。

在一个类型化的混合语言中，我们可以写成

| 混合 M 扩展 I { ... } |
| --- |

其中 I 是一个接口。然后 M 只能应用于满足接口 I 的类，并且反过来，语言可以确保只有在 I 中指定的成员在 M 中可见。这遵循了良好软件设计的一个重要原则。“根据接口而不是实现编程。” —<wbr>设计模式

一个好的混合设计甚至可以走得更远。从定义上来说，类在继承链中只能使用一次（如果一个类最终引用回自身，将导致继承链中的循环，可能导致无限循环）。相比之下，当我们组合函数时，我们对多次使用相同的函数并不犹豫（例如：(map ... (filter ... (map ...))））。两次使用混合有价值吗？当然有！请参阅[Classes and Mixins](http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/)的第 3 和第 4 节。

Mixins 解决了在库设计中出现的一个重要问题。假设我们有十几个可以以不同方式组合的特性。我们应该提供多少个类？显然，生成整个组合爆炸的类是不现实的。如果开发者可以挑选他们关心的特性，那就更好了。这正是 mixins 解决的问题：它们提供了类扩展，开发者可以以保持接口的方式组合，从而创建他们需要的类。Mixins 在 Racket GUI 库中被广泛使用。例如，color:text-mixin 消耗基本文本编辑器接口并实现了彩色文本编辑器接口。后者本身是一个基本文本编辑器接口，因此可以将额外的基本文本 mixins 应用于结果。

> 练习
> 
> > 你最喜欢的面向对象库是如何解决这个问题的？

Mixins 确实有一个限制：它们强制了组合的线性性。这种严格有时是不恰当的，因为它给程序员带来了可能是不必要的负担。Mixins 的一个泛化称为 traits，它说我们可以扩展一组 mixin 而不是单个 mixin。当然，一旦我们扩展多个，我们必须再次处理潜在的名称冲突。因此，traits 必须配备解决名称冲突的机制，通常以某种名称组合代数的形式。因此，traits 为 mixins 提供了一个很好的补充，使程序员能够选择最适合他们需求的机制。因此，一些语言，如 Racket，提供了[traits 和 mixins](http://www.eecs.northwestern.edu/~robby/pubs/papers/aplas2006-fff.pdf)。

## 32.5 对象分类和对象相等性

之前我们已经看到了三种不同类型的相等操作[一个相等谓词家族]。在本讨论中，我们将忽略 equal-now 和 equal-always 之间的区别，重点关注它们都是主要结构性的（equal-now 纯粹如此）。扩展到对象，这将递归地检查每个成员，也许忽略不能比较它们的语言中的方法，或者使用引用相等性来比较它们。

这让我们面对非常细粒度和苛刻的 identical，以及非常粗粒度且可能过于宽容的 equal-now。为什么结构相等性过于宽容？因为两个完全不相关的对象，恰好具有相同的成员名称和类型，最终可能被视为相等：正如对象社区中一个著名的例子所说，draw 是用户界面和牛仔的一个有意义的方法。

因此，一些系统提供了一个“中间”的相等谓词：它仍然基本上是结构的，但它区分了“不同方式制作”的对象。典型的构造概念与类相关联：所有由某个类制作的对象都被认为是（结构）相等的候选对象，但是由不同类制作的对象（对于某种“不同”的概念）立即被判定为不相等，而不考虑它们的结构（实际上可能是相同的）。

在特殊情况下，如果类被命名为一阶实体，这被称为名义相等：一种基于名称的相等。然而，它不必依赖于名称，甚至不必依赖于一阶类。一些语言有动态标签创建者——语言所知的——称为品牌。为了保持牛仔主题。每次品牌操作都会在对象上放置一个标签。然后，内置的相等原语检查品牌是否相同；当满足此条件时，它们将恢复到结构相等（在递归期间可能涉及额外的品牌检查）。

## 32.6 对象类型

在研究了各种编程机制之后，我们现在将重点转向用于它们的类型。首先（子类型化,
    sub1 :: (Number -> Number) }
```

这是一个具有给定类型的两个成员 add1 和 sub1 的对象的类型。我们需要回答的问题是，确切地说，哪些对象可以给予此类型？为了理解这一点，让我们考虑另一个相关类型，我们将其称为 Arith：

```
type Arith =
  { add1  :: (Number -> Number),
    sub1  :: (Number -> Number),
    plus  :: (Number, Number -> Number),
    mult  :: (Number, Number -> Number) }
```

请注意，两个成员具有相同的名称和相同的类型，但还有两个成员（plus 和 mult）。考虑一个设计用于处理 Arith 值的函数：

```
fun f(a :: Arith) -> Number:
  a.plus(2, 3)
end
```

将类型为 Add1Sub1 的值传递给 f 函数是否可以？当然不行：函数调用了成员 plus，而类型注释在 a 上说它可以期望找到这个成员；但是如果传入的值没有这个成员，这将导致运行时找不到成员的错误，而这正是类型系统试图避免的。因此，我们不能在期望 Arith 的上下文中替换类型为 Add1Sub1 的值。

那么在另一个方向上呢？这是完全合理的：上下文期望一个 Add1Sub，因此不会使用比该类型承诺更多的东西。因为 Arith 提供了 Add1Sub1 期望的一切，所以提供 Arith 值给 Add1Sub1 是可以的。

这是我们的第一个子类型示例。我们说 Arith 是 Add1Sub1 的一个子类型，因为我们可以在期望一个 Add1Sub1 值的任何上下文中提供一个 Arith 值。具体来说，因为这涉及到删除一些成员 —— 即，使对象“更窄” —— 所以这被称为宽度子类型。

子类型的本质是一个关系，惯例上写作<:，表示两种类型之间的关系。我们说 S <: T，如果一个类型为 S 的值可以在期望一个类型为 T 的值的地方给出，并称 S 为子类型，T 为超类型。因此，在上面的例子中，Arith <: Add1Sub1，Arith 是 Add1Sub1 的一个子类型。稍后[命名类型]，我们将讨论子类型如何对应于子类。但现在请注意，我们只谈论对象，没有提到类的存在。采用子集解释是有用的（并且通常是准确的）：如果 S 的值是 T 的一个子集，则期望 T 值的表达式不会因为只接收到 S 值而感到不愉快。

> 练习
> 
> > 为什么子类型是一个关系而不是一个函数？

换句话说：

```
{ add1  : (Number -> Number),            { add1 : (Number -> Number),
  sub1  : (Number -> Number),          <:  sub1 : (Number -> Number) }
  plus  : (Number, Number -> Number),
  mult  : (Number, Number -> Number) }
```

这可能暂时看起来令人困惑：我们已经说过，子类型遵循集合包含，因此我们期望左侧是较小的集合，右侧是较大的集合。然而，看起来我们左边有一个“更大的类型”（至少从字符计数的角度来看），右边有一个“更小的类型”。

要理解这为何是合理的，有助于培养这样一种直觉：类型“越大”，它可以拥有的值就越少。每个具有左侧四个成员的对象显然也具有右侧两个成员。然而，有许多具有右侧两个成员的对象，却没有左侧四个成员。如果我们将类型视为对可接受值形状的约束，则“更大”的类型会施加更多的约束，因此接受的值会更少。因此，尽管类型可能看起来大小不对，但一切都很好，因为它们所订阅的值集是预期大小的。

正如您所预料的，还有另一种重要的子类型形式，即在给定成员内部的子类型。这简单地表示任何特定成员可以被包含到其相应位置的超类型中。出于显而易见的原因，这种形式被称为深度子类型。

> 练习
> 
> > 构建两个深度子类型的示例。在一个示例中，将字段本身赋予对象类型，并使用宽度子类型来对该字段进行子类型化。在另一个示例中，将字段赋予函数类型。

宽度和深度子类型的组合涵盖了对象子类型的最有趣的情况。一个只实现了这两种类型的类型系统，然而，会不必要地使程序员感到烦恼。其他方便的规则包括能够对名称进行置换，自反性（每种类型都是其自身的子类型，这为我们提供了自由的不变性，并让我们将子类型关系解释为子集），以及传递性。

子类型对类型系统有普遍影响。我们必须重新审视每种类型并理解它与子类型的相互作用。对于基本类型，这通常是相当明显的：像 Number、String 等不相交的类型彼此之间没有关联。（在某些语言中，一个基本类型用于表示另一个——例如，在一些脚本语言中，数字仅仅是用特殊语法编写的字符串，而在其他语言中，布尔值仅仅是数字——这些基本类型之间可能存在子类型关系，但这种情况并不常见。）然而，我们必须考虑子类型如何与每种复合类型构造函数交互。

实际上，我们甚至关于类型的措辞也必须改变。假设我们有一个类型为 T 的表达式。通常，我们会说它产生了类型为 T 的值。现在，我们应该小心地说它产生了最多或最多为 T 的值，因为它可能只产生 T 的子类型的值。因此，对类型的每个引用都应该隐含地包含对子类型潜在性的引用。为了避免打扰您，我将不做此操作，但请注意，不考虑这种隐含解释可能会导致推理错误。

### 32.6.1.1 函数的子类型

我们上面的例子已经被精心挑选，以掩盖一个重要的细节：函数的子类型。为了理解这一点，我们将举例说明。

考虑一个具有新类型称为 Boolean01 的假想语言，其中 true 只是 1 的别名，false 只是 0 的别名。因此，在这种语言中，Boolean01 <: Number；所有 Boolean01 值都是 Number 类型，但不是所有 Number 值都是 Boolean01（事实上，大多数都不是）。在这种语言中，我们可以编写一些函数：

```
fun b2n(b :: Boolean01) -> Number:
  if b == 0:  # alias for false
    1
  else if b == 1:  # alias for true
    0
  else:
    raise('not valid number as Boolean01')
  end
end

fun n2b(n :: Number) -> Boolean01:
  if n == 0:
    false  # alias for 0
  else if n == 1:
    true   # alias for 1
  else:
    raise('no valid Boolean01 for number')
  end
end

fun n2n(n :: Number) -> Number:
  n + 1
end

fun b2b(b :: Boolean01) -> Boolean01:
  if b == 0:  # alias for false
    true   # alias for 1
  else if b == 1: # alias for true
    false  # alias 0
  else:
    raise('not valid number as Boolean01')
  end
end
```

我们还定义四种类型：

```
type N2N = (Number -> Number)
type B2B = (Boolean01 -> Boolean01)
type N2B = (Number -> Boolean01)
type B2N = (Boolean01 -> Number)
```

我们现在可以问以下问题：这些类型中哪些是另一种的子类型？更具体地说，哪些函数可以安全地替代哪些函数？

我们可能期望有以下规则。因为在我们想象的系统中 Boolean01 <: Number，所以 (Boolean01 -> Boolean01) 函数是 (Number -> Number) 函数的子类型。这是一个自然的结论...但是错误的，我们很快就会看到。

为了具体化这一点，假设我们有一个函数 p，它消耗并使用其中的一个函数。虽然该函数可能是对象中的一个成员，但为了理解基本问题，我们不需要这样做：我们可以只关注函数类型。因此，我们有类似于

```
fun p(op :: (A -> B)) -> B:
  op(a-value)
end
```

其中 A 和 B 将是所有 Number 和 Boolean01 的组合，并假设 a-value 具有 A 类型的任何内容。对于 op（列标题）的每种类型，我们将询问我们可以安全地将哪个上述函数（行标题）传递给 p。

> 现在动手吧！
> 
> > 停下来尝试首先填写这个表格。

|  |  | N2N |  | N2B |  | B2N |  | B2B |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| n2n |  | yes（相同） |  | no（范围） |  | yes（域） |  | no（范围） |
| n2b |  | yes (range) |  | yes (identical) |  | yes (domain and range) |  | yes (domain) |
| b2n |  | no (domain) |  | no (domain and range) |  | yes (identical) |  | no (range) |
| b2b |  | no (domain) |  | no (domain) |  | yes (range) |  | yes (identical) |

在每个单元格中，“yes”表示左侧的函数可以在期望顶部的类型时传入，而“no”表示不能。括号中给出了原因：“identical”表示它们是相同的类型（所以当然可以传入）；在“yes”情况下，它说明需要应用子类型，而在“no”情况下说明类型错误的地方。

让我们考虑尝试将 n2n 传递给 N2B 注释（对于 op）。因为 p 的返回类型是 Boolean01，无论谁使用 p(n2n)，都假定它只会返回 Boolean01 值。然而，函数 n2n 可以自由地返回它想要的任何数字值：特别是，给定 1，它返回 2，这既不对应于 Boolean01。因此，允许这个参数可能导致不安全的程序执行。为了防止这种情况发生，我们必须将其标记为类型错误。

更一般地说，如果强调形式参数的类型承诺为 Boolean01，则传递的实际函数最好只返回 Boolean01；但如果形式的类型是 Number，则实际可以安全地返回 Boolean01 而不会引起麻烦。因此，一般来说，对于(A -> B) <: (C -> D)，我们必须有 B <: D。换句话说，范围的子类型化与函数本身的子类型化相似，因此我们说范围位置是协变的（“co-”意味着“一起”）。

现在我们来看看更有趣的情况：域。考虑为什么我们可以在期望 B2N 的地方传递 n2n。在 op 的主体内，a-value 只能是 Boolean01，因为这是类型允许的。因为每个 Boolean01 都是一个数字，所以函数 n2n 没有问题接受它。

相反，考虑在期望 N2N 的地方传递 b2n。在 op 内部，a-value 可以评估为任何数字，因为根据 p 上的类型注释，op 应该能够接受它。然而，b2n 只能接受两个数字；其他一切都会导致错误。因此，如果类型检查器允许这样做，我们甚至可以在程序通过类型检查器的情况下获得运行时错误。

从中我们得出的道德是，对于域位置，形式参数必须是实际参数的子类型。形式参数限制了 op 可以期望的值；只要实际参数可以接受至少与之一样多的值集合，就不会有问题。因此，对于(A -> B) <: (C -> D)，我们必须有 C <: A。域的子类型化与函数本身的子类型化方向相反，因此我们说范围位置是逆变的（“contra-”表示“相反”）。

将这两条规则放在一起，当 C <: A 且 B <: D 时，(A -> B) <: (C -> D)。

### 32.6.1.2 子类型和信息隐藏

考虑一个实现了 Add1Sub1 类型的对象 o。由于宽度子类型的特性，绝对没有任何阻止该对象也具有正确类型的 plus 和 mult 成员的东西。这引发了一个问题：如果我们写为

```
o :: Add1Sub1 = ...
```

其中... 是一个具有 plus 和 mult 的对象，然后我们尝试将 o 传递给 f，应该发生什么？

在严格动态的解释中——例如，如果这个程序完全没有任何注释地编写——它将完美地工作。然而，静态地这样做意味着我们违反了对这些注释意义的直觉。一般来说，判断一个类型为 Add1Sub1 的对象实际上是否具有附加的 Arith 成员是不可判定的，因此，试图将 Add1Sub1 注释的值用作 Arith 的程序最安全的做法是拒绝。自然类型系统将阻止我们将 o 传递给 f。

简而言之，静态类型系统成为了信息隐藏的机制。通过在类型描述中省略一些成员，我们有效地隐藏了它们的存在。例如，可以创建一个对象

```
crypto =
  { private-key: ... ,
    public-key: ...,
    decrypt: fun(msg): ... end,
    encrypt: fun(plain-text): ... end }
```

并赋予它类型

```
type PK =
  { public-key: Number,
    encrypt: (String -> String) }
```

如下：

```
for-dist :: PK = crypto
```

那么所有对 DIST 的引用都只能使用公共接口，并且无法访问 private-key 或 decrypt 成员，但是那些可以访问 crypto 对象的人可以使用这些成员。只要小心配置了对 crypto 的访问权限，语言就会确保这两个敏感成员的隐私。然而，在一个不是纯静态类型的系统中（包括那些允许类型化语言与未类型化语言进行互操作的系统），情况会变得更加棘手。在未类型化语言中，没有注释，因此没有什么阻止 o 的 plus 成员或 for-dist 的 decrypt 成员被访问：毕竟，这些成员确实存在于底层对象中。因此，当将类型化对象“导出”到任何不受信任或未注释的上下文中时，通常会创建一个代理对象；这就好像开发者手动编写了以下内容：

```
fun proxy-for-crypto(c):
  { public-key: c.public-key,
    encrypt: c.encrypt }
end

proxy-dist = proxy-for-crypto(for-dist)
```

那么，它就是代理 DIST，随后提供给危险环境。由于生成的对象实际上只包含两个字段，并且底层对象仅在词法范围内可见 (c)，只要语言不提供检查或遍历范围的手段（这不是所有语言都保证的假设！），未类型化或危险上下文就无法访问私有内容。

### 32.6.1.3 实现子类型

当然，这些规则假设我们已经修改了类型检查器以尊重子类型。子类型的本质是一个规则，即，如果表达式 e 的类型是 S，并且 S <: T，则 e 也具有类型 T。虽然这听起来很直观，但由于以下两个原因，这也立即成为问题：

+   到目前为止，我们所有的类型规则都是基于语法驱动的，这使得我们能够编写递归下降类型检查器。然而，现在，我们有了一个适用于所有表达式的规则，因此我们不能再确定何时应用它。

+   子类型化可能有多个层次。因此，当“停止”子类型化时，不再明显。特别是，在以前，类型检查能够计算表达式的类型，现在每个表达式可能有许多可能的类型；如果我们返回了“错误”的类型，我们可能会得到一个类型错误（因为那不是上下文所期望的类型），即使存在某种其他类型是上下文所期望的类型。

这两个问题指出我们在此提供的子类型化描述基本上是声明性的：我们说出了什么是真的，但没有展示如何将其转换为算法。对于每种实际的类型语言，将其转换为算法子类型化存在着更或更少有趣的问题：一个真正实现了类型检查器的算法（理想情况下，它能够完全地检查那些在声明性制度下会被检查的程序，即一个既声音又完整的检查器）。

### 32.6.2 自引用类型

记住，许多对象系统的一个重要特性是在方法内部引用调用它的对象的引用：即，一个自引用[具有自引用的对象]。这个 self 标识符的类型是什么？

考虑我们之前描述的 Add1Sub1 类型。说实话，add1 和 sub1 的实现 - 作为方法 - 必须带有一个额外的参数，这个参数将是一个自引用。这个自引用参数的性质是什么？显然它是一个对象；显然它有两个方法，add1 和 sub1（至少在子类型化上）；每个方法都接受两个参数，一个是数字，...

你看出这是什么意思了吗？

因此，对象类型通常是递归类型：类型世界的 mu（“mu”）等价物。通常，它们用μ（“mu”）而不是 rec 来表示；因此：

```
type Add1Sub1 =
  μ T . { add1 :: (T, Number -> Number),
          sub1 :: (T, Number -> Number) }
```

将右边解释为“构造一个递归类型 T，使其（a）是一个对象，（b）有两个成员 add1 和 sub1，（c）每个成员有两个参数，第一个是正在定义的类型”（等等）。

不幸的是，递归类型并不像看起来那么简单。注意，上述类型没有“基本情况”；因此，它是一个无限类型的有限表示（这正是我们想要的，因为我们可以编写无限数量的自我应用）。因此，当涉及检查两个递归类型的相等性时，我们会遇到超出本研究范围的复杂性，请参阅 Pierce 的 Types and Programming Languages 了解详情。

### 32.6.3 名义类型

早些时候[对象分类和对象相等性]，我们读到了名义相等性，其中类用于辅助相等性比较。在一些类型化语言中 - 例如 Java 是典型代表 - 类承担了更重要的任务：它们还用作类型系统的基础，而不是结构类型。

基本思想是，每个类（或其他标称实体）都定义了一个全新的类型，即使其成员的类型结构与其他某些类型完全相同。然后，类型相等反映了标称相等，但是平凡的：如果两个值具有相同的类型，则它们必须具有相同的结构，如果它们具有不同的类型，则它们的结构无关紧要（即使它们相同）。因此，类型相等可以简化为一个常数时间的检查，检查类是否相同。

标称类型还有一个优点。它们有效地使得编写递归类型变得直接，而不用与 μ 打交道。考虑下面的 Java 类定义：

| class Add1Sub1 { |
| --- |
|   public int add1(int n) { ... } |
|   public int sub1(int n) { ... } |
| } |

这两个方法定义中隐含了 this 参数。但是，this 的类型是什么呢？它只是 Add1Sub1：关键词 class 不仅引入了一个新名称，还自动使其成为一个递归绑定。因此，程序员可以舒适地引用和使用标称类型，而不必纠结于它们的真正含义（作为递归类型）或它们的相等性（因为是按名称而不是按结构）。因此，尽管标称类型非常不灵活，但确实为特定的语言设计约束提供了一种优雅的解决方案。

值得注意的是，在 Java 中，继承（不幸地）对应于子类型化。当我们沿着继承链向上移动时，一个类的成员会越来越少（宽度子类型化），直到我们到达 Object，即所有类的超类型，它具有最少的成员。因此，对于 Java 中的所有类类型 C，C <: Object。有些令人困惑的是，有时候会使用缩小和扩大这些术语，但一些人可能认为它们的含义相反。扩大是指从子类型到超类型，因为它从“更窄”的（更小的）集合到“更宽”的（更大的）集合。这些术语是独立演变的，但不幸的是不一致。子类型化的解释如下：每个在继承层次结构中较低的类型也在继承层次结构中较高的位置上具有类型，但反之则不然。然而，当涉及到深度子类型化时，Java 更倾向于在对象层次结构下使类型不变，因为这对于常规变异是一种安全的选项。

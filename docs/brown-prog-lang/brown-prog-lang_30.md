# 30 类型推断

|     30.1 类型推断作为类型注释插入 |
| --- |
|     30.2 理解推断 |
|       30.2.1 约束生成 |
|       30.2.2 使用统一进行约束求解 |
|     30.3 类型检查和类型错误 |
|     30.4 超约束和欠约束的解 |
|     30.5 Let 多态 |

到目前为止，我们一直在学习需要用户明确注释其程序的编程语言。然而，在像 Haskell 和 ML 变种这样的语言中，用户可以省略注释，语言有能力自动为他们推断这些注释。例如，程序员可以写出相当于

```
fun f(x, y):
  if x:
    y + 1
  else:
    y - 1
  end
end
```

系统会自动推断出 f 的头部应该是

```
fun f(x :: Boolean, y :: Number): ...
```

Scala 和 Typed Racket 等新语言在这方面更为有限：一种称为局部类型推断的特性。然而，在这里，我们将学习更传统和更强大的形式。

## 30.1 类型推断作为类型注释插入

首先，让我们了解一下类型推断在做什么。有些人错误地认为具有推断的语言没有类型声明，推断取代了它们。这在多个层面上都是混淆的。首先，即使在具有推断的语言中，程序员也可以自由地（并且出于文档目的，通常鼓励）注释类型。此外，在缺少这些声明的情况下，推断实际上是什么意思并不太清楚。有时，推断也是不可判定的，程序员别无选择，只能声明一些类型。最后，编写显式注释可以大大减少难以理解的错误消息。

相反，最好将底层语言视为完全明确类型的，就像我们学过的语言一样（关于程序的推理：首次接触类型）。好像程序员写了

```
fun f(x :: ___, y :: ___): ...
```

和一些编程环境工具填写了具体的注释来代替 ___ 的：这是一种特别复杂的语法糖，可以这么说。最后一句话帮助我们正确理解推断：实际上有两种语言，一种是带有可选类型注释的，另一种是带有必需类型注释的。一旦这些注释填写完毕，我们就得到了一个传统的程序，可以使用我们已经学习过的方法进行检查，尽管实际上这并不是必要的（类型检查和类型错误）。因此，推断只是一种用户便利，用于减轻编写类型注释的负担，但底层语言是明确类型的。

## 30.2 理解推断

有关示例和更多细节，请参见《[编程语言：应用与解释](http://www.plai.org/)》第三十章。

假设我们有一个在明确类型的语言中编写的表达式（或程序）e：即，在需要的所有地方 e 都有类型注释。现在假设我们擦除 e 中的所有注释，并使用一个过程 infer 来推断它们。

> 现在就开始吧！
> 
> > 我们期望推断具有什么属性？

我们可以对它提出许多要求。其中之一可能是它精确地产生了我们最初拥有的那些注释。出于许多原因，这是有问题的，至少可能是因为它可能甚至无法进行类型检查，这种情况下，推断可能如何知道它们是什么（因此应该是什么）？这可能使您觉得这是一个迂腐的琐事：毕竟，如果它没有进行类型检查，那么擦除它的注释并重新填写它们能使它做到吗？由于两个程序都无法进行类型检查，那又有谁在乎呢？

> 现在就开始吧！
> 
> > 这种推理正确吗？

假设 e 是

```
lam(x :: Number) -> String: x end
```

这个过程显然无法进行类型检查。但是如果我们擦除类型注释——<wbr>获得

```
lam(x): x end
```

—<wbr>同样显然我们获得了一个可类型化的函数！因此，一个更合理的要求可能是，如果原始 e 可以进行类型检查，那么用推断类型替换注释的版本也必须如此。这个单向蕴含在两个方面都很有用：

1.  它并没有说明如果 e 无法进行类型检查会发生什么，即，它不排除一种使上述类型错误的恒等函数可类型化的类型推断算法。

1.  更重要的是，它向我们保证，通过使用类型推断，我们不会损失任何东西：以前可类型化的程序现在不会停止可类型化。这意味着我们可以专注于在我们想要的地方使用显式注释，但不会被迫这样做。当然，这仅在推断是可决定的情况下才成立。

我们可能还期望两个版本都具有相同的类型，但这不是必然的：函数

```
lam(x :: Number) -> Number: x end
```

类型为 Number -> Number，而在擦除类型后应用推断则产生一个更一般的类型，我们将会看到。因此，关联这些类型并给出类型相等的精确定义并不是微不足道的（关系参数化）。

有了这些前提，我们现在已经准备好深入研究类型推断的机制了。最重要的一点是，我们简单的、递归下降的类型检查算法（表达式和函数的类型检查器）将不再适用。那是可能的，因为我们已经在所有函数边界上有了注释，所以我们可以携带有关那些注释的信息下降到函数体中。没有这些注释，下降的方法就不清楚了。实际上，不清楚有什么特定的方向比另一个更有意义。

所有这些信息都在函数中。但是我们如何系统地提取它，并以终止和享有上述属性的算法？我们分两步来做这件事。首先，我们根据程序项生成约束，确定类型必须是什么。然后，我们解决约束以识别不一致，并合并函数体中分散的约束。每个步骤都相对简单，但组合起来就会产生奇迹。

### 30.2.1 约束生成

我们的最终目标是找到一个类型填充到每个类型注释位置。找到每个表达式的类型同样重要。稍加思考就会发现这可能是必要的：例如，我们如何确定在函数上放置的类型，而不知道其主体的类型呢？这也足够了，因为如果每个表达式的类型都已计算过，那么这将包括需要注释的表达式。

首先，我们必须生成约束（稍后解决）。约束生成遍历程序源代码，在每个表达式上发出适当的约束，并返回此约束集。它主要通过递归下降来工作，主要是为了简单起见；实际上，它确实计算出一组约束，因此遍历和生成的顺序原则上并不重要——所以我们可能也会选择递归下降，这很容易——虽然为了简单起见，我们将使用列表来表示此集合。

约束是什么？它们只是关于表达式类型的陈述。此外，虽然变量的绑定实例不是表达式，但我们也必须计算它们的类型（因为函数需要参数类型和返回类型）。通常，我们对表达式的类型能说些什么呢？

1.  它与某个标识符的类型相关。

1.  它与某个其他表达式的类型相关。

1.  它是一个基本类型，比如数字和布尔值。

1.  那就是一个构造类型，比如一个函数，其定义域和值域类型可能进一步受限。

因此，我们定义了以下两种数据类型：TyCHS 的名称缩写为“类型（Ty）约束（C）左或右手（H）边（S）”。

```
data TyCon: tyeq(l :: TyCHS, r :: TyCHS) end

data TyCHS:
  | t-expr(e :: TyExprC)
  | t-con(name :: String, fields :: List<TyCHS>)
end
```

请注意，我们已经将基本类型和构造类型合并为一个表示，即 t-con：基本类型将具有空字段列表，而构造类型将具有一个非空字段列表，对应其 arity。具体而言：

```
numeric-t-con = t-con("num", empty)
boolean-t-con = t-con("bool", empty)
fun mk-fun-t-con(a, r):
  t-con("fun", [list: a, r])
end
```

现在我们可以定义生成约束的过程：<tyinf-generate> ::=

|   fun generate(e :: TyExprC) -> List<TyCon>: |
| --- |
|     cases (TyExprC) e: |
|     <tyinf-generate-numC> |
|     <tyinf-generate-plusC/multC> |
|     <tyinf-generate-trueC/falseC> |
|     <tyinf-generate-ifC> |
|     <tyinf-generate-idC> |
|     <tyinf-generate-fdC> |
|     <tyinf-generate-appC> |
|     end |
|   end |

当表达式是一个数字时，我们只能说我们期望表达式的类型是数字的：<tyinf-generate-numC> ::=

|   &#124; numC(_) => |
| --- |
|     [list: tyeq(t-expr(e), numeric-t-con)] |

这听起来可能很琐碎，但我们不知道的是，外层表达式对这个表达式提出了什么其他期望。 因此，有可能某些外部表达式会与这个表达式的类型必须是数值的断言相矛盾，从而导致类型错误。标识符不会以任何新方式约束程序。 标识符（如果已绑定）将在绑定点约束其类型。 因此，没有约束：我们假设程序中所有绑定的标识符都具有不同的名称，因此不会有两个不同的标识符之间混淆的危险。<tyinf-generate-idC> ::=

|   &#124; idC(s) => |
| --- |
|     empty |

如果上下文限制了它的类型，那么这个表达式的类型将自动被限制，并且必须与其上下文对其的期望一致。加法让我们首次看到了上下文约束。 对于加法表达式，我们必须首先确保在两个子表达式中生成（并返回）约束，这可能会很复杂。 完成后，我们期望什么？ 每个子表达式都是数值类型。（如果其中一个子表达式的形式要求的类型不是数值类型，则会导致类型错误。） 最后，我们断言整个表达式的类型本身也是数值的。 因为乘法的处理方式相同，我们将两者抽象：<tyinf-generate-plusC/multC> ::=

|   &#124; plusC(l, r) => generate-arith-binop(e, l, r) |
| --- |
|   &#124; multC(l, r) => generate-arith-binop(e, l, r) |

其中有趣的工作由抽象完成：

```
fun generate-arith-binop(e :: TyExprC, l :: TyExprC, r :: TyExprC) -> List<TyCon>:
  [list: tyeq(t-expr(e), numeric-t-con),
    tyeq(t-expr(l), numeric-t-con),
    tyeq(t-expr(r), numeric-t-con)] +
  generate(l) +
  generate(r)
end
```

像数字一样，布尔值将当前表达式限制为布尔类型：<tyinf-generate-trueC/falseC> ::=

|   &#124; trueC => |
| --- |
|     [list: tyeq(t-expr(e), boolean-t-con)] |
|   &#124; falseC => |
|     [list: tyeq(t-expr(e), boolean-t-con)] |

对于条件语句，情况再次变得有趣。 我们必须确保条件表达式是布尔类型，并且两个分支具有相同的类型：<tyinf-generate-ifC> ::=

|   &#124; ifC(cnd, thn, els) => |
| --- |
|     [list: tyeq(t-expr(cnd), boolean-t-con), |
|       tyeq(t-expr(thn), t-expr(els))] + |
|     generate(cnd) + generate(thn) + generate(els) |

现在我们来看另外两种有趣的情况，函数声明和应用。 在这两种情况下，我们必须记住生成并返回子表达式的约束。

在函数定义中，函数的类型是一个函数类型，其参数类型是形式参数的类型，其返回类型是函数体的类型：<tyinf-generate-fdC> ::=

|   &#124; fdC(a, b) => |
| --- |
|     [list: tyeq(t-expr(e), mk-fun-t-con(t-expr(a), t-expr(b)))] + |
|     generate(b) |

最后，我们有应用。我们不能直接说明应用的类型约束。相反，我们可以说应用位置的函数必须消耗实际参数表达式类型的参数，并返回应用表达式类型的结果：<tyinf-generate-appC> ::=

|   &#124; appC(f, a) => |
| --- |
|     [list: tyeq(t-expr(f), mk-fun-t-con(t-expr(a), t-expr(e)))] + |
|     generate(f) + |
|     generate(a) |

就这样！我们已经完成了生成约束的过程；现在我们只需要解决它们。

### 30.2.2 使用统一解决约束

用于解决约束的过程称为统一。统一器给出一组方程。每个方程将一个变量映射到一个数据类型为上述的项。

对于我们的目的，统一的目标是生成一个替换，或者说是从变量到不包含任何变量的项的映射。这听起来应该很熟悉：我们有一组同时方程，其中每个变量都被线性地使用；这样的方程可以使用高斯消元法解决。在这种情况下，我们知道我们可能会得到既不足又过度约束的系统。在这里也会发生同样的事情，我们很快就会看到。

统一算法在约束集合上迭代地工作。因为每个约束方程有两个项，并且每个项都可以是两种类型之一，所以需要涵盖四种情况。

算法从所有约束集合和空替换开始。每个约束只考虑一次并从集合中移除，因此原则上终止参数应该非常简单，但事实证明会稍微棘手一些。随着约束的消除，替换集合往往会增长。当所有约束都被处理完毕时，统一操作返回最终的替换集合。

对于给定的约束，统一器检查等式的左边。如果它是一个变量，那么现在它已经成熟可以被消除了。统一器将变量的右边添加到替换中，并且为了真正消除它，用右边的值替换替换中所有变量的出现。值得注意的是，因为约束是相等关系，消除一个变量等同于将其与替换中所替换的任何内容关联起来。换句话说，我们可以使用并查集[REF]来高效地实现这个过程，尽管如果我们在统一过程中需要回溯（正如我们对逻辑编程[REF]所做的那样），这就变得更加棘手了。

> 现在动手！
> 
> > 你注意到上面微妙的错误了吗？

这个微妙的错误就在这里。我们说，解一致性通过在替换中替换它的所有实例来消除变量。但是，这假设右侧不包含相同变量的任何实例。否则，我们将得到一个循环定义，并且执行此特定替换变得不可能。因此，解一致性包括出现检查：检查是否在两侧都出现相同的变量，如果是，则拒绝统一。为简单起见，在这里我们将忽略此检查。

> 现在动手吧！
> 
> > 构建一个术语，其约束将触发出现检查。

你还记得 ω（递归与非终止）吗？

现在让我们实现统一。为简单起见，我们将使用类型约束列表作为替换的表示。在阅读此内容时，请记住，统一是一种通用过程，完全独立于类型推断：实际上，在推断类型过程之前，统一算法已经发明并推动了类型推断过程的创建。

> 练习
> 
> > 如果我们使用类型约束来表示替换，那么我们期望计算出的约束集具有什么不变量？

有一个辅助函数将当前替换作为累积参数。因此，我们应该包含它，并解决简单的情况：

<tyinf-unify> ::=

|   fun unify(cs :: List<TyCon>) -> List<TyCon>: |
| --- |
|     fun help(shadow cs :: List<TyCon>, sub :: List<TyCon>) -> List<TyCon>: |
|       cases (List) cs: |
|         &#124; empty => sub |
|         &#124; link(f, r) => |
|           <tyinf-unify-link> |
|       end |
|     end |
|     help(cs, empty) |
|   end |

我们需要考虑四种情况，因为其中一边可以是 t-expr 或 t-con：

+   如果两边都是 t-expr，则我们简单地用另一个替换其中一个（这是高斯过程的“变量消除”情况）。我们必须在所有地方执行此替换：在剩余的项中以及已执行的替换中。

    > 练习
    > 
    > > 如果我们错过在其中一个中进行替换会发生什么？

+   如果一边是 t-expr 而另一边是 t-con，则我们已将该表达式的类型解析为具体类型。记录下这一点并进行替换。

+   t-expr 和 t-con 有两种情况：为简单起见，我们处理一种情况，并在另一种情况下，将问题重写为前一种情况并递归。这种交换是合法的，因为这些是等式约束。

+   如果我们必须统一两个构造函数，那么它们最好是相同的构造函数！如果不是，则会出现类型错误。如果是，则对它们的参数进行递归。

这是在代码中的表现：<tyinf-unify-link> ::=

|   lhs = f.l |
| --- |
|   rhs = f.r |
|   询问： |
|     &#124; 如果 is-t-expr(lhs) 和 is-t-expr(rhs) 那么： |
|       help(subst(lhs, rhs, r), link(f, subst(lhs, rhs, sub))) |
|     &#124; 如果 is-t-expr(lhs) 和 is-t-con(rhs) 那么： |
|       help(subst(lhs, rhs, r), link(f, subst(lhs, rhs, sub))) |
|     &#124; 如果 lhs 是类型常量且 rhs 是表达式，则: |
|       help(link(tyeq(rhs, lhs), r), sub) |
|     &#124; 如果 lhs 是类型常量且 rhs 是类型常量，则: |
|       如果 lhs.name == rhs.name: |
|         help(map2(tyeq, lhs.fields, rhs.fields) + r, sub) |
|       else: |
|         raise('类型错误：' + lhs.name + ' vs. ' + rhs.name) |
|       end |
|   end |

在证明终止性方面，请注意最后两种情况不会缩小输入：第三种情况保持不变，而第四种情况在某些情况下会增加输入。

统一器取决于：

```
fun subst(to-rep :: TyCHS%(is-t-expr), rep-with :: TyCHS, in :: List<TyCon>)
    -> List<TyCon>:
  cases (List) in:
    | empty => empty
    | link(f, r) =>
      lhs = f.l
      rhs = f.r
      link(
        tyeq(
          if lhs == to-rep: rep-with else: lhs end,
          if rhs == to-rep: rep-with else: rhs end),
        subst(to-rep, rep-with, r))
  end
end
```

> 练习
> 
> > 上述统一实现中存在一个微妙的错误。它假设两个在文本上相同的表达式必须具有相同的类型。构造一个反例来证明这不是真的。然后修复这个实现（考虑使用引用而不是结构相等[REF]）。
> > 
> 练习
> 
> > 上述算法相当天真。如果可以选择，我们宁愿看到标识符的类型而不是表达式的类型。修改算法以偏向这个方向。
> > 
> 练习
> 
> > 上述算法的输出令人不满意：一组（已解决的）约束而不是一个“答案”。提取顶层表达式的类型，并仅以类型常量的形式“漂亮地打印”它，只在必要时引用表达式（过度约束和不足约束的解决方案 x)中，我们没有足够的约束来指示 x 的类型，因此也无法确定整个表达式的类型。这不是一个错误；这只是意味着 x 可以是任何类型。换句话说，它的类型是“x 的类型 -> x 的类型”，没有其他约束。这些欠约束标识符的类型被表示为类型变量，因此上述表达式的类型可能被报告为(A -> A)。

统一算法实际上具有一个奇妙的特性：它自动计算表达式的最一般类型，也称为主类型。也就是说，表达式可以具有的任何实际类型都可以通过用实际类型实例化推断的类型变量来获得。这是一个了不起的结果：在计算机战胜人类的另一个例子中，它表示没有人类可以生成比上述算法更一般的类型！

## 30.5Let-多态性

不幸的是，尽管这些类型变量在表面上类似于我们之前拥有的多态性（参数多态性），但它们并不是。考虑以下程序：

| (let ([id (fun (x) x)]) |
| --- |
|   (if (id true) |
|       (id 5) |
|       (id 6))) |

如果我们使用显式类型注释来编写它，它会通过类型检查：

| (if (id<布尔> true) |
| --- |
|     (id<数字> 5) |
|     (id<数字> 6)) |

但是，如果我们使用类型推断，情况就不同了！这是因为 id 类型中的 A 会统一为布尔值或数字，具体取决于约束处理的顺序。在那一点上，id 实际上变成了 (Boolean -> Boolean) 或 (Number -> Number) 函数。在使用另一种类型的 id 时，我们会得到类型错误！

这是因为我们通过统一推断出的类型实际上并不是多态的。这一点很重要：仅仅因为你有类型变量，并不一定意味着你有多态！类型变量可能会在下一次使用时统一，这时你最终得到的只是一个单态函数。相反，真正的多态只有在你可以实例化类型变量时才能获得。

因此，在真正多态的语言中，约束生成和统一是不够的。相反，像 ML 和 Haskell 这样的语言实现了一种俗称的 let-多态。在这种策略中，当在词法上下文中绑定具有类型变量的术语时，类型会自动提升为量化的类型。在每次使用时，术语实际上会自动实例化。

有许多实现策略可以实现这一点。最简单（但令人不满意）的是仅复制绑定标识符的代码；因此，上面每个 id 的使用都会得到它自己的 (fun (x) x) 的副本，因此每个都会得到它自己的类型变量。第一个可能得到类型 (A -> A)，第二个 (B -> B)，第三个 (C -> C)，依此类推。这些类型变量都不会发生冲突，因此我们得到了多态的效果。显然，这不仅增加了程序的大小，而且在存在递归时也不起作用。然而，这给了我们一个更好解决方案的启示：不要复制代码，为什么不只复制类型呢？因此，在每次使用时，我们创建推断类型的重命名副本：id 的 (A -> A) 在第一次使用时变成了 (B -> B)，依此类推，从而实现了与复制代码相同的效果，但不带来其负担。然而，由于所有这些策略实际上都是模仿复制代码，它们只在词法上下文中起作用。

# 源布局和其他一般点

# 源布局和其他一般点

## 头文件

### C/ C++

C 和 C++ 代码往往分布在两种常见类型的文件中：

+   头文件（.h、.hpp）包含类定义、外部函数签名、宏、模板、内联函数。有时内联函数会存储在自己的文件中。标准模板库 C++ 头文件没有文件扩展名。有些第三方库（如 Qt）有时可能会省略扩展名。

+   源文件（.c、.cc、.cpp）包含类和任何私有内容的实现。有时 C++ 会使用诸如前向类引用和 Pimpl 模式等技巧，以将复杂或依赖性代码保存在头文件之外。

有时您也可能会看到带有 .inl 或 .ipp 扩展名的文件，这些文件是具有大量内联模板或函数的头文件。

编译器只关心源文件及其 `#include` 的内容，所以在大多数 C/C++ 代码中真正发生的情况是，预处理器根据其中的 `#` 指令将各种头文件连接到源文件的前面，然后将生成的文件提供给编译器。

将定义和实现分散在多个文件中可能会很麻烦，因为这意味着对单个类的更改可能需要修改多个文件。

### Rust

Rust 没有头文件。每个结构体、实现和宏都驻留在以 .rs 结尾的文件中。通过将 .rs 文件结构化为模块并使用 `pub` 关键字暴露函数来使代码公开或不公开。

排序也不那么重要。可以对结构体或函数进行前向引用，甚至`use`代码片段所属的模块本身。唯一需要排序的时候是宏定义。宏必须在使用它的模块之前定义。

Rust 文件使用 `use` 关键字引用非依赖模块，并使用 `mod` 关键字引入依赖模块。

## 命名空间

## C / C++

C 不使用命名空间。库往往会在函数和结构体前面加上某种限定名称。

C++ *确实*有命名空间，但它们的使用是可选的，而且在不同的代码片段中变化很大。

### Rust

Rust 有模块，它们类似于 `#include` 和命名空间的组合

一个主要的便利是定义和实现是一体的。实现函数就会使其存在。任何其他选择“使用”它的模块只需声明即可，编译器会确保正确编译。

见 Namespacing with modules TODO ref

## 文件名约定

C++ 文件的典型后缀通常是：

+   .h、.hpp、.inl 用于头文件或内联代码

+   .c、.cpp、.cc 用于源代码

除了扩展名（可能会启动编译器以期望 C 或 C++）外，文件几乎没有预期的排列或命名约定。

如果愿意，您可以编译名为 deeply/nested/Timbuktu.cpp 的文件，其中定义了 20 个类和 30 个接口，名称并不重要。

Rust 文件使用蛇形命名法，并以.rs 结尾。文件名很重要，因为名称是其作用域的模块名称。还有一些特殊文件，称为 main.rs、lib.rs 和 mod.rs。

所以如果你把文件命名为 foo.rs，那么外部引用时，其中的所有内容都是以 foo::*的方式作用域。

## Unicode 支持

在 C++中使用 Unicode 一直是一件令人头疼的事情。C 和 C++都没有任何对此的支持，随着时间的推移出现了各种解决方案。最近的 C 和 C++标准的实现提供了用于 UTF 编码的字符串字面量类型，但在此之前严格遵循 ascii 或宽字符。

这里有一些关于 C / C++中 Unicode 的一般指南：

+   源代码通常只能使用 0-127 号字符，尽管一些编译器可能有参数允许 makefile 指定其他编码。

+   C++有 char 和 wchar_t 类型用于 8 位和 32 位或可能是 16 位宽字符串。wchar_t 的问题之一是宽度立即被颠覆了。

+   char 类型不意味着编码。它通常表示 ASCII，但也可能表示 UTF-8、Latin1 或者事实上任何早于 Unicode 的编码形式。基本上，程序要理解其含义。

+   “宽”wchar_t 并不是 UTF-32 的。它可能是 UTF-16，也可能是一些平台上的 UTF-16（例如 Windows）。这个混乱的定义使得对字符串进行切片等操作变得危险，因为可能会穿过控制点。

+   如果我想从命令行读取 Unicode 参数，比如文件路径——它们是什么编码？main()方法将它们作为 char*传递。Windows 有一个接受 wchar_t*的 wmain()。我应该怎么办？

+   Windows 偏爱宽字符（UTF-16）字符串用于其 API，尽管也有 ASCII 版本。ASCII 版本不是 UTF-8 的。编译代码中有#define UNICODE 以支持多种语言。

+   Linux 倾向于使用 UTF-8 编码的 char 字符串。大多数语言、工具包和工具都假定使用 UTF-8。例外是 Qt，它选择在内部使用 UTF-16。

+   C 库已经获得了各种宽版本的 strdup、strcmp、strcpy 等。它还获得了用于在磁盘上打开文件等的函数的宽版本。

+   C++库已经获得了 std::string / std::wstring 类。C++已经获得了这些类的显式 UTF-16 和 UTF-32 版本。

+   C11 和 C++11 引入了各种 UTF 宽度的显式字符串字面量。

+   在 C++中宽字符和窄字符之间的转换能力有限。一些操作系统具有不完整的转换能力。

+   常用的第三方转换库，如 ICU4C。像 boost、Qt 这样的库使用 libicu 进行编码转换。

+   将 Unicode 嵌入到 C 源代码中涉及使用转义码或十六进制值。

Rust 通过事后诸葛亮的好处大大简化了事情。

+   源代码是 UTF-8 编码的。

+   注释、字符和字符串字面量可以包含 Unicode 字符而无需转义。

+   原生 char 类型宽度为 4 个字节——与 Unicode 字符一样宽。

+   本地的`str`和`String`类型在内部是 UTF-8 编码的，以节省空间，但根据函数的操作，可以按字符或按字节进行迭代。

由于源代码是 UTF-8 编码的，你可以直接将字符串嵌入到源代码中。

```
let hello = "你好";
for c in hello.chars() { /* iterate chars */
  //...
} 
```

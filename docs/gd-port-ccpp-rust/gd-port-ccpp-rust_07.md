# Rust 背景

# Rust 背景

Rust 的催化剂是 Mozilla Firefox 网络浏览器。像大多数网络浏览器一样，Firefox 是：

+   用 C++编写。^(1)

+   复杂的，有数百万行代码。

+   易受错误、漏洞和利用攻击，其中许多可以归因于软件所使用的语言。

+   大多数情况下是单线程的，因此不太适合多核设备 - PC、手机、平板电脑等。将多线程实现到现有引擎中无疑会比单线程更容易引起更多的错误和漏洞。

Rust 被构想为一种获得 C 或 C++级别性能的方式，同时也消除了软件中不稳定的整个类别问题，并且可以被利用。通过编译器阶段的代码可以保证是内存安全的，因此可以以一种利用并发优势的方式编写。

因此，Rust 始于 2009 年由格雷登·霍尔为 Mozilla 基金会进行的研究项目，以解决这些问题。它一直发展，直到 2015 年发布了 1.0 版本。

该项目托管在[GitHub](https://github.com/rust-lang/rust)上。该语言已经有一段时间了*自举* - 也就是说，Rust 编译器是用 Rust 编写的，因此从一个用 Rust 编写的编译器中进行 Rust 编译。你要理解这个！但这也是 C 和 C++编译器如今的方式。

^(1) 阅读这个[Mozilla 内部字符串指南](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Internal_strings)以了解浏览器必须克服的问题的风格。一个浏览器显然使用了大量的临时字符串。STL 字符串在不同编译器之间效率低下/不稳定，因此浏览器产生了一个整个树的字符串相关类来解决这个问题。在 Qt 和其他大型库中也有类似的故事。

## C/C++的问题

编写错误代码（如导致内存泄漏）是微不足道的（偶然），而利用糟糕编写的代码使其出现错误是很容易的（恶意）。即使进行了最佳的测试，某些错误也可能只在代码投入生产时才显现出来。

在最好的情况下，错误对开发人员来说是一个昂贵的负担，不仅是时间和金钱，还有他们的声誉。在最坏的情况下，错误可能导致灾难性的失败，但更普遍的是使代码不稳定或容易受到黑客攻击。

Rust 是一种语言，它生成的机器码在性能上与 C/C++相当，但强调安全设计哲学。简而言之，语言和编译器试图阻止错误在第一时间发生。例如，编译器严格执行对象的生命周期跟踪，并在违规时生成错误。这些检查和保护大多数在编译时完成，因此在运行时没有额外开销。

## 活跃的开发

Rust 团队大约每 6 周发布一次新版本。这意味着随着时间的推移，Rust 会接收到代码和速度的改进。

大多数发布版本侧重于将 API 标记为稳定，改进代码优化和编译时间。

## 开源和免费

Rust 双重许可，根据 Apache 2.0 和 MIT 开源许可证。完整的版权信息可在线查看[此处](https://github.com/rust-lang/rust/blob/master/COPYRIGHT)。

本质上，许可证涵盖您修改和分发 Rust 源代码的权利。请注意，Rust 为 LLVM 生成代码，因此 LLVM 也有自己的软件许可证（TODO 链接）。

使用 Rust（或 LLVM）编译的内容不受开源许可证的影响。因此，您可以编译、执行和分发专有代码，而无需遵守这些许可证。

## Rust 适合所有人吗？

当然不是。在编写软件时，性能和安全性只是需要考虑的两个方面。

+   有时程序偶尔崩溃也是可以接受的

+   如果您已经编写并运行正常的代码，为什么要将其丢弃呢？

+   编写新代码总是需要努力的，仍然会导致各种应用级别的错误。

+   对于网络绑定代码，性能可能并不是一个大问题，更适合使用高级语言如 Java、C#、Go。

+   有些人会觉得学习曲线非常陡峭。

+   Rust 作为一种语言仍然相对不成熟，仍然存在一些问题 - 编译时间、优化、复杂的宏。

但您可能仍然会发现将部分代码转移到 Rust 中有益处。例如，您的 C++软件可能运行良好，但必须处理大量用户生成的数据，因此也许您希望在 Rust 中重新实现该代码路径以获得额外的安全性。

## 安全设计。

这种安全设计哲学的一些例子：

+   变量（绑定）默认是不可变的。这与 C++相反，C++中可变是默认的，我们必须明确指定 const 才能使某些东西不可变。不可变性延伸到结构函数上的&self 引用。

+   生命周期跟踪。Rust 编译器将跟踪对象的生命周期，并可以生成代码以在不再使用时自动丢弃它们。如果违反生命周期规则，它将生成错误。

+   借用/变量绑定。Rust 强制规定哪个变量在任何给定时间“拥有”一个对象，并跟踪被移动到其他变量的值。它强制执行关于谁可以持有可变或不可变引用的规则。如果代码尝试使用已移动的变量或获取多个可变引用，则会生成错误。

+   在安全代码中没有 NULL 指针。所有引用和指针都是有效的，因为它们的生命周期和借用是被跟踪的。

+   Rust 使用 LLVM 作为后端，因此生成优化的机器代码。

+   Lint 检查是内置的，例如对命名约定和代码一致性的样式强制执行。

+   单元测试可以集成到代码中并自动运行。

+   模块（等同于命名空间 C++）是自动的，这意味着我们通过文件结构隐式地获得它们。

## C++11 / C++14 难道不能解决这个问题吗？

是的也不是。C++11 和 C++14 当然带来了一些长期以来应该有的变化。并发原语（终于有线程了！）、移动语义、指针所有权和其他有益的东西都随着这些最新的标准而来。诸如类型推断、lambda 等便利功能也随之而来。

也许如果你程序中了正确的特性子集，并且努力避免 C++ 的常见陷阱，你更有可能创建安全的代码。

但什么是*正确*的子集？

+   如果您使用别人的库 - 他们是否使用了正确的子集？

+   如果有一个正确的子集，为什么 C++ 仍然包含所有超出范围的东西？

+   为什么所有明显不安全/危险的东西仍然被允许？

+   为什么某些危险的默认行为，比如默认复制构造函数没有被调整以提高代码安全性？

我们可以说，C++ 不想通过引入需要修改代码的变化来破坏现有代码。这是公平的，但另一方面，未来的代码几乎肯定会因此决定而被破坏。也许对于一点长期利益，稍微付出一些痛苦会更好。

## 不安全的编程 / C 互操作性

Rust 认识到你可能需要调用外部库，例如 C 库或系统 API。

因此，它提供了一个 `unsafe` 关键字，当必须与外界交流时，会打开一些安全开关。

这使您可以考虑部分将代码移植到 Rust，同时仍允许其中一些保留为 C。

# 内存管理

# 内存管理

Rust 的内存模型与 C++非常接近。你在 Rust 中声明的结构要么驻留在堆栈中，要么驻留在堆中。

## 堆栈

堆栈是操作系统为程序中的每个线程保留的内存。堆栈根据其预定大小移动堆栈指针寄存器向前，为本地变量保留空间。当本地变量超出范围时，堆栈指针减少相同的量。

```
// Stack allocated
double pi = 3.141592735;
{
  // Stack pointer moves as values goes in and out of scope
  int values[20] = { 0, 1, 2, 3, ... , 19, 20 };
} 
```

在 C 风格语言中，每个线程中的堆栈通常是代表程序的“最坏情况”情况的单个连续内存块，即你永远不会需要比线程在启动时分配的堆栈更多的堆栈。如果超出堆栈，则会导致堆栈溢出。

一些语言支持分割或分段栈的概念。在这种情况下，堆栈是一系列由链表连接在一起的“堆栈块”。当堆栈不足以进行下一次调用时，它会分配另一个堆栈块。

gcc 可以支持分段栈，但是当抛出异常或者在链接器边界之间进行调用时，比如在了解分段栈的进程和非分段栈动态库之间进行调用时，堆栈展开会变得非常复杂。

## 堆栈溢出

使用堆栈的主要担忧是堆栈溢出的可能性，即堆栈指针移出为堆栈保留的内存并开始侵占其他内存。

这可以通过两种常见方式单独或组合发生：

+   深度嵌套的函数调用，比如递归遍历二叉树的递归函数，或者永远不会停止的递归函数。

+   通过在函数中使用过多和/或大型本地变量来耗尽堆栈，例如大量的 64KB 字节数组。

### C++

一些 C++编译器根本不会捕捉溢出。它们没有守护页，因此允许堆栈指针随内存带它走，直到程序不稳定并崩溃。

gcc 编译器支持分段栈，但正如前面所述，不是没有问题。

当堆栈指针在单次跳转中可能前进超过一页时，MSVC 编译器会添加守护页和堆栈指针检查，并且可能会错过守护页。

### Rust

Rust 曾经支持分段栈作为检测内存违规的手段，但自 1.4 版本以来已将其替换为堆栈空间末尾的守护页。如果守护页被内存写入触及，它将生成一个导致线程停止的分段错误。守护页打开了堆栈可能大幅增长超过守护的小风险，并且可能需要一段时间才能使对守护的写入生成错误。

Rust 希望在所有平台上支持堆栈探测代码生成，到那时它可能会在使用守护页之外使用。堆栈探测是对使用超过一页空间的本地变量的函数生成的额外代码，用于测试它们是否超出堆栈。

Rust 通过一些间接的方式减少了栈溢出的风险。在 C++ 中，通过继承或者无意中调用多态方法会触发递归循环是很容易的。

## 堆

堆是语言运行时从操作系统请求的内存，并通过内存分配调用向您的代码提供的内存。

C++

```
char * v = (char *) malloc(128);
memset(v, 0, 128);
strcpy(v, "Hello world");
//...
free(string);

double *values = new double[10];
for (int i = 0; i < 10; i++) {
  values[i] = double(i);
}
delete []values; 
```

分配只是意味着将堆的一部分标记为已使用，并向代码提供一个指向保留区域的指针，以便按照自己的意愿处理。释放导致该部分返回到其空闲状态，与其在内存中相邻的任何空闲区域合并。

堆可以增长，代码可能会创建多个堆，甚至可能被迫这样做以控制诸如堆碎片化之类的问题。

## Rust

在 Rust 中在堆上分配内存，你在一个盒子内声明数据。例如，要创建一个 1k 字节的块：

```
let x: Box<[u8]> = Box::new([0; 1024]); 
```

std:: 和其他地方的许多结构体将具有基于堆栈的部分，并且还会在内部使用堆来保存它们的缓冲区。

## 堆碎片化

当堆中的连续空间受到它已包含的内存分配模式的限制时，会发生堆碎片化。当发生这种情况时，内存分配可能会失败，堆必须增长才能使其成功。在没有虚拟内存/分页的系统中，由于碎片化造成的内存耗尽可能会导致程序甚至操作系统完全失败。

最简单的查看碎片化的方法是通过一个简单的示例。我们假装没有管理结构、保护块或其他可能干扰的东西。想象一个 10 个字节的堆，最初每个字节都是空闲的。

现在为类型 A 的对象分配 5 个字节。堆保留了 5 个字节并标记为已使用。

![](img/aaaaa-----.png)

现在为类型 B 的对象分配 1 个字节。这也被标记为已使用。

![](img/aaaaaab.png)

现在释放对象 A。堆的一部分被标记为未使用。现在我们有一个 5 个字节的空块和一个 4 个字节的空块。

![](img/-----b----.png)

现在为类型 C 的对象分配 2 个字节。现在我们有一个 3 个字节的空块和一个 4 个字节的空块。

![](img/cc---b----.png)

现在为类型 A 的对象分配 5 个插槽 - 糟糕！我们不能这样做！堆有 7 个字节的空闲空间，但它们不是连续的。在这一点上，运行时将被迫增加堆，即请求操作系统另一个内存块，然后它可以为 A 分配 5 个字节。

![](img/cc---baaaaa---.png)

以上假设堆是连续的，或者内存分页使其看起来是连续的。在某些系统上，堆可能是一系列块的链接列表，在这种情况下，对象 A 的分配空间必须驻留在单个块中，即上面新分配的部分。

这也是一个夸张的例子，但它展示了堆可以有空间，但没有足够的空间来满足分配需求而不得不增长。

在嵌入式设备中运行的软件特别容易受到碎片化的影响，因为它们没有虚拟内存，物理内存较低，并且通常需要连续运行数天、数周或数年。

C++ 的一个主要问题是几乎无法避免堆碎片化。标准模板库为几乎所有的字符串和集合工作分配内存，如果一个字符串/集合增长了，那么可能需要重新分配更多的内存。

缓解问题的唯一方法是选择最佳的集合，并在可能的地方预留容量。

```
std::vector<double> values;
values.reserve(10);
for (int i = 0; i < 10; i++) {
  values.push_back(double(i));
} 
```

Rust 也存在这个问题，字符串/集合有方法来预留容量。但由于其设计的结果，它更倾向于使用栈而不是堆。除非显式地通过放入 Box、Cell 或 RefCell 来分配内存，否则不会在堆上分配内存。

## RAII

RAII 是 Resource Acquisition Is Initialization 的缩写。这是一种编程模式，将对象对资源的访问与对象的生命周期绑定在一起。

C++ 类允许一种称为 RAII（资源获取即初始化）的模式。一个类构造函数获取某些资源，析构函数释放该资源。一旦类超出范围，资源就会被释放。

**TODO** C++ 示例

Rust 本质上是 RAII，并通过生命周期来强制执行。当一个对象超出范围时，它所持有的东西会被释放。Rust 还允许程序员在自然生命周期之前显式地释放一个结构体，如果有理由的话。

RAII 最常见的用于堆分配的内存，但它也适用于文件、系统句柄等。

**TODO** Rust 示例

# C 和 C++ 背景

# C 和 C++ 背景

本节讨论了 C 和 C++。它描述了它的历史、标准，并提供了一个背景，说明它是如何发展到今天的。

## C 的历史

### 早期

C 的创建与 Unix 的早期有着密切关联。贝尔实验室将 Unix 开发出来，这是从一个名为 Multics 的早期项目发展而来的。Unix 的第一个版本在 PDP-7 微型计算机上运行，资金被提供用于将其移植到 PDP-11。Dennis Ritchie 是这个项目的关键成员，他着手创建一种语言，可以帮助他开发 Unix，同时最大限度地减少他必须编写的汇编语言量。到那时为止，大部分代码都是用汇编语言表达的，这种方式容易出错，显然不可移植。

Ritchie 开发了 C，以便他可以用变量、表达式、循环、函数等来编写代码，并使用 *编译器* 将 C 代码转换为机器代码。生成的代码几乎与手写的汇编代码一样快，并且更具可移植性，因为只需更改编译器即可支持新的架构。C 本身受到 B 的影响（因此被称为 C），而 B 受到 BCPL 的影响。

### 事实标准和日益流行

1978 年，C 被正式制定为一个名为 K&R C 的事实标准，以 Brian Kernighan 和 Dennis Ritche 的名字命名，他们将该标准出版为一本书。

随着时间的推移，C 的使用变得更加广泛，诸如 Turbo C、Lattice C、Microsoft C 等编译器在其他操作系统上（包括个人计算机）推广了 C。

### 国际标准

C 后来成为 ANSI 标准，C89。随后又有了 C99 标准，C 仍在审查和发展中。

一些在 C++ 中引入的功能也已经回归到 C 标准中。例如，// 样式的单行注释和块内变量声明规则。

## C++ 的历史

C++ 首次出现在 1983 年，称为 C with classes。它是由 Bjarne Stroustrop 发明的，作为赋予 C 类似 Simula 特性的一种方式。Simula 是一种允许对象、类和继承等概念在代码中表达的语言，正如其名称所暗示的那样，是为了运行模拟而创建的。然而，它被认为对于系统编程来说太慢了，因此将 C 的速度与面向对象的概念结合起来是非常可取的。

C++ 将这些概念作为 C 语言的扩展，并使用一个名为 `cfront` 的预编译器将 C++ 扩展转换为 C 代码，然后可以将其编译成机器代码。因此，C++ 程序可以具有高级面向对象的概念，但没有 Simula 带来的开销。

C++ 逐渐成为独立流行，并超越了 cfront 预处理器的限制，成为编译器自身支持的语言。因此，诸如 Microsoft Visual C++、GCC、Clang 等工具链都支持这两种语言。一些工具链也开始倾向于支持 C++ 而不是 C，例如微软的编译器一直很慢地实现 C99。

面向对象编程主要用于更高级别的软件 - 应用程序、游戏、模拟和数学工作。

C++也已经成为正式的标准，有 C++98、C++03、C++11 等。

#### 现代 C++

从 C++11 开始，它与早期版本有着明显的不同，努力添加功能，如果正确使用，可以消除后面将讨论的许多问题：

+   作用域和共享指针

+   auto 关键字

+   移动语义（即将数据所有权从一个变量移动到另一个变量）

+   右值引用

+   完美转发

+   空指针显式类型

然而，值得注意的是，由于许多这些东西是 C++的后期添加。像移动语义这样的东西必须显式使用，并且具有在 Rust 中不存在的影响，因为它们从一开始就是语言的一部分。

### C 和 C++之间的关系

尽管 C++起源于 C 并与之并行发展，但不能说 C++是 C 的超集。相反，它*大部分*是一个超集。例如，C 认识到的关键字和头文件在 C++中不认识。

C++具有函数重载和类，并使用名称混淆来消除重载函数的歧义。但实际上可以将 C 写成 C++的子集，并将两者编译成相同的可执行文件。大多数现实世界的 C 代码可以称为没有类的 C++。

C 和 C++通常由相同的工具链处理。大多数编译器由一个前端解析语言为中间形式和一个后端将中间形式转换为优化的机器代码组成。最后，链接器将所有二进制对象连接在一起形成可执行文件。C 和 C++将共享大部分这个代码路径。

C++倾向于在应用程序级别编程中更受欢迎。C++没有出现在较低层的部分的部分原因是人们认为异常处理、名称混淆、链接等问题增加了不必要的复杂性，或者生成的代码效率不高。有人认为这并非如此，但这种看法仍然存在。

C 仍然在低级系统编程中更受欢迎。诸如 Linux 内核之类的组件是纯 C 编写的，还有一些汇编语言。许多流行的开源库，如 sqlite3，也是用 C 编写的。

## Objective-C

Objective-C 是另一种源自 C 的语言，添加了对象和类。与 C++不同，Objective-C 表现为 C 的严格超集。

该语言在上世纪 80 年代开发，并在 NeXTSTEP 操作系统中广泛流行，后来在苹果的 OS X 和 iOS 中也得到推广。在这些平台之外，它并没有获得太多的流行，但 iPhone 的成功确保了它拥有庞大的开发者基础。它也得到了 GCC 和 Clang 工具链的良好支持。苹果已经开始弃用 Objective-C，转而支持 Swift，这是一种现代的高级语言，在某些方面类似于 Rust，但更注重应用程序。

Objective-C 受 Smalltalk 的强烈影响（与 C++中的 Simula 相反），因此代码的工作方式与 C++略有不同。

概念上，代码通过向对象发送消息来调用它们。对象定义了一个接口，指定它接受的消息以及将这些消息绑定到代码的实现。调用者代码发送消息来调用一个方法。对象也可以接收动态消息，即未由它们的接口定义的消息，因此它们可以执行某些任务，例如拦截和转发消息。此外，对象可以忽略消息或不实现消息而不被视为错误。广义上说，ObjC 消息和 C++方法在功能上或多或少是类似的。

## C/C++ 时间线

这些是 C 和 C++的主要修订版本

| 年份 | 事件 | 描述 |
| --- | --- | --- |
| 1972 | C | 用于 PDP-11、其他 Unix 系统的 C |
| 1978 | K&R C | Kernighan & Ritchie 的《The C Programming Language》书中定义的 C |
| 1989 | C89 (ANSI X3.159-1989) | C 标准化为 ANSI C，或 C89。C90 (ISO/IEC 9899:1990) 是这个相同标准的 ISO 认可版本。 |
| 1979 | 带类的 C -> C++ | Bjarne Stroustrops |
| 1995 | C95 (ISO/IEC 9899/AMD1:1995) | 宽字符支持，双字符，新宏，以及一些其他较小的更改。 |
| 1998 | C++98 (ISO/IEC 14882:1998) | C++首次标准化。 |
| 1999 | C99 (ISO/IEC 9899:1999) | 单行（//）注释，声明与代码混合，新的内置类型，内联，新的头文件，可变长度数组 |
| 2003 | C++03 (ISO/IEC 14882:2003) | 主要是一个缺陷修订，解决了规范中的各种缺陷。 |
| 2011 | C++11 (ISO/IEC 14882:2011) | 一个主要的修订，引入了类型推断（auto），基于范围的循环，lambda，强类型枚举，nullptr 常量，结构初始化。改进的 unicode char16_t、char32_t、u、U 和 u8 字符串字面量。 |
| 2011 | C11 (ISO/IEC 9899:2011) | 多线程支持。改进的 unicode char16_t、char32_t、u、U 和 u8 字符串字面量。其他较小的更改 |
| 2014 | C++14 (ISO/IEC 14882:2014) | 另一个主要修订，引入了自动返回类型，变量模板，数字分隔符（1'000'000），泛型 lambda，lambda 捕获表达式，不推荐使用的属性。 |

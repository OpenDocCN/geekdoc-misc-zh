## 书中的语言

这本书大量使用了[Racket](https://www.google.com/url?q=https://racket-lang.org/&sa=D&source=editors&ust=1695232021067159&usg=AOvVaw0kEHgZx4wlLC_o1l7GnVcx)。然而，这过于简单了。Racket 的力量在于其定义新语言的能力：[这篇文章](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/fffkbmt-programmable-prog-lang/&sa=D&source=editors&ust=1695232021067394&usg=AOvVaw214fGxlshmCAnJzUJUG5dk)和[这个简短的视频](https://www.google.com/url?q=https://youtu.be/R_1TnfCuxK8&sa=D&source=editors&ust=1695232021067621&usg=AOvVaw055kiEdpnPdwxtKaQRyL0R)更详细地讨论了这一点。确实，这本书中的一些程序是用 Racket 编程语言编写的（`#lang racket`），但许多是用为这本书理想设计的语言编写的（`#lang plait`）。此外，其他部分还定义了自己的语言：有多个 SMoL 语言和十几个以上的神秘语言。因此，虽然学习者必须对括号语法表现出一定的耐心，但作为回报，他们将获得丰富的学习体验。

`#lang`的存在，在某种程度上，推动了这本书的重设计。我在那个特性的[设计](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/cffk-macros-to-dsls/&sa=D&source=editors&ust=1695232021068197&usg=AOvVaw2ek0jEgcbTPyCNMaXY6ktq)中有所参与，这让我感到非常自省：面向广大受众的材料不应该是与我内心深处的工作过于接近。这就是为什么，虽然第一版使用了 Racket 的前身，但第二版却没有。然而，在这个过程中，我意识到我剥夺了我的学生许多学习机会：毕竟，还有什么比为设计语言而设计的语言更适合研究语言的呢？例如，神秘语言的第一个版本是临时的且令人困惑的；将它们重新实现为 Racket 的`#lang`集合使它们变得简单得多，也更清晰（而且也使它们成为直接研究的对象）。因此，这一版在 Racket 的使用上加大了力度（甚至更多）。做到正确可能很棘手（例如，避免模式混淆），可能需要几轮迭代，但这是值得付出的努力。

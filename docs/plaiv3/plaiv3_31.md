## 实现条件语句

好吧，所以我们有很多决定要做！为了首先得到一个可以工作的评估器，而不必超出数字的范围，我们可以使用一个稍微不同的条件构造：一个检查是否评估为特殊数值的条件，比如`0`。也就是说，我们实际上有一个可能称为`if0`的东西，它只适用于数字。

我们如何做出这个选择？幸运的是，我们正在用 plait 编写我们的解释器，它当然已经有一个条件语句。因此，我们只需重用它：

```
(define (calc e)
  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ (calc l) (calc r))]
    [(cnd c t e) (if (zero? (calc c))
                     (calc t)
                     (calc e))]))
```

注意，现在条件语句的语义——`0`为真，其他一切为假——已经在`calc`的主体中得到了体现。如果我们想要不同的语义，那就是程序需要集中改变的部分。

这个解决方案，实际上到目前为止我们的整个评估器，可能感觉有点……令人失望？我们确实有数字和条件语句，但我们所做的只是（主要）推迟到 plait 来处理这些。以下是一些关于这个问题的思考：

1.  这是真的！

1.  这并不完全正确。我们做出了一些有意识的决策，比如条件语句的处理。

1.  事实上，我们做出了更多的决定，无论我们是否意识到它们，比如数字的处理。我们只是碰巧把这些推迟给了 plait，但如果我们想的话，我们也可以做出其他决定。

1.  这种重用实际上是解释器力量的一个部分：它让你可以利用已经构建好的特性，而不是从头开始重新实现所有这些特性。

1.  通过重用宿主语言（在这里是 plait），我们可以专注于差异（比如条件语句的处理），否则如果我们不得不实现所有这些，这些差异可能会丢失。稍后我们将看到对 plait 语义的更强烈的偏离。

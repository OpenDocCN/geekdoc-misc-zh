## 手动模拟解释器

由于我们已经决定编写一个解释器，让我们首先了解我们想要让它做什么，然后再去研究我们将如何让它做到这一点。

让我们考虑以下程序：

```
(define (f x) (+ x 1))
(f 2)
```

它会产生什么？我们都可以猜到它会产生 `3`。现在假设我们被问及，为什么它会产生 `3`？你可能会说什么？

有很大可能性你会说这是因为 x 在 f 的主体中被替换成了 2，然后我们计算主体，这就是答案：

→ `(f 2)`

→ `(+ x 1)`其中 `x` 被替换为 `2`

→ `(+ 2 1)`

→ `3`

这些程序是用 Racket 编写的。你可以将这些程序放入 DrRacket 的早期学生语言级别（如 Beginning Student）中，并使用菜单栏中的 Step 按钮逐步运行它们：

![](img/image21.png)

现在让我们看看程序的扩展版本：

```
;; f is the same as before
(define (g z)
  (f (+ z 4)))
(g 5)
```

我们可以使用相同的过程：

→ `(g 5)`

→ `(f (+ z 4))`其中 `z` 被替换为 `5`

→ `(f (+ 5 4))`

→ `(f 9)`

→ `(+ x 1)`其中 `x` 被替换为 `9`

→ `(+ 9 1)`

→ `10`

术语：我们称函数头中的变量为形式参数，函数调用中的表达式为实际参数。所以，在 `f` 中，`x` 是形式参数，而 `9` 是实际参数。有些人也用 argument（论元）代替 parameter（参数），但这些术语之间没有真正的区别。

注意我们有一个选择：我们可以选择

→ `(f (+ 5 4))`

→ `(f 9)`

或者

→ `(f (+ 5 4))`

→ `(+ x 1)`其中 `x` 被替换为 `(+ 5 4)`

目前，这两个都会产生相同的答案，但这实际上是一个非常重要的决定！这实际上是在编程语言设计中最重要的选择之一。

术语：前者被称为 eager evaluation（急切求值）：把它想象成在开始函数调用之前“急切”地将实际参数减少到值。后者被称为 lazy evaluation（惰性求值）：把它想象成不急于执行评估。

SMoL 是 eager（急切）。这有很好的理由，我们将在后面探讨 [👉]。

好的，所以回到评估。让我们再走一步：

```
;; f is the same as before
;; g is the same as before
(define (h z w)
  (+ (g z) (g w)))
(h 6 7)
```

再次，我们可以看看这些步骤：

→ `(h 6 7)`

→ `(+ (g z) (g w))`其中 `z` 被替换为 `6` 和 `w` 被替换为 `7`

→ `(+ (g 6) (g 7))`

→ `(+ (f (+ y 4)) (g 7))`其中 `y` 被替换为 `6`

→ `(+ (f (+ 6 4)) (g 7))`

→ `(+ (f 10) (g 7))`

→ `(+ (+ x 1) (g 7))`其中 `x` 被替换为 `10`

→ `(+ (+ 10 1) (g 7))`

→ `(+ 11 (g 7))`

→ `(+ 11 (f (+ y 4)))`其中 `y` 被替换为 `7`

→ `(+ 11 (f (+ 7 4)))`

→ `(+ 11 (f 11))`

→ `(+ 11 (+ x 1))`其中 `x` 被替换为 `11`

→ `(+ 11 (+ 11 1))`

→ `(+ 11 12)`

→ `23`

注意我们再次有一些选择：

+   我们是一次替换两个调用，还是逐个替换？

+   如果是后者，我们是先做左边的还是右边的？

语言也需要在这些方面做出决定！上面，我们又做了 SMoL 所做的事情：在开始下一个调用之前完成一个调用，这使得 SMoL 是顺序的。如果我们同时替换这两个调用，我们就会探索一种并行语言。传统上，大多数语言选择从左到右的顺序，因此我们在 SMoL 中也选择了这种顺序。

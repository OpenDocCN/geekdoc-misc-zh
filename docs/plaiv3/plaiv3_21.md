## 一些更微妙的测试

尝试以下测试：

```
(test (calc (plus (num 0.1) (num 0.2))) 0.3)
```

它成功了！我们高兴吗？假设我们将其改写为：

```
(test (calc (plus (num 0.1) (num 0.2))) 1/3)
```

如预期的那样，它失败了：但是错误信息揭示了左侧评估结果为 0.30000000000000004。这应该是一个提示，我们实际上得到了[浮点数](https://www.google.com/url?q=https://0.30000000000000004.com/&sa=D&source=editors&ust=1695232021117958&usg=AOvVaw3K_UT0jvSMRzJJKE3HmGaN)加法。这是因为 plait 将带有小数点的数字，如`0.1`，视为浮点比特串。然而，浮点比特串无法精确表示数字 0.3。事实上，plait 的`test`允许一点数值上的宽松，使得上面的通过测试得以进行。（这是因为在大脑中，`0.3`确实精确地表示了数字 0.3，因为它是以文字形式书写的，而不是浮点计算的结果。）

这加强了我们上面提到的一个观点，因此很容易被忽略：通过采用 plait 的原始元素，我们也继承了其语义。这可能是我们想要的，也可能不是！因此，当使用宿主语言编写评估器时，我们必须确保其语义是我们想要的，否则我们可能会遇到不愉快的惊喜。如果我们想要不同的行为，我们必须明确实现它。

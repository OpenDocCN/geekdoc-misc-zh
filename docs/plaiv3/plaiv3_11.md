# 纸上评估

## 评估器

我们试图实现一种编程语言：也就是说，编写一个评估器（即“将程序简化为值”的东西）。如果我们能首先理解在纸上如何进行评估，然后再开始处理计算机复杂性，这会有所帮助。

在我们深入细节之前，值得知道的是，从广义上讲，有两种类型的评估器（以及许多它们的组合）。它们遵循非常不同的策略：

+   解释器消耗一个程序并模拟其执行。也就是说，解释器做的是我们预期“运行程序”应该做的事情。

+   编译器消耗一个程序并生成另一个程序。然后，必须进一步评估该输出程序。

即，解释器将某种语言 L 中的程序映射到值：

解释器 :: ProgramL → Value

我们现在不对“值”的确切含义进行详细说明，非正式地理解它为用户希望看到的答案——换句话说，某种不需要或不需要进一步评估的东西。相比之下，

编译器 :: ProgramL → ProgramT

即，从 L 到 T（我们用 T 表示“目标”）的编译器消耗 L 中的程序并生成 T 中的程序。我们并没有说这个 T 程序必须如何评估。它可以直接被解释，或者可以进一步被编译。例如，可以将 Scheme 程序编译成 C。C 程序可以直接被解释，但它也可能被编译成汇编。然而，我们不能无限制地编译：在底层，必须有一些类型的解释器（例如，在计算机的硬件中）来提供答案。

注意，解释器和编译器本身也是用某种语言编写的程序，并且必须自己运行。这自然会引出有趣的想法和问题。

在我们的研究中，我们将主要关注解释器，但也会看到一种非常轻量级的编译器形式。解释器之所以有用，是因为：

1.  简单的解释器通常比编译器更容易编写。

1.  调试解释器有时可能比调试编译器要容易得多。

因此，它们提供了一个有用的“基准”实现技术，每个人都可以达到。编译器通常可以涵盖整个学习课程。

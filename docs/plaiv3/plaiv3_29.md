## 条件语句的设计空间

即使是最简单的条件语句也暴露了语言设计中许多不同的变体。其意图是首先评估测试表达式；如果结果是真值，那么（仅）评估 then 表达式，否则（仅）评估 else 表达式。（我们通常将这两部分称为分支，因为程序的控制必须采取其中之一。）然而，即使这个简单的结构也导致了至少三个不同的、主要独立的设计决策：

1.  测试表达式可以是哪种类型的值？在一些语言中，它们必须是布尔值（两个值，一个代表真，另一个代表假）。在其他语言中，这个表达式可以评估为几乎任何值，其中一些集合——俗称为真值——代表真（即，它们会导致执行 then 表达式），而其余的则是假值，意味着它们会导致 else 表达式执行。

    初始时，设计一个具有多个真值和假值的语言可能看起来很有吸引力：毕竟，这似乎给程序员提供了更多便利，允许非布尔值函数和表达式在条件中使用。然而，这可能导致跨语言之间令人困惑的不一致性：

| 值 | JavaScript | Perl | PHP | Python | Ruby |
| --- | --- | --- | --- | --- | --- |

|

```
-1
```

| 真值 | 真值 | 真值 | 真值 | 真值 |
| --- | --- | --- | --- | --- |

|

```
0
```

| 假值 | 假值 | 假值 | 假值 | 真值 |
| --- | --- | --- | --- | --- |

|

```
""
```

| 假值 | 假值 | 假值 | 假值 | 真值 |
| --- | --- | --- | --- | --- |

|

```
"0"
```

| 真值 | 假值 | 假值 | 真值 | 真值 |
| --- | --- | --- | --- | --- |

|

```
NaN
```

| 假值 | 真值 | 真值 | 真值 | 真值 |
| --- | --- | --- | --- | --- |
| `nil`、`null`、`None`、未定义 | 假值 | 假值 | 假值 | 假值 | 假值 |

|

```
[]
```

| 真值 | 真值 | 假值 | 假值 | 真值 |
| --- | --- | --- | --- | --- |
| 空映射或对象 | 真值 | 假值 | 假值 | 假值 | 真值 |

当然，这不必如此复杂。例如，Scheme 语言只有一个假值：false 本身（写作`#false`）。其他所有值都是真值。对于那些重视在条件中允许非布尔值的人来说，这代表了一种优雅的权衡：这意味着一个函数不需要担心计算结果中可能引起条件反转的类型一致值。（例如，如果一个函数返回字符串，它不需要担心空字符串可能与其他字符串被不同对待。）请注意，受 Scheme 部分启发的 Ruby 语言采用了这个简单的模型。另一个受 Scheme 启发的语言 Lua，在假值方面也很简洁。

1.  分支有哪些术语？一些语言在语句和表达式之间做出区分；在这些语言中，设计者需要决定哪些是允许的。在一些语言中，甚至有两种语法形式的条件来反映这两种选择：例如，在 C 语言中，`if`使用语句（并且不返回任何值），而“三元运算符”（`(...?...:...)`）允许表达式并返回一个值。

1.  如果分支是表达式并且因此可以评估为值，这些值之间是如何相关的？许多（但并非所有）具有静态类型系统的语言都期望两个分支具有相同的类型 [👉]。没有静态类型系统的语言通常不设置任何限制。

旁白：在撰写本章的早期版本时，我在 Pyret 编程语言中遇到了一个奇怪的错误：所有数值 s-表达式都被解析为 `s-num` 值，除了 `0`，它被解析为 `s-sym`。最终 Justin Pombrio 报告说：“这是一个愚蠢的错误，在 JavaScript 中的 `if` 语句中，它将 `0` 误认为是 false。”这似乎很合适。

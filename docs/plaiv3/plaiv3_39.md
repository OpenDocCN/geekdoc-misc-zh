## 本地绑定的评估器

现在我们已经看到了我们想要的行为，我们应该实现它。也就是说，我们将扩展我们的计算器以处理本地绑定（你可能非常希望你的计算器拥有这个功能）。为了反映我们的计算器正在成长，从现在起我们将称它为解释器，在代码中简写为`interp`。

让我们从新的抽象语法树（AST）开始。为了简化，我们将忽略条件语句，因为它们无论如何都与我们的目标——处理本地绑定——正交。回想一下，我们在巴科斯-诺尔范式（BNF）中添加了两个新的分支，因此我们也将想要为抽象语法树添加两个新的对应分支：

```
(define-type Exp
  [numE (n : Number)]
  [plusE (left : Exp) (right : Exp)]
  [varE (name : Symbol)]
  [let1E (var : Symbol)
         (value : Exp)
         (body : Exp)])
```

我们也可以复制我们之前的计算器，但我们很快就会遇到麻烦：

```
(define (interp e)
  (type-case (Exp) e
    [(numE n) n]
    [(varE s) …]
    [(plusE l r) (+ (interp l) (interp r))]
    [(let1E var val body) …]))
```

当我们遇到`let1E`时我们该怎么办？同样，当我们遇到变量时我们该怎么办？实际上，这两个应该是紧密相连的：前者引入的变量绑定应该替换后者中的变量使用。

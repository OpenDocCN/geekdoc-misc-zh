## 更新评估器

现在假设我们尝试使用现有的代码：

```
[(plusE l r) (+ (calc l) (calc r))]
```

这有两个问题。第一个是我们不能返回一个数字；我们必须返回一个`numV`：

```
[(plusE l r) (numV (+ (calc l) (calc r)))]
```

但现在我们遇到了一个更微妙的问题。类型检查器对这个程序不满意。为什么？

因为`calc`的结果是一个`Value`，而`+`运算符只消耗`Number`类型的值。实际上，类型检查器正在强迫我们做出决定：如果`+`运算符的一侧没有评估为数字会发生什么？

首先，让我们构建一个抽象来处理这个问题，这样我们就可以保持解释器核心的相对简洁：

```
[(plusE l r) (add (calc l) (calc r))]
```

现在我们可以将评估`+`的逻辑推迟到`add`函数。现在我们必须做出一个语义上的决定。我们是否应该允许“添加”两个布尔值？或者将一个数字添加到布尔值，或者反过来？虽然这里并没有一个明确的 SMoL 决定——一些语言非常严格，而另一些语言则非常宽容——但最不标准的政策是要求两个分支都评估为数字，我们可以这样表达：

```
(define (add v1 v2)
  (type-case Value v1
    [(numV n1)
     (type-case Value v2
       [(numV n2) (numV (+ n1 n2))]
       [else (error '+ "expects RHS to be a number")])]
    [else (error '+ "expects LHS to be a number")]))
```

注意，这些`else`子句可以轻松地表示其他决策。我们可以在不同的选择中嵌入一个完整的神秘语言家族！

练习：为什么我们在`add`而不是在`calc`中编写了`numV`构造函数？

小贴士：你刚刚添加了一块复杂的代码。现在是一个非常好的时候来测试你的评估器。这里有几点要考虑：

1.  目前，条件语句的代码也没有通过类型检查。你可能发现用一些语义上不正确但类型正确的代码替换整个右侧部分很方便，比如`(numV 0)`，这样你就可以恢复你的工作评估器。

1.  不要忘记测试错误情况！你可以使用`test/exn`来这样做。例如：`(test/exn (calc (plusE (numE 4) (boolE #false))) "RHS")`

现在，让我们将注意力转向条件（构造函数名称已更新）：

```
[(cndE c t e) …]
```

核心逻辑必须明显相似：检查一下条件，然后根据它评估另外两个子句中的一个。再一次，我们必须决定如何处理条件：我们应该严格要求布尔值，还是应该做出真/假的决定？我们还可以将这个决定推迟到辅助函数：

```
    [(cndE c t e) (if (boolean-decision (calc c))
                      (calc t)
                      (calc e))]))
```

再次强调，最不标准的政策，也是为后续内容奠定基础的政策，是严格要求布尔值：

```
(define (boolean-decision v)
  (type-case Value v
    [(boolV b) b]
    [else (error 'if "expects conditional to evaluate to a boolean")]))
```

但再次强调，从严格的解释开始，我们可以看到我们可以在哪里屈服于我们感到的任何想要设计更自由语义的冲动：通过替换`else`子句。

顺便说一下，我们在处理条件语句时与处理加法时有所不同。对于`add`，我们评估了两个分支并给出了它们相应的`Value`。对条件语句做这样的事情是个糟糕的想法，因为条件语句的全部意义就在于不评估其中一个分支！我们可以将分支的 AST 发送给一个辅助函数，但我们上面所做的方法也适用：它将语义上的变化局部化到辅助函数中，但将那些预期不会改变的部分（即条件语法导致条件评估的事实）保留在评估器的核心部分。

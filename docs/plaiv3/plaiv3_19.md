# 评估算术

## 定义评估器

看过如何表示算术程序后，我们转向编写一个评估程序，将它们转换为答案。

这个评估器的类型是什么？显然它消耗程序，在这里由`Exp`表示。它产生什么？在这种情况下，所有这些表达式都将产生数字。因此，我们现在可以称这个为计算器，或者简称为`calc`。因此，我们可以给`calc`赋予类型

```
(calc : (Exp -> Number))
```

现在我们来尝试定义它的主体。显然我们必须有

```
(define (calc e)
  …)
```

在主体中，给定一个 Exp，我们希望使用类型匹配将其拆分，这告诉我们有两种选择，每种选择都有一些额外的数据（这在 Java 中相当于方法调用的方式）：

```
  (type-case Exp e
    [(num n) …]
    [(plus l r) …])
```

如果整个表达式已经是一个数字会发生什么？好吧，我们有了答案，所以我们只需返回它。否则，我们必须将两边相加：

```
  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ l r)])
```

给我们一个整体体：

```
(define (calc e)
  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ l r)]))
```

让我们运行它……哎呀！我们得到一个类型错误！它告诉我们加法期望一个数字，但`l`不是一个数字：它是一个`Exp`。啊，这是因为`l`和`r`仍然代表表达式，而不是表达式评估到的答案。为了解决这个问题，我们需要一个可以将表达式转换为数字的东西……这正是我们正在定义的！因此，我们改为写

```
(define (calc e)
  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ (calc l) (calc r))]))
```

类型检查器现在很高兴。确实，我们可以确认我们的示例产生了我们预期的结果。例如：

```
(calc (num 1))
```

产生`1`，

```
(calc (plus (num 1) (num 2))
```

产生`3`，并且

```
(plus (num 1)
      (plus (num 2) (num 3)))
```

产生`6`。

旁白：我们忽略了一个细节：我们假设`+`总是表示数值加法（这在 AST 中调用它为“`plus`”时已经隐含）。但有些语言允许任何数量的不同类型进行“加法”：例如，它也可以连接字符串。在这些语言中，AST 中的名称可能更通用，评估器需要处理不同的可能行为。

实际上，我们忽略了一个更基本的问题：数值加法的含义，或者更确切地说，甚至数字是什么。正如我们从《神秘语言：算术》中看到的那样，这里有很多选择。在我们的计算器中，我们采用了来自 plait（在`num`中）的数字和来自 plait 的加法（通过使用`+`）。`calc`中的这些地方也告诉我们，如果我们想要改变这些选择，我们应该去哪里。

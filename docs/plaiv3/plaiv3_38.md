## 静态作用域

程序

```
{let1 {x 1}
  {+ {let1 {x 2} x}
     x}}
```

介绍了一个非常重要的概念：实际上，SMoL 背后的核心思想之一。这就是变量的绑定由其在源程序中的位置决定，而不是由程序执行的顺序决定。也就是说，最后一行的`x`与相同的绑定位置绑定——因此获得相同的值——不考虑它在评估之前发生的其他绑定。为了更好地理解这一点，让我们看看一系列程序：

```
{let1 {x 1}
  {+ {let1 {x 2} x}
     x}}
```

你可能会认为，无论它产生`3`还是`4`都是可以接受的。再看看这个？

```
{let1 {x 1}
  {+ {if true
         {let1 {x 2} x}
         4}
      x}}
```

你应该期望这个结果：条件始终为真，因此显然我们总是要评估内部绑定，所以它的答案应该与上一个程序相同。但是，关于这个呢？

```
{let1 {x 1}
  {+ {if true
         4
```

{let1 {x 2} x}`}`

```
      x}}
```

现在你可能不太确定。由于条件从未被采取，你可能不希望内部绑定产生影响。也就是说，你愿意让程序的流程控制影响绑定。表面上这听起来合理，但现在看看这个程序？

```
{let1 {x 1}
```

`{+ {if` {random}

```
         4
         {let1 {x 2} x}}
      x}}
```

或

```
{let1 {x 1}
```

`{+ {if` {moon-is-currently-full}

```
         4
         {let1 {x 2} x}}
      x}}
```

你能否接受绑定结构每两周改变一次？看看这个版本：

```
{let1 {x 1}
  {+ {if {moon-is-currently-full}
         4
```

`         {let1 {`y` 2} x}}`

y`}}`

然后，根据月亮的相位，程序要么产生一个答案，要么导致未绑定变量错误。

让控制流决定绑定的决定被称为动态作用域。这是编程语言中一个明确错误的设计决策。它有一个漫长而复杂的历史：原始的 Lisp 就有这个，直到十多年后 Scheme 才修复了它。不幸的是，那些不了解历史的人注定要重蹈覆辙：Python 和 JavaScript 的早期版本也有动态作用域。将其移除是一个艰巨的任务。动态作用域意味着：

+   我们无法确定我们程序的绑定结构。

+   评估器也无法确定。

+   程序员工具也无法确定。

例如，一个程序重构工具需要了解绑定结构：即使是简单的“变量重命名”工具也需要知道哪些变量需要重命名。在 DrRacket 中，没有歧义，因此变量重命名可以正确工作。在其他语言中并非如此：例如，参见[这篇论文](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&sa=D&source=editors&ust=1695232021187018&usg=AOvVaw137u3e7Dklg2SwW_JHiS7q)附录 2 中关于 Python 语法的讨论。

与动态作用域相反——我们可以通过跟随 AST 的结构来确定绑定——被称为静态作用域。静态作用域是 SMoL 的一个定义特征。

动态作用域在早期实现中发生，因为它很容易获得：它是默认行为。我们将看到，要获得静态作用域，我们需要付出更多的努力。

## 抽象语法的表示

在本书的其余部分，除非另有说明，我们将使用 Racket 语言的[plait](https://www.google.com/url?q=https://docs.racket-lang.org/plait/index.html&sa=D&source=editors&ust=1695232021101325&usg=AOvVaw1V2YliLbtsEZqqySfseP61)语言来实现这些功能。请确保您已安装 plait，以便跟随。

我们将在 plait 中创建一个新的树状数据类型来表示 AST。在上面的句子图中，树的叶子是单词，节点是语法术语。在我们的 AST 中，叶子将是数字，而节点将是表示每个子表达式的树的运算。目前，我们只有一个运算：加法。以下是我们在 plait 语法中表示它的方法：

```
(define-type Exp
  [num (n : Number)]
  [plus (left : Exp) (right : Exp)])
```

这表示：

+   我们正在定义一个新的类型，`Exp`

+   创建`Exp`有两种方式

+   一种方式是通过构造函数`num`：

+   `num`运算需要一个参数

+   那个参数必须是一个实际的数字

+   另一种方式是通过构造函数`plus`：

+   `plus`运算需要两个参数

+   两个参数都必须是`Exp`

如果阅读以下内容时这有助于您，这非常类似于以下 Java 伪代码框架（或 Python 数据类的类似物）：

```
abstract class Exp {}
```

```
class num extends Exp {
  num(Number n) { … }
}
```

```
class plus extends Exp {
  plus(Exp left, Exp right) { … }
}
```

让我们看看一些先前示例是如何表示的：

| 表面语法 | AST |
| --- | --- |

|

```
1
```

|

```
(num 1)
```

|

|

```
2.3
```

|

```
(num 2.3)
```

|

|

```
1 + 2
```

|

```
(plus (num 1) (num 2))
```

|

|

```
(1 + 2) + 3
```

|

```
(plus (plus (num 1) (num 2))
      (num 3))
```

|

|

```
1 + (2 + 3)
```

|

```
(plus (num 1)
      (plus (num 2) (num 3)))
```

|

|

```
1 + ((2 + 3) + 4)
```

|

```
(plus (num 1)
      (plus (plus (num 2)
                  (num 3))
            (num 4)))
```

|

观察这些示例的几个方面：

+   数据类型定义不允许我们直接表示表面语法术语，例如`1 + 2 + 3 + 4`；任何歧义都必须在我们构造相应的 AST 术语时处理。

+   数字表示可能看起来有点奇怪：我们有一个`num`构造函数，它的唯一任务就是“包装”一个数字。我们这样做是为了保持表示的一致性。当我们开始编写处理这些数据的程序时，就会清楚为什么我们这样做。

+   注意，表达式的每个重要部分都进入了其 AST 表示，尽管不一定是以相同的方式。特别是，加法运算的`+`由构造函数表示；它不是参数的一部分。

+   AST 实际上并不关心使用了什么表面语法。最后一个术语也可以写成`(+ 1 (+ (+ 2 3) 4))`或者甚至写成![image11.png](img/image11.png)，它可能会产生相同的 AST。

简而言之，ASTs 是表示程序中的程序的树状结构数据。这是一个深刻的思想！事实上，这是 20 世纪伟大的思想之一，建立在哥德尔（编码）、图灵（通用机器）、冯·诺伊曼（存储程序计算机）和麦卡锡（元循环解释器）的杰出工作之上。

旁白：源程序中的每一部分并不都在抽象语法树（AST）中得到了表示。例如，假设`1 + 2`和`1 + 2`将以相同的方式表示，忽略空格。在实践中，一个真实的语言实现确实需要了解一些关于语法的知识：例如，当存在错误时，像 DrRacket 那样突出显示程序源代码的某些部分。因此，现实世界的实现使用抽象语法，但带有与源代码相关的元数据。

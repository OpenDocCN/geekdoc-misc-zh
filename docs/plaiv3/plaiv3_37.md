## 局部绑定的含义

现在来做一下练习：这里有一些这种新构造的例子；你期望每个会产生什么结果？

```
{let1 {x 1}
  {+ x x}}
```

```
{let1 {x 1}
  {let1 {y 2}
    {+ x y}}}
```

```
{let1 {x 1}
  {let1 {y 2}
    {let1 {x 3}
      {+ x y}}}}
```

```
{let1 {x 1}
  {+ x
     {let1 {x 2} x}}}
```

```
{let1 {x 1}
  {+ {let1 {x 2} x}
     x}}
```

```
x
```

现在来做一下练习：哦，你注意到什么了吗？上述所有程序在语法上都是不合法的！为什么？

这是因为还没有为变量定义语法。我们的语法允许我们绑定变量，但不能使用它们。所以我们必须解决这个问题：

```
<expr> ::= <num>
         | {+ <expr> <expr>}
         | {let1 {<var> <expr>} <expr>}
         | <var>
```

现在上述术语在语法上都是有效的，因此我们可以回到它们应该评估为什么的问题。

前两个程序相当明显：

```
{let1 {x 1}
  {+ x x}}
```

应该评估为 2，并且

```
{let1 {x 1}
  {let1 {y 2}
    {+ x y}}}
```

应该评估为 3。

那么这个程序怎么样？

```
{let1 {x 1}
  {let1 {y 2}
    {let1 {x 3}
      {+ x y}}}}
```

在这里，我们可以看到括号记法的优势。在更传统的语法中，这可能会对应于

```
x = 1
y = 2
x = 3
x + y
```

在这里，可能发生任何情况：我们可能有不同的两个 `x`；我们可能有一个 `x` 被绑定然后被修改；在某些语言中，`x` 的引入可能被“提升”，以至于不再清楚哪个 `x` 是最新的。然而，在我们的括号语法中，我们可以很清楚地知道我们想要的范围。为了确定值，我们可以依靠我们老朋友替换。然而，当我们替换外部的 `x` 时，我们期望它停止在内部 `x` 开始的地方：也就是说，内部 `x` 遮蔽了外部的 `x`。因此，结果应该是 `5`。

现在来做一下练习：上面的例子没有意思，因为外部的 `x` 从未被使用。我们可能编写什么样的程序，有两个 `x` 的 `let` 绑定，使我们清楚地看到有两个 `x`？

这个程序显示的就是这个：

```
{let1 {x 1}
  {+ x
     {let1 {x 2} x}}}
```

很明显，加法中的左边的 `x` 应该是 `1`，而右边的表达式中的 `x` 应该被遮蔽，因此应该评估为 `2`。因此，总和应该是 `3`。顺便说一句，DrRacket 在这种情况下很有用，因为我们可以在 #lang racket 中写出等效的表达式——

```
(let ([x 1])
  (+ x
     (let ([x 2]) 
       x)))
```

——并将鼠标悬停在最后一个 `x` 上，DrRacket（对于 Racket，它代表了一种相当理想的 SMoL 形式）将自动绘制一个蓝色箭头，显示变量的绑定位置：

![](img/image18.png)

现在来看一个更复杂的例子：

```
{let1 {x 1}
  {+ {let1 {x 2} x}
     x}}
```

在这里，使用替换来确定答案特别有用。再次强调，左边的表达式中的 `x` 被遮蔽，因此应该是 `2`。当然，最大的问题是加法右边（即最后一行）的 `x` 是什么？ 

这里，同样，传统的文本语法充满了歧义：是

```
x = 2
```

左边是一个新的 `x` 绑定或外部 `x` 的修改？这两者是非常不同的事情！但根据我们的语法，它应该更清楚地表明应该是前者，而不是后者。因此，通过替换，外部 `x` 被替换为 `1`，得到

```
{+ {let1 {x 2} x}
   1}
```

在其中我们进行一次替换，产生

```
{+ 2
   1}
```

因此这次，DrRacket 特别有用以确认：

![](img/image2.png)

这就留下了一个程序：

```
x
```

因为 `x` 在任何地方都没有绑定，这只是一个语法错误。

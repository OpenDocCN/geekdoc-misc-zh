## 添加布尔值

好吧，如果我们想要真正的布尔值怎么办？

再次，要使用 SImPl，我们需要修改 AST（抽象语法树）、评估器和解析器。

我们可以像处理数字一样添加布尔值：使用一个构造函数来包装布尔值的编织表示。

```
(define-type Exp
  [num (n : Number)]
  [bool (b : Boolean)]
  [plus (left : Exp) (right : Exp)]
  [cnd (test : Exp) (then : Exp) (else : Exp)])
```

记住`num`和`bool`构造函数代表什么非常重要。回想一下，这是抽象语法：我们只是（抽象地）表示用户编写的程序，而不是其评估的结果。因此，这些构造函数正在捕获源程序中的句法常量：前者如`3.14`和`-1`，后者如`#true`和`#false`。它们不代表将评估为数字或布尔值的复合表达式。目前，一个表达式将评估为什么，只能通过运行它来确定。稍后 [👉]，我们将看到还有其他方法可以做到这一点！

旁白：抽象语法并不规定我们使用什么具体语法。例如，我们可能将数字写成`3`或`III`。我们可能将布尔值写成`#t`、`#true`、`true`、`True`等等。我们甚至可能为相同的抽象语法有不同的具体语法。这正是抽象语法提供的抽象！

简单易行！这自然提示我们在评估器中应该做什么：

```
(define (calc e)
  (type-case Exp e
    [(num n) n]
    [(bool b) b]
    [(plus l r) (+ (calc l) (calc r))]
    [(cnd c t e) (if (zero? (calc c))
                     (calc t)
                     (calc e))]))
```

哦……糟糕。这个版本的`calc`没有类型检查，因为我们的计算器应该只返回数字，而不是布尔值！

事实上，我们必须知道这不可能持久。我们不仅对计算器感兴趣；我们想要构建完整的编程语言。它们具有广泛的价值范围，即答案：数字、布尔值、字符串、图像、函数等等。

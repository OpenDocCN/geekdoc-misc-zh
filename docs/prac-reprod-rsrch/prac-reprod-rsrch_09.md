# 术语表

# 术语表

## Ariel Rokem 和 Fernando Chirigati

像其他技术领域一样，计算再现性的主题有其自己的术语和行话。这些术语涵盖了该领域的关键概念，这些概念在定义可再现研究的参数时非常重要，以及用于维护计算再现性的具体技术和实践。最后，在本书中提到了大量的技术工具和实践。在本章中，我们提供一些重要的定义，以帮助澄清在案例研究和其他章节中提到的术语、技术和工具。

### 关键概念

#### 科学实验

**科学实验**，或简称**实验**，是为了验证或反驳假设而进行的程序。在我们现代社会，研究项目中的许多阶段部分或完全通过计算机程序和过程完成，并涉及消耗的数字数据（**输入数据**）和产生的数字数据（**输出数据**）。这可能包括实验本身具有计算性质的研究。在这种情况下，实验通常被建模为一个**流水线**（或**数据流**）：一系列*步骤*通过数据的流动连接在一起，其中一个步骤的输出数据被用作下一个步骤的输入数据。一个步骤可以由计算机程序或一系列程序（一个子流水线）表示，并且它会转换它作为程序一部分消耗的数据。

#### 再现性

**再现性**是科学的基石。在科学学科中，定义差异很大，但我们认为最普遍的含义是“独立科学家使用原始数据集和方法计算定量科学结果”（Stodden，Leisch 和 Peng，2014）。再现性的目标不仅仅是复制他人的调查：它还包括对自己的研究结果进行再现，打败科学结果中的自我欺骗（Ioannidis，2005；Nuzzo，2015），并扩展另一位研究者的方法以构建自己的工作。再现性是程度问题，而非种类问题。我们说研究是可再现的，如果再现性在某种程度上适用于结果。也就是说，一些相应的实验和科学方法被认为是可再现的。

##### 实证和计算再现性

我们可以根据 Stodden（2014）的定义，将不同类型的可再现研究定义如下：实证再现性和计算再现性。

**经验再现性**包括传达与实验相关的程序、协议、设备和观察，但不要求公开研究中使用的计算资产（代码和数据）。这通常是科学中的最低标准：发表的手稿包含描述和静态图表，科学家需要遵循这些描述，希望能够在过去的研究基础上建立。

在**计算再现性**中，除了发表的手稿外，用于测试所有假设和推导结果的计算资产也是可用的，这允许计算过程被逐字复制，并在某些情况下被重复使用。这些资产可能包括但不限于：输入数据，无论是在扩展（原始数据）还是在内涵（生成数据的脚本）中；软件（二进制或源代码）；以及计算环境（计算依赖项和操作系统信息）。

当提到再现性时，**验证**和**验证**的概念也经常被使用（Stodden 等人，2013 年）：验证涉及代码是否解决了它声称解决的问题，而验证涉及结果是否与所研究现象的观察一致。在这个意义上，经验再现性有助于验证过程，而计算再现性有助于验证过程，因为实验执行可以被更详细地调查。

关于验证过程，计算再现性有助于确定代码是否存在问题，并指出可能使结果无效的任何统计问题。例如，*p-hacking*是科学中常见的偏见，研究人员选择数据或统计分析，直到非显著结果变得显著。通过拥有数据和所有工件，包括完整的研究事件链，可以调整不同的变量并改变原始分析，以检测声明的稳健性和显著性。

##### 再现性模式

再现性也可以根据结果如何再现来定义。在这方面经常使用的术语包括可复制性、近似再现性和模块再现性。

与可再现性类似，在不同的科学领域存在**复制性**的相互冲突的定义。 在某些科学领域，这是**精确可再现性**的同义词：复制的结果与相应的已发表的手稿中呈现和讨论的结果完全相同（意味着确切相同的数字）。 计算资产，例如软件，配置参数和硬件，最好是相同的，以确保可复制性。 复制性保证了可再现性，但反之则不然（Leek & Peng, 2015）。 在其他领域，复制性可能指的是使用相同的程序但使用新数据重复以前的研究（Stodden 等人，2014）。

**近似可再现性**与在原始实验运行中产生的结果相似（但不相同）相关联。 这通常包括变化的配置参数和输入文件，以更好地验证实验的稳健性，并可能模拟一些难以复制的步骤。 例如，涉及并行和分布式计算的实验可能取决于大型服务器的可用性以进行复制； 然后可以模拟或以较小的规模进行这些步骤，以使其可再现性成为可能（Hunold & Träff, 2013）。 另外，一些实验本质上难以复制，例如需要非确定性步骤（随机数生成）和访问第三方服务器的实验（服务器上的代码无法由研究人员控制）。 请注意，复制的结果需要与原始结果一致，以允许他人验证实验。

当实验支持**模块化可再现性**时，其不同的步骤和组件可以分别再现，即实验不需要完全再现。 例如，如果为整个实验共享了单个二进制文件，则可能很难再现其中的一些步骤； 但是，如果提供了源代码，研究人员将能够更灵活地使用他们想要/需要的实验部分。 模块化可再现性允许**可重用性**：实验可以更轻松地用于其他目的，从而使其他人能够修改并建立在原始工作的基础上。

##### 可再现性覆盖范围

可再现性的另一个重要方面是其**覆盖范围**（Freire, Bonnet, & Shasha, 2012）：某些实验可能无法完全再现，包括依赖于第三方 Web 服务或特殊硬件的实验，或者需要非确定性计算过程的实验。 但是，这样的实验有时可以部分再现。 例如，如果一个实验使用由特殊或专有硬件派生的数据，那么数据派生过程可能无法再现，但是如果原始数据可用，则其他人可以复制使用这些数据的下游分析。

#### 来源

随着数字数据量的增加和处理这些数据的计算过程的复杂性增长，管理它们的**来源**变得越来越重要。《牛津英语词典》将来源定义为*对象的来源或起源；其历史和血统；物品通过其各个所有者的最终衍生和传递的记录*。来源有助于确定对象的价值、准确性和作者。

**计算来源**使得通过计算过程产生的数据产品能够被解释和理解（Freire、Koop、Santos 和 Silva，2008）。通过检查导致结果的一系列步骤，可以深入了解用于生成该结果的推理链；验证步骤是否按照可接受的程序执行；以及确定实验的输入以及它们的来源。

来源是可重复性的关键要素（Freire 和 Silva，2012）。提供有关实验结果来源的详细信息既告知数据，又告知生成结果的步骤序列。通过这些信息，可以检测实验所需的组件，从而简化使其可重复的任务。这种来源信息的可用性不仅使复制结果成为可能，而且使重新使用和扩展结果变得更加容易（通过更改输入和修改步骤序列）；换句话说，详细的来源允许模块化的可重复性。

来源可以是**可描述的**或**可执行的**。可描述的来源涉及对实验的全面描述（文字描述，或详细说明所有步骤的图表），以便详细传达需要知道以重现每个步骤的计算方面。另一方面，可执行的来源涉及具有可直接用于重现实验的可执行资产（二进制文件或科学工作流程（Davidson 和 Freire，2008））。

不同的**来源组件**必须被捕获，以确保实验的可重复性（Chirigati、Shasha 和 Freire，2013）：

+   ***数据***包括用于执行实验的原始输入数据，以及用于比较原始结果的原始输出数据。如果某些步骤无法重现，则共享中间数据（管道中间步骤产生的数据）也可能是有用的（请参阅*可重复性*中的*覆盖率*）。

+   ***过程***包括用于执行实验的所有计算程序和脚本。如前所述，可以通过共享源代码或二进制文件来实现这一点，这影响了可重用性。

+   ***环境***包括实验最初执行的计算环境中的所有资产，其中包括有关操作系统的信息（例如：名称和内核版本）、硬件架构（例如：32 位或 64 位、计算节点数）和计算依赖项（例如：实验运行所依赖的库和软件包）。这一组成部分对于使实验可在其他计算机上移植至关重要，特别是如果它们具有不同的软件和硬件系统。

### 技术

#### 版本控制

版本控制是一套最初用于软件开发的实践和工具，用于跟踪软件的各个版本。这些工具监控、跟踪和存储文件的更改，通常在文件系统的一个**仓库**中，这一部分常常被称为**仓库**。第一代这些系统被称为**集中式版本控制**系统（包括**Concurrent Versions System (CVS)**和**Subversion (SVN)**）。这些系统依赖于一个中央服务器的存在和设置，该服务器存储了代码更改的历史。相比之下，**分布式版本控制**系统（如**git**和**Mercurial**）不依赖于中央服务器的存在。历史记录相反地与每个用户计算机中的文件一起存储。为了促进在不同用户计算机上的协作和工作协调，通常仍然使用集中式服务器作为’推送‘和’拉取‘操作的共同点，这些操作同步了存储在不同计算机上的仓库之间的历史，并合并了同时由不同用户在不同文件或同一文件的不同部分上进行的工作。集中式服务器可以设置在网站上，并且这些网站提供其他功能。例如，它们显示并允许浏览虚拟文件系统样式的网站中的文件，并提供可用于浏览仓库中文件的网页，而无需下载它们。此外，这些网站为用户提供了协作和沟通的机会（例如**bug 跟踪器**，其中可以报告和解决代码中的错误或“bug”）。近年来，在科学领域使用版本控制工具的情况有所上升，许多大型合作项目和机构（如 CERN、LSST 和 NCBI）利用像**GitHub**这样的网站来分发和协作开发软件。

#### 文学编程

计算机程序被阅读的次数比编写的次数要多得多（Wulf，1977 年）。考虑到这一事实，Knuth（Knuth，1984 年）提出，与其将计算机程序仅仅看作是向计算机传达指令的集合，不如将计算机程序的重点放在解释通过这些指令实现的是什么（应该是什么）。这种关注焦点的转变意味着对软件的描述性细节（例如功能和变量名称）进行更加深思熟虑的方法，以及对文档的重点关注。在研究环境中，计算机程序嵌入在诸如科学论文之类的文档中。这种做法也被描述为“文学计算”、“文学统计编程”、“文学数据分析”和“文学统计实践”，以认可从软件开发背景到数据分析背景采用文学编程方法。几种系统，如**knitr**和**Jupyter**，允许编写包含代码的文档，包括论文，在其中代码与文本交叉编排。

#### 数据发布

计算再现性的**完全可获取**先前报告结果的计算资产是必不可少的。**数据发布**（也称为**“数据共享”**）特指使用的数据的公开可用性（与软件等不同）。如果数据以数字形式存储，可以通过将数据发送给特定的合作者、创建数字副本或通过互联网提供文件来实现。可以通过将数据上传到可以无障碍访问的公开网站，或需要同意特定使用条款和条件的网站来实现。在某些情况下，数据大小也限制了数据发布的可能性，将数据的物理副本发送出去更加实际（例如，由 NIH 资助的人类连接组计划分发的所谓“盒中连结组”，这是大量人类 MRI 数据的硬盘版本）。其他限制可能包括由于参与者隐私而受到的限制（美国 1996 年颁布的《健康保险便携性与责任法案》（HIPAA）限制了可在研究数据中公开的信息；其他国家/地区也有类似的法律）。虽然数据可以被视为无法受版权保护的事实信息，但研究数据在变得有用之前通常经历多个转换步骤：它被收集、汇总和操纵，耗费了大量的时间或资源。因此，它可能代表了源（或“原始”）数据的原创性和创造性表达，并且可能被视为可受版权保护的知识产权。因此，在分享数据时，考虑并定义适当的许可条件以供潜在用户使用是非常重要的，以实现数据共享的再现性目标。

#### 数据清理

研究数据通常非常“混乱”。这意味着它不会立即适用于标准统计分析，需要额外的步骤（Milliken，2006）。

**数据整理**（也称为**数据清洗**）指的是对数据应用转换，使其从“混乱”状态变为“整洁”状态（Wickham，2014）。这可能包括过滤操作（排除包含缺失值的某些观测）、聚合以及整合来自不同来源的数据。根据一些估计，数据整理是进行跨不同领域的数据分析的个人的主要活动之一，包括工业和学术研究（Dasu＆Johnson，2003；Lohr，2014）。

在比喻上，人们集体称这些转换和数据“清洁”工作为数据“整理”。这个词来源于英语单词“mung”，指的是一种混乱的混合物（最初是一种谷物的混合物）（牛津英语词典，2016a），或者是指“贪婪地大声吃东西”的“munge”一词（牛津英语词典，2016c）（可能与“munching”一词有关）。更少见的是，它还指擦拭一个人的鼻子（牛津英语词典，2016b），这可能是对清洁行为本身的参考。另外，这可能源自首字母缩略词 MUNG，意思是“混合直到没有好处”（或递归地，“混合直到没有好处”）。为了保持这些步骤的可重现性，必须使用**溯源跟踪**来维护数据的转换和中间状态。

#### 软件测试

有几种测试类型需要考虑：

1.  ***单元测试***：这种类型的测试侧重于软件的各个部分（“单元”）的操作。一个经验法则是，单元测试不应需要磁盘输入/输出或访问网络。当与模块化软件设计结合时，单元测试效果最佳。在科学软件中，单元测试采用验证特定函数的已知结果的形式。

1.  ***集成测试***：这种类型的测试侧重于测试系统不同部分的组合。例如，验证系统的一部分的输出是否可以被其他部分作为输入接受，以产生合理的结果。

1.  ***回归测试***：这种类型的测试侧重于测试计算的先前结果是否随着时间的推移保持不变。这对于评估软件中难以编写单元测试的部分非常有用。例如，包含随机数生成的软件部分可以进行测试，以确保不会偏离之前存储的结果超过一定因子。

1.  ***端到端测试***：这种类型的测试验证整个系统在现实条件下是否产生了预期的结果。例如，一个从原始实验数据开始（被认为代表了系统设计用于分析的实际数据）的分析管道转换和处理这些数据，并产生一些统计分析。测试整个工作流程被认为是端到端测试（另请参见下文的**持续集成**）。

#### 持续集成

在软件开发中，**集成** 指的是在不同开发阶段采取的步骤，以使由小部分组成的系统的不同部分的操作协调一致。将新功能集成到软件系统中可能会导致其行为出现意外变化。这可以通过**软件测试**来解决：如果现有软件具有足够的**测试覆盖率** —— 即，测试涵盖了软件的所有不同部分，并涵盖了足够广泛的场景：边缘情况，处理极端和不寻常的值等 —— 那么对软件的新部分进行集成将根据软件的预期行为进行评估。为了使集成过程更容易，许多人主张*早期和频繁地*进行（Duvall，Matyas 和 Glover，2007）。为了使集成测试变得**连续**，可以配置自动化系统，在引入软件更改时每次运行软件系统的**测试套件**（所有测试的完整集合）。此类公开可用的系统包括[**Travis**](https://travis-ci.com/)和[**CircleCI**](https://circleci.com/)。这些服务与提供版本控制存储库的网站（如 GitHub 或 Bitbucket）很好地集成在一起，其中来自协作者对软件的新贡献可以设置为在公共可访问服务器上触发测试套件的运行。远程服务器上的持续集成还有助于确保软件的依赖关系被明确定义，并通过在这些软件依赖关系发生变化时触发测试失败来防止由于更改这些软件依赖关系而引起的问题。

#### 工作流管理

许多科学项目依赖于执行几个数据处理步骤，包括数据清洗和不同步骤的数据分析。工作流管理系统有助于分发和编排需要在可用的计算资源上完成的工作，同时还有助于通过存储数据、过程和分析过程中发生的执行的详细信息来*跟踪来源*的结果（Davidson & Freire, 2008）。

#### 文件格式标准

科学数据以多种文件格式保存。典型的文件格式可能包括描述数据在磁盘上布局的**文件头**，与数据相关的**元数据**，以及数据本身，通常以二进制格式存储。在某些情况下（例如**CSV（逗号分隔值）文件**），数据将以文本形式存储。科学数据文件格式的泛滥危险在于需要构建和维护用于读取、写入和处理所有这些数据格式的单独软件工具。这使得不同从业者之间的互操作性更加困难，并限制了数据共享的价值，因为对文件中数据的访问仍然有限。

#### 许可

在世界上大多数国家，创意作品受版权法保护。国际公约，主要是 1886 年的伯尔尼公约，保护创作者的版权，即使跨越国际边界，也会在创作者去世后 50 年内保护版权。这意味着复制和使用创意作品受到创作者或其他版权持有者设定的条件限制。例如，在许多情况下，音乐录音可能不得未经音乐家或从音乐家那里获得版权的制作公司的许可而复制和进一步分发。通过研究发现的宇宙事实不受版权保护，但对研究数据的收集、聚合、分析和解释可能被视为创意作品，并可能受版权法保护。因此，对研究出版物的使用受版权法约束。此外，即使数据共享也经常受版权法约束，因为要共享的数据编制通常需要创造性努力。另一个与研究相关的受版权保护的产品是在研究过程中开发的软件。在所有这些情况下，如果未明确指定许可条款，则该作品被视为受到“保留所有权利”的保护。这意味着除了作品的创作者外，没有人可以无障碍地使用该作品。对于软件来说，这意味着禁止复制和进一步分发软件。甚至可能限制运行软件。许可证的确切选择超出了本节的范围，但取决于您对软件的意图和目标（Fogel，2005；Hunter，2004；Rosen＆Einschlag，2004）。

#### 虚拟化和环境隔离

软件通常需要其他软件才能正常运行。正常运行程序所需的软件和硬件元素被称为**软件依赖项**。由于硬件和操作系统之间的差异，以及不同程序之间的冲突依赖关系，创建和维护具有软件系统所有依赖项的软件环境是繁琐的，并且可能需要大量的系统管理专业知识。通过提供用户以虚拟机（或 VM）的方式运行的预配置软件环境，这些系统可以提供所需的所有依赖项、软件，有时还包括进行分析所需的数据。这些虚拟化系统包括**VirtualBox**和**Vagrant**。

这些系统依赖于将整个虚拟机存储为可以复制和在其他机器环境中启动的文件的能力。此外，一些系统通过创建被称为“容器”的最小虚拟机，提供编程虚拟化和依赖管理。这包括**Docker**系统，它不仅允许存储和发布轻量级虚拟机，还允许跟踪虚拟机的溯源和版本控制。冲突的软件依赖关系也可以通过将可见的文件系统部分隔离来管理，包括安装依赖库版本的文件系统部分。在 Python 环境中，可以通过使用如**virtualenv**和**conda**等虚拟环境来实现隔离。

### 工具

#### 编程语言及相关工具

##### C/C++

C 是有史以来使用最广泛的编程语言之一。设计为一种编译语言，C 用于重新实现 Unix 操作系统，并且许多高级语言都是用 C 实现的，包括 Python。C++ 是 C 的扩展，提供了对面向对象功能的支持，已经成为最广泛使用的面向对象语言之一，特别是用于大规模和高性能应用程序。

##### Go

[Go](https://golang.org/) 是一种由 Google 开发的编译型编程语言，主要用于 Google 的一些生产系统中。

##### IPython

[IPython](http://ipython.org/)，或称交互式 Python（Pérez & Granger，2007），是一个命令行壳，允许用于 Python 的交互式计算，包括制表符补全、历史记录（溯源捕获）、并行计算工具以及对交互式数据可视化的支持。

##### Java

[Java](https://www.java.com/) 是一种编程语言，编译成 Java 字节码并在 Java 虚拟机（JVM）上运行，这确保了所有实现在不同环境中是可互操作的。

##### JavaScript

[JavaScript](https://www.javascript.com/)是一种解释性编程语言，广泛用于万维网内容制作，与 HTML 和 CSS 一起使用。

##### Jupyter

[Jupyter](http://jupyter.org/)是一个 Web 应用程序，允许用户创建和共享*notebooks*，这些文档包含动态和实时代码。Jupyter 项目是从最初的 IPython 发展而来的，将交互式环境从仅支持 Python 扩展到支持 40 多种编程语言。

##### Python

[Python](https://www.python.org/)是一种通用的解释性编程语言。虽然 Python 有一个全面的标准库，但[PyP](https://pypi.python.org/pypi)（Python 包索引）允许用户搜索并下载许多额外的 Python 包和库。其中许多包在不同的科学领域都非常受欢迎和广泛使用，包括：

+   [*NumPy*](http://www.numpy.org/)：这个库提供了对大型、多维数组和矩阵的支持，并实现了大量的高级数学函数，这些函数操作这些数组和矩阵。NumPy 还允许定义任意数据类型，这有助于与其他库和工具集成。

+   [*SciPy*](http://www.scipy.org/scipylib/index.html)：这个库构建在 NumPy 之上，主要为数值积分和优化提供了许多高级和高效的数值例程。

+   [*matplotlib*](http://matplotlib.org/)：这个库为 Python 提供了 2D 绘图程序。

+   [*scikit-learn*](http://scikit-learn.org/)：这个库支持各种机器学习算法，包括分类、回归、聚类、降维和模型选择技术。scikit-learn 是建立在 NumPy、SciPy 和 matplotlib 之上的。

+   [*scikit-image*](http://scikit-image.org/)：这个库提供了一系列图像处理算法的支持。类似于 scikit-learn，它是建立在 NumPy、SciPy 和 matplotlib 之上的。

+   [*pandas*](http://pandas.pydata.org/)：这个库为 Python 带来了许多数据分析功能，包括高级数据操作任务（选择、过滤、切片、排序、分组、绘图等）。

+   [*MNE*](http://mne-tools.github.io/)：这个库包含了一个用于处理脑电图和脑磁图数据的 Python 包。

+   [*Nipype*](http://nipy.org/nipype/)：这个库提供了一个统一的界面，用于创建集成了一系列神经影像软件和应用的工作流程。

##### R

[R](https://www.r-project.org/) 是一种广泛使用的解释型编程语言，用于统计计算、数据分析和可视化，在过去几年中在各个科学领域的流行程度大大增加（Tippmann, 2014）。有一个庞大而充满活力的科学家社区在使用和开发 R 软件，贡献了 8000 多个包到[Comprehensive R Archive Network](https://cran.r-project.org/)。这些包可以免费下载，并通过添加专门的统计算法、可视化技术和文件处理方法来扩展 R 的功能。以下 R 包值得注意：

+   [*knitr*](http://yihui.name/knitr/)：这个库提供了动态报告生成的支持：R 代码可以实时评估以生成包含 R 分析结果的文档（PDF、HTML 或 MS Word 文件）。

+   [*knitcitations*](https://github.com/cboettig/knitcitations)：这个库通过允许用户向动态报告添加引用来扩展 knitr。

+   [*dplyr*](https://cran.rstudio.com/web/packages/dplyr/)：这个库包含用于数据操作任务的高级函数，类似于数据库查询（选择、过滤和汇总数据）。

+   [*stringr*](https://cran.r-project.org/web/packages/stringr/index.html)：这个库提供用于操作文本的工具，使用正则表达式和字符串。

+   [*caret*](http://topepo.github.io/caret/index.html)：这个库提供了一套广泛的工具，用于训练回归和分类模型。

+   [*ggplot2*](http://ggplot2.org/)：这个库为 R 提供数据可视化程序。

+   [*Rcpp*](http://www.rcpp.org/)：这个库使 R 函数能够调用 C++代码进行高性能计算。

+   [*devtools*](https://cran.r-project.org/web/packages/devtools/index.html)：这个库包含简化新 R 包开发的函数。

+   [*testthat*](https://cran.r-project.org/web/packages/testthat/index.html)：这个库包含设置代码单元测试的函数。

##### RStudio

[RStudio](https://www.rstudio.com/) 是用于 R 的集成开发环境（IDE），包括桌面和 Web 服务器版本。其代码编辑器提供语法高亮、制表符补全、缩进和定义。它包括调试控制台、断点、环境面板、历史记录、跟踪和集成的 R 帮助和文档。它支持 2D 和 3D 可视化、数据显示和数据操作。Knitr、markdown 和 git 深度集成到 RStudio 中，通过 R markdown 文档实现版本控制编程。

##### Ruby

[Ruby](https://www.ruby-lang.org/) 是一种解释型编程语言，常用于 Web 开发，其语法与 Python 广泛相似。

##### Scala

[Scala](http://www.scala-lang.org/)是一种旨在编译为 Java 字节码并在 JVM 上执行的编程语言。Java 和 Scala 是可互操作的，即一个语言的库可以在另一个语言中使用。

#### 文档生成器

##### Doxygen

[Doxygen](http://www.stack.nl/~dimitri/doxygen/)是一个工具，可以从带注释的源代码自动生成文档（以不同格式），支持多种不同的编程语言。

##### 阅读文档

[Rea](https://readthedocs.org/)是一个软件文档托管服务。该服务简化了为代码的不同版本生成文档的过程，Read the Docs 可以设置为在生成新版本的代码时自动构建文档。

##### Roxygen

[Roxygen](http://roxygen.org/)是用于 R 的类似 Doxygen 的系统。

##### Sphinx

[Sphinx](http://sphinx-doc.org/)是一个可以生成多种不同文件格式文档的工具。

##### Pandoc

[Pandoc](http://pandoc.org/)是一个可以在许多不同文件格式之间转换的工具，包括 LaTeX、HTML、Microsoft Word 文档和 Markdown 文件。

#### 版本控制

##### Bitbucket

[Bitbucket](https://bitbucket.org/)是两种分布式版本控制系统 git 和[Mercurial](https://www.mercurial-scm.org/)的仓库托管服务。类似于 GitHub，它提供了一个基于 Web 的界面，以便在项目中进行协作。

##### Git

[Git](https://git-scm.com/)是一种分布式版本控制系统，在过去几年中已经变得[广泛使用](https://ianskerrett.wordpress.com/2014/06/23/eclipse-community-survey-2014-results/)。

##### GitHub

[GitHub](http://github.com/)是一个 git 仓库托管服务：开发人员在 Web 上维护他们的 git 仓库。它提供了一个基于 Web 的界面，以及一个桌面应用程序，以便与同一项目中的其他人合作。GitHub 具有许多功能，包括分叉、问题跟踪、拉取请求和维基等。

##### SVN

[Subversion](https://subversion.apache.org/)，或者 SVN，是一个集中式版本控制系统。

#### 数据整理和分析

##### Apache Hadoop

[Hadoop](https://hadoop.apache.org/)是一个用于跨计算机集群分布式处理大型数据集的流行框架。Hadoop 使用 map-reduce 编程模型来扩展到多台机器。Apache HDFS 是用于存储输入、中间和输出数据的分布式文件系统。

##### Apache Spark

[Spark](http://spark.apache.org/)是一个用于分布式处理的框架，与 Hadoop 相比，提供了可以实现更好性能的内存原语，适用于许多应用程序。

##### 连接组工作台

[连接组工作台](http://www.humanconnectome.org/software/connectome-workbench.html)是一个工具，提供多种资源用于映射神经影像数据。

##### MATLAB

[MATLAB](http://www.mathworks.com/products/matlab/) 是一个广泛流行的用于数据和统计分析的数值计算环境，也是一种编程语言。它提供了许多有用的功能，特别是对于数据管理、矩阵操作和绘图。

##### Microsoft Excel

[Excel](https://products.office.com/en-us/excel) 是由 Microsoft 开发的电子表格系统，具有许多不同的功能，包括绘图工具和对宏编程语言的支持。

##### MongoDB

[MongoDB](https://www.mongodb.com/) 是最近广泛使用的数据库系统，特别是用于分布式存储。MongoDB 是面向文档的，而不是像传统的关系系统中那样将数据存储在多个关系结构中，它将数据存储在最小数量的文档中。

##### pandas

[panda](http://pandas.pydata.org/) 是一个 Python 库，具有许多数据分析功能，包括高级数据操作任务（选择、过滤、切片、排序、分组、绘图等）。

##### SEPlib

[SEPlib](http://sepwww.stanford.edu/doku.php?id=sep:software:seplib) 是用于地震数据处理的分布式软件包，包括地震处理例程、图形库和 IO 子程序库。

##### Stata

[Stata](http://www.stata.com/) 是一款商业数据分析和统计分析软件。

#### 数据可视化

##### Adobe Photoshop

[Adobe Photoshop](http://www.adobe.com/products/photoshop.html) 是一款流行的商业图形编辑软件，提供了丰富的功能来组合和操作图形。

##### D3

[D3](http://d3js.org/) 是一个用于操作数据和创建二维交互信息和数据可视化的 JavaScript 库。

##### ggplot2

[ggplot2](http://ggplot2.org/) 是 R 的数据可视化库。

##### matplotlib

[matplotlib](http://matplotlib.org/) 是 Python 中流行的二维绘图库。

#### 工作流和溯源管理

##### EUPS

[EUPS](https://github.com/RobertLuptonTheGood/eups) 是一个版本管理工具，用于跟踪项目的确切计算依赖关系。

##### Make

[GNU Make](https://www.gnu.org/software/make/) 和 [CMake](https://cmake.org/) 是常用的构建工具，用于从源文件构建和生成可执行程序。这些实用程序获取了构建程序的数据流程，称为*makefiles*的文件。

##### VisTrails

[VisTrails](http://www.vistrails.org/) 是一个开源的科学工作流系统，提供对仿真、数据探索和可视化的支持，同时具有许多用于溯源捕获、管理和分析的功能。

#### 软件测试和持续集成

##### BuildBot

[BuildBot](http://buildbot.net/) 是一个基于 Python 的持续集成工具，自动化构建和测试软件项目的过程。

##### CircleCI

[CircleCI](https://circleci.com/) 是一个托管的持续集成服务，用于 Web 和移动应用程序，类似于 Travis CI，可以用于自动构建和测试托管在 GitHub 上的项目。

##### Coveralls

[Coveralls](https://coveralls.io/) 是一个工具，自动识别项目中的测试覆盖率，显示测试套件未覆盖的代码部分。

##### devtools

[devtools](https://cran.r-project.org/web/packages/devtools/index.html) 是一个包含一系列函数以便于 R 包开发的库。

##### Google Test

[Google Test](https://github.com/google/googletest) 是 Google 开发和使用的 C++ 单元测试库。

##### Jenkins

[Jenkins](https://jenkins-ci.org/) 是一个基于 Java 的持续集成工具，自动化构建和测试软件项目的过程。

##### JIRA

[JIRA](https://www.atlassian.com/software/jira) 是一种商业软件，用于缺陷跟踪、问题跟踪和项目管理。

##### Nose

[nos](https://nose.readthedocs.org/) 是一个 Python 库，实现了帮助编写和运行软件测试的函数。

##### nose2

[nose2](https://nose2.readthedocs.org/) —— nose 的后继者 —— 是 Python 的一个单元测试库。

##### testthat

[testtha](https://cran.r-project.org/web/packages/testthat/index.html) 是 R 的一个单元测试库。

##### Travis CI

[Travis CI](https://travis-ci.com/) 是一个托管的、分布式的持续集成服务，可用于自动构建和测试托管在 GitHub 上的项目。如果配置了服务，GitHub 仓库的每个新提交都会触发 Travis CI，尝试构建项目并运行测试。Travis CI 可用于多种不同的语言。

#### 虚拟化和环境隔离

##### 亚马逊 EC2

[亚马逊 EC2](https://aws.amazon.com/ec2/) 是一种提供云计算基础设施的 Web 服务。虚拟环境可以根据需要创建、启动和终止，用户按小时付费使用活跃服务器。

##### Docker

[Docker](https://www.docker.com/) 是一种工具，用于在软件容器内自动部署应用程序，容器比虚拟机轻得多：容器是隔离的，但共享操作系统，必要时还共享二进制文件和库。[boot2docker](http://boot2docker.io) 是一个专门用于运行 Docker 容器的 Linux 发行版。

##### Vagrant

[Vagrant](https://www.vagrantup.com/) 是一个用于创建和配置虚拟环境（如虚拟机和 Docker 容器）的工具。

##### Virtualenv

[Virtualenv](https://virtualenv.readthedocs.org/) 是一个创建隔离 Python 环境的工具。这允许具有不同（有时是冲突的）依赖关系的多个 Python 项目在同一台计算机上共存。

#### 数据分享与仓库

##### 亚马逊 S3

[亚马逊 S3](https://aws.amazon.com/s3/) 是一种用于云上文件存储的服务。S3 在 Web 托管、图像托管和备份系统存储方面被广泛使用。

##### arXiv

[arXiv](http://arxiv.org/) 是科学出版物的电子预印本存储库，在数学和物理领域被广泛使用。

##### CrossRef

[CrossRef](http://www.crossref.org/) 是官方的数字对象标识符（DOI）注册机构。DOI 常被分配给出版物或研究数据，以便其可以被唯一标识，并因此可被引用。像 Dataverse 和 figshare 这样的服务会自动生成所上传数据的 DOI。

##### Dataverse

[Dataverse 项目](http://dataverse.org/) 是一个用于分享、引用和归档研究数据的存储库。它提供备份、恢复、数据发现和编目、元数据提取和保存支持。

##### Docker Hub

[Docker Hub](https://hub.docker.com/) 是一个用于构建和发布 Docker 容器的服务。Docker Hub 允许与 GitHub 和 BitBucket 集成，以及不同用户之间的协作，等等。

##### Dropbox

[Dropbox](https://www.dropbox.com/) 是一个在网络上托管文件并在不同平台之间同步文件的服务。Dropbox 还具有文件版本控制功能，用户可以在不丢失任何工作的情况下访问他们文件的旧版本。

##### figshare

[figshare](https://figshare.com/) 是一个用于分享和引用研究数据（结果和手稿）的存储库。

##### Flickr

[Flickr](https://www.flickr.com/) 是一个用于在网络上托管和分享图像和视频的服务。它在摄影研究人员和博客作者中广受欢迎。

##### Mendeley 和 Zotero

[Mendeley](https://www.mendeley.com/) 和 [Zoter](https://www.zotero.org/) 都是用于管理和共享研究出版物的网络服务和桌面应用程序。

##### NeuroVault

[NeuroVault](http://neurovault.org/) 是一个用于分享人类大脑统计地图、分区和地图册的存储库。

##### Zenodo

[Zenodo](https://zenodo.org/) 是一个用于分享和引用研究成果的存储库，包括数据和出版物。

#### 文档撰写

##### LaTeX

[LaTeX](https://www.latex-project.org/) 是一种用于撰写研究出版物的文字处理器和文档标记语言。与 Microsoft Word 相比，LaTeX 不是所见即所得的编辑器：文档需要编译才能生成最终产品。

##### Microsoft Word

[Word](https://products.office.com/en/word) 是由微软开发的文档和文字处理软件。Microsoft Word 是一个所见即所得的编辑器，编辑时，屏幕上显示的内容类似于其作为最终产品的外观（WYSIWYG 代表“所见即所得”）。

##### Overleaf

[Overleaf](https://www.overleaf.com/) 是一个使用 LaTeX 进行协作写作和出版的在线平台，具有与所见即所得编辑器紧密相似的集成实时预览。

#### 文件格式

##### API

API（或应用程序编程接口）是软件系统设计的组成部分，允许程序员使用系统来构建应用程序。例如，软件库 API 将是库中函数和对象的设计，可以组合在一起创建新的函数和对象。

##### CSV

CSV（“逗号分隔值”）文件格式以纯文本的方式以表格形式存储数据。这种格式通常用于在应用程序之间传输数据。

##### DO

DO 文件是一个由 Web 服务器运行的 Web-based Java 程序。

##### Dockerfile

Dockerfile 是一个具有一组用于构建 Docker 容器的指令和命令的文件。

##### FIF

FIF（“分形图像文件”）文件以分形形式存储图像，可以在不失去图像质量的情况下调整大小。

##### HDF5

HDF5 文件格式旨在存储和组织大量数据。可以指定不同的数据模型来存储数据，包括多维数组和表格。

##### ipynb

ipynb 文件表示一个 IPython 笔记本文档。

##### JSON

JSON 是一种既能够人类阅读又能够机器读取的数据交换格式，将数据存储和传输为属性-值对。最近广泛使用，主要取代了 XML。

##### Markdown

Markdown 文件包含一种简单标记语言的数据，可以轻松将其从纯文本转换为 HTML 和其他格式。这种文件的常见扩展名包括 *md* 和 *Rmd*（后者表示其中包含了 R 代码的 R Markdown 文件）。

##### netCDF

netCDF（“网络通用数据格式”）文件格式是一种常用的机器无关格式，用于共享面向数组的科学数据。

##### PDF

PDF（“便携式文档格式”）文件格式通常用于以可互操作的方式显示文档。

##### RAID

RAID（独立磁盘冗余阵列）是一种通过在子分区之间实现冗余来为数据存储提供鲁棒性的系统。每个数据位都存储在至少两个不同的分区中，以便在任何给定的分区失败时，可以进行交换而不会丢失数据。

##### SQL

SQL（“结构化查询语言”）文件包含一系列数据库查询，用于分析和管理数据库中的表。这些查询由 SQL 语句表示，SQL 是一种专为管理关系数据库系统中的数据而设计的编程语言。

##### SVG

SVG（“可缩放矢量图形”）文件使用基于 XML 的格式表示图形，提供对交互和动画的支持。

##### VT

VT 文件存储 VisTrails 工作流及其相应的溯源。

##### XML

XML（“可扩展标记语言”）文件以 XML 格式存储数据，这是一种将文档编码为既能够人类阅读又能够机器读取的格式。XML 因提供不同应用程序之间的互操作性而闻名。

### 参考文献

Chirigati, F., Shasha, D., & Freire, J. (2013). ReproZip：使用溯源支持计算再现性。在*第 5 届用尼克斯理论和实践的溯源研讨会论文集* 中（pp. 1:1–1:4）。

Dasu, T., & Johnson, T. (2003). *探索性数据挖掘和数据清洗*。John Wiley & Sons。

Davidson, S. B., & Freire, J. (2008). **Provenance and Scientific Workflows: Challenges and Opportunities**. 在*2008 年 acm sigmod 国际数据管理会议论文集*中 (pp. 1345–1350)。

Duvall, P. M., Matyas, S., & Glover, A. (2007). *持续集成：提高软件质量和降低风险*。Pearson Education。

Fogel, K. (2005). *制作开源软件：如何运行成功的自由软件项目*。O’Reilly Media, Inc。

Freire, J., & Silva, C. T. (2012). **使用 VisTrails 使计算和出版物可复制**。*科学工程计算*，*14*(4)，18–25。

Freire, J., Bonnet, P., & Shasha, D. (2012). **计算可复制性：现状、挑战和数据库研究机会**。在*2012 年 acm sigmod 国际数据管理会议论文集*中 (pp. 593–596)。

Freire, J., Koop, D., Santos, E., & Silva, C. T. (2008). **计算任务的溯源：一项调查**。*科学与工程计算*，*10*(3)，11–21。

Hunold, S., & Träff, J. L. (2013). **关于并行计算中可复制实验研究的状态和重要性**。*CoRR*。

Hunter, J. (2004). **为什么我们应该使用 BSD**。访问日期：2015-10-25。检索自[`nipy.org/nipy/faq/johns_bsd_pitch.html`](http://nipy.org/nipy/faq/johns_bsd_pitch.html)。

Ioannidis, J. P. A. (2005). **大多数发表的研究结果都是错误的**。*PLoS Med*，*2*(8)，e124。[`doi.org/10.1371/journal.pmed.0020124`](http://doi.org/10.1371/journal.pmed.0020124)。

Knuth, D. E. (1984). **可读编程**。*计算机杂志*，*27*(2)，97–111。

Leek, J. T., & Peng, R. D. (2015). **观点：可复制研究仍可能是错误的：采用预防性方法**。*国家科学院会议论文集*，*112*(6)，1645–1646。[`doi.org/10.1073/pnas.1421412111`](http://doi.org/10.1073/pnas.1421412111)。

Lohr, S. (2014, August 17). **对于大数据科学家，'清洁工作'是洞察力的关键障碍**。*纽约时报*。检索自[`www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html`](http://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html)。

Milliken, G. (2006). **混乱的数据**。在 S. Kotz (Ed.)的*统计科学百科全书*中。Hoboken, NJ: Wiley。

Nuzzo, R. (2015). **科学家如何欺骗自己 - 以及他们如何停止**。*自然*，*526*(7572)，182–185。

牛津英语词典。 (2016a). **Mung, n.1 and adj**. 牛津大学出版社。检索自[`www.oed.com/view/Entry/113400`](http://www.oed.com/view/Entry/113400)。

牛津英语词典。 (2016b). **Munge, v.1**。牛津大学出版社。检索自[`www.oed.com/view/Entry/123777?rskey=KZFDs3&result=1`](http://www.oed.com/view/Entry/123777?rskey=KZFDs3&result=1)。

牛津英语词典。 (2016c). Munge, v.2\. 牛津大学出版社。 检索自[`www.oed.com/view/Entry/252110?rskey=KZFDs3&result=2`](http://www.oed.com/view/Entry/252110?rskey=KZFDs3&result=2)

Pérez, F., & Granger, B. E. (2007). IPython：交互式科学计算系统。*Computing in Science and Engineering*, *9*(3), 21–29\. [`doi.org/10.1109/MCSE.2007.53`](http://doi.org/10.1109/MCSE.2007.53)

Poldrack, R. A., & Gorgolewski, K. J. (2014). 在神经影像学中开放大数据：数据共享。*Nat. Neurosci.*, *17*(11), 1510–1517.

Rosen, L., & Einschlag, M. (2004). *开源许可*. Prentice Hill.

Stodden, V. (2014). 哪个科学理念准备退休？可重复性。*Edge.org*. 检索自[`edge.org/response-detail/25340`](http://edge.org/response-detail/25340)

Stodden, V., Bailey, D. H., Borwein, J., LeVeque, R. J., Rider, B., & Stein, W. (2013). 将默认设置为可重复性：计算和实验数学中的可重复性。*ICERM 研讨会报告*. 检索自[`stodden.net/icerm_report.pdf`](http://stodden.net/icerm_report.pdf)

Stodden, V., Leisch, F., & Peng, R. D. (2014). *实施可重复研究*. CRC Press.

Tippmann, S. (2014). 编程工具：与 R 一起冒险。*Nature*, *517*(7532), 109–110\. [`doi.org/10.1038/517109a`](http://doi.org/10.1038/517109a)

Wickham, H. (2014). 整洁数据。*J. Stat. Softw.*, *59*(10).

Wulf, W. A. (1977). 对下一代编程语言的一些思考。*计算机科学视角*, 217–234.

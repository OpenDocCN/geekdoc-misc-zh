# 用领域语言编写代码

# 用领域语言编写代码

想象两个代码库。在其中一个中，你会看到：

```
if (portfolioIdsByTraderId.get(trader.getId())
  .containsKey(portfolio.getId())) {...} 
```

你挠着头，想知道这段代码可能是做什么的。它似乎从一个交易员对象中获取一个 ID，然后使用它从一个，嗯，显然是一个地图-地图的地图中获取一个映射，然后看看另一个来自投资组合对象的 ID 是否存在于内部地图中。你更加挠头了。你寻找 portfolioIdsByTraderId 的声明，发现了这个：

```
Map<int, Map<int, int>> portfolioIdsByTraderId; 
```

逐渐地，你会意识到这可能与一个交易员是否能够访问特定投资组合有关。当然，每当某些东西关心一个交易员是否能够访问特定投资组合时，你都会找到相同的查找片段——或者更可能是一个类似但略有不同的代码片段。

在另一个代码库中，你会看到这个：

```
if (trader.canView(portfolio)) {...} 
```

没有挠头。你不需要知道一个交易员是如何知道的。也许在某个地方有一个这样的映射-地图。但那是交易员的事情，不是你的。

那么，你更愿意在哪个代码库中工作呢？

很久以前，我们只有非常基本的数据结构：位、字节和字符（实际上只是字节，但我们会假装它们是字母和标点符号）。十进制数有点棘手，因为我们的十进制数字在二进制中不太好用，所以我们有几种大小的浮点类型。然后是数组和字符串（实际上只是不同的数组）。然后我们有栈、队列、哈希表、链表、跳表和许多其他令人兴奋的数据结构*在现实世界中不存在*。“计算机科学”是关于花费大量精力将现实世界映射到我们的限制性数据结构中。真正的专家甚至可以记住他们是如何做到的。

然后我们有了用户定义类型！好吧，这不是新闻，但它确实改变了游戏规则。如果你的领域包含像交易员和投资组合这样的概念，你可以使用名为 Trader 和 Portfolio 的类型来对它们建模。但更重要的是，你也可以使用领域术语来建模它们之间的*关系*。

如果你不使用领域术语编写代码，你就在创造一种默认的（可读：秘密的）理解，*这里的* int 表示标识交易员的方式，而*那里的* int 表示标识投资组合的方式。（最好不要搞混！）如果你用一个算法片段来表示业务概念（“有些交易员不被允许查看某些投资组合——这是非法的”），比如在一个键映射中的存在关系，你对审计和合规人员并没有什么帮助。

下一个程序员可能不知道这个秘密，那么为什么不让它显式化呢？使用一个键作为查找另一个键的方式来执行存在性检查并不是非常明显的。有人怎么能直觉到这是实施防止利益冲突的业务规则的地方呢？

将领域概念明确地体现在你的代码中意味着其他程序员可以比试图将算法迁移到他们对领域的理解中更容易地了解代码的*意图*。 这也意味着当领域模型发展变化时——随着你对领域的理解增长，它将会发生——你处于一个良好的位置来演变代码。 结合良好的封装，很有可能规则只存在一个地方，并且你可以在没有任何依赖代码发现的情况下进行更改。

几个月后接手这段代码的程序员会感谢你。 几个月后接手这段代码的程序员可能就是你。

由[Dan North](http://programmer.97things.oreilly.com/wiki/index.php/Dan_North)

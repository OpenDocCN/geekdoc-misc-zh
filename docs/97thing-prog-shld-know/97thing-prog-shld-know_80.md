# 测试所需行为，而不是次要行为

# 测试所需行为，而不是次要行为

测试中的一个常见陷阱是假设实现的确切行为就是您要测试的内容。乍一看，这听起来更像是一种优点而不是陷阱。然而，用另一种方式表达，问题就更加明显了：测试中的一个常见陷阱是将测试硬编码到实现的具体细节中，而这些具体细节是次要的，与所需功能无关。

当测试被硬编码到实现的具体细节中时，与所需行为实际兼容的实现更改可能会导致测试失败，从而产生错误的阳性。程序员通常通过重新编写测试或重新编写代码来回应这种情况。假设错误的阳性实际上是正确的阳性通常是由于恐惧、不确定性或怀疑造成的。这将次要行为的状态提升到所需行为的级别。在重写测试时，程序员要么将测试重新聚焦于所需行为（好的），要么简单地将其硬编码到新实现中（不好）。测试需要足够精确，但也需要准确。

例如，在三向比较中，比如 C 的 `strcmp` 或 Java 的 `String.compareTo`，结果的要求是：如果左侧小于右侧，则结果为负；如果左侧大于右侧，则结果为正；如果它们被认为相等，则结果为零。这种比较风格在许多 API 中都有使用，包括 C 的 `qsort` 函数的比较器和 Java 的 `Comparable` 接口的 `compareTo` 方法。尽管具体的值 `-1` 和 `+1` 在实现中通常用于表示*小于*和*大于*，但程序员经常错误地假设这些值代表了实际的要求，因此编写了验证此假设的测试。

类似的问题也会出现在测试空格、精确措辞以及其他与文本格式和呈现相关的方面的测试中，这些都是次要的。除非你正在编写例如提供可配置格式的 XML 生成器，否则空格对结果不应该有重大影响。同样，将按钮和标签的位置硬编码到 UI 控件上会减少更改和完善这些次要方面的选项。实现中的微小更改和格式上的无关变化突然成为构建中断的原因。

过度规定的测试通常是白盒测试方法的问题。白盒测试使用代码结构确定所需的测试用例。白盒测试的典型失败模式是测试最终肯定代码已经实现了代码所做的事情。简单地重申代码已经明显的功能并没有增加任何价值，反而导致了对进展和安全性的虚假认识。

要有效果，测试需要陈述合同义务，而不是机械地复述实现。它们需要以黑盒的视角来看待被测试单元，以可执行的形式勾勒出接口合同。因此，要将测试行为与所需行为保持一致。

由[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)撰写。

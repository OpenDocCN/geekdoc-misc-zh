# 抵制单例模式的诱惑

# 抵制单例模式的诱惑

单例模式解决了许多问题。你知道只需要一个实例。你保证这个实例在使用前已经被初始化。通过具有全局访问点来保持你的设计简单。一切都很好。这个经典的设计模式有什么不好的呢？

事实证明，实际上有很多不好的地方。它们可能很诱人，但经验表明，大多数单例模式真的带来的伤害大于好处。它们阻碍了可测试性，损害了可维护性。不幸的是，这种额外的智慧并没有像应该的那样普及开来，单例模式仍然对许多程序员具有不可抗拒的吸引力。但值得抵制：

+   单实例需求常常是想象出来的。在许多情况下，纯粹是推测未来不会需要额外的实例。将这种推测性质传播到应用程序的设计中肯定会在某个时候带来痛苦。需求会变化。良好的设计应该接受这一点。而单例模式不会。

+   单例模式会导致代码中概念上独立的单元之间存在隐式依赖关系。这一问题的根源在于它们被隐藏了，而且它们引入了不必要的单元之间的耦合。当你尝试编写单元测试时，这种代码味道会变得刺鼻，因为单元测试依赖于松散耦合和能够有选择地用模拟实现替换真实实现。单例模式阻止了这样直接的模拟。

+   单例模式还携带隐式的持久状态，这再次妨碍了单元测试。单元测试依赖于测试彼此独立，因此可以以任何顺序运行测试，并且可以在执行每个单元测试之前将程序设置为已知状态。一旦引入了具有可变状态的单例模式，这可能很难实现。此外，这种全局可访问的持久状态使得在多线程环境中理解代码变得更加困难。

+   多线程为单例模式引入了更多的陷阱。由于直接在访问上进行锁定效率不高，所以所谓的双重检查锁定模式（DCLP）变得越来越流行。不幸的是，这可能是另一种致命的吸引力形式。事实证明，在许多语言中，DCLP 并不是线程安全的，即使在它是线程安全的情况下，仍然存在将其微妙地使用错误的机会。

清理单例可能会带来最后的挑战：

+   没有明确销毁单例的支持，这在某些情况下可能是一个严重问题。例如，在一个插件架构中，插件只有在其所有对象都已清理完毕后才能安全卸载。

+   单例在程序退出时的隐式清理没有顺序。这对包含具有相互依赖关系的单例的应用程序可能会造成麻烦。在关闭这样的应用程序时，一个单例可能会访问另一个已经被销毁的单例。

+   通过引入额外的机制，可以克服其中一些缺点。然而，这会增加代码的复杂性，而本可以通过选择替代设计来避免这种复杂性。

因此，将对单例模式的使用限制在那些确实绝对不应该被实例化超过一次的类上。不要从任意代码中使用单例的全局访问点。相反，对单例的直接访问应该只来自于几个明确定义的地方，从这些地方可以通过其接口将其传递到其他代码中。这些其他代码是不知道的，因此不依赖于单例还是任何其他类型的类实现接口。这打破了阻止单元测试的依赖关系，并提高了可维护性。所以，下次当你考虑实现或访问一个单例时，希望你能停下来，再次思考。

由[Sam Saariste](http://programmer.97things.oreilly.com/wiki/index.php/Sam_Saariste)撰写。

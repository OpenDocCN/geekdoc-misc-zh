# 封装行为，而不仅仅是状态

# 封装行为，而不仅仅是状态

在系统理论中，封装是处理大型和复杂系统结构时最有用的构造之一。在软件行业中，封装的价值是被充分理解的。封装得到编程语言构造的支持，如子程序和函数、模块和包、类等。

模块和包解决了封装的更大规模需求，而类、子程序和函数解决了更细粒度的问题。多年来，我发现类似是开发人员最难正确使用的封装构造之一。发现一个只有一个 3000 行主方法的类，或者一个只有*set*和*get*方法用于其基本属性的类并不罕见。这些例子表明，涉及的开发人员并没有完全理解面向对象思维，未能充分利用对象作为建模构造的力量。对于熟悉 POJO（Plain Old Java Object）和 POCO（Plain Old C# Object 或 Plain Old CLR Object）术语的开发人员来说，这是回归面向对象作为建模范式的初衷——对象是朴素而简单的，但并不愚蠢。

一个对象封装了状态和行为，其中行为由实际状态定义。考虑一个门对象。它有四种状态：关闭、打开、关闭中、打开中。它提供两个操作：打开和关闭。根据状态，打开和关闭操作将有不同的行为。对象的这种固有属性使得设计过程在概念上变得简单。它归结为两个简单的任务：分配和委托责任给不同的对象，包括对象间的交互协议。

这在实践中如何运作最好通过一个例子来说明。假设我们有三个类：Customer、Order 和 Item。Customer 对象是信用额度和信用验证规则的自然占位符。Order 对象知道其关联的 Customer，并且其 addItem 操作通过调用`customer.validateCredit(item.price())`来委托实际的信用检查。如果方法的后置条件失败，可以抛出异常并中止购买。

经验不足的面向对象开发人员可能会决定将所有业务规则封装到一个经常被称为`OrderManager`或`OrderService`的对象中。在这些设计中，`Order`、`Customer`和`Item`被视为几乎只是记录类型。所有逻辑都被分解出类，并在一个大型的过程方法中用许多内部*if-then-else*结构绑定在一起。这些方法很容易被破坏，几乎不可能维护。原因是？封装被破坏了。

因此，最终，不要破坏封装，并利用编程语言的力量来维护它。

由[Einar Landre](http://programmer.97things.oreilly.com/wiki/index.php/Einar_Landre)提供

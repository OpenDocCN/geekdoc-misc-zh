# 测试要精确而具体

# 测试要精确而具体

对于代码单元的期望、基本行为进行测试非常重要，而不是测试特定实现的附带行为。但这不应该被认为是对模糊测试的借口或误解。测试需要既准确又精确。

一种经过试验、测试并成为经典的东西，排序例程提供了一个说明性示例。实现排序算法对于程序员来说不一定是每天的任务，但排序是一个如此熟悉的概念，大多数人认为他们知道可以从中期待什么。然而，这种随意的熟悉感可能会使人难以看穿某些假设。

当程序员被问及“你会测试什么？”时，迄今为止最常见的答案是“排序的结果是一个已排序的元素序列。”虽然这是正确的，但这并不是全部的事实。在要求更精确的条件时，许多程序员补充说，结果序列应该与原始序列具有相同的长度。虽然正确，但这仍然不够。例如，给定以下序列：

```
3 1 4 1 5 9 
```

以下序列满足按非降序排序并且与原始序列长度相同的后置条件：

```
3 3 3 3 3 3 
```

尽管它满足了规范，但肯定不是原意！这个例子基于真实生产代码中的一个错误（幸运的是在发布之前就被捕捉到了），其中一个按键的简单失误或短暂的理智缺失导致了一个复杂的机制，用于将整个结果填充为给定数组的第一个元素。

完整的后置条件是结果已排序，并且保留了原始值的排列。这适当地限制了所需的行为。结果长度与输入长度相同的事实在清洗过程中显现出来，无需重复说明。

即使按照上述方式陈述后置条件也不足以给你一个好的测试。一个好的测试应该是可读的。它应该是可以理解的，并且足够简单，以便你可以很容易地看出它是否正确（或错误）。除非你已经有代码来检查一个序列是否已排序，并且一个序列是否包含另一个序列的值的排列，否则测试代码很可能比待测试的代码更复杂。正如 Tony Hoare 所观察到的：

> 构建软件设计有两种方式：一种是使其非常简单，显然没有任何缺陷；另一种是使其非常复杂，没有明显的缺陷。

使用具体示例可以消除这种偶发复杂性和意外机会。例如，给定以下序列：

```
3 1 4 1 5 9 
```

排序的结果如下：

```
1 1 3 4 5 9 
```

没有其他答案可行。不要接受任何替代品。

具体的例子有助于以一种易于理解和明确的方式说明一般行为。将项目添加到空集合中的结果不仅仅是它不是空的：它是集合现在有了一个单独的项目。而且所持有的单个项目就是添加的项目。两个或更多项目将被视为非空。并且也是错误的。一个不同值的单个项目也是错误的。向表中添加行的结果不仅仅是表增加了一行。它还意味着该行的键可以用于恢复添加的行。诸如此类。

在规定行为时，测试不应仅仅准确：它们还必须精确。

[凯夫林·亨尼](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)

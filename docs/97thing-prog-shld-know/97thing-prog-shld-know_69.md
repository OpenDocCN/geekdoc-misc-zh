# 放下鼠标，远离键盘

# 放下鼠标，远离键盘

你已经专注于某个棘手的问题几个小时了，但看不到解决方案。于是你站起来伸展一下，或者去买点东西吃，回来的路上突然就想到了答案。

这种情况听起来熟悉吗？曾经想过为什么会发生吗？诀窍在于当你编码时，你的逻辑大脑活跃，而创造性的一面被排斥在外。直到逻辑一侧休息，它才能向你呈现任何东西。

这是一个真实的例子：我正在整理一些遗留代码，遇到了一个“有趣”的方法。它旨在验证一个字符串是否符合 *hh:mm:ss xx* 格式的有效时间，其中 *hh* 表示小时，*mm* 表示分钟，*ss* 表示秒，*xx* 是 *AM* 或 *PM*。

该方法使用以下代码将两个字符（表示小时）转换为一个数字，并验证它是否在适当的范围内：

```
try {
    Integer.parseInt(time.substring(0, 2));
} catch (Exception x) {
    return false;
}

if (Integer.parseInt(time.substring(0, 2)) > 12) {
    return false;
} 
```

同样的代码再出现两次，通过适当更改字符偏移和上限，来测试分钟和秒。该方法以以下代码结束，用于检查上午和下午：

```
if (!time.substring(9, 11).equals("AM") &
    !time.substring(9, 11).equals("PM")) {
    return false;
} 
```

如果这一系列比较都没有失败，返回 false，那么该方法就返回 true。

如果前面的代码看起来啰嗦且难以理解，不要担心。我也是这么认为的 — 这意味着我找到了值得整理的东西。我重构了它并写了几个单元测试，只是为了确保它仍然有效。

当我完成时，我对结果感到满意。新版本易于阅读，大小减半，更准确，因为原始代码仅测试了小时、分钟和秒的上限。

在准备第二天上班时，我脑子里突然冒出一个想法：为什么不使用正则表达式验证字符串呢？几分钟后，我只用了一行代码就实现了一个可工作的实现。这就是它：

```
public static boolean validateTime(String time) {
    return time.matches("(0[1-9]|1[0-2]):[0-5][0-9]:[0-5][0-9] ([AP]M)");
} 
```

这个故事的重点不在于我最终用一行代码替换了超过三十行的代码。重点是，在我远离电脑之前，我认为我的第一次尝试是解决问题的最佳方案。

所以下次遇到棘手问题时，请自己一个忙。一旦你真正理解了问题，做一些涉及你大脑创造性一面的事情 —— 梳理问题，听些音乐，或者出去散步。有时解决问题最好的方法就是放下鼠标，远离键盘。

作者：[BurkHufnagel](http://programmer.97things.oreilly.com/wiki/index.php/BurkHufnagel)

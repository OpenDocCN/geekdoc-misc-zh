# 了解自己的极限

# 了解自己的极限

> *"人必须了解自己的限制。" —《独行侠》*

你的资源是有限的。你只有那么多时间和金钱来完成工作，包括保持你的知识、技能和工具的最新状态所需的时间和金钱。你只能努力工作，努力快速、聪明和长时间工作。你的工具只有那么强大。你的目标机器也只有那么强大。因此，你必须尊重你的资源限制。

如何尊重这些限制？了解自己，了解你的团队，了解你的预算，了解你的东西。特别是，作为一名软件工程师，了解你的数据结构和算法的空间和时间复杂度，了解你系统的架构和性能特征。你的工作是创建软件和系统的最佳结合。

空间和时间复杂度被表示为函数*O(f(n))*，对于 n 等于输入大小，随着 n 趋向无穷大，所需的渐近空间或时间。对于*f(n)*的重要复杂度类包括*ln(n)*，*n*，*n ln(n)*，*n^e*和*e^n*。正如绘制这些函数清楚显示的那样，随着*n*变大，*O(ln(n))*比*O(n)*和*O(n ln(n))*要小得多，后者比*O(n^e)*和*O(e^n)*要小得多。正如 Sean Parent 所说，对于可实现的 n，所有复杂度类都接近恒定、近线性或近无限。

![](img/cec77cd7.jpeg)

|  | 访问时间 | 容量 |
| --- | --- | --- |
| 寄存器 | < 1 ns | 64b |
| 缓存行 |  | 64B |
| L1 缓存 | 1 ns | 64 KB |
| L2 缓存 | 4 ns | 8 MB |
| RAM | 20 ns | 32 GB |
| 磁盘 | 10 ms | 10 TB |
| 局域网 | 20 ms | > 1 PB |
| 互联网 | 100 ms | > 1 ZB |

复杂度分析是基于一个抽象机器，但软件运行在真实机器上。现代计算机系统组织为物理和虚拟机器的层次结构，包括语言运行时、操作系统、CPU、缓存内存、随机访问内存、磁盘驱动器和网络。第一个表显示了典型网络服务器的随机访问时间和存储容量的限制。

请注意，容量和速度相差几个数量级。在我们系统的每个级别都大量使用缓存和预读来隐藏这种变化，但只有在访问可预测时才有效。当缓存未命中频繁发生时，系统将出现抖动。例如，随机检查硬盘上的每个字节可能需要 32 年。即使随机检查 RAM 中的每个字节也可能需要 11 分钟。随机访问是不可预测的。什么是可预测的？这取决于系统，但重新访问最近使用的项目和顺序访问项目通常是成功的。

算法和数据结构在如何有效利用缓存方面有所不同。例如：

+   线性搜索充分利用预读，但需要*O(n)*次比较。

+   对排序数组进行二分查找仅需要*O(log(n))*次比较。

+   van Emde Boas 树的搜索是*O(log(n))*且具有缓存无关性。

| 元素 | 搜索时间 (ns) |  |  |
| --- | --- | --- | --- |
|  | **线性** | **二分** | **vEB** |
| 8 | 50 | 90 | 40 |
| 64 | 180 | 150 | 70 |
| 512 | 1200 | 230 | 100 |
| 4096 | 17000 | 320 | 160 |

如何选择？最终通过测量来决定。第二个表格显示了通过这三种方法搜索 64 位整数数组所需的时间。在我的电脑上：

+   线性搜索对于小数组是有竞争力的，但对于更大的数组来说，失去的速度是指数级的。

+   van Emde Boas 因其可预测的访问模式而轻松获胜。

> *"你出钱，你做选择。" — [Punch](http://www.nytimes.com/1988/02/28/magazine/on-language-you-pays-yer-money.html?pagewanted=all)*

作者：[Greg Colvin](http://programmer.97things.oreilly.com/wiki/index.php/Greg_Colvin)

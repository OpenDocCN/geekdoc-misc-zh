# 进程间通信影响应用程序的响应时间

# 进程间通信影响应用程序的响应时间

响应时间对软件的可用性至关重要。等待软件系统响应是很令人沮丧的事情，特别是当我们与软件的交互涉及到重复的刺激和响应循环时。我们觉得软件浪费了我们的时间，影响了我们的生产力。然而，造成响应时间不佳的原因并没有得到充分重视，特别是在现代应用程序中。许多性能管理文献仍然侧重于数据结构和算法，这些问题在某些情况下可能会产生影响，但在现代多层企业应用程序中很少会主导性能。

在这种应用程序中，当性能成为问题时，我的经验是检查数据结构和算法并不是寻找改进的正确地方。响应时间最大程度上取决于对刺激进行的远程进程间通信（IPC）的数量。虽然可能存在其他本地瓶颈，但是远程进程间通信的数量通常占主导地位。每次远程进程间通信都会对整体响应时间产生一些不可忽视的延迟，这些个别贡献会累加起来，特别是当它们依次发生时。

一个主要例子是在使用对象关系映射的应用程序中的*波及加载*。波及加载描述了执行许多数据库调用以选择构建对象图所需数据的顺序过程（参见[Martin Fowler 的*企业应用架构模式*](http://martinfowler.com/eaaCatalog/lazyLoad.html)中的*延迟加载*）。当数据库客户端是呈现网页的中间层应用服务器时，这些数据库调用通常在单个线程中顺序执行。它们的各自延迟累积，导致整体响应时间增加。即使每个数据库调用只需要 10 毫秒，一个需要 1000 次调用的页面（这并不罕见）也会展示至少 10 秒的响应时间。其他例子包括 Web 服务调用、来自 Web 浏览器的 HTTP 请求、分布式对象调用、请求-应答消息传递和通过自定义网络协议进行数据网格交互。需要响应刺激的远程 IPC 数量越多，响应时间就会越长。

有一些相对明显和众所周知的策略可以减少每次刺激的远程进程通信数量。一种策略是应用简约原则，优化进程之间的接口，以便以最小的交互量交换适用于手头工作的确切数据。另一种策略是在可能的情况下并行化进程间通信，以便整体响应时间主要受到最长延迟 IPC 的驱动。第三种策略是缓存先前 IPC 的结果，以便通过命中本地缓存而避免未来的 IPC。

当你设计一个应用程序时，要注意每个刺激产生的进程间通信数量。在分析性能不佳的应用程序时，我经常发现 IPC 到刺激比例是千对一。减少这个比例，无论是通过缓存、并行化还是其他技术，都会比改变数据结构选择或调整排序算法更有意义。

由[Randy Stafford](http://programmer.97things.oreilly.com/wiki/index.php/Randy_Stafford)撰写。

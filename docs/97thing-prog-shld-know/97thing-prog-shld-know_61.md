# 单一二进制文件

# 单一二进制文件

我见过几个项目，其中构建会重新编写代码的某些部分，以生成针对每个目标环境的定制二进制文件。这总是会使事情变得比它们应该的更加复杂，并引入了一个风险，即团队可能在每个安装上没有一致的版本。至少，它涉及构建多个几乎相同的软件副本，然后必须将每个副本部署到正确的位置。这意味着比必要的移动部件更多，这意味着出错的机会更多。

曾经，我曾在一个团队工作，那里每次属性更改都必须提交进行完整的构建周期检查，所以测试人员每当需要进行微小调整时就会被留下（我提到过构建时间太长了吗？）。我还曾在一个团队工作过，那里的系统管理员坚持要为生产环境从头开始重建（使用我们使用的相同脚本），这意味着我们无法证明生产环境中的版本是经过测试的版本。等等。

规则很简单：*构建一个单一的二进制文件，你可以通过发布管道中的所有阶段进行识别和推广。*将环境特定的细节保留在环境中。例如，这可能意味着将它们保存在组件容器中，在已知文件中或在路径中。

如果您的团队要么有一个乱码的构建，要么将所有目标设置与代码存储在一起，这表明没有人认真考虑过设计，以区分那些是应用程序核心的功能和那些是特定于平台的功能。或者更糟的是：团队知道该怎么做，但无法优先考虑进行更改的努力。

当然，也有例外情况：您可能正在为具有显着不同资源约束的目标构建，但这不适用于我们大多数编写“从数据库到屏幕再回来”应用程序的人。或者，您可能正在处理一些现在很难修复的旧系统混乱。在这种情况下，您必须进行逐步移动-但尽快开始。

还有一件事：也要将环境信息进行版本控制。没有比破坏环境配置并且无法弄清楚发生了什么更糟糕的了。环境信息应该与代码分开进行版本控制，因为它们的变化速率和原因不同。一些团队使用分布式版本控制系统进行这项工作（例如 bazaar 和 git），因为它们使得将在生产环境中进行的更改（不可避免地发生）轻松地推回存储库变得更容易。

作者：[史蒂夫·弗里曼](http://programmer.97things.oreilly.com/wiki/index.php/Steve_Freeman)

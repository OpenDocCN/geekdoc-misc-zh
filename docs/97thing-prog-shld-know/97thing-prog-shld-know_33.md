# 浮点数不是真实的

# 浮点数不是真实的

浮点数在数学意义上不是“实数”，尽管在某些编程语言中（如 Pascal 和 Fortran）它们被称为*实数*。实数具有无限的精度，因此是连续的和非丢失的；浮点数具有有限的精度，因此它们是有限的，它们类似于“表现不佳的”整数，因为它们在其范围内不是均匀分布的。

举个例子，将 2147483647（最大的 32 位有符号整数）赋值给一个 32 位浮点变量（比如说 x），然后打印它。你会看到 2147483648。现在打印`x - 64`。仍然是 2147483648。现在打印`x - 65`，你会得到 2147483520！为什么？因为在这个范围内相邻浮点数之间的间隔是 128，浮点运算会四舍五入到最近的浮点数。

IEEE 浮点数是基于二进制科学计数法的固定精度数字：1.d[1]d[2]...d[p-1] × 2^e，其中*p*是精度（float 为 24，double 为 53）。两个连续数字之间的间距是 2^(1-p+e)，可以安全地近似为ε|x|，其中ε是*机器精度*（2^(1-p)）。

了解浮点数周围的间距可以帮助您避免经典的数值错误。例如，如果您正在执行迭代计算，比如搜索方程的根，那么在答案附近要求比数字系统能给出的精度更高是没有意义的。确保您请求的容差不小于那里的间距；否则你会无限循环。

由于浮点数是实数的近似值，难免存在一些误差。这种误差称为*舍入误差*，可能导致意想不到的结果。例如，当你减去几乎相等的数字时，最显著的数字会相互抵消，所以舍入误差存在的最低有效位会提升到浮点结果的最显著位置，从而污染任何进一步相关的计算（这种现象称为*涂抹*）。你需要仔细检查你的算法，以防止这种*灾难性的抵消*。举个例子，考虑用求根公式解方程*x² - 100000x + 1 = 0*。由于表达式*-b + sqrt(b² - 4)*中的操作数几乎相等，你可以计算根*r[1] = -b + sqrt(b² - 4)*，然后得到*r[2] = 1/r[1]*，因为对于任何二次方程，ax2 + bx + c = 0，根满足*r[1]r[2] = c/a*。

即使更微妙的方式也可能发生涂抹。假设一个库通过公式*1 + x + x²/2 + x³/3! + ...*天真地计算*e^x*。对于正数*x*，这样做没问题，但是当*x*是一个很大的负数时会发生什么呢？偶次幂会产生很大的正数，而减去奇次幂的量甚至不会影响结果。问题在于，大正数的舍入值位于远比真实答案更为重要的数字位置。答案会朝着正无穷发散！解决方法也很简单：对于负数*x*，计算*e^x = 1/e^(|x|)*。

应该不言而喻，你不应该在金融应用中使用浮点数 —— 这就是像 Python 和 C# 这样的语言中的十进制类存在的原因。浮点数旨在进行高效的科学计算。但是效率没有准确性就毫无价值，所以请记住舍入误差的来源，并相应地编写代码！

作者：[查克·艾利森](http://programmer.97things.oreilly.com/wiki/index.php/Chuck_Allison)

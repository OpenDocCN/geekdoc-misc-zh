# 通向性能之路上布满了脏代码炸弹

# 通向性能之路上布满了脏代码炸弹

很多时候，性能调优系统需要您修改代码。 当我们需要修改代码时，每个过度复杂或高度耦合的块都是一个潜在的脏代码炸弹，等待着破坏努力。 脏代码的第一个受害者将是您的进度。 如果前进的道路顺畅，您将很容易预测何时完成。 与脏代码的意外相遇将使得做出理智的预测非常困难。

考虑一种情况，即您发现了一个执行热点。 正常的操作是减少底层算法的强度。 假设您对经理的估计请求做出了 3-4 小时的回答。 当您应用修复时，您很快意识到您破坏了一个依赖部分。 由于相关的事物通常必然耦合在一起，这种破坏很可能是预期的并已经考虑在内。 但是，如果修复该依赖性导致其他依赖部分破坏会发生什么？ 此外，依赖性距离原点越远，您就越不可能将其识别为这样的依赖性，并在您的估计中加以考虑。 突然间，您的 3-4 小时估计很容易膨胀到 3-4 周。 通常，进度意外膨胀会一次或两次发生 1 天或 2 天。 "快速"重构最终需要几个月的时间完成并不罕见。 在这些情况下，负责团队的信誉和政治资本的损害程度将从严重到终结不等。 要是我们有一个工具来帮助我们识别和衡量这种风险就好了。

实际上，我们有许多方法来衡量和控制我们代码的耦合程度和复杂度。 软件度量可以用来计算我们代码中特定功能的发生次数。 这些计数的值与代码质量相关。 衡量耦合的许多度量中的两个是 fan-in 和 fan-out。 考虑 fan-out 用于类的情况：它被定义为从感兴趣的类直接或间接引用的类的数量。 您可以将其视为必须在编译您的类之前编译您的类的所有类的计数。 另一方面，fan-in 是依赖于感兴趣类的所有类的计数。 知道 fan-out 和 fan-in，我们可以使用*I = f[o] / (f[i] + f[o])*来计算不稳定因子。 当*I*接近 0 时，包变得更加稳定。 当*I*接近 1 时，包变得不稳定。 稳定的包是重新编码的低风险目标，而不稳定的包更有可能充满脏代码炸弹。 重构的目标是将*I*接近 0。

在使用度量标准时，必须记住它们只是经验法则。仅从数学上看，我们可以看到增加 *f[i]* 而不改变 fo 将使 *I* 接近于 0。然而，非常大的扇入值也有缺点，即这些类更难以在不破坏依赖关系的情况下修改。此外，如果不解决扇出问题，您实际上并没有减少风险，因此必须做出一些权衡。

软件度量标准的一个缺点是，度量工具产生的大量数字可能会让未经训练的人望而生畏。尽管如此，软件度量标准可以成为我们追求优雅代码的强大工具。它们可以帮助我们在性能调优之前识别并消除脏代码炸弹，以免造成严重风险。

作者为[Kirk Pepperdine](http://programmer.97things.oreilly.com/wiki/index.php/Kirk_Pepperdine)

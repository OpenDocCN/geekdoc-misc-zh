# 在责怪他人之前，先检查你的代码

# 在责怪他人之前，先检查你的代码

开发人员 —— 我们所有人！ —— 往往难以相信我们自己的代码是错误的。很难想象，这一次，代码是错误的，所以这一定是编译器出错了。

然而，事实上，由编译器、解释器、操作系统、应用服务器、数据库、内存管理器或任何其他系统软件中的错误导致代码出错是非常（非常）不寻常的。是的，这些错误存在，但它们远不像我们希望的那样常见。

我曾经真正遇到一个编译器错误，优化掉了一个循环变量，但我想象过我的编译器或操作系统有很多次错误。在这个过程中，我浪费了大量的时间、支持时间和管理时间，只是每次都发现最后还是我的错，感觉有点愚蠢。

假设这些工具被广泛使用、成熟，并在各种技术栈中使用，就没有理由怀疑其质量。当然，如果这个工具是早期发布的，或者只被全球少数人使用，或者是一种很少下载的软件，版本 0.1 的开源软件，那么怀疑这个软件可能是有充分理由的。（同样，商业软件的α版本可能会受到怀疑。）

鉴于编译器错误的罕见性，将时间和精力放在查找代码中的错误上要比证明编译器错误更好得多。所有通常的调试建议都适用，所以要隔离问题，桩化调用，用测试环绕它；检查调用约定、共享库和版本号；向别人解释它；注意堆栈破坏和变量类型不匹配；在不同的机器和不同的构建配置上尝试代码，比如调试和发布。

质疑自己的假设和他人的假设。来自不同供应商的工具可能内置了不同的假设 —— 同一供应商的不同工具也可能如此。当其他人报告你无法复制的问题时，去看看他们在做什么。他们可能在做一些你从未想过的事情，或者以不同的顺序进行某些操作。

作为一个个人规则，如果我有一个找不到原因的错误，而我开始认为是编译器的问题，那么是时候寻找堆栈破坏的迹象了。如果添加跟踪代码使问题发生位置变动，尤其如此。

多线程问题是另一个导致头发变灰并引发对机器尖叫的错误来源。当系统是多线程时，所有倾向于简化代码的建议都会倍增。调试和单元测试无法始终可靠地找到这些错误，因此设计的简洁性至关重要。

因此，在你急于责怪编译器之前，记住福尔摩斯的建议，“一旦你排除了不可能的，无论其余的是多么不可能，都必然是真相”，并更喜欢它，而不是迪克·金特利的“一旦你排除了不可能的，无论其余的是多么不可能，都必然是真相”。

由[Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)撰写。

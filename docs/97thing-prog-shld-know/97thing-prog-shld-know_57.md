# 消息传递在并行系统中导致更好的可伸缩性

# 消息传递在并行系统中导致更好的可伸缩性

程序员从他们学习计算的最初阶段就被教导，并发——尤其是并行性，是困难的，只有最优秀的人才有希望做对，即使他们也会出错。人们总是非常关注线程、信号量、监视器，以及如何让并发访问变量变得线程安全的困难。

确实，存在许多困难问题，而且它们可能非常难以解决。但问题的根源是什么？共享内存。人们一直在谈论的几乎所有并发问题都与使用共享可变内存有关：竞争条件、死锁、活锁等。答案似乎很明显：要么放弃并发，要么放弃共享内存！

放弃并发几乎肯定不是一个选项。计算机几乎每个季度都会增加更多的核心，因此利用真正的并行性变得越来越重要。我们不能再依赖不断增加的处理器时钟速度来提高应用程序性能。只有通过利用并行性，应用程序的性能才会提高。显然，不提高性能是一个选择，但这不太可能被用户接受。

那么我们可以放弃共享内存吗？当然可以。

我们可以使用进程和消息传递而不是线程和共享内存作为我们的编程模型。这里的进程只是指具有执行代码的受保护独立状态，不一定是操作系统进程。诸如 Erlang（以及之前的 occam）等语言已经证明，进程是编程并发和并行系统的非常成功的机制。这些系统没有所有共享内存、多线程系统所具有的所有同步压力。此外，还有一个正式模型——通信顺序进程（CSP）——可以作为这些系统工程的一部分应用。

我们可以进一步引入数据流系统作为一种计算方式。在数据流系统中，没有明确编程的控制流。相反，建立一个由数据路径连接的操作符有向图，然后将数据输入系统。评估由系统内数据的准备情况控制。绝对不会出现同步问题。

尽管如此，诸如 C、C++、Java、Python 和 Groovy 等语言是系统开发的主要语言，所有这些语言都被呈现给程序员作为开发共享内存、多线程系统的语言。那么该怎么办呢？答案是使用——或者，如果不存在，创建——提供进程模型和消息传递的库和框架，避免使用任何共享可变内存。

总的来说，不是使用共享内存进行编程，而是使用消息传递，很可能是实现利用计算机硬件中现在普遍存在的并行性的系统最成功的方式。或许有些奇怪，尽管进程在并发性方面早于线程，但未来似乎在于使用线程来实现进程。

作者：[Russel Winder](http://programmer.97things.oreilly.com/wiki/index.php/Russel_Winder)

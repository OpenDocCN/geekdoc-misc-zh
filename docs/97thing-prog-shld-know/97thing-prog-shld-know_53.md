# 链接器不是一个神奇的程序

# 链接器不是一个神奇的程序

令人沮丧的是（就在我写这篇文章之前又发生了），许多程序员对从源代码到编译语言的静态链接可执行文件的过程的看法是：

1.  编辑源代码

1.  将源代码编译成目标文件

1.  一些神奇的事情发生了

1.  运行可执行文件

第三步当然是链接步骤。为什么我会说出这样一个荒谬的事情？我做技术支持已经几十年了，我一遍又一遍地收到以下问题：

1.  链接器说 def 被定义了多次。

1.  链接器说 abc 是一个未解析的符号。

1.  为什么我的可执行文件这么大？

紧随其后的是“我现在该怎么办？”通常会出现“似乎”和“某种方式”这样的短语，并带有一种彻底的困惑氛围。正是“似乎”和“某种方式”表明了链接过程被视为一个神奇的过程，可能只有巫师和术士才能理解。编译的过程不会引起这种短语，这意味着程序员通常了解编译器的工作原理，或者至少知道它们做什么。

链接器是一个非常愚蠢、平凡、直截了当的程序。它所做的就是将目标文件的代码和数据部分连接在一起，将符号的引用与其定义连接起来，从库中提取未解析的符号，并写出一个可执行文件。就是这样。没有咒语！没有魔法！写链接器的烦恼通常都在于解码和生成通常过于复杂的文件格式，但这并不改变链接器的本质。

所以假设链接器说 def 被定义了多次。许多编程语言，如 C、C++和 D，都有声明和定义。声明通常放在头文件中，像：

```
extern int iii; 
```

这会生成对符号`iii`的外部引用。另一方面，定义实际上为符号保留存储空间，通常出现在实现文件中，看起来像这样：

```
int iii = 3; 
```

每个符号可以有多少个定义？就像电影*Highlander*中一样，只能有一个。那么，如果 iii 的定义出现在多个实现文件中怎么办？

```
// File a.c
int iii = 3; 
```

```
// File b.c
double iii(int x) { return 3.7; } 
```

链接器会抱怨`iii`被多次定义。

不仅可以只有一个，必须有一个。如果 iii 只出现在声明中，而从未出现在定义中，链接器会抱怨 iii 是一个未解析的符号。

要确定可执行文件的大小原因，可以查看链接器可选择生成的映射文件。映射文件只是可执行文件中所有符号及其地址的列表。这告诉您从库中链接了哪些模块，以及每个模块的大小。现在你可以看到浮肿来自哪里。通常会有一些库模块，你不知道为什么会被链接进来。为了弄清楚，暂时从库中移除可疑模块，并重新链接。然后生成的未定义符号错误将指示谁在引用该模块。

虽然为什么会得到特定的链接器消息并不总是显而易见，但链接器并不神奇。其机制很简单；需要在每种情况下弄清楚的是细节。

由[Walter Bright](http://creativecommons.org/licenses/by/3.0/us/)

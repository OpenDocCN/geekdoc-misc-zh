# 考虑线程安全性

# 考虑线程安全性

## 避免全局数据

全局数据会导致函数之间意想不到的副作用，并且可能使代码难以或不可能并行化。即使代码今天不打算并行化，也没有理由使未来变得不可能。

### 静态变量

除了是全局数据之外，静态变量并不总是按照您期望的方式构造和销毁。这在跨平台环境中尤其如此。例如，请参阅[g++错误报告](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66830)，关于从动态模块加载的共享静态数据的销毁顺序。

### 共享指针

`std::shared_ptr`就像全局一样好（[`stackoverflow.com/a/18803611/29975`](http://stackoverflow.com/a/18803611/29975)），因为它允许多个代码片段与相同的数据进行交互。

### 单例

单例通常使用静态和/或`shared_ptr`实现。

## 避免堆操作

在多线程环境中速度要慢得多。在许多情况下，甚至可能大多数情况下，复制数据更快。再加上移动操作等等。

## 互斥量和可变性一起使用（M&M rule，C++11）

对于成员变量，使用互斥量和可变性是良好的实践。这适用于双向：

+   可变成员变量被假定为共享变量，因此应使用互斥量进行同步（或使其原子化）

+   如果成员变量本身是互斥量，则应将其声明为可变的。这是在 const 成员函数中使用它所必需的。

更多信息，请参阅 Herb Sutter 的以下文章：[`herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/`](http://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/)

还请参阅相关的安全讨论，关于`const &`返回值

- en: The Future trait
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Future 特性
- en: 原文：[https://rust-exercises.com/100-exercises/08_futures/04_future.html](https://rust-exercises.com/100-exercises/08_futures/04_future.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://rust-exercises.com/100-exercises/08_futures/04_future.html](https://rust-exercises.com/100-exercises/08_futures/04_future.html)'
- en: '[The local `Rc` problem](#the-local-rc-problem)'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[局部 `Rc` 问题](#the-local-rc-problem)'
- en: 'Let''s go back to `tokio::spawn`''s signature:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `tokio::spawn` 的签名：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What does it *actually* mean for `F` to be `Send`?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`F` 为 `Send` 究竟意味着什么？'
- en: It implies, as we saw in the previous section, that whatever value it captures
    from the spawning environment has to be `Send`. But it goes further than that.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这意味着它从启动环境捕获的任何值都必须是 `Send`。但它不仅仅如此。
- en: Any value that's *held across a .await point* has to be `Send`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 任何跨越 `.await` 点持有的值都必须是 `Send`。
- en: 'Let''s look at an example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The compiler will reject this code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会拒绝这段代码：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To understand why that's the case, we need to refine our understanding of Rust's
    asynchronous model.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么是这样，我们需要深化对 Rust 异步模型的理解。
- en: '[The `Future` trait](#the-future-trait-1)'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Future 特性](#the-future-trait-1)'
- en: 'We stated early on that `async` functions return **futures**, types that implement
    the `Future` trait. You can think of a future as a **state machine**. It''s in
    one of two states:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一开始就声明了 `async` 函数返回 **futures**，即实现了 `Future` 特性的类型。你可以将未来视为 **状态机**。它处于两种状态之一：
- en: '**pending**: the computation has not finished yet.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pending**：计算尚未完成。'
- en: '**ready**: the computation has finished, here''s the output.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ready**：计算已完成，这里是输出。'
- en: 'This is encoded in the trait definition:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在特性定义中有所体现：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[`poll`](#poll)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`poll`](#poll)'
- en: The `poll` method is the heart of the `Future` trait.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll` 方法是 `Future` 特性的核心。'
- en: A future on its own doesn't do anything. It needs to be **polled** to make progress.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未来本身不做什么。它需要被 **轮询** 才能取得进展。
- en: 'When you call `poll`, you''re asking the future to do some work. `poll` tries
    to make progress, and then returns one of the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `poll` 时，你是在要求未来执行一些工作。`poll` 尝试取得进展，然后返回以下之一：
- en: '`Poll::Pending`: the future is not ready yet. You need to call `poll` again
    later.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Poll::Pending`：未来尚未准备好。你需要稍后再次调用 `poll`。'
- en: '`Poll::Ready(value)`: the future has finished. `value` is the result of the
    computation, of type `Self::Output`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Poll::Ready(value)`：未来已完成。`value` 是计算的结果，类型为 `Self::Output`。'
- en: 'Once `Future::poll` returns `Poll::Ready`, it should not be polled again: the
    future has completed, there''s nothing left to do.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Future::poll` 返回 `Poll::Ready`，它就不应该再次被轮询：未来已完成，没有剩下要做的。
- en: '[The role of the runtime](#the-role-of-the-runtime)'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[运行时的作用](#the-role-of-the-runtime)'
- en: You'll rarely, if ever, be calling poll directly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少，如果不是永远，会直接调用 `poll`。
- en: 'That''s the job of your async runtime: it has all the required information
    (the `Context` in `poll`''s signature) to ensure that your futures are making
    progress whenever they can.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的异步运行时的工作：它拥有所有必要的信息（`poll` 签名中的 `Context`），以确保你的未来可以在可能的时候取得进展。
- en: '[`async fn` and futures](#async-fn-and-futures)'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`async fn` 和 futures](#async-fn-and-futures)'
- en: We've worked with the high-level interface, asynchronous functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用高级接口，异步函数进行了工作。
- en: We've now looked at the low-level primitive, the `Future trait`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了低级原语，即 `Future` 特性。
- en: How are they related?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是如何相关的？
- en: 'Every time you mark a function as asynchronous, that function will return a
    future. The compiler will transform the body of your asynchronous function into
    a **state machine**: one state for each `.await` point.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你将一个函数标记为异步时，该函数将返回一个未来。编译器会将你的异步函数的主体转换为 **状态机**：每个 `.await` 点对应一个状态。
- en: 'Going back to our `Rc` example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的 `Rc` 例子：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiler would transform it into an enum that looks somewhat like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会将其转换为类似以下的枚举：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When `example` is called, it returns `ExampleFuture::NotStarted`. The future
    has never been polled yet, so nothing has happened.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `example` 时，它返回 `ExampleFuture::NotStarted`。未来尚未被轮询，因此没有任何事情发生。
- en: 'When the runtime polls it the first time, `ExampleFuture` will advance until
    the next `.await` point: it''ll stop at the `ExampleFuture::YieldNow(Rc<i32>)`
    stage of the state machine, returning `Poll::Pending`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时第一次轮询它时，`ExampleFuture` 将推进到下一个 `.await` 点：它会在状态机的 `ExampleFuture::YieldNow(Rc<i32>)`
    阶段停止，返回 `Poll::Pending`。
- en: When it's polled again, it'll execute the remaining code (`println!`) and return
    `Poll::Ready(())`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当它再次被轮询时，它将执行剩余的代码（`println!`）并返回 `Poll::Ready(())`。
- en: 'When you look at its state machine representation, `ExampleFuture`, it is now
    clear why `example` is not `Send`: it holds an `Rc`, therefore it cannot be `Send`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看其状态机表示，`ExampleFuture`，现在就很清楚为什么`example`不是`Send`：因为它持有`Rc`，因此不能是`Send`。
- en: '[Yield points](#yield-points)'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[让步点](#yield-points)'
- en: As you've just seen with `example`, every `.await` point creates a new intermediate
    state in the lifecycle of a future.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才在`example`中看到的，每一个`.await`点都会在未来的生命周期中创建一个新的中间状态。
- en: 'That''s why `.await` points are also known as **yield points**: your future
    *yields control* back to the runtime that was polling it, allowing the runtime
    to pause it and (if necessary) schedule another task for execution, thus making
    progress on multiple fronts concurrently.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，`.await`点也被称为**让步点**：你的未来让步将控制权交回正在轮询它的运行时，允许运行时暂停它，并在必要时安排另一个任务执行，从而在多个方面同时取得进展。
- en: We'll come back to the importance of yielding in a later section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中再次讨论让步的重要性。
- en: '[Exercise](#exercise)'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`08_futures/04_future`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/04_future)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的练习位于[`08_futures/04_future`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/04_future)

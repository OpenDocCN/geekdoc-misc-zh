- en: Heap
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html](https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html](https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html)
- en: The stack is great, but it can't solve all our problems. What about data whose
    size is not known at compile time? Collections, strings, and other dynamically-sized
    data cannot be (entirely) stack-allocated. That's where the **heap** comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 栈很棒，但它不能解决我们所有的问题。对于编译时不知道大小的数据怎么办？集合、字符串和其他动态大小的数据不能（完全）在栈上分配。这就是堆的作用所在。
- en: '[Heap allocations](#heap-allocations)'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[堆分配](#heap-allocations)'
- en: You can visualize the heap as a big chunk of memory—a huge array, if you will.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将堆想象成一大块内存——如果你愿意，可以把它想象成一个巨大的数组。
- en: Whenever you need to store data on the heap, you ask a special program, the
    **allocator**, to reserve for you a subset of the heap. We call this interaction
    (and the memory you reserved) a **heap allocation**. If the allocation succeeds,
    the allocator will give you a **pointer** to the start of the reserved block.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要在堆上存储数据时，你都会要求一个特殊的程序，即**分配器**，为你预留堆的一个子集。我们称这种交互（以及你预留的内存）为**堆分配**。如果分配成功，分配器会给你一个指向预留块起始的**指针**。
- en: '[No automatic de-allocation](#no-automatic-de-allocation)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[无自动释放](#no-automatic-de-allocation)'
- en: The heap is structured quite differently from the stack.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的结构与栈大不相同。
- en: Heap allocations are not contiguous, they can be located anywhere inside the
    heap.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配不是连续的，它们可以位于堆内的任何位置。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s the allocator''s job to keep track of which parts of the heap are in
    use and which are free. The allocator won''t automatically free the memory you
    allocated, though: you need to be deliberate about it, calling the allocator again
    to **free** the memory you no longer need.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪堆中哪些部分在使用，哪些部分是空闲的，这是分配器的职责。尽管如此，分配器不会自动释放你分配的内存：你需要有意识地去做，再次调用分配器来**释放**你不再需要的内存。
- en: '[Performance](#performance)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[性能](#performance)'
- en: 'The heap''s flexibility comes at a cost: heap allocations are **slower** than
    stack allocations. There''s a lot more bookkeeping involved!'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的灵活性是有代价的：堆分配比栈分配**慢**。涉及的记账工作更多！
- en: If you read articles about performance optimization you'll often be advised
    to minimize heap allocations and prefer stack-allocated data whenever possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读关于性能优化的文章，你经常会得到这样的建议：尽量减少堆分配，并在可能的情况下优先选择栈分配的数据。
- en: '[`String`''s memory layout](#strings-memory-layout)'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`String` 的内存布局](#strings-memory-layout)'
- en: 'When you create a local variable of type `String`, Rust is forced to allocate
    on the heap^([1](#footnote-empty)): it doesn''t know in advance how much text
    you''re going to put in it, so it can''t reserve the right amount of space on
    the stack.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个类型为 `String` 的局部变量时，Rust 被迫在堆上分配^([1](#footnote-empty))：它事先不知道你将放入多少文本，因此它不能在栈上预留正确数量的空间。
- en: 'But a `String` is not *entirely* heap-allocated, it also keeps some data on
    the stack. In particular:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但一个 `String` 并不是**完全**堆分配的，它也保留了一些数据在栈上。特别是：
- en: The **pointer** to the heap region you reserved.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你预留的堆区域的**指针**。
- en: The **length** of the string, i.e. how many bytes are in the string.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的**长度**，即字符串中有多少字节。
- en: The **capacity** of the string, i.e. how many bytes have been reserved on the
    heap.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的**容量**，即已经预留了多少字节在堆上。
- en: 'Let''s look at an example to understand this better:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解这一点：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you run this code, memory will be laid out like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，内存将按照以下方式布局：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We asked for a `String` that can hold up to 5 bytes of text.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求了一个可以容纳多达5字节文本的 `String`。
- en: '`String::with_capacity` goes to the allocator and asks for 5 bytes of heap
    memory. The allocator returns a pointer to the start of that memory block.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`String::with_capacity` 会去请求分配器，并要求5字节的堆内存。分配器返回该内存块的起始指针。'
- en: 'The `String` is empty, though. On the stack, we keep track of this information
    by distinguishing between the length and the capacity: this `String` can hold
    up to 5 bytes, but it currently holds 0 bytes of actual text.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `String` 是空的。在栈上，我们通过区分长度和容量来跟踪这些信息：这个 `String` 可以容纳多达5字节，但目前只包含0字节的实际文本。
- en: 'If you push some text into the `String`, the situation will change:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一些文本推入 `String`，情况将发生变化：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`s` now holds 3 bytes of text. Its length is updated to 3, but capacity remains
    5. Three of the five bytes on the heap are used to store the characters `H`, `e`,
    and `y`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`s` 现在包含3个字节的文本。其长度更新为3，但容量保持为5。堆上的五个字节中有三个被用来存储字符 `H`、`e` 和 `y`。'
- en: '[`usize`](#usize)'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`usize`](#usize)'
- en: How much space do we need to store pointer, length and capacity on the stack?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要多少空间来在栈上存储指针、长度和容量？
- en: It depends on the **architecture** of the machine you're running on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你运行的机器的**架构**。
- en: Every memory location on your machine has an [**address**](https://en.wikipedia.org/wiki/Memory_address),
    commonly represented as an unsigned integer. Depending on the maximum size of
    the address space (i.e. how much memory your machine can address), this integer
    can have a different size. Most modern machines use either a 32-bit or a 64-bit
    address space.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您机器上的每个内存位置都有一个[**地址**](https://en.wikipedia.org/wiki/Memory_address)，通常表示为无符号整数。根据地址空间的最大大小（即您的机器可以寻址的内存量），这个整数可以有不同的大小。大多数现代机器使用32位或64位地址空间。
- en: 'Rust abstracts away these architecture-specific details by providing the `usize`
    type: an unsigned integer that''s as big as the number of bytes needed to address
    memory on your machine. On a 32-bit machine, `usize` is equivalent to `u32`. On
    a 64-bit machine, it matches `u64`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Rust通过提供`usize`类型来抽象这些架构特定的细节：这是一个无符号整数，其大小与在您的机器上寻址内存所需的字节数相同。在32位机器上，`usize`相当于`u32`。在64位机器上，它匹配`u64`。
- en: Capacity, length and pointers are all represented as `usize`s in Rust^([2](#footnote-equivalence)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容量、长度和指针在Rust中都用`usize`表示^([2](#footnote-equivalence))。
- en: '[No `std::mem::size_of` for the heap](#no-stdmemsize_of-for-the-heap)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[没有`std::mem::size_of`用于堆](#no-stdmemsize_of-for-the-heap)'
- en: '`std::mem::size_of` returns the amount of space a type would take on the stack,
    which is also known as the **size of the type**.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mem::size_of`返回一个类型在栈上占用多少空间，这也就是所谓的**类型大小**。'
- en: What about the memory buffer that `String` is managing on the heap? Isn't that
    part of the size of `String`?
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那么`String`在堆上管理的内存缓冲区呢？这不是`String`大小的一部分吗？
- en: No!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不！
- en: That heap allocation is a **resource** that `String` is managing. It's not considered
    to be part of the `String` type by the compiler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那堆分配是`String`正在管理的**资源**。编译器并不认为它是`String`类型的一部分。
- en: '`std::mem::size_of` doesn''t know (or care) about additional heap-allocated
    data that a type might manage or refer to via pointers, as is the case with `String`,
    therefore it doesn''t track its size.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mem::size_of`不知道（或关心）类型可能通过指针管理或引用的额外堆分配数据，例如`String`，因此它不跟踪其大小。'
- en: Unfortunately there is no equivalent of `std::mem::size_of` to measure the amount
    of heap memory that a certain value is allocating at runtime. Some types might
    provide methods to inspect their heap usage (e.g. `String`'s `capacity` method),
    but there is no general-purpose "API" to retrieve runtime heap usage in Rust.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有`std::mem::size_of`的等价功能来测量运行时某个值分配的堆内存量。某些类型可能提供方法来检查它们的堆使用情况（例如`String`的`capacity`方法），但在Rust中没有任何通用“API”来检索运行时的堆使用情况。
- en: You can, however, use a memory profiler tool (e.g. [DHAT](https://valgrind.org/docs/manual/dh-manual.html)
    or [a custom allocator](https://docs.rs/dhat/latest/dhat/)) to inspect the heap
    usage of your program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用内存分析工具（例如 [DHAT](https://valgrind.org/docs/manual/dh-manual.html) 或
    [自定义分配器](https://docs.rs/dhat/latest/dhat/))来检查你程序的堆使用情况。
- en: '[Exercise](#exercise)'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`03_ticket_v1/09_heap`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`03_ticket_v1/09_heap`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap)
- en: '* * *'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '`std` doesn''t allocate if you create an **empty** `String` (i.e. `String::new()`).
    Heap memory will be reserved when you push data into it for the first time. [↩](#fr-empty-1)'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你创建一个**空**的`String`（即`String::new()`），`std`不会进行分配。[↩](#fr-empty-1)
- en: The size of a pointer depends on the operating system too. In certain environments,
    a pointer is **larger** than a memory address (e.g. [CHERI](https://web.archive.org/web/20240517051950/https://blog.acolyer.org/2019/05/28/cheri-abi/)).
    Rust makes the simplifying assumption that pointers are the same size as memory
    addresses, which is true for most modern systems you're likely to encounter. [↩](#fr-equivalence-1)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指针的大小也取决于操作系统。在某些环境中，指针**更大**于内存地址（例如 [CHERI](https://web.archive.org/web/20240517051950/https://blog.acolyer.org/2019/05/28/cheri-abi/))。Rust做出了简化的假设，即指针的大小与内存地址相同，这在大多数现代系统中都是正确的。[↩](#fr-equivalence-1)

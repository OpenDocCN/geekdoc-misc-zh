- en: Interior mutability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部可变性
- en: 原文：[https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html](https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html](https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html)
- en: 'Let''s take a moment to reason about the signature of `Sender`''s `send`:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来推理 `Sender` 的 `send` 方法的签名：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`send` takes `&self` as its argument.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 方法以 `&self` 作为其参数。'
- en: 'But it''s clearly causing a mutation: it''s adding a new message to the channel.
    What''s even more interesting is that `Sender` is cloneable: we can have multiple
    instances of `Sender` trying to modify the channel state **at the same time**,
    from different threads.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但它显然引起了一种突变：它向通道添加了一条新消息。更有趣的是，`Sender` 是可克隆的：我们可以有多个 `Sender` 实例同时尝试修改通道状态，来自不同的线程。
- en: That's the key property we are using to build this client-server architecture.
    But why does it work? Doesn't it violate Rust's rules about borrowing? How are
    we performing mutations via an *immutable* reference?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们构建这个客户端-服务器架构的关键属性。但为什么它有效？它不是违反 Rust 的借用规则吗？我们是如何通过一个**不可变**引用执行变动的？
- en: '[Shared rather than immutable references](#shared-rather-than-immutable-references)'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[共享而非不变引用](#shared-rather-than-immutable-references)'
- en: 'When we introduced the borrow-checker, we named the two types of references
    we can have in Rust:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引入借用检查器时，我们为 Rust 中可以拥有的两种引用类型命名：
- en: immutable references (`&T`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变引用（`&T`）
- en: mutable references (`&mut T`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变引用（`&mut T`）
- en: 'It would have been more accurate to name them:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，应该这样命名它们：
- en: shared references (`&T`)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享引用（`&T`）
- en: exclusive references (`&mut T`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独占引用（`&mut T`）
- en: 'Immutable/mutable is a mental model that works for the vast majority of cases,
    and it''s a great one to get started with Rust. But it''s not the whole story,
    as you''ve just seen: `&T` doesn''t actually guarantee that the data it points
    to is immutable.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不变/可变是一种适用于绝大多数情况的心理模型，也是 Rust 的一个很好的入门模型。但正如你所看到的，这并不是全部故事：`&T` 并不真正保证它指向的数据是不变的。
- en: 'Don''t worry, though: Rust is still keeping its promises. It''s just that the
    terms are a bit more nuanced than they might seem at first.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，尽管如此：Rust 仍然在履行其承诺。只是这些条款比最初看起来要复杂一些。
- en: '[`UnsafeCell`](#unsafecell)'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`UnsafeCell`](#unsafecell)'
- en: Whenever a type allows you to mutate data through a shared reference, you're
    dealing with **interior mutability**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每当类型允许你通过共享引用修改数据时，你就是在处理**内部可变性**。
- en: By default, the Rust compiler assumes that shared references are immutable.
    It **optimises your code** based on that assumption.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rust 编译器假设共享引用是不变的。它根据这个假设**优化你的代码**。
- en: The compiler can reorder operations, cache values, and do all sorts of magic
    to make your code faster.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以重新排序操作，缓存值，并执行各种魔法来使你的代码更快。
- en: You can tell the compiler "No, this shared reference is actually mutable" by
    wrapping the data in an `UnsafeCell`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将数据包裹在 `UnsafeCell` 中来告诉编译器：“不，这个共享引用实际上是可变的。”
- en: Every time you see a type that allows interior mutability, you can be certain
    that `UnsafeCell` is involved, either directly or indirectly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你看到允许内部可变性的类型时，你可以确信 `UnsafeCell` 是涉及的，无论是直接还是间接的。
- en: Using `UnsafeCell`, raw pointers and `unsafe` code, you can mutate data through
    shared references.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UnsafeCell`、原始指针和 `unsafe` 代码，你可以通过共享引用来修改数据。
- en: 'Let''s be clear, though: `UnsafeCell` isn''t a magic wand that allows you to
    ignore the borrow-checker!'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清楚地说明：`UnsafeCell` 不是一个魔法棒，可以让你忽略借用检查器！
- en: '`unsafe` code is still subject to Rust''s rules about borrowing and aliasing.
    It''s an (advanced) tool that you can leverage to build **safe abstractions**
    whose safety can''t be directly expressed in Rust''s type system. Whenever you
    use the `unsafe` keyword you''re telling the compiler: "I know what I''m doing,
    I won''t violate your invariants, trust me."'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe` 代码仍然受 Rust 关于借用和别名规则的约束。它是一个（高级）工具，你可以利用它来构建**安全的抽象**，其安全性不能直接在 Rust
    的类型系统中表达。每次你使用 `unsafe` 关键字时，你都在告诉编译器：“我知道我在做什么，我不会违反你的不变性，相信我。”'
- en: 'Every time you call an `unsafe` function, there will be documentation explaining
    its **safety preconditions**: under what circumstances it''s safe to execute its
    `unsafe` block. You can find the ones for `UnsafeCell` [in `std`''s documentation](https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `unsafe` 函数时，都会有文档解释其**安全前提条件**：在什么情况下执行其 `unsafe` 块是安全的。你可以在 `std` 的文档中找到
    `UnsafeCell` 的那些[文档](https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html)。
- en: We won't be using `UnsafeCell` directly in this course, nor will we be writing
    `unsafe` code. But it's important to know that it's there, why it exists and how
    it relates to the types you use every day in Rust.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，我们不会直接使用`UnsafeCell`，也不会编写`unsafe`代码。但了解它的存在、为什么存在以及它与你在Rust中每天使用的类型之间的关系是很重要的。
- en: '[Key examples](#key-examples)'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[关键示例](#key-examples)'
- en: Let's go through a couple of important `std` types that leverage interior mutability.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个利用内部可变性的重要`std`类型。
- en: These are types that you'll encounter somewhat often in Rust code, especially
    if you peek under the hood of some the libraries you use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在Rust代码中你会经常遇到的类型，特别是如果你查看你使用的某些库的内部结构。
- en: '[Reference counting](#reference-counting)'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[引用计数](#reference-counting)'
- en: '`Rc` is a reference-counted pointer.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc`是一个引用计数的指针。'
- en: It wraps around a value and keeps track of how many references to the value
    exist. When the last reference is dropped, the value is deallocated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它围绕一个值进行包装，并跟踪有多少引用指向该值。当最后一个引用被丢弃时，该值将被释放。
- en: 'The value wrapped in an `Rc` is immutable: you can only get shared references
    to it.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 包装在`Rc`中的值是不可变的：你只能获取对其的共享引用。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Rc` uses `UnsafeCell` internally to allow shared references to increment and
    decrement the reference count.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc`在内部使用`UnsafeCell`来允许共享引用增加和减少引用计数。'
- en: '[`RefCell`](#refcell)'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`RefCell`](#refcell)'
- en: '`RefCell` is one of the most common examples of interior mutability in Rust.
    It allows you to mutate the value wrapped in a `RefCell` even if you only have
    an immutable reference to the `RefCell` itself.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`RefCell`是Rust中内部可变性的最常见例子之一。它允许你在只有对`RefCell`本身的不可变引用的情况下，修改`RefCell`中包裹的值。'
- en: This is done via **runtime borrow checking**. The `RefCell` keeps track of the
    number (and type) of references to the value it contains at runtime. If you try
    to borrow the value mutably while it's already borrowed immutably, the program
    will panic, ensuring that Rust's borrowing rules are always enforced.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过**运行时借用检查**来实现的。`RefCell`在运行时跟踪其包含的值的引用数量（和类型）。如果你在值已被不可变借用时尝试可变借用该值，程序将引发恐慌，确保Rust的借用规则始终得到执行。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Exercise](#exercise)'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`07_threads/06_interior_mutability`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`07_threads/06_interior_mutability`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability)

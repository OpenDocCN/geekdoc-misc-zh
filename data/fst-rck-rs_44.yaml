- en: Non-scoped Threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非作用域线程
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/non-scoped_threads.html](https://freddiehaddad.github.io/fast-track-to-rust/non-scoped_threads.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/non-scoped_threads.html](https://freddiehaddad.github.io/fast-track-to-rust/non-scoped_threads.html)
- en: The simplest way to enable multithreading support in our rustle program is to
    spawn a thread for each specified file, perform the pattern matching steps we've
    developed, and print the results using a fork/join pattern. If you have a C++
    background, you might start by exploring the functions in the [thread](https://doc.rust-lang.org/std/thread/)
    module, discovering the [spawn](https://doc.rust-lang.org/stable/std/thread/fn.spawn.html)
    function, and diving right in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 rustle 程序中启用多线程支持的最简单方法是为每个指定的文件启动一个线程，执行我们开发的模式匹配步骤，并使用 fork/join 模式打印结果。如果你有
    C++ 背景，你可能首先从探索 [thread](https://doc.rust-lang.org/std/thread/) 模块中的函数开始，发现 [spawn](https://doc.rust-lang.org/stable/std/thread/fn.spawn.html)
    函数，然后直接深入。
- en: However, this approach is flawed! While it might be a valuable learning experience,
    it will likely be time-consuming, frustrating, and confusing. Let's examine some
    of the pitfalls of this approach and then explore a more effective solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法是有缺陷的！虽然这可能是一个有价值的学习经验，但它可能会很耗时、令人沮丧且令人困惑。让我们来探讨一下这种方法的一些陷阱，然后探索一个更有效的解决方案。
- en: '[The `spawn` Function](#the-spawn-function)'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`spawn` 函数](#the-spawn-function)'
- en: 'Here''s the signature for the `spawn` function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `spawn` 函数的签名：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `spawn` function takes a closure (`f`) as an argument, spawns a new thread
    to run the closure, and returns a [`JoinHandle`](https://doc.rust-lang.org/stable/std/thread/struct.JoinHandle.html).
    As the name suggests, the `JoinHandle` provides a [`join`](https://doc.rust-lang.org/stable/std/thread/struct.JoinHandle.html#method.join)
    method to wait for the spawned thread to finish. So far, so good. However, the
    `'static`^([1](#footnote-1)) constraint on `F` and the return value `T` is where,
    as the Bard would say, lies the rub.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn` 函数接受一个闭包（`f`）作为参数，为运行闭包启动一个新线程，并返回一个 `JoinHandle`。正如其名所示，`JoinHandle`
    提供了一个 `join` 方法来等待派生线程完成。到目前为止，一切顺利。然而，`F` 和返回值 `T` 上的 `''static`^([1](#footnote-1))
    约束，正如诗人所说，是问题的关键所在。'
- en: The `'static` constraint requires that the closure and its return value must
    live for the entire duration of the program's execution. This is necessary because
    threads can outlive the context in which they were created.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`''static` 约束要求闭包及其返回值必须在整个程序执行期间存活。这是必要的，因为线程可能会比创建它们的上下文存活得更久。'
- en: If a thread, and by extension its return value, can outlive its caller, we need
    to ensure they remain valid afterward. Since we *can't* predict when the thread
    will finish, they must be valid until the end of the program. Hence, the `'static`
    lifetime.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程及其返回值可以比调用者存活得更久，我们需要确保它们在之后仍然有效。由于我们 *无法* 预测线程何时完成，它们必须一直有效到程序结束。因此，需要
    `'static` 生命周期。
- en: Don't worry if this concept is still unclear; it's one of the most challenging
    aspects of Rust, and many developers find it difficult at first.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这个概念仍然不清楚，不要担心；这是 Rust 中最具挑战性的方面之一，许多开发者一开始都发现很难理解。
- en: Let's examine a simple program to better understand these concepts. Review the
    following code snippet and then run the program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的程序来更好地理解这些概念。审查以下代码片段，然后运行程序。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This simple program seems perfectly valid. So why does the Rust compiler complain
    about code that would run without issues in most other languages? Even though
    it''s not the case in this example, in a more general sense, the spawned thread
    created in `main` could potentially outlive the thread from which it was created.
    Because the closure borrows the `error` value, the parent thread could go out
    of scope, causing the `error` value to be dropped rendering the reference invalid.
    Because the compiler *can''t* know whether or not that''s going to happen, we
    see the error:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序看起来完全有效。那么为什么 Rust 编译器会抱怨那些在其他大多数语言中运行无问题的代码？即使在这个例子中不是这样，从更一般的角度来看，`main`
    中创建的派生线程可能会比创建它的线程存活得更久。因为闭包借用了 `error` 值，父线程可能会超出作用域，导致 `error` 值被丢弃，使引用无效。因为编译器
    *无法* 知道这会不会发生，所以我们看到了错误：
- en: 'error[E0373](https://doc.rust-lang.org/stable/error_codes/E0373.html): closure
    may outlive the current function, but it borrows `error`, which is owned by the
    current function'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'error[E0373](https://doc.rust-lang.org/stable/error_codes/E0373.html): 闭包可能超出当前函数的生命周期，但它借用
    `error`，而 `error` 是当前函数所拥有的'
- en: 'The compiler does offer a solution that may work under some circumstances:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器确实提供了一个在某些情况下可能有效的解决方案：
- en: 'help: to force the closure to take ownership of `error` (and any other referenced
    variables), use the [`move`](https://doc.rust-lang.org/std/keyword.move.html)
    ^([2](#footnote-2)) keyword'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'help: 要强制闭包获取 `error`（以及任何其他引用的变量）的所有权，请使用 `[`move`](https://doc.rust-lang.org/std/keyword.move.html)
    ^([2](#footnote-2)) 关键字'
- en: 'Let''s see what happens if we do that:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这样做会发生什么：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Recalling our discussion on *copy semantics*, it probably makes sense why this
    worked. The value was *copied* into the scope of the spawned thread, making it
    independent from the original and solving the lifetime problem. The variable is
    now guaranteed to live for as long as the thread. This works fine for primitive
    types and types implementing the `Copy` trait. But what if copying is an expensive
    operation, or the object can''t be copied? This leads to the next challenge that
    developers learning Rust often face: what happens if we need to spawn additional
    threads that also need access to the same variable?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们关于 *拷贝语义* 的讨论，这可能就是为什么它有效的原因。值被 *拷贝* 到新线程的作用域中，使其独立于原始值并解决了生命周期问题。变量现在保证与线程的寿命相同。这对于原始类型和实现了
    `Copy` 特质的类型来说工作得很好。但如果拷贝是一个昂贵的操作，或者对象不能被拷贝怎么办？这导致开发者学习 Rust 时经常面临的下一个挑战：如果我们需要启动额外的线程，而这些线程也需要访问相同的变量，会发生什么？
- en: 'For example, consider this case:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下情况：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While these strict rules may seem daunting, especially in larger programs, they
    are the foundation of Rust's [fearless concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html#fearless-concurrency)
    goals. These rules ensure that concurrency in your programs is both safe and efficient.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些严格的规则可能看起来令人畏惧，尤其是在较大的程序中，但它们是 Rust 的 [无惧并发](https://doc.rust-lang.org/book/ch16-00-concurrency.html#fearless-concurrency)
    目标的基础。这些规则确保了程序中的并发既安全又高效。
- en: Now that we understand why the traditional fork/join model, which works in many
    other languages, is likely to fail in Rust, let's explore how to correctly implement
    this approach!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了为什么在许多其他语言中工作得很好的传统 fork/join 模型在 Rust 中很可能会失败，让我们来探讨如何正确实现这种方法！
- en: '* * *'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Lifetimes are another type of generic. However, instead of ensuring that a type
    has the desired behavior, they ensure that references remain valid for the desired
    duration. [↩](#fr-1-1)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生命周期是另一种泛型。然而，它们不是确保类型具有期望的行为，而是确保引用在期望的持续时间内保持有效。 [↩](#fr-1-1)
- en: '`move` converts any variables captured by reference or mutable reference to
    variables captured by value. [↩](#fr-2-1)'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`move` 将任何通过引用或可变引用捕获的变量转换为通过值捕获的变量。 [↩](#fr-2-1)'

- en: Derive macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导宏
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/04_derive.html](https://rust-exercises.com/100-exercises/04_traits/04_derive.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/04_traits/04_derive.html](https://rust-exercises.com/100-exercises/04_traits/04_derive.html)
- en: Implementing `PartialEq` for `Ticket` was a bit tedious, wasn't it? You had
    to manually compare each field of the struct.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Ticket`的`PartialEq`有点繁琐，不是吗？你必须手动比较结构体的每个字段。
- en: '[Destructuring syntax](#destructuring-syntax)'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[解构语法](#destructuring-syntax)'
- en: 'Furthermore, the implementation is brittle: if the struct definition changes
    (e.g. a new field is added), you have to remember to update the `PartialEq` implementation.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实现是脆弱的：如果结构体定义发生变化（例如添加了新字段），你必须记得更新`PartialEq`的实现。
- en: 'You can mitigate the risk by **destructuring** the struct into its fields:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将结构体解构为其字段来降低风险：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the definition of `Ticket` changes, the compiler will error out, complaining
    that your destructuring is no longer exhaustive.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Ticket`的定义发生变化，编译器将报错，抱怨你的解构不再详尽。
- en: 'You can also rename struct fields, to avoid variable shadowing:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以重命名结构体字段，以避免变量遮蔽：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Destructuring is a useful pattern to have in your toolkit, but there''s an
    even more convenient way to do this: **derive macros**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是工具箱中的一个有用模式，但还有更方便的方法来做这件事：**推导宏**。
- en: '[Macros](#macros)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[宏](#macros)'
- en: 'You''ve already encountered a few macros in past exercises:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在过去的练习中遇到了几个宏：
- en: '`assert_eq!` and `assert!`, in the test cases'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_eq!`和`assert!`，在测试用例中'
- en: '`println!`, to print to the console'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`println!`，用于打印到控制台'
- en: Rust macros are **code generators**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust宏是**代码生成器**。
- en: They generate new Rust code based on the input you provide, and that generated
    code is then compiled alongside the rest of your program. Some macros are built
    into Rust's standard library, but you can also write your own. We won't be creating
    our own macro in this course, but you can find some useful pointers in the ["Further
    reading" section](#further-reading).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它们根据你提供的输入生成新的Rust代码，然后该生成的代码将与你的程序的其他部分一起编译。一些宏是内置在Rust的标准库中的，但你也可以编写自己的宏。我们不会在本课程中创建自己的宏，但你可以在["进一步阅读"部分](#further-reading)中找到一些有用的提示。
- en: '[Inspection](#inspection)'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[检查](#inspection)'
- en: Some IDEs let you expand a macro to inspect the generated code. If that's not
    possible, you can use [`cargo-expand`](https://github.com/dtolnay/cargo-expand).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IDE允许你展开宏来检查生成的代码。如果不行，你可以使用`cargo-expand`。
- en: '[Derive macros](#derive-macros-1)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[推导宏](#derive-macros-1)'
- en: A **derive macro** is a particular flavour of Rust macro. It is specified as
    an **attribute** on top of a struct.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**推导宏**是Rust宏的一种特定类型。它被指定为结构体顶部的**属性**。'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Derive macros are used to automate the implementation of common (and "obvious")
    traits for custom types. In the example above, the `PartialEq` trait is automatically
    implemented for `Ticket`. If you expand the macro, you''ll see that the generated
    code is functionally equivalent to the one you wrote manually, although a bit
    more cumbersome to read:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 推导宏用于自动为自定义类型实现常见（且“明显”）的特质。在上面的例子中，`PartialEq`特质自动应用于`Ticket`。如果你展开宏，你会看到生成的代码在功能上等同于你手动编写的代码，尽管阅读起来稍微有些繁琐：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The compiler will nudge you to derive traits when possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会建议你在可能的情况下推导特质。
- en: '[Further reading](#further-reading)'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading)'
- en: '[The little book of Rust macros](https://veykril.github.io/tlborm/)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rust宏小书](https://veykril.github.io/tlborm/)'
- en: '[Proc macro workshop](https://github.com/dtolnay/proc-macro-workshop)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[进程宏研讨会](https://github.com/dtolnay/proc-macro-workshop)'
- en: '[Exercise](#exercise)'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`04_traits/04_derive`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于[`04_traits/04_derive`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive)

- en: impl Trait
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: impl Trait
- en: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/08_impl_trait.html](https://rust-exercises.com/100-exercises/06_ticket_management/08_impl_trait.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/08_impl_trait.html](https://rust-exercises.com/100-exercises/06_ticket_management/08_impl_trait.html)
- en: '`TicketStore::to_dos` returns a `Vec<&Ticket>`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`TicketStore::to_dos` 返回一个 `Vec<&Ticket>`。'
- en: That signature introduces a new heap allocation every time `to_dos` is called,
    which may be unnecessary depending on what the caller needs to do with the result.
    It'd be better if `to_dos` returned an iterator instead of a `Vec`, thus empowering
    the caller to decide whether to collect the results into a `Vec` or just iterate
    over them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名在每次调用 `to_dos` 时都会引入一个新的堆分配，这可能是不必要的，取决于调用者需要用结果做什么。如果 `to_dos` 返回一个迭代器而不是
    `Vec`，那就更好了，这样调用者就可以决定是将结果收集到一个 `Vec` 中，还是只是迭代它们。
- en: That's tricky though! What's the return type of `to_dos`, as implemented below?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这很棘手！下面实现的 `to_dos` 的返回类型是什么？
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Unnameable types](#unnameable-types)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[不可命名类型](#unnameable-types)'
- en: 'The `filter` method returns an instance of `std::iter::Filter`, which has the
    following definition:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 方法返回一个 `std::iter::Filter` 的实例，其定义如下：'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: where `I` is the type of the iterator being filtered on and `P` is the predicate
    used to filter the elements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `I` 是正在过滤的迭代器的类型，而 `P` 是用于过滤元素的谓词。
- en: We know that `I` is `std::slice::Iter<'_, Ticket>` in this case, but what about
    `P`?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在这种情况下 `I` 是 `std::slice::Iter<'_, Ticket>`，但 `P` 呢？
- en: '`P` is a closure, an **anonymous function**. As the name suggests, closures
    don''t have a name, so we can''t write them down in our code.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`P` 是一个闭包，一个 **匿名函数**。正如其名所示，闭包没有名称，所以我们不能在代码中将其写下来。'
- en: 'Rust has a solution for this: **impl Trait**.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有一个解决方案：**impl Trait**。
- en: '[`impl Trait`](#impl-trait-1)'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`impl Trait`](#impl-trait-1)'
- en: '`impl Trait` is a feature that allows you to return a type without specifying
    its name. You just declare what trait(s) the type implements, and Rust figures
    out the rest.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl Trait` 是一个允许你返回一个类型而不指定其名称的特性。你只需声明该类型实现了哪些特质，Rust 就会自动推断其余部分。'
- en: 'In this case, we want to return an iterator of references to `Ticket`s:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要返回一个指向 `Ticket` 的引用迭代器：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's it!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: '[Generic?](#generic)'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[泛型？](#generic)'
- en: '`impl Trait` in return position is **not** a generic parameter.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 返回位置上的 `impl Trait` **不是**一个泛型参数。
- en: 'Generics are placeholders for types that are filled in by the caller of the
    function. A function with a generic parameter is **polymorphic**: it can be called
    with different types, and the compiler will generate a different implementation
    for each type.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是用于类型的占位符，这些类型由函数的调用者填充。具有泛型参数的函数是 **多态的**：它可以使用不同的类型调用，编译器将为每种类型生成不同的实现。
- en: 'That''s not the case with `impl Trait`. The return type of a function with
    `impl Trait` is **fixed** at compile time, and the compiler will generate a single
    implementation for it. This is why `impl Trait` is also called **opaque return
    type**: the caller doesn''t know the exact type of the return value, only that
    it implements the specified trait(s). But the compiler knows the exact type, there
    is no polymorphism involved.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `impl Trait` 来说情况并非如此。具有 `impl Trait` 的函数的返回类型在编译时是 **固定的**，编译器将为其生成单个实现。这就是为什么
    `impl Trait` 也被称为 **不可见返回类型**：调用者不知道返回值的确切类型，只知道它实现了指定的特质（s）。但是编译器知道确切的类型，没有涉及多态。
- en: '[RPIT](#rpit)'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[RPIT](#rpit)'
- en: If you read RFCs or deep-dives about Rust, you might come across the acronym
    **RPIT**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了关于 Rust 的 RFC 或深入研究，你可能会遇到缩写 **RPIT**。
- en: It stands for **"Return Position Impl Trait"** and refers to the use of `impl
    Trait` in return position.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表 **"Return Position Impl Trait"**，指的是在返回位置使用 `impl Trait`。
- en: '[Exercise](#exercise)'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`06_ticket_management/08_impl_trait`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/08_impl_trait)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于 `06_ticket_management/08_impl_trait` 中（[https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/08_impl_trait](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/08_impl_trait)）

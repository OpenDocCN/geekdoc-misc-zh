- en: Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/01_arrays.html](https://rust-exercises.com/100-exercises/06_ticket_management/01_arrays.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/01_arrays.html](https://rust-exercises.com/100-exercises/06_ticket_management/01_arrays.html)
- en: 'As soon as we start talking about "ticket management" we need to think about
    a way to store *multiple* tickets. In turn, this means we need to think about
    collections. In particular, homogeneous collections: we want to store multiple
    instances of the same type.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始谈论“票务管理”，我们就需要考虑一种存储 *多个* 票的方法。反过来，这意味着我们需要考虑集合。特别是同质集合：我们希望存储同一类型的多个实例。
- en: What does Rust have to offer in this regard?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在这方面能提供什么？
- en: '[Arrays](#arrays-1)'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[数组](#arrays-1)'
- en: A first attempt could be to use an **array**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试可能会使用 **数组**。
- en: Arrays in Rust are fixed-size collections of elements of the same type.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的数组是相同类型元素的固定大小集合。
- en: 'Here''s how you can define an array:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你定义数组的方法：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This creates an array of 3 integers, initialized with the values `1`, `2`, and
    `3`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含 3 个整数的数组，并初始化为值 `1`、`2` 和 `3`。
- en: The type of the array is `[u32; 3]`, which reads as "an array of `u32`s with
    a length of 3".
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型是 `[u32; 3]`，读作“长度为 3 的 `u32` 数组”。
- en: 'If all array elements are the same, you can use a shorter syntax to initialize
    it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有数组元素都相同，你可以使用更短的语法来初始化它：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`[1; 3]` creates an array of three elements, all equal to `1`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1; 3]` 创建了一个包含三个元素且所有元素都等于 `1` 的数组。'
- en: '[Accessing elements](#accessing-elements)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[访问元素](#accessing-elements)'
- en: 'You can access elements of an array using square brackets:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号访问数组的元素：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The index must be of type `usize`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 索引必须是 `usize` 类型。
- en: Arrays are **zero-indexed**, like everything in Rust. You've seen this before
    with string slices and field indexing in tuples/tuple-like variants.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 **零索引** 的，就像 Rust 中的所有东西一样。你之前在字符串切片和元组的字段索引中见过。
- en: '[Out-of-bounds access](#out-of-bounds-access)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[越界访问](#out-of-bounds-access)'
- en: 'If you try to access an element that''s out of bounds, Rust will panic:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问超出边界的元素，Rust 将会引发恐慌：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is enforced at runtime using **bounds checking**. It comes with a small
    performance overhead, but it's how Rust prevents buffer overflows.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这在运行时通过 **边界检查** 来强制执行。它带来了一些性能开销，但这是 Rust 防止缓冲区溢出的方法。
- en: In some scenarios the Rust compiler can optimize away bounds checks, especially
    if iterators are involved—we'll speak more about this later on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，Rust 编译器可以优化掉边界检查，特别是如果涉及到迭代器时——我们稍后会更多地讨论这一点。
- en: 'If you don''t want to panic, you can use the `get` method, which returns an
    `Option<&T>`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望引发恐慌，可以使用 `get` 方法，它返回一个 `Option<&T>`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Performance](#performance)'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[性能](#performance)'
- en: 'Since the size of an array is known at compile-time, the compiler can allocate
    the array on the stack. If you run the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组的大小在编译时已知，编译器可以在栈上分配数组。如果你运行以下代码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You''ll get the following memory layout:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下内存布局：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In other words, the size of an array is `std::mem::size_of::<T>() * N`, where
    `T` is the type of the elements and `N` is the number of elements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，数组的大小是 `std::mem::size_of::<T>() * N`，其中 `T` 是元素类型，`N` 是元素数量。
- en: You can access and replace each element in `O(1)` time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `O(1)` 时间内访问和替换每个元素。
- en: '[Exercise](#exercise)'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`06_ticket_management/01_arrays`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/01_arrays)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于 `06_ticket_management/01_arrays` 中，请参阅[此处](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/01_arrays)。

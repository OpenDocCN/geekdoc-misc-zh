- en: Don't block the runtime
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要阻塞运行时
- en: 原文：[https://rust-exercises.com/100-exercises/08_futures/05_blocking.html](https://rust-exercises.com/100-exercises/08_futures/05_blocking.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/08_futures/05_blocking.html](https://rust-exercises.com/100-exercises/08_futures/05_blocking.html)
- en: Let's circle back to yield points.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到释放点。
- en: Unlike threads, **Rust tasks cannot be preempted**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程不同，**Rust任务不能被抢占**。
- en: '`tokio` cannot, on its own, decide to pause a task and run another one in its
    place. The control goes back to the executor **exclusively** when the task yields—i.e.
    when `Future::poll` returns `Poll::Pending` or, in the case of `async fn`, when
    you `.await` a future.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokio`本身无法决定暂停一个任务并运行另一个任务来替代它。当任务释放资源时——即`Future::poll`返回`Poll::Pending`，或者在`async
    fn`的情况下，当你`.await`一个未来时——控制权才会完全回到执行器。'
- en: 'This exposes the runtime to a risk: if a task never yields, the runtime will
    never be able to run another task. This is called **blocking the runtime**.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得运行时面临风险：如果一个任务从不释放资源，运行时将永远无法运行另一个任务。这被称为**阻塞运行时**。
- en: '[What is blocking?](#what-is-blocking)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[什么是阻塞？](#what-is-blocking)'
- en: How long is too long? How much time can a task spend without yielding before
    it becomes a problem?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 多长时间算太长？一个任务在没有释放资源之前可以花费多少时间才成为问题？
- en: It depends on the runtime, the application, the number of in-flight tasks, and
    many other factors. But, as a general rule of thumb, try to spend less than 100
    microseconds between yield points.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '这取决于运行时、应用程序、正在执行的任务数量以及许多其他因素。但作为一个一般规则，尽量在释放点之间花费少于100微秒。 '
- en: '[Consequences](#consequences)'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[后果](#consequences)'
- en: 'Blocking the runtime can lead to:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞运行时可能导致：
- en: '**Deadlocks**: if the task that''s not yielding is waiting for another task
    to complete, and that task is waiting for the first one to yield, you have a deadlock.
    No progress can be made, unless the runtime is able to schedule the other task
    on a different thread.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**：如果一个任务没有释放资源，却在等待另一个任务完成，而那个任务又在等待第一个任务释放资源，那么你就遇到了死锁。除非运行时能够将其他任务调度到不同的线程上，否则无法取得任何进展。'
- en: '**Starvation**: other tasks might not be able to run, or might run after a
    long delay, which can lead to poor performances (e.g. high tail latencies).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**饥饿**：其他任务可能无法运行，或者可能经过长时间的延迟后才能运行，这可能导致性能下降（例如，高尾部延迟）。'
- en: '[Blocking is not always obvious](#blocking-is-not-always-obvious)'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[阻塞并不总是显而易见](#blocking-is-not-always-obvious)'
- en: 'Some types of operations should generally be avoided in async code, like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步代码中，一些类型的操作通常应该避免，例如：
- en: Synchronous I/O. You can't predict how long it will take, and it's likely to
    be longer than 100 microseconds.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步I/O。你无法预测它将花费多长时间，而且它很可能超过100微秒。
- en: Expensive CPU-bound computations.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耗时的CPU密集型计算。
- en: The latter category is not always obvious though. For example, sorting a vector
    with a few elements is not a problem; that evaluation changes if the vector has
    billions of entries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 后者类别并不总是显而易见。例如，对包含少量元素的向量进行排序不是问题；但如果向量有数十亿条记录，情况就不同了。
- en: '[How to avoid blocking](#how-to-avoid-blocking)'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[如何避免阻塞](#how-to-avoid-blocking)'
- en: OK, so how do you avoid blocking the runtime assuming you *must* perform an
    operation that qualifies or risks qualifying as blocking?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么在必须执行一个可能或风险成为阻塞的操作的情况下，你如何避免阻塞运行时？
- en: You need to move the work to a different thread. You don't want to use the so-called
    runtime threads, the ones used by `tokio` to run tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将工作移动到不同的线程。你不想使用所谓的运行时线程，即`tokio`用来运行任务的那些线程。
- en: '`tokio` provides a dedicated threadpool for this purpose, called the **blocking
    pool**. You can spawn a synchronous operation on the blocking pool using the `tokio::task::spawn_blocking`
    function. `spawn_blocking` returns a future that resolves to the result of the
    operation when it completes.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokio`为此提供了一个专门的线程池，称为**阻塞池**。你可以使用`tokio::task::spawn_blocking`函数在阻塞池上启动一个同步操作。`spawn_blocking`返回一个在操作完成时解析为操作结果的未来。'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The blocking pool is long-lived. `spawn_blocking` should be faster than creating
    a new thread directly via `std::thread::spawn` because the cost of thread initialization
    is amortized over multiple calls.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞池是长期存在的。`spawn_blocking`应该比直接通过`std::thread::spawn`创建新线程更快，因为线程初始化的成本被分摊到多次调用中。
- en: '[Further reading](#further-reading)'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading)'
- en: Check out [Alice Ryhl's blog post](https://ryhl.io/blog/async-what-is-blocking/)
    on the topic.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Alice Ryhl关于这个主题的博客文章[（https://ryhl.io/blog/async-what-is-blocking/）](https://ryhl.io/blog/async-what-is-blocking/)。
- en: '[Exercise](#exercise)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`08_futures/05_blocking`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/05_blocking)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于[`08_futures/05_blocking`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/05_blocking)

- en: Extending the Representation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展表示
- en: Therefore, let’s think about what it takes to evaluate functions-as-values to
    SMoL. We don’t need functions to inherently have a name, because naming can be
    done by `let1`.  We’ll assume, for simplicity, that all functions take only one
    argument; extending this to multiple arguments is left as an exercise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们思考一下评估函数作为值到SMoL需要什么。我们不需要函数本质上有一个名称，因为命名可以通过 `let1` 完成。为了简单起见，我们假设所有函数只接受一个参数；将其扩展到多个参数留作练习。
- en: Exercise: What issues might we have to deal with when we extend functions from
    having one argument only to having multiple arguments?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：当我们从只有一个参数的函数扩展到多个参数的函数时，我们可能需要处理哪些问题？
- en: First, we need to extend our abstract syntax.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要扩展我们的抽象语法。
- en: Do Now: How many new constructs do we need to add to the abstract syntax?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做：我们需要添加多少新构造到抽象语法中？
- en: 'When we added `let1`, you may recall that it didn’t suffice to add one construct;
    we needed two: one for variable bindingand one for variable use. You’ll often
    see this pattern when adding values to the language. For any new kind of value,
     you can expect to see one or more ways to makeit and one or more ways to use it.
    (Even arithmetic: numeric constants were a way to make them, arithmetic operations
    consumed them—but also made them.)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加 `let1` 时，你可能还记得，仅仅添加一个构造是不够的；我们需要两个：一个用于变量绑定，一个用于变量使用。当你向语言添加值时，你经常会看到这种模式。对于任何新的值类型，你都可以期待看到一种或多种创建它的方法，以及一种或多种使用它的方法。（甚至算术：数字常量是创建它们的一种方式，算术运算消耗了它们——但也创造了它们。）
- en: Likewise with functions, we need a way to represent both
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于函数，我们需要一种方式来表示两种
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: for defining new functions, and
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义新函数，并且
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: to use them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们。
- en: 'Terminology:In more advanced texts, you will sometimes see the (formally correct,
    but perhaps slightly confusing) terms introductionand elimination: introduction
    brings the new concept in, elimination uses them. Thus, the `lam` introduces new
    functions, and an application eliminates them.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：在更高级的文本中，你有时会看到（形式上正确，但可能有些令人困惑）的术语引入和消除：引入将新概念引入，消除使用它们。因此，`lam` 引入新函数，而应用消除它们。
- en: We therefore add
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们添加
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: to our AST.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到我们的AST。
- en: 'Let’s assume we’ve already extended our parser, so that programs like the following
    are legal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经扩展了我们的解析器，因此以下程序是合法的：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These parse, respectively, into
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分别解析为
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and should both evaluate to `6`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都应该评估为 `6`。
- en: Evaluating Functions
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估函数
- en: Now let’s think about the evaluator, which by now we can think of as turning
    into a full-blown interpreter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑评估器，到现在我们可以将其视为成为一个完整的解释器。
- en: 'Let’s start with the (almost) simplest kind of new program:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从（几乎）最简单的新程序类型开始：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: which is represented as
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它被表示为
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do Now: What do we want this program to evaluate to? Think in terms of types!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做：我们希望这个程序评估为什么？从类型的角度思考！
- en: Remember that `calc`produces numbers. What numberdoes the above expression evaluate
    to? What number do you expect it to produce?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `calc` 产生数字。上述表达式评估为多少数字？你期望它产生多少数字？
- en: 'If we really want to stretch our credibility, we could either make up an encoding
    of it in a number, or use a number in memory. But neither of these is what we
    would expect! Let’s look at what some other languages do:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想提高我们的可信度，我们可以在数字中编解码它，或者使用内存中的数字。但这两种都不是我们预期的！让我们看看其他语言是如何做的：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both Racket and Python agree: the result of creating an anonymous function
    is a function-kind of value, not a number. What this says is that we have to broaden
    the kinds of values that `interp` can produce.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 和 Python 都同意：创建匿名函数的结果是函数类型的值，而不是数字。这意味着我们必须扩大 `interp` 可以产生值的类型。
- en: 'Terminology: A side-effect is a change to the system that is visible from outside
    the body of a function. Typical side-effects are modifications to variables that
    are defined outside the function, communication with a network, changes to files,
    and so on.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：副作用是指从函数体外部可见的系统变化。典型的副作用包括对函数外部定义的变量的修改、与网络的通信、文件更改等。
- en: 'Terminology:A function is pureif, for a given input, it always produces the
    same output, and has no side-effects. In reality, a computation always has some side-effects,
    such as the consumption of energy and production of heat, but we usually overlook
    these because they are universal. In a few settings, however, they can matter:
    e.g., if a cryptographic key can be stolen by measuring these side-effects.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：一个函数是纯函数，如果对于给定的输入，它总是产生相同的输出，并且没有副作用。在现实中，计算总是有一些副作用，比如能量的消耗和热量的产生，但我们通常忽略这些，因为它们是普遍存在的。然而，在少数情况下，它们可能很重要：例如，如果可以通过测量这些副作用来窃取加密密钥。
- en: Terminology:Traditionally, some languages have used the terms procedureand function for
    similar but not identical concepts. Both are function-like entities that encapsulate
    a body of code and can be applied (or “called”). A procedure is an encapsulation
    that does not produce a value; therefore, it must have side-effects to be of any
    use. In contrast, a function always produces a value (and may be expected to not
    have any side-effects). This terminology has gotten completely scrambled over
    the years and people now use the terms interchangeably, but if someone seems to
    be making a distinction between the two, they probably mean something like the
    above.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：传统上，一些语言已经使用了“过程”和“函数”这两个术语来表示类似但不完全相同的概念。两者都是类似于函数的实体，封装了一组代码，并且可以被应用（或“调用”）。过程是一个不产生值的封装；因此，它必须具有副作用才有任何用处。相比之下，函数总是产生一个值（并且可能期望没有副作用）。这个术语在多年中已经完全混乱，现在人们可以互换使用这些术语，但如果有人似乎在两者之间做出区分，他们可能意味着类似于上述内容。
- en: Extending Values
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展值
- en: What happens when evaluating a function? Both Racket and Python seem to suggest
    that we return a function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估一个函数时会发生什么？Racket 和 Python 似乎都表明我们会返回一个函数。
- en: 'We could have no additional information about the function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能没有关于函数的额外信息：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '(That syntax means `funV`is a constructor of no parameters. It conveys no information
    at all other than the fact that it’s a `funV`; because we can’t mix types, it
    says, in particular, that a value is not numeric or a Boolean—and nothing more.)
    But now think about a program like this (assuming `x` is bound):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: （这种语法意味着 `funV` 是一个无参数的构造函数。它传达的信息仅限于它是一个 `funV`；因为我们不能混合类型，所以它特别说明一个值既不是数值也不是布尔值——仅此而已。）但现在想想这样的程序（假设
    `x` 已绑定）：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In both cases we’re going to get a `funV` value with no additional information,
    so when we try to perform the application, we…can’t.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都会得到一个没有任何额外信息的 `funV` 值，所以当我们尝试执行应用时，我们……不能。
- en: Instead, it’s clear that the function value needs to tell us about the function.
    We need to know the body, because that’s what we need to evaluate; but the body
    can (and very likely does) reference the name of the formal parameter, so we need
    that too. Therefore, what we really need is
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 而实际上，函数值需要告诉我们关于函数的信息。我们需要知道主体，因为那是我们需要评估的；但主体可以（并且很可能）引用形式参数的名称，因此我们也需要那个。因此，我们真正需要的是
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, it seems like we’ve gone to a lot of trouble for nothing. We
    take numeric and Boolean values and simply re-wrap them in new constructors, and
    now we’re doing the same thing for functions.  A certain Shakespeareian play’s
    title comes to mind.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们似乎白费了很大力气。我们取了数值和布尔值，只是简单地用新的构造函数重新包装它们，现在我们又为函数做了同样的事情。某个莎士比亚戏剧的标题浮现在我的脑海中。
- en: Patience.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 耐心。
- en: 'With what we have, we can already have a functioning interpreter. The lam case
    is obviously very simple:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们所拥有的，我们已经有了一个功能性的解释器。lam 情况显然非常简单：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The application case is a bit more detailed. We need to:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用案例稍微详细一些。我们需要：
- en: Evaluate the function position, to figure out what kind of value it is.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估函数位置，以确定它的值类型。
- en: Evaluate the argument position, since we’ve agreed that’s what happens in SMoL.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估论证位置，因为我们已经同意在 SMoL 中会发生这种情况。
- en: Check that the function position really does evaluate to a function. If it does
    not, raise an error.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查函数位置是否确实评估为一个函数。如果不是，则引发错误。
- en: Evaluate the body of the function. But because the body can refer to the formal
    parameter…
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估函数的主体。但由于主体可以引用形式参数…
- en: …first make sure the formal is bound to the actual value of the argument.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: …首先确保形式参数绑定到实际参数的值。
- en: 'Codifying this, in stages:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 分阶段地编纂这一点：
- en: '`[(appE f a)` (let ([fv (interp f nv)]'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(appE f a)` (let ([fv (interp f nv)])'
- en: '[av (interp a nv)])'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[av (interp a nv)])'
- en: …)`]`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: …`)]`
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: (type-case Value fv
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: （类型案例 Value fv
- en: '[(funV v b) …]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[(funV v b) …]'
- en: '[else (error ''app "didn''t get a function")]`))]`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`[else (error ''app "didn''t get a function")]`))]`'
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (interp b …)`]`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (interp b …)`]`
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`(interp b` (extend nv v av)`)]`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`(interp b (extend nv v av)`)]'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Stepping Back
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Putting it all together, we get the following interpreter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下解释器：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Exercise: We wrote down a particular ordering above, which we put into practice
    in the code. But is that the same ordering that actual languages use? In particular,
    are non-function errors reported after or before evaluating the argument? Experiment
    and find out!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：我们上面写下了一个特定的顺序，我们在代码中将其付诸实践。但这是否是实际语言使用的相同顺序？特别是，非函数错误是在评估参数之前还是之后报告的？进行实验并找出答案！
- en: Since we’ve taken several steps to get here, it’s easy to lose sight of what
    we’ve just done. In just 20 lines of code (with a few helper functions), we have
    described the implementation of a full programming language. Not only that, a
    language that can express [all computations](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Church%25E2%2580%2593Turing_thesis&sa=D&source=editors&ust=1695232021212601&usg=AOvVaw1o9iRZ1zIR7qNKrD6lFhCa).
    When Turing Award winner [Alan Kay](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Alan_Kay&sa=D&source=editors&ust=1695232021213036&usg=AOvVaw1mQ9COqfNQ40uhDQa8ed0D)first
    saw the equivalent program, [he says](https://www.google.com/url?q=https://queue.acm.org/detail.cfm?id%3D1039523&sa=D&source=editors&ust=1695232021213294&usg=AOvVaw2Jqf_V8SktzbJT9CEIRj32),
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经走了几步才到达这里，很容易忽视我们刚刚做了什么。仅仅用20行代码（和一些辅助函数），我们就描述了一个完整编程语言的实现。不仅如此，这是一个可以表达[所有计算](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Church%25E2%2580%2593Turing_thesis&sa=D&source=editors&ust=1695232021212601&usg=AOvVaw1o9iRZ1zIR7qNKrD6lFhCa)的语言。当图灵奖获得者[艾伦·凯](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Alan_Kay&sa=D&source=editors&ust=1695232021213036&usg=AOvVaw1mQ9COqfNQ40uhDQa8ed0D)第一次看到等效程序时，[他说](https://www.google.com/url?q=https://queue.acm.org/detail.cfm?id%3D1039523&sa=D&source=editors&ust=1695232021213294&usg=AOvVaw2Jqf_V8SktzbJT9CEIRj32)，
- en: Yes, that was the big revelation to me when I was in graduate school—when I
    finally understood that the half page of code on the bottom of page 13 of the
    Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!”
    This is the whole world of programming in a few lines that I can put my hand over.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是我读研究生时的大发现——当我终于理解了Lisp 1.5手册第13页底部的半页代码本身就是Lisp时。这些都是“软件的麦克斯韦方程！”这是用几行代码就能覆盖整个编程世界的全部。
- en: I realized that anytime I want to know what I’m doing, I can just write down
    the kernel of this thing in a half page and it’s not going to lose any power.
    In fact, it’s going to gain power by being able to reenter itself much more readily
    than most systems done the other way can possibly do.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到，无论何时我想知道我在做什么，我都可以写下这个事物的核心，用半页纸就足够了，而且它不会失去任何力量。事实上，它通过能够比大多数其他方式做得更轻松地重新进入自己而增强了力量。
- en: 'We’ve just rediscovered this same beautiful, powerful idea! If you want to
    see the original, here’s [that manual](https://www.google.com/url?q=https://www.softwarepreservation.org/projects/LISP/book/LISP%25201.5%2520Programmers%2520Manual.pdf&sa=D&source=editors&ust=1695232021214133&usg=AOvVaw2NEGhAo0Lj5kqCqv5LySNb) (by
    McCarthy, Abrahams, Edwards, Hart, Levin). Here it is, copied:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚重新发现了这个同样美丽、强大的想法！如果你想看到原始版本，这里是有[那份手册](https://www.google.com/url?q=https://www.softwarepreservation.org/projects/LISP/book/LISP%25201.5%2520Programmers%2520Manual.pdf&sa=D&source=editors&ust=1695232021214133&usg=AOvVaw2NEGhAo0Lj5kqCqv5LySNb)（由麦卡锡、阿布拉哈姆斯、爱德华兹、哈特、莱文编写）。以下是复制的内容：
- en: '![](image3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](image3.png)'
- en: Alright, so we now have a working interpreter for a full-fledged language. But
    before we can feel sure of that, we should try a few more examples to confirm
    that we’re happy with what we have.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们现在有一个完整的语言的运行解释器。但在我们确信这一点之前，我们应该尝试更多的例子来确认我们对所拥有的内容感到满意。
- en: Extending Tests
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展测试
- en: 'Well, actually, we shouldn’t be too happy. Consider the following examples:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，实际上，我们不应该太高兴。考虑以下例子：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What do we expect it to produce? If in doubt, we can write the same thing as
    a Racket program:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望它产生什么？如果有疑问，我们可以将其作为Racket程序写出来：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What we see is that in Racket, the inner binding of `x`does notoverride the
    outer one, the one that was present at the time the function bound to `f`was defined.
    Therefore, this produces `1` in Racket.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是，在Racket中，`x`的内层绑定不会覆盖外层绑定，即函数绑定到`f`时存在的那个。因此，在Racket中产生`1`。
- en: 'We should want this! Otherwise, consider this program:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该想要这样！否则，考虑以下程序：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This corresponds to
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: which has an unbound identifier (`x`) error. But our interpreter produces `1`instead
    of halting with an error, which leads us right back to ☠️dynamic scope ☠️!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个未绑定标识符（`x`）错误。但是我们的解释器产生了`1`而不是因为错误而停止，这直接带我们回到了☠️动态作用域☠️！
- en: Return to Static Scope
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回静态作用域
- en: 'Exercise: Run the following programs in the Stacker.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：在Stacker中运行以下程序。
- en: 'So how do we fix this? The examples above actually give us a clue, but there
    is another source of inspiration as well. Do you remember that we started with
    substitution? We’ll walk through these examples in Racket, so that you can run
    each of them directly and check that they produce the same answer. Consider again
    this program:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这个问题？上面的例子实际上给我们提供了一个线索，但还有一个灵感来源。你还记得我们是从替换开始的吗？我们将通过Racket来遍历这些例子，这样你就可以直接运行它们，并检查它们是否产生相同的答案。再次考虑这个程序：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Substituting `1`for `x` produces:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 用`1`替换`x`得到：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Substituting `f` produces:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 用`f`替换后得到：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, substituting `x`with `2`produces (note that there are no `x`s left
    in the program!):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用`2`替换`x`得到（注意程序中不再有`x`了）：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you see it this way, it’s clear whythe later binding of `x`should have
    no impact: it’s a different `x`, and the earlier `x`has effectively already been
    substituted. Since we have agreed that substitution is how we want our programs
    to work, our job now is to make sure that the environment actually implements
    that correctly.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样看待时，很明显为什么`x`的后期绑定应该没有影响：它是一个不同的`x`，而较早的`x`实际上已经被替换了。既然我们已经同意替换是我们希望程序工作的方式，那么我们现在的工作就是确保环境实际上正确地实现了这一点。
- en: 'The way to do it is to recognize that the environment represents the substitutions
    waiting to happen, and just remember them. That is, our representation of a function
    needs to also keep track of the environment at the moment of function creation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的方法是认识到环境代表了等待发生的替换，并且记住它们。也就是说，我们函数的表示需要同时跟踪函数创建时的环境：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`[funV (var : Symbol) (body : Exp)` (nv : Env)`])`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`[funV (var : Symbol) (body : Exp)` (nv : Env)`])`'
- en: 'This new and richer kind of `funV`value has a special name: it’s called a closure.
    That’s because the expression is “closed” over the environment in which it was
    defined.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的、更丰富的`funV`值有一个特殊的名称：它被称为闭包。这是因为表达式在其定义的环境中是“封闭”的。
- en: Terminology:A closedterm is one that has no unbound variables. The body of a
    function may have unbound variables—like `x`above—but the closure makes sure that
    they aren’t really unbound, because they can get their values from the stored
    environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：闭包是一个没有未绑定变量的表达式。函数的主体可能包含未绑定变量——比如上面的`x`——但是闭包确保它们实际上并不是未绑定的，因为它们可以从存储的环境中获得它们的值。
- en: Quote: “Save the environment! Create a closure today!” —[Cormac Flanagan](https://www.google.com/url?q=https://users.soe.ucsc.edu/~cormac/&sa=D&source=editors&ust=1695232021221610&usg=AOvVaw0ubwf31ENzplf9Txn7x4SS)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 引用：“拯救环境！今天创建一个闭包！” —[科马克·弗拉纳根](https://www.google.com/url?q=https://users.soe.ucsc.edu/~cormac/&sa=D&source=editors&ust=1695232021221610&usg=AOvVaw0ubwf31ENzplf9Txn7x4SS)
- en: Quote:“Lambdas are relegated to relative obscurity until Java makes them popular
    by not having them.” —James Iry, [A Brief, Incomplete, and Mostly Wrong History
    of Programming Languages](https://www.google.com/url?q=http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html&sa=D&source=editors&ust=1695232021222322&usg=AOvVaw15zUkk_RscjegRPA01Zrxb)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 引用：“Lambda函数被忽视到相对的默默无闻，直到Java通过不包含它们而使它们变得流行。” —詹姆斯·艾里，《编程语言简史：简短、不完整且大多错误》（[A
    Brief, Incomplete, and Mostly Wrong History of Programming Languages](https://www.google.com/url?q=http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html&sa=D&source=editors&ust=1695232021222322&usg=AOvVaw15zUkk_RscjegRPA01Zrxb)）
- en: 'That means, when we create a closure, we have to record the environment at
    the time of its creation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当我们创建一个闭包时，我们必须记录其创建时的环境：
- en: '`[(lamE v b) (funV v b` nv`)]`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(lamE v b) (funV v b` nv`)]`'
- en: 'Finally, when we use a function (represented by a closure), we have to make
    sure we use the storedenvironment, not the one present at the point of calling
    the function, which is the dynamic one:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们使用一个函数（由闭包表示）时，我们必须确保我们使用存储的环境，而不是调用函数点的动态环境：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`[(funV v b` nv`)`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(funV v b` nv`)`'
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Just to be clear: in the code above, the `nv`in the `funV`case intentionally
    shadowsthe `nv`bound at the top of the interpreter. Thus, the call to `extend`extends
    the environment from the closure, rather than the one present at the point of
    the call.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见：在上面的代码中，`funV`情况中的`nv`故意遮蔽了在解释器顶部绑定的`nv`。因此，`extend`调用扩展的是闭包的环境，而不是调用点的环境。
- en: Exercise: Notice that the function and argument expressions (`f`and `a`, respectively)
    are evaluated in the environment given to the interpreter, not the one inside
    the closure. Is this correct? Or should they be using the closure’s environment?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：注意，函数和参数表达式（分别称为`f`和`a`）是在解释器提供的环境中评估的，而不是在闭包内部。这是正确的吗？或者它们应该使用闭包的环境？
- en: 'You can do two things: argue from first principles or argue with examples.
    In the latter case, you would modify the interpreter to make the other choice.
    You would then use a sample input that produces different answers depending on
    which environment is used, indicate which one is correct (showing what the equivalent
    Racket program would produce can be a good argument), and use that to justify
    the chosen environment. Hint: One of these you will need to argue from first principles,
    the other you should be able to argue using a program.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做两件事：从第一性原理进行论证或用例子进行论证。在后一种情况下，你会修改解释器以做出另一种选择。然后，你会使用一个样本输入，该输入根据所使用的环境产生不同的答案，指出哪个是正确的（显示等效的Racket程序会产生什么可以是一个好的论据），并使用它来证明所选的环境。提示：其中之一你需要从第一性原理进行论证，而另一个你应该能够通过程序进行论证。
- en: A Subtle Test
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个微妙的测试
- en: 'In the examples above, we always use the closure in the scope in which it was
    defined. However, our language is actually more powerful than that: we can returna
    closure and use it outside the scope in which it was defined. Here’s a sample
    Racket program:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们总是使用在定义范围内定义的闭包。然而，我们的语言实际上比这更强大：我们可以返回一个闭包并在定义范围之外使用它。以下是一个示例Racket程序：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do Now: Take a moment to read it carefully. What should it produce?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在行动：花点时间仔细阅读它。它应该产生什么？
- en: 'First we bind the `x`, then we evaluate the lambda. This creates a closure
    that remembers the binding to `x`. This closure is the value returned by this
    expression:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们绑定`x`，然后评估lambda。这创建了一个记住`x`的绑定的闭包。这个闭包是这个表达式返回的值：
- en: '`(`(let ([x 3])'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`(`(let ([x 3])'
- en: (lambda (y) (+ x y)))
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (y) (+ x y)))
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This value is now applied to `4`. It’s legal to do this, because the value
    returned is a function. When we apply it to `4`, that evaluates the sum of `4`and
    `3`, producing `7`. Sure enough, translating this and sending it to our interpreter
    produces `7`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值现在被应用到`4`上。这样做是合法的，因为返回的值是一个函数。当我们将其应用到`4`上时，它评估了`4`和`3`的和，产生了`7`。果然，将这个翻译并发送到我们的解释器产生了`7`：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Exercise: Here’s another test to try out, written as a Racket program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：这里有一个测试程序，供你尝试，它是一个Racket程序：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What does it produce in Racket? Translate it and try it in your interpreter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Racket中它会产生什么？翻译它并在你的解释器中尝试。
- en: ••••• Syntactic Sugar •••••
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ••••• 语法糖 •••••
- en: We have now seen the essence of a small core language. In practice, programming
    languages need to also be usable. To do this, they have to provide features that
    make programming convenient. We will see they can do this while minimizing their
    effort and pain.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了一个小核心语言的本质。在实践中，编程语言还需要易于使用。为了做到这一点，它们必须提供使编程方便的特性。我们将看到它们可以在最小化努力和痛苦的同时做到这一点。
- en: How SMoL Becomes Large
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMoL如何变成大型
- en: 'We have already been introduced to the idea of SImPl, the Standard Implementation
    Plan. The core idea is that the program’s syntax is represented as abstract syntax
    using a (mutually) recursive algebraic datatype, and we then write a similar (mutually)
    recursive program to process it. What that program produces depends on the process
    we are trying to implement: an interpreter produces values, a compiler produces
    programs(in another language), a type-checker produces judgments about type-correctness (and
    more, as we’ll soon see), and so on. But they all have the same basic structure.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了SImPl（标准实现计划）的概念。核心思想是程序的语法用（相互）递归的代数数据类型表示，然后我们编写一个类似的（相互）递归程序来处理它。该程序产生的结果取决于我们试图实现的过程：解释器产生值，编译器产生程序（在另一种语言中），类型检查器产生关于类型正确性的判断（以及更多，我们很快就会看到），等等。但它们都具有相同的基本结构。
- en: 'In practice, this means that a SImPl needs to have a case to handle each of
    the constructs in the language. This is not a problem in principle, but it can
    become onerous in practice. Suppose we have two constructs that have a lot of
    repetition. Not only does it mean we have to duplicate programming, it also means
    we have to duplicate maintenance: if we fix a bug in one, we have to remember
    to fix it in the other in the corresponding way.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着SImPl需要有一个案例来处理语言中的每个构造。原则上这没问题，但在实践中可能会变得很繁琐。假设我们有两个有很多重复的构造。这不仅意味着我们必须重复编程，还意味着我们必须重复维护：如果我们在一个中修复了一个错误，我们必须记得以相应的方式在另一个中修复它。
- en: Redundancy in Languages
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言中的冗余
- en: 'Where might we find such redundancy? There are several examples in real languages.
    For instance, many languages have both `for`and `while`loops. Consider a typical
    `for` loop in C:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在哪里可能找到这样的冗余？在现实语言中有很多例子。例如，许多语言都有`for`和`while`循环。考虑C语言中的一个典型的`for`循环：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is exactly the same as
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这与
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is, in fact, a general pattern:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一个普遍的模式：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: is the same (with some syntactic liberties) as
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 是相同的（有一些语法上的自由度）作为
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now imagine you’re writing an interpreter for this. Clearly, the `while`loop’s
    implementation has to make several recursive calls, iterate, check, and perhaps
    perform some other bookkeeping (and maybe even manage temporary scope extensions).
    Allof that work has to be duplicatedfor `for`! Wouldn’t it be much simpler to
    instead implement it just once, and translate the `for`body into a `while` body?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象你正在编写这个解释器的代码。显然，`while`循环的实现需要多次递归调用，迭代，检查，也许还要执行一些其他簿记（也许甚至管理临时作用域扩展）。所有这些工作都必须为`for`重复！不是更简单吗，只实现一次，并将`for`体转换为`while`体？
- en: Why have both constructs at all? Because each one is convenient for different
    purposes. In particular, there’s a certain stylistic use of `while`that would
    be harder to spot from a mass of `while`code that is automatically classified
    for us with `for`. It adds to our vocabulary as programmers. It just happens to
    also add to our pain as implementors. We’d like the convenience and richer vocabulary
    without the pain.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要有这两个构造呢？因为每个构造都适用于不同的目的。特别是，`while`的某种风格使用在大量的`for`代码中可能更难被发现，这些代码被自动分类为我们。它增加了我们的程序员词汇量。它碰巧也增加了我们的实现者的痛苦。我们希望有便利性和更丰富的词汇量，而不希望有痛苦。
- en: Desugaring
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去糖
- en: This introduces a distinction between a corelanguage and a surfacelanguage.
    The surface language may have various conveniences, but these get translated into
    the core language, whose constructs are all handled directly. The extra constructs—those
    that make it “sweeter” to program—are called syntactic sugar. The program that
    translates surface programs down to the core is called a desugarer, because it
    removes sugar. (In principle, a desugarer is actually a compilerfrom the surface
    language to the core language. However, since the core language is a sub-language
    of the surface, this is a very special case of compilation, and we find it useful
    to have a special term to distinguish it from general compilation. Just like we
    find it useful to have a special term to distinguish `for`from the general `while`…)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了核心语言和表面语言的区别。表面语言可能有很多便利之处，但这些便利最终都会被转换为核心语言，核心语言的构造都是直接处理的。那些使编程“更甜美”的额外构造被称为语法糖。将表面程序转换为核心程序的程序称为去糖器，因为它移除了糖。（原则上，去糖器实际上是从表面语言到核心语言的编译器。然而，由于核心语言是表面语言的子语言，这是一个非常特殊的编译情况，我们发现有一个专门的术语来区分它是有用的。就像我们找到一个专门的术语来区分`for`和一般的`while`……）
- en: 'Aside:In a real implementation, this compilation requires a little more care.
    Suppose you make an error using `for`, but the error was reported in terms of
    `while`: you’d be pretty confused, because you never did type the `while`. As
    a special case, you may be a student who doesn’t even know what `while` is! Modern
    desguaring systems, such as that in Racket, have special support to take care
    of this in most of the common cases.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：在实际实现中，这种编译需要更多的注意。假设你使用`for`时犯了一个错误，但错误是以`while`的形式报告的：你会感到非常困惑，因为你从未输入过`while`。作为一个特殊情况，你可能是一个甚至不知道`while`是什么的学生！现代去糖系统，如Racket中的系统，有特殊支持来处理大多数常见情况。
- en: 'There are actually many more desugarings in real languages. For instance, `and`and
    `or`can desugar into nested `if`s. In JavaScript, `o.x`desugars into `o["x"]`(which
    will be relevant in a while). In many languages, `x += y`is sugar for `x = x +
    y`. In Python, `+`desugars into the method `__add__`. In fact, Python has a whole
    bunch of these desugarings; these methods are called “dunder” methods (short for
    double-underscore), and a whole programming style of “[protocols](https://www.google.com/url?q=https://twitter.com/gvanrossum/status/1307712322320785409&sa=D&source=editors&ust=1695232021233535&usg=AOvVaw2ERm9Pb0kR6LijXtV_K83D)”
    has evolved around it. Many languages (like Haskell and Python) have list comprehensions,
    which desugar into function and method calls. And so on. In short, desugaring
    is everywhere in programming. If you don’t notice it, that’s part of the point:
    it feels like you’re working with a larger surface syntax than the implementor
    has to manage.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在现实语言中存在许多更多的简化形式。例如，`and`和`or`可以简化为嵌套的`if`语句。在JavaScript中，`o.x`简化为`o["x"]`（这将在稍后变得相关）。在许多语言中，`x
    += y`是`x = x + y`的简化形式。在Python中，`+`简化为方法`__add__`。实际上，Python有一系列这样的简化形式；这些方法被称为“双下划线”方法（简称“dunder”），并且围绕它形成了一种完整的编程风格——“[协议](https://www.google.com/url?q=https://twitter.com/gvanrossum/status/1307712322320785409&sa=D&source=editors&ust=1695232021233535&usg=AOvVaw2ERm9Pb0kR6LijXtV_K83D)”。许多语言（如Haskell和Python）有列表推导式，这些推导式简化为函数和方法调用。等等。简而言之，简化在编程中无处不在。如果你没有注意到它，那也是其目的的一部分：感觉你正在使用比实现者需要管理的更大范围的语法。
- en: 'There are many ways in which desugaring can be implemented. One way is to parse
    the program normally, then rewrite the AST into a subset of the same AST. But
    in some languages, especially those with parenthetical syntax, there are two levels
    of parsing: the coarser parenthetical level and the finer level of ASTs. This
    means we can perform rewriting on the parenthetical terms, and the internal AST
    never needs to know about the sugars (i.e., it need cover only the core language).
    These are typically called macrosystems: systems in which program source (slightly
    abstracted) is rewritten into program source, before parsing takes place. It’s
    important to understand that mostlanguages have syntactic sugar, but very few languages
    have macro systems, which provide program rewriting capabilities directly to the
    programmer (as opposed to hiding them inside the compiler).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实现简化有多种方式。一种方式是正常解析程序，然后将AST重写为相同AST的子集。但在某些语言中，特别是那些有括号语法的语言，存在两个解析级别：较粗的括号级别和较细的AST级别。这意味着我们可以在括号项上进行重写，而内部AST永远不需要知道关于糖（即它只需要覆盖核心语言）。这些通常被称为宏系统：在解析之前，程序源（略微抽象）被重写为程序源的系统。重要的是要理解，大多数语言都有语法糖，但很少有语言有宏系统，它们直接向程序员提供程序重写能力（而不是将其隐藏在编译器中）。
- en: Macros By Example
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过示例学习宏
- en: Racket is one of the few languages to have a macro system, and in fact has a
    very powerful one. Its rarity means ideas we learn using macros will take some
    effort to port to other languages; but its power means we can write quite sophisticated
    systems by leveraging the full power of Racket, and we will do so. In essence,
    Racket macros compile an extended version of Racket—call it Racket++, if you like—down
    to Racket, where we can then exploit the full power of the existing Racket framework.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Racket是少数具有宏系统的语言之一，实际上它有一个非常强大的系统。它的罕见性意味着我们使用宏学到的想法需要一些努力才能移植到其他语言；但它的强大意味着我们可以通过利用Racket的全部力量来编写相当复杂的系统，我们将这样做。本质上，Racket宏将Racket的扩展版本编译成Racket——如果你喜欢，可以称之为Racket++——然后我们可以利用现有Racket框架的全部力量。
- en: We will introduce the Racket macro system through a series of examples. In what
    follows, please switch to using
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一系列示例介绍Racket宏系统。在下面的内容中，请切换到使用
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: because the restrictions and types of `plait`, while very useful for writing
    interpreters, can get in the way of some of what we’ll write.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`plait`的限制和类型虽然对编写解释器非常有用，但可能会妨碍我们的一些编写。
- en: A New Conditional
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的条件语句
- en: 'Recall that Racket is a truthy/falsy language, where `if`takes any non-false
    value to be true. Suppose we want a strict `if`that takes only Booleans. That
    is, we want to extend Racket itself with a `strict-if`. Let’s try this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Racket是一种真值/假值语言，其中`if`接受任何非假值作为真。假设我们想要一个严格的`if`，它只接受布尔值。也就是说，我们想要通过`strict-if`扩展Racket本身。让我们试试这个：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Try examples like:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Seems to work as desired!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来按预期工作！
- en: Do Now: Do you see what the problem is?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来做：你看到问题在哪里了吗？
- en: 'The problem is that we have an eager language (this is true of SMoL in general!),
    so `strict-if`s arguments are going to be evaluated before the body begins to
    execute. However, the whole point of a conditional is to avoid evaluating part
    of the evaluation: Try'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们有一个急切的语言（这在SMoL中通常是正确的！），所以`strict-if`的参数将在主体开始执行之前被评估。然而，条件的目的正是为了避免评估评估的一部分：尝试
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Compare this to what happens with
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下情况比较
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Okay, so we can’t use functions for this purpose. We need some other definition
    mechanism that consumes the syntax and rewrites that, instead of letting it evaluate
    right away. These are macros.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们不能使用函数来完成这个目的。我们需要某种其他定义机制来消耗语法并重新编写它，而不是立即评估它。这些是宏。
- en: 'Let’s dive into how the macro is written, because it’s not so different from
    the function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解宏是如何编写的，因为它与函数并没有太大的不同：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'What are the pieces? `define-syntax`says we’re defining a new piece of syntax(as
    opposed to a function). `syntax-rules`introduces a pattern-matcher (for now, ignore
    what the `()`means: but you do need to include it). Each rule, in brackets, is
    a pattern and output: if the input matches the pattern, then the desugarer (here
    called a macro expander) produces the corresponding output, but with the namesin
    the pattern (here, `C`, `T`, and `E`) copied as program source into the output.
    Thus, given'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分是什么？`define-syntax`告诉我们我们正在定义一个新的语法元素（与函数相对）。`syntax-rules`引入了一个模式匹配器（现在忽略`()`的含义：但你需要包括它）。每个规则（括号内）都是一个模式和输出：如果输入与模式匹配，那么去糖化器（在这里称为宏展开器）将产生相应的输出，但将模式中的名称（在这里是`C`、`T`和`E`）复制为程序源代码到输出中。因此，给定
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: the above macro definition transforms it into
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述宏定义将其转换为
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: which then evaluates exactly as we’d expect.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将正好按照我们预期的那样评估。
- en: One nice feature of Racket is the Macro Stepper (![](image25.png)). It shows
    the program expanding step-by-step, which is useful both for understanding macros
    and debugging them. If necessary, change the “Macro hiding” option at the bottom-left
    to read “Standard”.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Racket的一个很好的特性是宏步进器（![image25.png](image25.png)）。它显示了程序逐步展开，这对于理解宏和调试宏都很有用。如果需要，请将左下角的“宏隐藏”选项更改为“标准”。
- en: Exercise: Try it out with the above macro definition and use. See what you get.
    Observe how, at each step, it highlights the macro use about to be expanded followed
    by the result of that expansion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用上面的宏定义和用法尝试一下。看看你得到了什么。观察在每一步中，它如何突出即将展开的宏使用，然后展示展开的结果。
- en: Note:The Macro Stepper is not an evaluator. It does not show the steps of evaluation,
    only the steps of expansion! Thus, if you write a program that will produce an
    error at run-time, the Macro Stepper does not show that error. It only shows syntax errors.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：宏步进器不是一个评估器。它不显示评估步骤，只显示展开步骤！因此，如果你编写了一个在运行时会产生错误的程序，宏步进器不会显示那个错误。它只显示语法错误。
- en: Local Binding
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部绑定
- en: 'Now let’s look at the `let`bindings we’ve been using until now. Imagine we
    want to extend Racket with a `let1` construct: for example, we want'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们一直使用的`let`绑定。想象一下，我们想要扩展Racket的`let1`构造：例如，我们想要
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: to evaluate to 6.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以评估为6。
- en: Do Now:Can `let1` be defined as a function? Why or why not?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在行动：`let1`能否定义为函数？为什么或为什么不？
- en: '`let1`can’t be a function. If it were, we would first try to evaluate each
    of the sub-terms as arguments. There are two things here that look like argument
    expressions: `(x 3)`and `(+ x x)`. Suppose we try to evaluate `(x 3)`. First of
    all, it looks like an application. Second, `x`isn’t even bound. Third, there is
    no meaningful “value” it could produce: its only job is instead to bind `x`. No,
    `let1` is also a new piece of syntax.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`let1`不能是一个函数。如果是，我们首先会尝试评估每个子项作为参数。这里有看起来像参数表达式的东西：`(x 3)`和`(+ x x)`。假设我们尝试评估`(x
    3)`。首先，它看起来像是一个应用。其次，`x`甚至没有被绑定。第三，它没有产生有意义的“值”：它的唯一任务是绑定`x`。不，`let1`也是一个新的语法元素。'
- en: Terminology:We will often refer to these new pieces of syntax as constructs(as
    in, “a new language construct”). In the Lisp/Scheme/Racket community, these are
    sometimes also called special forms, because they are syntactic forms with their
    own special rules for binding and evaluation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：我们经常会将这些新的语法元素称为构造（例如，“一个新的语言构造”）。在Lisp/Scheme/Racket社区中，这些有时也被称为特殊形式，因为它们是具有自己特殊绑定和评估规则的语法形式。
- en: From now on we’ll use the prefix `my-` on our macros, because we don’t want
    to clash with the names of macros already built into Racket.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将在我们的宏上使用前缀`my-`，因为我们不想与Racket中已经内置的宏名称冲突。
- en: 'From what we’ve seen above, we can probably figure out half of the macro for
    `my-let1`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们上面看到的，我们可能可以找出`my-let1`宏的一半：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: But what would it `expan`d into? We certainly couldjust expand it into the existing
    `let` construct in Racket, but there’s another interesting option.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但它将扩展成什么？我们当然可以将它扩展成Racket中现有的`let`结构，但还有一个有趣的选项。
- en: 'Let’s think about what `my-let1`does: it bindsa name to a value, and then immediately
    evaluatesits body in an environment extended by its name. Now, can we think of
    anything else that binds names to values? Yes, functions. And functions evaluate
    a body in an extended environment. When do functions evaluate their body? When
    they are applied to an argument. Therefore, we can express `my-let1` in terms
    of an anonymous function that is applied immediately:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下`my-let1`做了什么：它将一个名称绑定到一个值，然后立即在一个扩展了其名称的环境中评估其主体。现在，我们能想到其他将名称绑定到值的东西吗？是的，函数。函数在扩展环境中评估主体。函数在什么时候评估它们的主体？当它们被应用于一个参数时。因此，我们可以用立即应用的匿名函数来表示`my-let1`：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Sure enough,
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: will produce `6`. Use the Macro Stepper to see how!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生`6`。使用宏步进器查看它是如何做到的！
- en: Terminology:This pattern, of an anonymous function that is used right away,
    is commonly called left-left-lambda(where “left” stands for left-parenthesis).
    For a long time this remained an obscure term in the Lisp/Scheme community. But
    JavaScript made this pattern popular again under the name Immediately Invoked
    Function Expression (IIFE), because of problems with the handling of scope in
    earlier versions of the language. If you think the parentheses look bad here,
    look up some examples of IIFE on the Web.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：这种立即使用的匿名函数模式通常被称为左左lambda（其中“左”代表左括号）。在很长的一段时间里，这个术语在Lisp/Scheme社区中一直是个模糊的概念。但JavaScript因为早期语言版本中作用域处理的问题，使得这种模式以立即调用的函数表达式（IIFE）的名字再次流行起来。如果你觉得这里的括号看起来不好，可以在网上查找一些IIFE的例子。
- en: 'Exercise: Suppose we make a mistake in the macro and swap two parts:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：假设我们在宏中犯了一个错误，交换了两个部分：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What happens when we try to evaluate
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试评估
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '? Use the Macro Stepper to see what happened.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '? 使用宏步进器查看发生了什么。'
- en: Binding More Locals
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定更多局部变量
- en: 'As we have noticed in Racket, however, the `let` can bind many names at once,
    not only one. It becomes clear how: the function takes formal arguments, and is
    applied to just as many actual arguments. There can be as many as we want! But
    how do we express this in macro syntax?'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在Racket中注意到的，`let`可以一次绑定许多名称，而不仅仅是其中一个。这变得很清楚：函数接受形式参数，并且应用于与实际参数一样多的实际参数。可以有我们想要的那么多！但我们如何在宏语法中表达这一点？
- en: 'In mathematics, it’s common to use ellipses (…) to denote a sequence of arbitrary
    length. Therefore, it would be nice if we could write something like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，使用省略号（…）来表示任意长度的序列是很常见的。因此，如果我们能写出类似这样的东西会很好：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This would say, `my-let2`is followed by any number of `var`-`val`pairs, followed
    by a body. Turn that into a `lambda`with all the `var`s as formal arguments, whose
    body is `body`, applied to all the same `val`s as the actual argument expressions.
    We would use it like so (the extra parens are to help us group the bindings):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将意味着`my-let2`后面跟着任意数量的`var`-`val`对，然后是一个主体。将其转换为一个`lambda`，其中所有的`var`作为形式参数，其主体是`body`，应用于与实际参数表达式相同的所有`val`。我们将这样使用它（额外的括号有助于我们分组绑定）：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In fact, that is exactly the syntax supported by Racket! Try out the above
    program: run it, and also examine it in the Macro Stepper!'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这正是Racket支持的语法！尝试上面的程序：运行它，并在宏步进器中检查它！
- en: Multi-Armed Conditionals
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多分支条件
- en: 'Here’s one last example that clarifies what … means: it means “zero or more
    instances of the preceding pattern”. Using it, we can define our own multi-armed
    conditional. Suppose we want to define a function called `sign` that produces
    a string based on the sign of a number:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个最后的例子，它澄清了…的含义：它意味着“前一个模式的零个或多个实例”。使用它，我们可以定义自己的多分支条件。假设我们想要定义一个名为`sign`的函数，该函数根据数字的符号产生一个字符串：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, it’s clear that `my-cond` can’t be a function; we need to extend the
    language with a new construct, using a macro.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，很明显`my-cond`不能是一个函数；我们需要通过一个新的结构扩展语言，使用宏。
- en: How many arms should our multi-armed conditional have? As many as the programmer
    wants, of course. We’ll further stipulate that if we have exhausted all the questions
    and none has yielded a true value, the “falling through” produces an error.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多分支条件应该有多少分支？当然是程序员想要的那么多。我们进一步规定，如果我们已经用完了所有的问题，并且没有一个问题产生了真值，那么“跌落”将产生一个错误。
- en: Thus, we want to peel off the first question-answer pair and evaluate the question.
    If it succeeds, we evaluate the answer. Otherwise, we want to recur on the remaining
    questions…which is essentially a smaller instance of `my-cond`. (That’s right,
    we’re recurring on syntax now!)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要剥离第一个问题-答案对并评估问题。如果成功，我们评估答案。否则，我们希望对剩余的问题进行递归……这本质上是一个更小的`my-cond`实例。（没错，我们现在正在递归语法！）
- en: 'Since `…`means “zero or more”, we end up with a pattern where we repeat a pattern:
    the first copy peels off the first instance, while the second, followed by a `…`,
    captures all the remaining instances:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`…`表示“零个或多个”，我们最终得到一个重复模式的模式：第一个副本剥离第一个实例，而第二个，后面跟着一个`…`，捕获所有剩余的实例：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Exercise:Examine this code in detail. Try out the example above. It’s essential that
    you run this through the Macro Stepper: you’ll learn a lot about macros from this
    example!'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：仔细检查这段代码。尝试上面的例子。运行宏步进器是至关重要的：你将从这个例子中学到很多关于宏的知识！
- en: More on Macros
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于宏的内容
- en: 'Note:All the examples from this chapter you can find in a video on YouTube,
    so if you prefer, you can watch that instead: [More on Macros](https://www.google.com/url?q=https://youtu.be/2FK6jpAcX9Q&sa=D&source=editors&ust=1695232021251280&usg=AOvVaw2wCzzJcOXLR7zXUAetXhxF).
    Be sure to stop and reflect after each example, and try each of them out for yourself!'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章的所有示例你都可以在YouTube上的视频中找到，所以如果你愿意，你可以观看那个视频：[更多关于宏](https://www.google.com/url?q=https://youtu.be/2FK6jpAcX9Q&sa=D&source=editors&ust=1695232021251280&usg=AOvVaw2wCzzJcOXLR7zXUAetXhxF)。确保在每个例子之后停下来反思，并亲自尝试每个例子！
- en: 'Now let’s start to look at various idiomatic aspects of using Racket macros.
    We’ll want this understanding under our belt because we’ll make use of several
    of these features. Here are five concrete things we’ll see:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始探讨Racket宏的各种惯用用法方面。我们将希望掌握这些知识，因为我们将会使用这些特性中的几个。以下是我们将看到的五个具体事项：
- en: A convenience in definitions
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义中的便利
- en: A major and critical macro feature
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主要且关键的宏特性
- en: An important idiom in truthy/falsy languages
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真值/假值语言中的一个重要惯用用法
- en: A peril in macro definitions
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏定义中的风险
- en: A push to generalize definitions
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推动泛化定义
- en: A Definitional Convenience
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义便利
- en: 'Supposing we want to define a “one-armed `if`” (e.g., useful for checking erroneous
    conditions and proceeding only if the coast is clear): this is commonly called
    `unless`. We can write it this way:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义一个“单臂`if`”（例如，用于检查错误条件，并且只有在情况清晰时才继续）：这通常被称为`unless`。我们可以这样写：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For instance, we can use it this way:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样使用它：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Notice that in the pattern, we don’t have to repeat the `unless`; we can just
    use an `_` instead.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模式中，我们不必重复`unless`；我们可以只用一个`_`。
- en: Aside:The full truth is, this isn’t just a convenience. They actually do slightly
    different things that you can detect in subtle situations. You can safely, and
    should, just use `_` instead of repeating the name of the macro.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：事实的真相是，这不仅仅是一种便利。它们实际上执行了略微不同的操作，你可以在微妙的情况下检测到这些操作。你可以安全地，并且应该使用`_`而不是重复宏的名称。
- en: Name Capture
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称捕获
- en: 'But now, what if we use the above code in this kind of context:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，如果我们在这个类型的上下文中使用上述代码：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This seems problematic: it seems to expand into'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有问题：它似乎展开成
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'which is pretty much the opposite of what we want. That’s because the `not`outside
    the macro seems to have captured the `not` inside the macro. This is roughly analogous
    to dynamic scope: any use context can modify what happens inside the abstraction.
    If this were true, it would be terrifying to be a macro writer!'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是我们不希望的结果。这是因为宏外的`not`似乎捕获了宏内的`not`。这大致类似于动态作用域：任何使用上下文都可以修改抽象内部发生的事情。如果这是真的，那么作为宏编写者将会非常可怕！
- en: Do Now: Run both versions. Do they produce the same answer?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做：运行两个版本。它们产生相同的答案吗？
- en: 'But running the macro version makes clear that the name `not`is notbeing captured.
    Most of all, use the Macro Stepper to see how the expansion works. The important
    thing is that variables are more than just names; they record binding information,
    which keeps names introduced in different settings separate. They may print the
    same way, but internally Racket keeps them separate (and shows this separation
    in the Macro Stepper using colors). That is, it’s as if we start with this program:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但运行宏版本清楚地表明，名称`not`没有被捕获。最重要的是，使用宏步进器查看展开是如何工作的。重要的是，变量不仅仅是名称；它们记录绑定信息，这保持了在不同设置中引入的名称的分离。它们可能以相同的方式打印，但Racket在内部将它们分开（并在宏步进器中使用颜色显示这种分离）。也就是说，我们就像从以下程序开始：
- en: (let ([not (λ (v) v)])
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([not (λ (v) v)])
- en: (unless false
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (unless false
- en: (println 1)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: (println 1)
- en: (println 2)))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: (println 2)))
- en: 'which, after expansion, turns into this program:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 经过展开后，变成这个程序：
- en: (let ([not (λ (v) v)])
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([not (λ (v) v)])
- en: (if (not false)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: (if (not false)
- en: (begin
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (println 1)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: (println 1)
- en: (println 2))
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: (println 2))
- en: (void)))
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: (void)))
- en: 'So now we can easily keep the identifiers apart: the red notis different from
    the blue not. The actual internal representation is an efficient analog to colors.
    If necessary, the macro expander can also use distinct fresh (i.e., previously
    unused) names—`not1`, `not2`, etc.—to represent the different variables of the
    same name.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们可以很容易地保持标识符分开：红色的not与蓝色的not不同。实际的内部表示是一个高效的类似颜色的表示。如果需要，宏展开器也可以使用不同的新（即以前未使用的）名称——`not1`、`not2`等——来表示相同名称的不同变量。
- en: This property, which recovers an analog of static scoping for macros, and is
    called hygiene. Hygiene is a critical feature for macros (and, notably, is one
    not given by the C pre-processor). It lets programmers use whatever name they
    want in the macro definition without worrying about what names will be bound in
    the use context; and similarly, lets users use whatever variable names they want
    without worrying about the macro’s code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性，它为宏恢复了一个静态作用域的类似物，被称为卫生。卫生是宏的关键特性（并且值得注意的是，它不是C预处理器提供的）。它允许程序员在宏定义中使用他们想要的任何名称，而无需担心使用上下文中将绑定什么名称；同样，也允许用户使用他们想要的任何变量名称，无需担心宏的代码。
- en: That said, you may wonder whether hygiene is just for built-in functions like
    `not`. We’ll see that it’s not. But to get there, we’ll work through some other
    idiomatic examples.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可能想知道卫生是否只是针对像`not`这样的内置函数。我们将看到它不是。但为了达到那里，我们将通过一些其他的习惯用法示例。
- en: A Truthy/Falsy Idiom
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真值/假值习语
- en: 'Unrelated to macros, here’s something we often see in truthy/falsy languages.
    Consider a two-arm `or`, which we can define as a macro:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与宏无关，这里有一些我们在真/假语言中经常看到的东西。考虑一个双臂`or`，我们可以将其定义为宏：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This works well enough for
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于
- en: '[PRE64]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, consider a function like `member`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑一个像`member`这样的函数：
- en: '[PRE65]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When it succeeds, it doesn’t just return `true`, it returns the entire rest
    of the list (which is a truthy value). But if we combine this with `or-2`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当它成功时，它不仅返回`true`，还返回整个剩余的列表（这是一个真值）。但如果我们将其与`or-2`结合：
- en: '[PRE66]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is clearly not the result we want: we’ve lost the useful return value.
    Instead, here’s a different macro that returns rather than suppressing that result:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是我们想要的结果：我们丢失了有用的返回值。相反，这里有一个不同的宏，它返回结果而不是抑制它：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This makes
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: work as expected.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样工作。
- en: A Macro Definition Peril
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏定义的危险
- en: 'However, this macro contains a subtle (almost hidden), important peril. Consider
    this example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个宏包含一个微妙（几乎是隐藏的）、重要的危险。考虑这个例子：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That also returns a truthy value, but now we see the print twice. So we need
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这也返回一个真值，但现在我们看到打印了两次。所以我们需要
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Exercise: Confirm that this produces the correct answer.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：确认这会产生正确的答案。
- en: Back to Hygiene
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到卫生
- en: This now works fine for the printing example. But now we have to worry about
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这对于打印示例来说工作得很好。但现在我们必须担心
- en: '[PRE71]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Using fresh names, there are two things this could expand into:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新名字，这可以展开成两件事：
- en: '[PRE72]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Which does the macro version produce? That’s right, the latter: the one corresponding
    to'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 宏版本会产生什么？没错，后者：对应于
- en: (let ([v 1])
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([v 1]))
- en: (let ([v false])
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([v false])
- en: (if v
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (if v
- en: v
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: v
- en: v)))
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: v)))
- en: In other words, hygiene works just as well for local variables, not just for
    built-in functions! In other words, we have spent a whole bunch of time on something
    you don’t need to worry about. In return, it means you can use names with impunity
    in your macro programs, just as you do inside functions and methods because of
    static scoping.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，卫生对于局部变量和内置函数都同样有效！换句话说，我们花了很多时间在你不需要担心的事情上。作为回报，这意味着你可以在宏程序中使用名称而无需担心使用上下文中将绑定什么名称；同样，也允许用户使用他们想要的任何变量名称，无需担心宏的代码。
- en: Generalizing Macros
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏的推广
- en: Finally, unlike the poor programmers stuck with their infix syntaxes and binary
    operators, parenthetical syntax programmers can generalize constructs to arbitrary
    arity. We’ve seen `…`already; let’s put it to work here to create an n-ary `or`.
    A natural first definition is
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与那些被中缀语法和二元运算符困扰的糟糕程序员不同，括号语法程序员可以将结构推广到任意阶。我们已经看到了`…`；让我们在这里使用它来创建一个n元`or`。一个自然的第一个定义是
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Do Now: However,  see what happens when we try:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来做：然而，看看当我们尝试时会发生什么：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Okay, so that doesn’t work. It’s important to pay attention to the error message:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这样是不行的。注意错误信息很重要：
- en: 'orN: bad syntax in: (orN)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: orN：在`(orN)`中存在语法错误
- en: 'This highlights the need for a base case. The problem is our definition above
    requires one or more sub-expressions: `e1`is the first, and `e2 …`means zero or
    more from the second position onward. But nothing covers the case of no sub-terms.
    So we need'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这突出了需要基例的需求。问题是我们的定义要求一个或多个子表达式：`e1`是第一个，`e2 …`意味着从第二个位置开始的零个或多个。但是没有任何内容覆盖没有子项的情况。因此，我们需要
- en: '[PRE76]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: and of course this works fine.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这没问题。
- en: 'Exercise: The problem above appears to have been self-inflicted: why did we
    start with the pattern `(_ e1 e2 ...)`, which requires one-or-more (`e1`is the
    first, `e2 …`is zero or more)? We should have just written `(_ e...)`instead,
    which would be zero-or-more! Rewrite the `orN` macro using this pattern: can you
    make it work?'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：上述问题似乎是我们自己造成的：为什么我们从模式`(_ e1 e2 ...)`开始，它要求一个或多个（`e1`是第一个，`e2 …`是零个或多个）？我们应该只写`(_
    e...)`，这将表示零个或多个！使用这个模式重写`orN`宏：你能让它工作吗？
- en: ••••• Objects •••••
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ••••• 对象 •••••
- en: Objects—the bundling of data with operations over them—are a generalization
    of closures. Many languages have objects, but in a variety of different forms.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对象——将数据与操作捆绑在一起——是闭包的泛化。许多语言都有对象，但形式各不相同。
- en: A Standard Model of Objects
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的标准模型
- en: 'Now we’re ready to start looking at our first major language feature that goes
    beyond SMoL: objects. Not all SMoL languages have objects; though many do, they
    have them in very different ways. Nevertheless, what we will see is that there
    is a fairly uniform way to think about objects across all these languages, and
    furthermore this way of thinking really builds on our understanding of SMoL.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始查看第一个超越SMoL的主要语言特性：对象。并非所有SMoL语言都有对象；尽管许多语言有，但它们的实现方式非常不同。然而，我们将看到，在这些语言中，思考对象的方式相当统一，而且这种思考方式实际上建立在我们对SMoL的理解之上。
- en: 'When building the essence of objects, though, we now have a choice: we can
    do it either in the core or through syntactic sugar. The former is frustrating
    in several ways:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建对象的本质时，尽管如此，我们现在有选择：我们可以在核心中做，或者通过语法糖来实现。前者以几种方式令人沮丧：
- en: We have to do more low-level bookkeeping (e.g., with environments) that may
    not necessarily be instructive.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须做更多低级别的账目记录（例如，使用环境），这可能不一定具有指导意义。
- en: The interpreter gets larger and more unwieldy, because all the new constructs
    go in the same place rather than each being independent definitions.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器变得更大、更难以控制，因为所有的新构造都放在同一个地方，而不是每个都是独立的定义。
- en: 'Most of all: it becomes a lot harder to write illustrative programs and tests,
    because the core language may not have all the features we need to make this convenient.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是：编写说明性程序和测试变得更加困难，因为核心语言可能没有我们需要的所有功能来使这变得方便。
- en: 'In contrast, all these problems go away if we use syntactic sugar instead.
    Therefore, even though a real implementation may well have at least parts of objects
    (especially the parts needed for efficiency) in the core language, we are going
    to build objects entirely through desugaring, using macros. In fact, in this book,
    we will do something even simpler: we will give concrete examples of what programs
    desugar to. Figuring out the general desugaring will be left as an exercise for
    you. To aid in that process, we will write code in as stylized a form as possible,
    not using any short-cuts that might obscure the macro rules.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们使用语法糖，所有这些问题都会消失。因此，即使实际的实现可能确实在核心语言中有对象的部分（特别是需要效率的部分），我们也将完全通过去糖化，使用宏来构建对象。实际上，在这本书中，我们将做一些更简单的事情：我们将给出程序去糖化的具体示例。找出一般的去糖化将留给你作为练习。为了帮助这个过程，我们将尽可能以风格化的形式编写代码，不使用可能掩盖宏规则的任何捷径。
- en: Note:The programs in this section cannot be written in the language `plait`.
    Instead, we will use  `#lang racket`, which does not perform static type-checking.
    Add the line
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节中的程序不能使用`plait`语言编写。相反，我们将使用`#lang racket`，它不执行静态类型检查。添加以下行
- en: '[PRE77]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: at the top to access the testing operator and printing control parameter from
    `plait`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部访问测试操作符和打印控制参数从`plait`。
- en: Exercise:Spot the point at which the type-checker would become problematic.
    Hint:The easiest way is, of course, to keep using `#lang plait` until you run
    into a problem. Make sure you understand what the problem is!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：找出类型检查器可能成为问题的点。提示：当然，最容易的方法是继续使用`#lang plait`直到遇到问题。确保你理解了问题是什么！
- en: What is an Object?
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: The central question we must answer, before we start thinking about implementations,
    is what an object is. There is a lot of variation between languages, but they
    all seem to agree that an object is
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始考虑实现之前，我们必须回答的中心问题是对象是什么。不同语言之间的差异很大，但它们似乎都同意对象是这样的
- en: a value, that
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值，它
- en: maps names to
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射名称到
- en: 'stuff: either other values or “methods”.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stuff：要么是其他值，要么是“方法”。
- en: From a minimalist perspective, methods seem to be just functions, and since
    we already have those in the language, we can put aside this distinction.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从极简主义的角度来看，方法似乎只是函数，既然我们已经在语言中有了这些，我们就可以忽略这种区别。
- en: Terminology:We will use the term member to refer to a generic entry in an object,
    when we don’t want to make a distinction between fields and methods.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：当我们不想在字段和方法之间做出区分时，我们将使用术语“成员”来指代对象中的通用条目。
- en: 'How can we capture this? An object is just a value that dispatches on a given
    name. For simplicity, we’ll use `lambda`to represent the object and Racket’s `case` construct
    to implement the dispatching. Here’s an object that responds to either add1 or
    sub1, and in each case returns a function that either increments or decrements:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何捕捉这个？对象只是一个根据给定名称进行分发的值。为了简单起见，我们将使用`lambda`来表示对象，并使用Racket的`case`构造来实现分发。以下是一个响应add1或sub1的对象，在每种情况下都返回一个增加或减少的函数：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We would use this as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如下使用它：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Aside:Observe that basic objects are a generalization of `lambda`to have multiple
    “entry-points”. Conversely, a `lambda`is an object with only one entry-point;
    therefore, it doesn’t need a “method name” to disambiguate.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：观察基本对象是`lambda`的泛化，具有多个“入口点”。相反，一个`lambda`是一个只有一个入口点的对象；因此，它不需要“方法名称”来消除歧义。
- en: 'Of course, writing method invocations with these nested function calls is unwieldy
    (and is about to become even more so), so we’d be best off equipping ourselves
    with a convenient syntax for invoking methods:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用嵌套函数调用编写方法调用是不方便的（而且很快就会变得更加不便），因此我们最好装备一个方便的语法来调用方法：
- en: '[PRE80]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This enables us to rewrite our test:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够重写我们的测试：
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Aside:We’ve taken advantage of Racket’s variable-arity syntax: `. a`says “bind
    all the remaining—zero or more—arguments to a list named `a`”. The `apply` function
    “splices” in such lists of arguments to call functions.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：我们利用了Racket的可变参数语法：`. a`表示“将所有剩余的——零个或多个——参数绑定到名为`a`的列表”。`apply`函数“拼接”这样的参数列表来调用函数。
- en: 'Observe something very subtle about our language: nothing precludes us from
    writing an arbitrary expression in the second position of a call to `msg`. That
    is, we can compute which member we want to access. For instance:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们语言中的一个非常微妙之处：在`msg`调用的第二个位置中，没有什么阻止我们编写任意表达式。也就是说，我们可以计算我们想要访问的成员。例如：
- en: '[PRE82]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is unlike many languages with objects, which force you to write the literal
    name of the member (e.g., in Java, in most cases). We’ll return to this later!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这与许多具有对象的编程语言不同，这些语言强制你写出成员的明确定义名称（例如，在Java中，在大多数情况下）。我们稍后会回到这个问题！
- en: 'Aside:This is a general problem with desugaring: the target language may allow
    expressions that have no counterpart in the source, and hence cannot be mapped
    back to it. Fortunately we don’t often need to perform this inverse mapping, though
    it does arise in some debugging and program comprehension tools. More subtly,
    however, we must ensure that the target language does not produce values that
    have no corresponding equivalent in the source.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：这是去糖化的一般问题：目标语言可能允许源语言中没有对应表达式的表达式，因此无法映射回它。幸运的是，我们并不经常需要执行这种逆向映射，尽管它在一些调试和程序理解工具中确实会出现。然而，更微妙的是，我们必须确保目标语言不会产生源语言中没有对应等价物的值。
- en: Now that we have basic objects, let’s start adding the kinds of features we’ve
    come to expect from most object systems.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本对象，让我们开始添加大多数对象系统所期望的功能。
- en: The “Object” Pattern
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “对象”模式
- en: 'We can consolidate what we have written above as the “object” pattern: code
    that looks like'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们上面写的内容合并为“对象”模式：看起来像的代码
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Constructors
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'A constructor is simply a function that is invoked at object construction time.
    We currently lack such a feature, but by turning an object from a literal into
    a function that takes constructor parameters, we achieve this effect:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个在对象构造时调用的函数。我们目前缺少这样的功能，但通过将对象从字面量转换为接受构造函数参数的函数，我们实现了这种效果：
- en: '[PRE84]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the first example, we pass 5 as the constructor’s argument, so adding 3 yields
    8\. The second is similar, and shows that the two invocations of the constructors
    don’t interfere with one another (just as we would expect from static scope).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们将5作为构造函数的参数传递，因此加上3得到8。第二个例子类似，表明两次构造函数调用不会相互干扰（正如我们期望的静态作用域那样）。
- en: The “Class” Pattern
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “类”模式
- en: 'We’ve actually made quite a momentous change with this small addition: we’ve
    gone from objects to functions-that-make-objects (notice the object pattern inside
    the function). But traditionally, what makes objects? Classes! And classes typically
    have constructors. So in the process of introducing constructors, we have actually
    also shifted from objects to classes. The “class” pattern, at its simplest, is:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上通过这个小小的补充做出了相当重大的改变：我们从对象转变为了创建对象的函数（注意函数内的对象模式）。但传统上，是什么造就了对象？类！而且类通常有构造函数。因此，在引入构造函数的过程中，我们实际上也从对象转变到了类。最简单的“类”模式是：
- en: '[PRE85]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: State
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: Many people believe that objects primarily exist to encapsulate state.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为，对象主要存在是为了封装状态。
- en: Aside:Curiously, Alan Kay, who won a Turing Award for inventing Smalltalk and
    modern object technology, disagrees. In [The Early History of Smalltalk](https://www.google.com/url?q=http://worrydream.com/EarlyHistoryOfSmalltalk/&sa=D&source=editors&ust=1695232021277736&usg=AOvVaw2Jq9XZtuuo6438N_xh50ZK),
    he says, “[t]he small scale [motivation for OOP] was to find a more flexible version
    of assignment, and then to try to eliminate it altogether”. He adds, “It is unfortunate
    that much of what is called ‘object-oriented programming’ today is simply old
    style programming with fancier constructs. Many programs are loaded with ‘assignment-style’
    operations now done by more expensive attached procedures.”
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：有趣的是，艾伦·凯（Alan Kay）因发明Smalltalk和现代面向对象技术而获得图灵奖，他不同意这种观点。在《Smalltalk的早期历史》（[The
    Early History of Smalltalk](https://www.google.com/url?q=http://worrydream.com/EarlyHistoryOfSmalltalk/&sa=D&source=editors&ust=1695232021277736&usg=AOvVaw2Jq9XZtuuo6438N_xh50ZK)）中，他说：“面向对象编程（OOP）的小规模动机是找到一个更灵活的赋值版本，然后尝试完全消除它。”他补充说：“遗憾的是，今天所谓的许多‘面向对象编程’实际上只是带有更花哨结构的旧式编程。许多程序现在都充满了‘赋值式’操作，这些操作现在由更昂贵的附加过程来完成。”
- en: 'We certainly haven’t lost that ability. If we desugar to a language with variables,
    we can easily have multiple methods mutate common state, such as a constructor
    argument:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然没有失去这种能力。如果我们将代码简化为具有变量的语言，我们就可以轻松地让多个方法修改公共状态，例如构造函数参数：
- en: '[PRE86]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We have changed the name to `mk-o-…` to reflect the fact that this is an object-maker,
    i.e., analogous to a class. For instance, we can test a sequence of operations:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将名称更改为`mk-o-…`，以反映这是一个对象制造者，即类似于类。例如，我们可以测试一系列操作：
- en: '[PRE87]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'and also notice that mutating one object doesn’t affect another:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，修改一个对象不会影响另一个对象：
- en: '[PRE88]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Private Members
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有成员
- en: 'Another common object language feature is private members: ones that are visible
    only inside the object, not outside it.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的对象语言特性是私有成员：仅在对象内部可见，不在对象外部可见。
- en: Aside: Except that, in Java, instances of other classes of the same type are
    privy to “private” members. Otherwise, you would simply never be able to implement
    an Abstract Data Type. Note that classes are not Abstract Data Types!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：但在Java中，同一类型的其他类的实例可以访问“私有”成员。否则，你就永远无法实现抽象数据类型。请注意，类不是抽象数据类型！
- en: 'These may seem like an additional feature we need to implement, but we already
    have the necessary mechanism in the form of locally-scoped, lexically-bound variables:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能看起来像是我们需要实现的新功能，但实际上我们已经有了一种必要的机制，即局部作用域、词法绑定的变量：
- en: '[PRE89]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The code above uses lexical scoping to ensure that `count`remains hidden to
    the world. Trying to access `count` directly from the outside will fail.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用词法作用域来确保`count`对世界保持隐藏。直接从外部尝试访问`count`将失败。
- en: A Refined “Class” Pattern
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精炼的“类”模式
- en: 'With this change, we can now refine our pattern for classes:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，我们现在可以精炼我们的类模式：
- en: '[PRE90]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'which we can also write as:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其写成：
- en: '[PRE91]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We’ll see in a moment why we might want to do this.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到为什么我们可能想要这样做。
- en: Static Members
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员
- en: 'Another feature often valuable to users of objects is static members: those
    that are common to all instances of the same type of object. This, however, is
    merely a lexically-scoped identifier (making it private) that lives outside the
    constructor (making it common to all uses of the constructor).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对象用户经常需要的另一个特性是静态成员：那些属于同一类型对象所有实例的成员。然而，这仅仅是一个词法作用域的标识符（使其成为私有的），它存在于构造函数之外（使其对所有使用构造函数的情况都是通用的）。
- en: 'Suppose we want to keep a count of how many instances of a kind of object are
    created. This count cannot be inside any one of those objects, because they would
    not “know” about each other; rather, the constructor needs to keep track of this.
    This is the role of static members, and the variable `counter` plays this role
    in the following example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要记录创建某种对象实例的数量。这个计数不能包含在任何对象内部，因为它们不会“知道”彼此；相反，构造函数需要跟踪这个计数。这就是静态成员的作用，在下面的例子中，变量`counter`就扮演了这个角色：
- en: '[PRE92]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We’ve written the counter increment where the “constructor” for this object
    would go, though it could just as well be manipulated inside the methods.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了计数器递增的地方，这是这个对象的“构造函数”所在的位置，尽管它也可以在方法内部被操作。
- en: 'To test it, we should make multiple objects and ensure they each affect the
    global count:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们应该创建多个对象并确保它们各自影响全局计数：
- en: '[PRE93]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'It is productive to see how this program runs through the Stacker. For simplicity,
    we can ignore most of the details and focus just on the core static pattern. Here
    is a Stacker-friendly translation:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Stacker查看这个程序是如何运行的，这是很有生产力的。为了简单起见，我们可以忽略大多数细节，只关注核心静态模式。以下是Stacker友好的翻译：
- en: '[PRE94]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Run this and see how the static member works!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序，看看静态成员是如何工作的！
- en: A Re-Refined “Class” Pattern
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新精炼的“类”模式
- en: 'Now we can refine our pattern for classes even further:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进一步细化我们的类模式：
- en: '[PRE97]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Put differently:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：
- en: '[PRE98]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Exercise: Statics, as defined here, are accessed through objects. However,
    statics by definition belong to a class, not to objects, and hence should be accessible
    through the class itself—for instance, even if no instances of the class have
    ever been created. (In the working example above, one should be able to access
    the count when it is still `0`.) Modify the pattern above to respect this by making
    static members be accessible directly through the class rather than through objects.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：如这里定义的静态，是通过对象访问的。然而，根据定义，静态属于类，而不是对象，因此应该可以通过类本身来访问——例如，即使从未创建过类的实例。（在上述工作示例中，应该能够在计数器仍然是`0`时访问计数。）修改上述模式，通过使静态成员可以直接通过类而不是通过对象来访问，以尊重这一点。
- en: Objects with Self Reference
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有自引用的对象
- en: 'Until now, our objects have simply been packages of named functions: functions
    with multiple named entry-points, if you will. We’ve seen that many of the features
    considered important in object systems are actually simple patterns over functions
    and scope, and have indeed been used—without names assigned to them—for decades
    by programmers armed with lambdas.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的对象仅仅是命名函数的包：如果你愿意，具有多个命名入口点的函数。我们已经看到，在对象系统中被认为重要的许多特性实际上只是函数和作用域的简单模式，并且确实被程序员们使用了数十年，他们装备了lambda函数。
- en: 'What this means is that the different members are actually independent of each
    other: they can’t, for instance, directly reference one another. This is too limiting
    for a true object system, where a method has a way of referencing the object it
    is part of so that it can use other members of that object. To enable this, many
    object systems automatically equip each object with a reference to itself, often
    called `self`or `this`. Can we implement this?'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着不同的成员实际上是相互独立的：例如，它们不能直接引用彼此。这对于真正的对象系统来说过于限制，因为在对象系统中，方法有一种方式可以引用它所属的对象，以便它可以使用该对象的其他成员。为了实现这一点，许多对象系统自动为每个对象提供一个指向自身的引用，通常称为`self`或`this`。我们能实现这个吗？
- en: 'Aside: I prefer this slightly dry way of putting it to the anthropomorphic
    “knows about itself” terminology often adopted by object advocates. Indeed, note
    that we have gotten this far into object system properties without ever needing
    to resort to anthropomorphism.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句：我更喜欢这种稍微有点枯燥的表达方式，而不是对象倡导者经常采用的拟人化“知道自身”的术语。确实，请注意，我们已经在对象系统属性方面取得了如此大的进展，而从未需要诉诸拟人化。
- en: Self-Reference Using Mutation
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用变异进行自引用
- en: 'Yes, we can! This relies on a pattern that sets up the name for the recursive
    reference, then uses that to create the body that will employ the recursion, and
    finally uses mutation to make the name refer to the defined body. For simplicity,
    we will go back to the object pattern, ignoring the class-related features:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以！这依赖于一种设置递归引用名称的模式，然后使用它来创建将使用递归的主体，最后使用变异使名称指向定义的主体。为了简单起见，我们将回到对象模式，忽略与类相关的功能：
- en: '[PRE99]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can test it by having `first`invoke `second`. Sure enough, this produces
    the expected answer:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过让 `first` 调用 `second` 来测试它。确实如此，这产生了预期的答案：
- en: '[PRE100]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here is the above program translated into the simpler smol/fun language. Once
    translated, we can run it in the Stacker:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是将上述程序翻译成更简单的 smol/fun 语言的版本。一旦翻译，我们就可以在 Stacker 中运行它：
- en: '[PRE101]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Run it for yourself! What do you learn from it? Do you see how `self` works?
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 自己运行它！你从中学到了什么？你看到 `self` 是如何工作的吗？
- en: Exercise:This change to the object pattern is essentially independent of the
    class pattern. Extend the class pattern to include self-reference.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：这种对对象模式的改变基本上与类模式无关。扩展类模式以包括自引用。
- en: Self-Reference Without Mutation
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无变异的自引用
- en: 'There’s another pattern we can use that avoids mutation, which is to send the
    object itself as a parameter:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用另一种避免变异的模式，即发送对象本身作为参数：
- en: '[PRE104]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Each method now takes `self` as an argument. That means method invocation must
    be modified to follow this new pattern:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法现在都接受 `self` 作为参数。这意味着方法调用必须修改以遵循这个新模式：
- en: '[PRE105]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: That is, when invoking a method on `o`, we must pass `o` as a parameter to the
    method. Notice that we did not do any such thing when invoking a function! This
    distinguishes functions and methods.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，当我们对 `o` 调用一个方法时，我们必须将 `o` 作为参数传递给该方法。请注意，我们在调用函数时并没有做这样的事情！这区分了函数和方法。
- en: 'Obviously, this approach is dangerous because we can potentially pass a different
    object as the “self”. Exposing this to the developer is therefore probably a bad
    idea; if this implementation technique is used, it should only be done in desugaring.
    (Unfortunately, Python exposes exactly this in its surface syntax.) Sure enough:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法是危险的，因为我们可能传递一个不同的对象作为“self”。因此，将此暴露给开发者可能是一个糟糕的想法；如果使用这种实现技术，它应该只在去糖化时使用。（不幸的是，Python
    正好在其表面语法中暴露了这一点。）确实如此：
- en: '[PRE106]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Dynamic Dispatch
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分派
- en: Finally, we should make sure our objects can handle a characteristic attribute
    of object systems, which is the ability to invoke a method without the caller
    having to know or decide which object will handle the invocation.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该确保我们的对象能够处理对象系统的一个特性，即调用者不必知道或决定哪个对象将处理调用。
- en: Suppose we have a binary tree data structure, where a tree consists of either
    empty nodes or leaves that hold a value. In traditional functions, we are forced
    to implement some form of conditional—such as a `type-case`—that exhaustively
    lists and selects between the different kinds of trees. If the definition of a
    tree grows to include new kinds of trees, each of these code fragments must be
    modified.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个二叉树数据结构，其中一棵树要么是空节点，要么是包含值的叶子。在传统的函数中，我们被迫实现某种形式的条件——例如 `type-case`——来详尽地列出并选择不同种类的树。如果树的定义扩展到包括新的树种类，那么每个这些代码片段都必须被修改。
- en: Dynamic dispatch solves this problem by making that conditional branch disappear
    from the user’s program and instead be handled by the method selection code built
    into the language. The key feature that this provides is an extensible conditional.
    This is one dimension of the extensibility that objects provide.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分派通过从用户的程序中消除这个条件分支，并让语言内建的方法选择代码来处理它，从而解决了这个问题。它提供的关键特性是可扩展的条件。这是对象提供的一个可扩展维度。
- en: 'Let’s first define our two kinds of tree objects:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们的两种树对象：
- en: '[PRE107]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'With these, we can make a concrete tree:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，我们可以创建一个具体的树：
- en: '[PRE109]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'And finally, test it:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试它：
- en: '[PRE110]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Observe that both in the test case and in the `sum`method of `node`, there is
    a reference to `’sum`without checking whether the recipient is a `mt`or `node`.
    Instead, the language’s run-time systemextracts the recipient’s `sum` method and
    invokes it. This conditional missing from the user’s program, and handled automatically
    by the language,  is the essence of dynamic dispatch.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到在测试用例和 `node` 的 `sum` 方法中，都有一个对 `’sum` 的引用，而不检查接收者是否是 `mt` 或 `node`。相反，语言的运行时系统提取接收者的
    `sum` 方法并调用它。用户程序中缺失的这个条件，并由语言自动处理，是动态分派的核心。
- en: It’s worth noting that we didn’t have to change our pattern to add dynamic dispatch;
    it simply followed as a result of the rest of the design.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们无需改变我们的模式来添加动态分派；它只是作为设计其余部分的结果而自然出现。
- en: Aside:This property—which appears to make systems more black-box extensible
    because one part of the system can grow without the other part needing to be modified
    to accommodate those changes—is often hailed as a key benefit of object-orientation.
    While this is indeed an advantage objects have over functions, there is a dual
    advantage that functions have over objects, and indeed many object programmers
    end up contorting their code—using the Visitor pattern—to make it look more like
    a function-based organization. Read [Synthesizing Object-Oriented and Functional
    Design to Promote Re-Use](https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&sa=D&source=editors&ust=1695232021299288&usg=AOvVaw3CC6NAYK9gN3UxWzQtILYg)for
    a running example that will lay out the problem in its full glory. Try to solve
    it in your favorite language, and see the [Racket solution](https://www.google.com/url?q=http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml&sa=D&source=editors&ust=1695232021299768&usg=AOvVaw1BZuSy7k1EJ8XRqphKUm57).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：这种特性——似乎使系统更易于黑盒扩展，因为系统的一部分可以增长，而另一部分无需修改以适应这些变化——通常被认为是面向对象的关键好处。虽然这确实是对象相对于函数的优势，但函数相对于对象也有双重优势，而且确实许多面向对象的程序员最终会扭曲他们的代码——使用访问者模式——使其看起来更像基于函数的组织。阅读[综合面向对象和函数式设计以促进重用](https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&sa=D&source=editors&ust=1695232021299288&usg=AOvVaw3CC6NAYK9gN3UxWzQtILYg)以获取一个运行示例，它将全面展示这个问题。尝试用你喜欢的语言解决它，并查看[Racket解决方案](https://www.google.com/url?q=http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml&sa=D&source=editors&ust=1695232021299768&usg=AOvVaw1BZuSy7k1EJ8XRqphKUm57)。
- en: What Else do Objects Have?
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象还有什么其他东西？
- en: Member Name Design Space
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员名称设计空间
- en: 'Now we will focus on the names of members (a term we use to not distinguish
    between fields and methods). Also, let’s set aside the distinction between classes
    and objects for a moment: whether through classes or not, we eventually end up
    with objects, which programs use. So the two questions are:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于成员的名称（我们使用这个术语来区分字段和方法）。同时，让我们暂时放下类和对象的区别：无论是否通过类，我们最终都会得到对象，这是程序使用的。所以有两个问题：
- en: Is the set of member names statically fixed, or can it be changed dynamically?
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员名称集合是否是静态固定的，或者可以动态更改？
- en: Is the member being accessed at a point statically fixed, or can it be computed
    dynamically?
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问的成员在某个点是否是静态固定的，或者可以动态计算？
- en: 'This gives us a 2x2 table, and it’s worthwhile to ask whether each cell makes
    sense (and whether we’ve seen it in any real languages). We get:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个2x2的表格，值得问一问每个单元格是否合理（以及我们是否在任何真实语言中见过它）。我们得到：
- en: '|  | Name is Static | Name is Computed |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称是静态的 | 名称是计算的 |'
- en: '| Fixed Set of Members | As in base Java. | As in Java with reflection to compute
    the name. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 固定成员集合 | 与基本Java相同。 | 与使用反射计算名称的Java相同。 |'
- en: '| Variable Set of Members | Difficult to envision (what use would it be?).
    | Most “scripting” languages. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 可变成员集合 | 难以想象（有什么用？）。 | 大多数“脚本”语言。 |'
- en: 'Only one case does not quite make sense: if the member being accessed must
    be fixed in the source program, then the set of names is pre-decided, so it doesn’t
    seem to make sense to be able to dynamically change the set of members (new members
    would not be accessible, while deleted members would cause some existing accesses
    might fail). All other points in this design space have, however, been explored
    by languages.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一种情况不太合理：如果访问的成员必须在源程序中固定，那么名称集合是预先决定的，所以看起来没有意义能够动态更改成员集合（新成员将不可访问，而删除的成员可能会导致一些现有的访问失败）。然而，在这个设计空间中的所有其他点都已被语言所探索。
- en: The lower-right quadrant corresponds closely with languages that use hash-tables
    to represent objects. Then the name is simply the index into the hash-table. Some
    languages carry this to an extreme and use the same representation even for numeric
    indices, thereby (for instance) conflating objects with dictionaries and even
    arrays. Even when the object only handles “member names”, this style of object
    creates significant difficulty for type-checking and is hence not automatically
    desirable.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 右下象限与使用哈希表表示对象的编程语言密切相关。然后名称就是哈希表的索引。一些语言甚至将这种做法推向极端，对于数值索引也使用相同的表示，从而（例如）将对象与字典和数组混淆。即使对象只处理“成员名称”，这种对象风格在类型检查中也会造成重大困难，因此不是自动想要的。
- en: Therefore, in the rest of this section, we will stick with “traditional” objects
    that have a fixed set of names and even static member name references (the top-left
    quadrant). Even then, we will find there is much, much more to study.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节的其余部分，我们将坚持使用“传统”对象，这些对象具有固定的名称集合，甚至静态成员名称引用（左上象限）。即便如此，我们也会发现还有很多很多要研究。
- en: What (Goes In) Else?
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有什么（进入）？
- en: 'Until now, our case statements have not had an `else`clause. One reason to
    do so would be if we had a variable set of members in an object, though that is
    probably better handled through a different representation than a conditional:
    a hash-table, for instance, as we’ve discussed above. In contrast, if an object’s
    set of members is fixed, desugaring to a conditional works well for the purpose
    of illustration (because it emphasizesthe fixed nature of the set of member names,
    which a hash table leaves open to interpretation—and also error). There is, however,
    another reason for an `else`clause, which is to “chain” control to another, parent,
    object. This is called inheritance.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的case语句还没有`else`子句。这样做的一个原因可能是如果我们有一个对象中成员变量的集合，尽管这可能更适合通过不同的表示方式来处理，比如我们上面讨论过的哈希表。相反，如果一个对象的成员集合是固定的，将反编译为条件语句对于说明目的来说效果很好（因为它强调了成员名称集合的固定性，而哈希表则留给解释——也可能导致错误）。然而，还有一个添加`else`子句的原因，那就是“链”控制到另一个父对象。这被称为继承。
- en: Let’s return to our model of desugared objects. To implement inheritance, the
    object must be given “something” to which it can delegate method invocations that
    it does not recognize. A great deal will depend on what that “something” is.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的反编译对象模型。为了实现继承，对象必须被赋予“某种东西”，以便它可以委托它不认识的方法调用。这将很大程度上取决于“某种东西”是什么。
- en: 'One answer could be that it is simply another object:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的答案是它只是一个另一个对象：
- en: '[PRE111]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Due to our representation of objects, this application effectively searches
    for the member in the parent object (and, presumably, recursively in its parents).
    If a member matching the name is found, it returns through this chain to the original
    call in `msg` that sought the member. If none is found, the final object presumably
    signals a “message not found” error.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对对象的表示，这个应用实际上是在父对象中搜索成员（并且，假设地，在其父对象中递归搜索）。如果找到一个匹配名称的成员，它将通过这个链返回到原始的`msg`调用中，该调用寻求这个成员。如果没有找到，最终对象可能发出一个“消息未找到”的错误。
- en: Exercise:If you know what an l-value is, then you might notice that the application
    `(parent-object m)`is like “half a `msg`”, just like an l-value was “half a value
    lookup”. Is there any connection?
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：如果你知道什么是l-value，那么你可能会注意到应用`(parent-object m)`就像“半个`msg`”，就像l-value是“半个值查找”。是否存在任何联系？
- en: 'Let’s try this by extending our trees to implement another method, `size`.
    We’ll write an “extension” (you may be tempted to say “sub-class”, but hold off
    for now!) for each `node`and `mt`to implement the `size`method. We intend these
    to extend the existing definitions of `node`and `mt`, so we’ll use the extension
    pattern described above. In other words, if we previously had the rough equivalent
    of this Java code:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过扩展我们的树来实现另一个方法，`size`。我们将为每个`node`和`mt`编写一个“扩展”（你可能想说是“子类”，但现在请稍等！）来实现`size`方法。我们打算这些扩展现有的`node`和`mt`定义，所以我们将使用上面描述的扩展模式。换句话说，如果我们之前有这个Java代码的大致等价物：
- en: '[PRE112]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'now we want to extend it:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想扩展它：
- en: '[PRE113]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Aside: We’re not editing the existing definitions because that is supposed
    to be the whole point of object inheritance: to reuse code in a black-box fashion.
    This also means different parties, who do not know one another, can each extend
    the same base code. If they had to edit the base, first they have to find out
    about each other, and in addition, one might dislike the edits of the other. Inheritance
    is meant to sidestep these issues entirely.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们不是在编辑现有的定义，因为这应该是对象继承的全部要点：以黑盒方式重用代码。这也意味着不同的各方，彼此之间并不了解，可以各自扩展相同的基代码。如果他们必须编辑基类，首先他们必须了解彼此，而且，一方可能不喜欢另一方的编辑。继承的目的是完全避开这些问题。
- en: 'Aside: Relatedly, read about the [fragile base class problem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Fragile_base_class&sa=D&source=editors&ust=1695232021308845&usg=AOvVaw0jUQoyWZ_AaVZEFstRRSte).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，相关内容请阅读关于[脆弱基类问题](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Fragile_base_class&sa=D&source=editors&ust=1695232021308845&usg=AOvVaw0jUQoyWZ_AaVZEFstRRSte)的介绍。
- en: A Java Excursion
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java探险
- en: 'Let’s first understand what’s going on in Java. For simplicity, let’s use a
    canonical “2d point” and “3d point” example. We’ll start with this class:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解Java中正在发生的事情。为了简单起见，让我们使用一个标准的“二维点”和“三维点”示例。我们将从这个类开始：
- en: '[PRE114]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can make instances of it easily enough:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地创建它的实例：
- en: '[PRE115]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'and this prints the expected output. Now suppose we extend this class:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出预期的输出。现在假设我们扩展这个类：
- en: '[PRE116]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This won’t even compile. We will get a somewhat strange-looking error. The error
    is because Java is expecting to make an instance of `Pt2`as well, but we have
    not told it how to. In the absence of anything else, it invokes a “default constructor”,
    which takes noparameters (because Java has no way of knowing which parameters
    to pass). If we modify `Pt2` to instead be
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至无法编译。我们将得到一个看起来有些奇怪的错误。错误是因为Java期望创建一个`Pt2`实例，但我们没有告诉它如何创建。在没有其他东西的情况下，它调用了一个“默认构造函数”，该构造函数不接受任何参数（因为Java没有知道要传递哪些参数的方法）。如果我们修改`Pt2`以使其
- en: '[PRE117]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: then we find that the program compiles and, if we change `Main` suitably,
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们发现程序可以编译，如果我们适当地更改`Main`，
- en: '[PRE118]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'it runs, but perhaps without the effect we were expecting. The solution, in
    Java terms, is to explicitly invoke the constructor of the super-class:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行了，但可能没有达到我们预期的效果。在Java术语中，解决方案是显式调用超类的构造函数：
- en: '[PRE119]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'but this won’t work either: Java expects the `super`invocation to be the first thing
    in the sub-class’s constructor.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 但这也不会起作用：Java期望在子类的构造函数中首先调用`super`。
- en: 'As the error message above reveals, hidden in the constructor of the extended
    class is lurking something important: it tries to create an instanceof the super-class,
    just as if we had written `new Pt2`. This is entirely masked by the syntactic
    sugar of `super`. The actual `Pt2` instance is hidden out of sight, and it takes
    a little effort to coax it into view.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的错误信息所示，在扩展类的构造函数中隐藏着一些重要的事情：它试图创建一个超类的实例，就像我们写了`new Pt2`一样。这完全被`super`的语法糖所掩盖。实际的`Pt2`实例隐藏在视线之外，需要一点努力才能将其呈现出来。
- en: 'To see it, let’s first add some instance variables:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到它，让我们首先添加一些实例变量：
- en: '[PRE120]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We’ve purposely made the instance variables have values that look different
    from those of the parameters, so that when we try to examine them, we can tell
    them apart. Now let’s modify the constructor to make two objects:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意使实例变量的值看起来与参数不同，这样当我们尝试检查它们时，我们可以区分它们。现在让我们修改构造函数来创建两个对象：
- en: '[PRE122]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Twoobjects…how many objects did we really make? Well, we made at least two,
    because adding
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象……我们实际上创建了几个对象？好吧，我们至少创建了两个，因为添加
- en: '[PRE123]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: to the constructor shows that there are two different objects with two different
    values for `x`. So far, so unsurprising.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数显示有两个不同的对象，它们的`x`值不同。到目前为止，这并不令人惊讶。
- en: 'However, I’ve claimed that there are two more objects, of type `Pt2`. Can we
    seethem? Yes, in fact, we can. The problem is that they’re of type `Pt2`, and
    what we have are `Pt3`objects. We can’t just make a `Pt2`, because that doesn’t
    reveal the hidden `Pt2`. But in fact the Java type system lets us get to the `Pt2`by
    casting:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我声称还有两个对象，类型为`Pt2`。我们能看到它们吗？是的，实际上我们可以。问题是它们是`Pt2`类型的，而我们有的是`Pt3`对象。我们无法直接创建一个`Pt2`，因为这不会揭示隐藏的`Pt2`。但事实上，Java类型系统允许我们通过类型转换来获取`Pt2`：
- en: '[PRE124]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: And that’s how we can see that there are actually two `Pt2` objects lurking
    as well!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，我们实际上还有两个隐藏的`Pt2`对象！
- en: Extending Classes
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展类
- en: Now we have to port all this code over to our world of desugaring. Is this the
    constructor pattern?
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将所有这些代码移植到我们的去糖化世界中。这是构造函数模式吗？
- en: '[PRE125]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: That suggests that the parent is at the “same level” as the object’s constructor
    fields. That seems reasonable, in that once all these parameters are given, the
    object is “fully defined”. However, we also still have
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明父类与对象的构造函数字段处于“同一级别”。这似乎是合理的，因为一旦所有这些参数都给出，对象就是“完全定义”的。然而，我们仍然有
- en: '[PRE126]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The crucial issue here is that we need to make twoobjects: one of `node/size`and
    one more of `node`. We could imagine a protocol where the user of `node/size`constructs
    a `node`object and passes it to `node/size`, but in doing so, they could make
    any number of mistakes. Alternatively, we can leave it to `node/size`to invoke
    node, and keep track of the object constructed through this process. That is,
    `node/size`’s parent parameter should not be the parent objectbut rather the parent
    object’s maker.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的问题是，我们需要创建两个对象：一个是`node/size`，另一个是`node`。我们可以想象一个协议，其中`node/size`的用户构建一个`node`对象并将其传递给`node/size`，但在这样做的时候，他们可能会犯任何数量的错误。或者，我们可以让`node/size`调用node，并跟踪通过这个过程构建的对象。也就是说，`node/size`的父参数不应该是父对象，而应该是父对象的创建者。
- en: '[PRE127]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Then the object constructor must remember to pass the parent-object maker on
    every invocation:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对象构造函数必须记住在每次调用时传递父对象创建者：
- en: '[PRE128]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Aside:Note the repeated pattern of invoking the “super” class: e.g., `(mt/size
    mt)`. We would instead want to do this just once. Essentially, this binding of
    `mt/size`to `mt`is precisely what the `extends` clause of Java does. We could
    simulate that here, but later in this chapter we’ll see a much more elegant way
    of achieving this end while also making programming with classes much more flexible.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：注意调用“超类”的重复模式：例如，（mt/size mt）。我们宁愿只做一次。本质上，这个将`mt/size`绑定到`mt`的过程正是Java中的`extends`子句所做的事情。我们可以在这里模拟它，但在这个章节的后面，我们将看到一种更优雅的方法来实现这一目标，同时使使用类进行编程更加灵活。
- en: 'We can confirm that both the old and new tests still work:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认旧的和新的测试仍然有效：
- en: '[PRE129]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Exercise: Rewrite this block of code using self-application instead of mutation.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使用自我应用而不是变异重写这段代码块。
- en: 'What we have done is capture the essence of a class. Each function parameterized
    over a parent is...well, it’s a bit tricky, really. Let’s call it a class extension—we’ll
    soon see why. A class extension corresponds to what a Java programmer defines
    when they write:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是捕捉一个类的本质。每个在父类上参数化的函数……嗯，实际上有点棘手。让我们称它为类扩展——我们很快就会看到原因。类扩展对应于Java程序员在编写代码时定义的内容：
- en: '[PRE130]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Exercise: So why are we going out of the way to not call it a “class”?
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：为什么我们故意不称它为“类”？
- en: When a developer invokes a Java class’s constructor, it in effect constructs
    objects all the way up the inheritance chain (in practice, a compiler might optimize
    this to require only one constructor invocation and one object allocation). These
    are effectively “personal” copies of the objects corresponding to the parent classes
    (personal, that is, up to the presence of static members). There is, however,
    a question of how much of these objects is visible. Java chooses that—unlike in
    our implementation above—only one method of a given name (and signature) remains,
    no matter how many there might have been on the inheritance chain, whereas every
    field remains in the result, and can be accessed by casting. The latter makes
    some sense because each field presumably has invariants governing it, so keeping
    them separate (and hence all present) is wise. In contrast, it is easy to imagine
    an implementation that also makes all the methods available, not only the ones
    lowest (i.e., most refined) in the inheritance hierarchy. Many scripting languages
    take the latter approach.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者调用Java类的构造函数时，实际上是在继承链的顶端构建对象（在实践中，编译器可能会优化这一点，只需要调用一个构造函数和分配一个对象）。这些实际上是“个人”的对应于父类的对象副本（个人，即直到静态成员的存在）。然而，有一个问题是这些对象中有多少是可见的。Java选择的是——与我们的实现不同——无论在继承链上有多少个同名（和签名）的方法，只有一个方法保留，而每个字段都保留在结果中，可以通过类型转换来访问。后者是有道理的，因为每个字段可能都有控制它的不变量，所以保持它们分开（因此全部存在）是明智的。相比之下，可以想象一个实现也使所有方法都可用，而不仅仅是继承层次结构中最底层（即最精细）的方法。许多脚本语言采用后一种方法。
- en: 'Exercise:The code above is not what we would reallywant as programmers. The
    self-reference is to the same syntactic object, whereas it needs to refer to the
    most-refined object: this is known as open recursion. Modify the object representations
    so that self always refers to the most refined version of the object. Hint: You
    will find the self-application method (Self-Reference Without Mutation) of recursion
    handy.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：上面的代码并不是我们作为程序员真正想要的。这里的自引用是指同一个句法对象，而它需要引用最精细的对象：这被称为开放递归。修改对象表示，使self始终指向对象的最精细版本。提示：你会发现递归的自应用方法（Self-Reference
    Without Mutation）对递归很有用。
- en: 'Aside:This demonstrates the other form of extensibility we get from traditional
    objects: extensible recursion.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：这展示了从传统对象中获得的另一种扩展形式：可扩展递归。
- en: Extending Prototypes
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展原型
- en: 'In our description above, we’ve supplied each class with a description of its
    parent class. Object construction then makes instances of each as it goes up the
    inheritance chain. There is another way to think of the parent: not as a class
    to be instantiated but, instead, directly as an object itself. Then all children
    with the same parent would observe the very same object, which means changes to
    it from one child object would be visible to another child. The shared parent
    object is known as a prototype.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的描述中，我们为每个类提供了一个其父类的描述。对象构造时，它会沿着继承链创建每个类的实例。还有一种思考父类的方式：不是将其视为一个要实例化的类，而是直接将其视为一个对象本身。然后所有具有相同父类的子类都会观察到同一个对象，这意味着一个子对象对其的更改对另一个子对象是可见的。共享的父对象被称为原型。
- en: Aside:The archetypal prototype-based language is [Self](https://www.google.com/url?q=http://selflanguage.org/&sa=D&source=editors&ust=1695232021325680&usg=AOvVaw34T7y09URpNkHh7uTLFlXk).
    Though you may have read that languages like JavaScript are “based on” Self, there
    is value to studying the idea from its source, especially because Self presents
    these ideas in their purest form.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：典型的基于原型的语言是[Self](https://www.google.com/url?q=http://selflanguage.org/&sa=D&source=editors&ust=1695232021325680&usg=AOvVaw34T7y09URpNkHh7uTLFlXk)。尽管你可能已经读到像JavaScript这样的语言是“基于”Self的，但研究其源头中的想法是有价值的，尤其是因为Self以最纯粹的形式呈现了这些想法。
- en: 'Some language designers have argued that prototypes are more primitive than
    classes in that, with other basic mechanisms such as functions, one can recover
    classes from prototypes—but not the other way around. That is essentially what
    we have done above: each “class” function contains inside it an object description,
    so a class is an object-returning-function. Had we exposed these as two different
    operations and chosen to inherit directly an object, we would have something akin
    to prototypes.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言设计者认为，与类相比，原型更原始，因为在其他基本机制（如函数）中，可以从原型中恢复类，但不能反过来。这正是我们上面所做的那样：每个“类”函数内部都包含一个对象描述，因此类是一个返回对象的函数。如果我们将这些暴露为两种不同的操作，并选择直接继承对象，那么我们就会得到类似原型的东西。
- en: Exercise: Modify the inheritance pattern above to implement a Self-like, prototype-based
    language, instead of a class-based language. Because classes provide each object
    with distinct copies of their parent objects, a prototype-language might provide
    a “clone” operation to simplify creation of the operation that simulates classes
    atop prototypes.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：修改上述继承模式以实现类似于Self的、基于原型的语言，而不是基于类的语言。因为类为每个对象提供了其父对象的独立副本，所以原型语言可能提供一个“克隆”操作来简化在原型之上模拟类的操作。
- en: Multiple Inheritance
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重继承
- en: Now you might ask, why is there only one fall-through option? It’s easy to generalize
    this to there being many, which leads naturally to multiple inheritance. In effect,
    we have multiple objects to which we can chain the lookup, which of course raises
    the question of what order in which we should do so.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问，为什么只有一个穿透选项？很容易推广到有多个选项，这自然导致多重继承。实际上，我们有多个对象可以将其查找链式连接，这当然会引发我们应该以何种顺序进行的问题。
- en: 'It would be bad enough if the ascendants were arranged in a tree, because even
    a tree does not have a canonical order of traversal: take just breadth-first and
    depth-first traversal, for instance (each of which has compelling uses). Worse,
    suppose a blob A extends B and C; but now suppose B and C each extend D. Now we
    have to confront this question: will there be one or two D objects in the instance
    of A? Having only one saves space and might interact better with our expectations,
    but then, will we visit this object once or twice? Visiting it twice should not
    make any difference, so it seems unnecessary. But visiting it once means the behavior
    of one of B or C might change. And so on. As a result, virtually every multiple-inheritance
    language is accompanied by a subtle algorithm merely to define the lookup order.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果祖先被安排在一棵树中，那已经足够糟糕了，因为即使是树也没有遍历的规范顺序：例如，广度优先遍历和深度优先遍历（每个都有其有力的用途）。更糟糕的是，假设一个Blob
    A扩展了B和C；但现在假设B和C各自扩展了D。现在我们必须面对这个问题：在A的实例中会有一个还是两个D对象？只有一个可以节省空间，并且可能与我们的期望更好地交互，但那样的话，我们会访问这个对象一次还是两次？访问两次应该不会有什么区别，所以这似乎是不必要的。但访问一次意味着B或C中的一个的行为可能会改变。以此类推。因此，几乎每一种多重继承的语言都伴随着一个微妙的算法，仅仅是为了定义查找顺序。
- en: This infamous situation is called the [“diamond problem”](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Multiple_inheritance&sa=D&source=editors&ust=1695232021327121&usg=AOvVaw33E5ifiPPmd1ChrRegan9z) (or
    even, “the Deadly Diamond of Death”!). If you choose to include multiple inheritance
    in your language you can lose yourself for days in design decisions on this. Because
    it is highly unlikely you will find a canonical answer, your pain will have only
    begun. Multiple inheritance is only attractive until you’ve thought it through.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这种臭名昭著的情况被称为[“菱形问题”（“diamond problem”）](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Multiple_inheritance&sa=D&source=editors&ust=1695232021327121&usg=AOvVaw33E5ifiPPmd1ChrRegan9z)（或者甚至称为“致命的菱形死亡”）。如果你选择在你的语言中包含多重继承，你可能会在关于这个问题的设计决策上迷失数日。因为找到规范答案的可能性非常低，你的痛苦才刚刚开始。多重继承只有在深入思考之后才具有吸引力。
- en: 'Class Extensions: Mixins and Traits'
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类扩展：混入（Mixins）和特性（Traits）
- en: 'When we write `class`in Java, what are we really defining between the opening
    and closing braces? It is not the entire class: that depends on the parent that
    it extends, and so on recursively. Rather, what we define inside the braces is
    a class extension. It only becomes a full-blown class because we also identify
    the parent class in the same place.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Java中写`class`时，我们在大括号之间实际上定义了什么？它不是整个类：这取决于它所扩展的父类，以及递归地向上。相反，我们在大括号内定义的是一个类扩展。它之所以成为一个完整的类，仅仅是因为我们在同一个地方也确定了父类。
- en: 'Naturally, we should ask: Why? Why not separate the act of definingan extension
    from applying the extension to a base class? That is, suppose instead of'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们应该问：为什么？为什么不将定义扩展的行为与应用到基类上的行为分开？也就是说，假设不是
- en: '[PRE131]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'we instead write:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改写为：
- en: '[PRE132]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: and separately
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 并且单独
- en: '[PRE133]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: where `B` is some already-defined class?
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`B`是某个已经定义好的类？
- en: 'Thus far, it looks like we’ve just gone to great lengths to obtain what we
    had before. However, the function-application-like syntax is meant to be suggestive:
    we can “apply” this extension to several different base classes. Thus:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，看起来我们只是费尽心思去获得我们之前已经拥有的东西。然而，这种类似于函数应用的语法是为了启发性的：我们可以“应用”这种扩展到几个不同的基类。因此：
- en: '[PRE134]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'and so on. What we have done by separating the definition of `E`from that of
    the class it extends is to liberate class extensions from the tyranny of the fixed
    base class. We have a name for these extensions: they’re called mixins.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推。通过将`E`的定义与它所扩展的类的定义分开，我们所做的是使类扩展摆脱了固定基类的专制。我们给这些扩展起了一个名字：它们被称为混入（mixins）。
- en: Mixins make class definition more compositional. They provide many of the benefits
    of multiple-inheritance (reusing multiple fragments of functionality) but within
    the aegis of a single-inheritance language (i.e., no complicated rules about lookup
    order). Observe that when desugaring, it’s actually quite easy to add mixins to
    the language. A mixin is just a “function over classes”. Because we have already
    determined how to desugar classes, and our target language for desugaring also
    has functions, and classes desugar to expressions that can be nested inside functions,
    it becomes almost trivial to implement a simple model of mixins.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 混入使类定义更具组合性。它们提供了多重继承（重用多个功能片段）的许多好处，但都在单一继承语言的庇护下（即，没有关于查找顺序的复杂规则）。观察当去糖化时，实际上很容易将混入添加到语言中。混入只是一个“类上的函数”。因为我们已经确定了如何去糖化类，我们的去糖化目标语言也有函数，并且类去糖化成可以在函数内部嵌套的表达式，因此实现一个简单的混入模型几乎变得微不足道。
- en: Aside:This is a case where the greater generality of the target language of
    desugaring can lead us to a better construct, if we reflect it back into the source
    language.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：这是一个情况，目标语言的更大通用性可以引导我们得到更好的构造，如果我们将其反映回源语言。
- en: 'In a typed language, a good design for mixins can actually improve object-oriented
    programming practice. Suppose we’re defining a mixin-based version of Java. If
    a mixin is effectively a class-to-class function, what is the “type” of this “function”?
    Clearly, mixins ought to use interfacesto describe what they expect and what they
    provide. Java already enables (but does not require) the latter, namely classes
    can say what interfaces they provide. However, it does not enable the former,
    namely specifying its parent as an interface: a class (extension) in Java extends
    its parent class—with all the parent’s members visible to the extension—rather
    than an interface that stands forthe parent (or any other class that matches that
    same interface). That means it obtains all of the parent’s behavior, not a specification
    thereof. In turn, if the parent changes, the class might break. Mixins help break
    this asymmetry between extension and provision.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向类型的语言中，混入的良好设计实际上可以改善面向对象编程实践。假设我们正在定义一个基于混入的 Java 版本。如果混入实际上是一个类到类的函数，那么这个“函数”的“类型”是什么？显然，混入应该使用接口来描述它们期望的和提供的。Java
    已经允许（但不要求）后者，即类可以声明它们提供的接口。然而，它并没有允许前者，即指定其父类为一个接口：Java 中的类（扩展）扩展其父类——所有父类的成员对扩展可见——而不是代表父类（或任何其他匹配相同接口的类）。这意味着它获得了所有父类的行为，而不是其规范。反过来，如果父类发生变化，类可能会损坏。混入有助于打破扩展和提供之间的这种不对称性。
- en: In a mixin language, we can instead write
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在混入语言中，我们可以写成
- en: '[PRE135]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'where `I1`and `I2` are interfaces. Then `M`can only be applied to a class that
    satisfies the interface `I1`, and in turn the language can ensure that only members
    specified in` I1`are visible in `M`. This becomes directly analogous to how a
    client of `M`can only see what is provided by `I2`, and follows one of the important
    principles of good software design:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `I1` 和 `I2` 是接口。然后 `M` 只能应用于满足接口 `I1` 的类，并且语言可以确保只有 `I1` 中指定的成员在 `M` 中可见。这直接类似于
    `M` 的客户端只能看到 `I2` 提供的内容，并遵循软件设计的重要原则之一：
- en: Quote: “Program to an interface, not an implementation.” —[Design Patterns](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Design_Patterns&sa=D&source=editors&ust=1695232021331399&usg=AOvVaw0oLqFKll63oSL1E3kTxWev)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 引用：“面向接口编程，而不是面向实现。” ——[设计模式](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Design_Patterns&sa=D&source=editors&ust=1695232021331399&usg=AOvVaw0oLqFKll63oSL1E3kTxWev)
- en: 'In short, a mixin is a class that has been turned into a function over parent
    classes:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，混入（mixin）是一种被转换成函数的类，它作用于父类：
- en: '[PRE136]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'A good design for mixins can go even further. A class can only be used once
    in an inheritance chain, by definition (if a class eventually referred back to
    itself, there would be a cycle in the inheritance chain, causing potential infinite
    loops). In contrast, when we compose functions, we have no qualms about using
    the same function twice (e.g.: `(map ... (filter ... (map ...))))`. Is there value
    to using a mixin twice?'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混入的良好设计可以更进一步。一个类在继承链中只能被使用一次，这是定义上的（如果一个类最终指回自己，继承链中会出现循环，导致潜在的无限循环）。相比之下，当我们组合函数时，我们并不介意使用同一个函数两次（例如：（map
    ... (filter ... (map ...))))。使用混入两次是否有价值？
- en: Aside:There certainly is! See sections 3 and 4 of [Classes and Mixins](https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/&sa=D&source=editors&ust=1695232021332340&usg=AOvVaw2wOohANSHEwTtdW3WtYZHP).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：当然有！请参阅[类和混入](https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/&sa=D&source=editors&ust=1695232021332340&usg=AOvVaw2wOohANSHEwTtdW3WtYZHP)的第3和第4节。
- en: 'Mixins solve an important problem that arises in the design of libraries. Suppose
    we have a dozen different features which can be combined in different ways. How
    many classes should we provide? Furthermore, not all of these can be combined
    with each other. It is obviously impractical to generate the entire combinatorial
    explosion of classes. It would be better if the developer could pick and choose
    the features they care about, with some mechanism to prevent unreasonable combinations.
    This is precisely the problem that mixins solve: they provide the class extensions,
    which the developers can combine, in an interface-preserving way, to create just
    the classes they need.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 混入解决了在库设计中出现的一个重要问题。假设我们有十几种不同的特性，它们可以以不同的方式组合。我们应该提供多少个类？此外，并非所有这些特性都可以相互组合。显然，生成整个组合爆炸的类是不切实际的。如果开发者能够选择他们关心的特性，并有一些机制来防止不合理的组合，那就更好了。这正是混入解决的问题：它们以接口保留的方式提供类扩展，开发者可以组合这些扩展，以创建他们需要的类。
- en: Aside:Mixins are used extensively in the Racket GUI library. For instance, `color:text-mixin` consumes
    basic text editor interfaces and implements the colored text editor interface.
    The latter is itself a basic text editor interface, so additional basic text mixins
    can be applied to the result.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：混入在Racket GUI库中被广泛使用。例如，`color:text-mixin`消耗基本的文本编辑器接口并实现了彩色文本编辑器接口。后者本身也是一个基本的文本编辑器接口，因此可以应用额外的基本文本混入到结果中。
- en: Exercise: How does the analogous library in your favorite object-oriented language
    solve this same problem?
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：你最喜欢的面向对象语言中类似的库是如何解决这个相同问题的？
- en: 'Mixins do have one limitation: they enforce a linearity of composition. This
    strictness is sometimes misplaced, because it puts a burden on programmers that
    may not be necessary. A generalization of mixins called traits says that instead
    of extending a single mixin, we can extend a set of them. Of course, the moment
    we extend more than one, we must again contend with potential name-clashes. Thus
    traits must be equipped with mechanisms for resolving name clashes, often in the
    form of some name-combination algebra. Traits thus offer a nice complement to
    mixins, enabling programmers to choose the mechanism that best fits their needs.
    As a result, Racket provides both mixins and traits.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 混入确实有一个限制：它们强制执行组合的线性。这种严格性有时是错误的，因为它给程序员带来了可能不必要的负担。混入的泛化称为特性（traits），它表明我们不仅可以扩展单个混入，还可以扩展一组混入。当然，当我们扩展多个混入时，我们必须再次应对潜在的名字冲突。因此，特性必须配备解决名字冲突的机制，通常是以某种名字组合代数的形式。因此，特性为混入提供了一个很好的补充，使程序员能够选择最适合他们需求的机制。结果，Racket提供了混入和特性。
- en: ••••• Types •••••
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ••••• 类型 •••••
- en: Types that are checked before program execution—what are known as static types—are
    a vital part of programming, and a growing number of languages either have them
    from the start or, realizing their importance, are adding them in various forms.
    Types are a common first step towards proving properties about programs. If you
    use a typed language, you write small proofs about your programs every day, whether
    you realize it or not.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行前检查的类型——通常称为静态类型——是编程的重要组成部分，越来越多的语言要么从一开始就有它们，要么意识到它们的重要性，正在以各种形式添加它们。类型是证明程序属性的一个常见第一步。如果你使用类型化语言，你每天都在写关于你程序的小证明，无论你是否意识到这一点。
- en: Introduction to Types
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型介绍
- en: We’re done with objects. Why weren’t objects in SMoL?
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对象。为什么SMoL中没有对象？
- en: Not all languages have them.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并非所有语言都有它们。
- en: The ones that do have them can’t seem to agree on the details (classes versus
    prototypes, single- versus multiple-inheritance, classes versus traits and mixins,
    etc.). There’s very little “standard” there.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那些有它们的人似乎在细节上无法达成一致（类与原型，单继承与多继承，类与特性与混入等）。那里几乎没有“标准”。
- en: We can add most notions through desugaring!
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过去糖化添加大多数概念！
- en: Now we move on to types. We will always use the term typeto refer to a static check,
    i.e., one that can be done purely with the program source. This means types cannot
    refer to dynamic conditions, and may suffer from either false-positive or false-negative
    errors (e.g., something that is in the code but can never run in practice may
    still cause a type error); in return, they give us guarantees without ever having
    to run the program. This is important when the program is expensive to run, impossible
    (e.g., it depends on conditions that can’t be reproduced by the developer), or
    dangerous.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论类型。我们总是使用术语“类型”来指代静态检查，即纯粹通过程序源代码就能完成的检查。这意味着类型不能引用动态条件，并且可能会出现误报或漏报错误（例如，代码中存在但实际运行中永远无法执行的东西仍可能导致类型错误）；作为回报，它们为我们提供了保证，而无需运行程序。当程序运行成本高昂、无法执行（例如，它依赖于开发者无法重现的条件）或危险时，这一点很重要。
- en: 'Types aren’t really a part of SMoL either, but not because we can add them
    through desugaring (which we can’t); rather, it’s for the first two reasons: many
    languages don’t have them, and those that do don’t often agree on their form (in
    large part because of their disagreement over the nature of objects). However,
    there are parts they do (largely) agree on, which we will begin with.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 类型实际上也不是SMoL的一部分，但这并不是因为我们可以通过去糖化来添加它们（我们做不到）；而是因为前两个原因：许多语言没有类型，而那些有类型的语言通常对它们的格式没有共识（在很大程度上是因为它们对对象本质的不同看法）。然而，它们在某些方面（在很大程度上）是达成一致的，我们将从这里开始。
- en: A Standard Model of Types
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型标准模型
- en: 'Types can be thought of as abstractions of run-time values. That is, whereas
    at run-time we can have a very large number of numbers and strings and images
    (and two Booleans), we will collapse the distinctions withinthese and preserve
    only the distinctions between them. Therefore, it is instructive to start with
    a basic interpreter and try to build a type checker from there:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将类型视为运行时值的抽象。也就是说，在运行时，我们可以有大量数字、字符串和图像（以及两个布尔值），我们将合并这些区别，并仅保留它们之间的区别。因此，从基本解释器开始，并尝试从中构建类型检查器是有教育意义的：
- en: '[PRE137]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now let’s see what needs to happen with a type-checker. The label on the tin
    says “checker”: that is, the job of a type-checker is to pass judgment on programs,
    i.e., to determine whether or not they are type-correct. Thus, a natural type
    (for the type checker) would be'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看类型检查器需要做什么。罐子上面的标签写着“检查器”：也就是说，类型检查器的任务是评判程序，即确定它们是否类型正确。因此，对于类型检查器来说，一个自然的类型会是
- en: '`(tc : (Exp ->` Boolean`))`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`(tc : (Exp ->` Boolean`))`'
- en: '(In practice, of course, we would want more information in case the program
    is not type-correct, i.e., we’d like an error diagnostic. But we’re ignoring human
    factors considerations here.) With this type, we can now rewrite the relevant
    parts of the interpreter above:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: （在实践中，当然，如果程序类型不正确，我们希望得到更多信息，即我们希望有一个错误诊断。但在这里我们忽略了人为因素考虑。）有了这种类型，我们现在可以重写上面解释器中相关的部分：
- en: '`(define (`tc` e)`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (`tc` e)`'
- en: '[PRE142]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '`       [(plus) (`and` (`tc` l) (`tc` r))])]`'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`       [(plus) (`and` (`tc` l) (`tc` r))])]`'
- en: '`[(numE v)` #true`]))`'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(numE v)` #true`]))`'
- en: '`(test (`tc`(binE (plus) (numE 5) (numE 6)))` #true`)`'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`(test (`tc`(binE (plus) (numE 5) (numE 6)))` #true`)`'
- en: Actually, let’s peer at this for a moment. Given a number, the type-checker
    returns `#true`. In the recursive cases, it computes the `and`of type-checking
    the pieces. And that’s it. Since there is no way to return `#false`, the entire
    type-checker must always only return `#true`. That is, every program is type-correct.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，让我们仔细看看这个。给定一个数字，类型检查器返回`#true`。在递归情况下，它计算类型检查各个部分的`and`。就是这样。由于没有返回`#false`的方法，整个类型检查器必须始终只返回`#true`。也就是说，每个程序都是类型正确的。
- en: The problem is because we have only one type, numbers, and only one operation,
    also on numbers, so what could possibly go wrong? We need to extend the types
    and operations so that there are meaningful possibilities for errors. Therefore,
    suppose we add a `++` operation that concatenates strings.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，因为我们只有一个类型，数字，以及一个操作，也是对数字的操作，所以可能出什么问题呢？我们需要扩展类型和操作，以便有意义的错误可能性。因此，假设我们添加一个`++`操作，该操作用于连接字符串。
- en: '[PRE143]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`[plus]` [++]`)`'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`[plus]` [++]`)`'
- en: '[PRE144]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[strE (value : String)]`)`'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[strE (value : String)]`)`'
- en: Various things break, and need to be fixed. How about this?
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 会有各种事情出错，需要修复。这个怎么样？
- en: '[PRE145]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[(++)   (and (tc l) (tc r))]`)]`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '[(++)   (and (tc l) (tc r))]`)]`'
- en: '[PRE146]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[(strE v) #true]`))`'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '[(strE v) #true]`))`'
- en: '(test (tc (binE (++) (strE "hello") (strE "world"))) #true)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '(test (tc (binE (++) (strE "hello") (strE "world"))) #true)'
- en: So this looks pretty good, right?
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这看起来相当不错，对吧？
- en: Do Now: This is not at all what we want! Write a test case that demonstrates
    that.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 立即行动：这根本不是我们想要的！编写一个测试用例来证明这一点。
- en: 'Here are two tests that demonstrate desirable behavior:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个测试用例展示了期望的行为：
- en: '[PRE147]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The first string-concatenates two numbers, the second adds two strings. Therefore,
    both should be rejected by the type-checker. Yet both of them pass (i.e., the
    tests above fail).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串连接两个数字，第二个添加两个字符串。因此，两者都应由类型检查器拒绝。然而，两者都通过了（即，上面的测试失败了）。
- en: What is the core problem here? It’s that, given an expression, we only know
    whetherits sub-expressions typed correctly, but not whattheir types are.  That
    is insufficient to determine whether the current expression is type-correct. For
    instance, the `++` operator needs to check not only whether its two sub-expressions
    are well-typed, but also whether they produced strings; if they did not, then
    the concatenation is erroneous.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的核心问题是什么？问题是，给定一个表达式，我们只知道其子表达式是否正确类型化，但不知道它们的类型。这不足以确定当前表达式是否类型正确。例如，`++`运算符需要检查不仅其两个子表达式是否类型良好，而且它们是否产生了字符串；如果没有，那么连接就是错误的。
- en: 'What this shows is that we need the type-checker to have a richer type: it
    must instead be'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们需要类型检查器拥有更丰富的类型：它必须改为
- en: '`(tc : (Exp ->` Type`))`'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`(tc : (Exp -> Type))`'
- en: That is, the type “checker” must actually be a type calculator, i.e., it even
    more closely parallels the evaluator, just over the universe of abstracted values
    (types) rather than concrete ones. Following convention, however, we’ll continue
    to call it a checker, because it also checks in the process of calculating types.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，“类型检查器”实际上必须是一个类型计算器，即它甚至更接近于评估器，只是在抽象值（类型）的宇宙而不是具体值上。然而，按照惯例，我们仍然将其称为检查器，因为它在计算类型的过程中也会进行检查。
- en: 'In the type declaration above, `Type` is a new (`plait` type) definition that
    records the possible types:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的类型声明中，`Type`是一个新的（`plait`类型）定义，它记录了可能的类型：
- en: '[PRE148]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'With this, we can rewrite our type-“checker”:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一点，我们可以重写我们的类型“检查器”：
- en: '[PRE149]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'There are three take-aways from this:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以得到三个要点：
- en: 'The type-checker follows the same implementation schema as the interpreter:
    an algebraic datatype to represent the AST, and structural recursion to process
    it. This is the schema we’re calling SImPl.'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型检查器遵循与解释器相同的实现模式：一个代数数据类型来表示AST，以及结构递归来处理它。这就是我们称之为SImPl的模式。
- en: 'A type-checker, unlike an interpreter, operates with “weak” values: note, for
    instance, how the `numE` case ignores the actual numeric values. Both the strengths
    and weaknesses of traditional type-checking arise from this ignorance.'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与解释器不同，类型检查器使用“弱”值：注意，例如`numE`情况忽略了实际的数值。传统类型检查的优缺点都源于这种无知。
- en: 'In mathematical terms, the upgrade we performed in going from a type-checker
    to a type-calculator was a process of strengthening the inductive hypothesis:
    instead of returning only a `Boolean`, we had to return the actual type of each
    expression. This may not seem like a literal strengthening; but it is inasmuch
    as the former `#true`has been replaced by a `Type`and the `#false` by an error.'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用数学术语来说，我们从类型检查器到类型计算器的升级是一个加强归纳假设的过程：我们不再只返回一个`Boolean`，而是必须返回每个表达式的实际类型。这看起来可能不是字面上的加强；但它在某种程度上是，因为前者`#true`已被替换为`Type`，而`#false`则被错误替换。
- en: Exercise: Add division to the language and type-check it.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：向语言中添加除法并对其进行类型检查。
- en: A Concise Notation
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简洁的符号
- en: As we extend our type system, it is increasingly unwieldy to write everything
    out as code. Instead, we will adopt a notation commonly used in the world of types
    (though it can also be used for interpreters and other SImPl programs). We will
    write terms of the form
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们类型系统的扩展，将所有内容都写出来作为代码变得越来越难以管理。因此，我们将采用在类型世界中常用的符号（尽管它也可以用于解释器和其他SImPl程序）。我们将写出形式为
- en: '[PRE152]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'where the `e`are expressions, `T`are types, and `:` is pronounced as “has type”:
    i.e., the notation above says “`e`has type `T`”. For now we won’t pronounce `|-` as
    anything at all; later, we will see that it should be read as “proves”.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`e`是表达式，`T`是类型，而`:`读作“具有类型”：即上面的符号表示“`e`具有类型`T`”。现在我们不会将`|-`读作任何东西；稍后，我们将看到它应该被读作“证明”。
- en: 'First, we can very concisely say that all numeric expressions have numeric
    type and all string expressions have string type:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以非常简洁地说，所有数值表达式都具有数值类型，所有字符串表达式都具有字符串类型：
- en: '[PRE153]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: where `n`stands for all the syntactic terms with the syntax of numbers, and
    `s` likewise for strings. (We can think of this as an infinite number of rules,
    one for each number and each string. We’re in the realm of mathematics, so what’s
    an infinite number of rules between friends?) The former is exactly equivalent
    to writing
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`n`代表所有具有数字语法的语法项，而`s`同样代表字符串。（我们可以将其视为无限多的规则，每个数字和每个字符串一个规则。我们处于数学领域，所以朋友之间有什么无限多的规则呢？）前者正好等同于写出
- en: '[PRE154]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: but much more concisely.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 但更为简洁。
- en: 'When we get to Booleans, we have a choice: we can either write'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达布尔值时，我们有一个选择：我们可以要么写
- en: '[PRE155]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'where `b` stands for all the syntactic terms with the syntax of Booleans, or—because
    there are only two of them—just enumerate them explicitly:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`b`代表所有具有布尔语法的语法项，或者——因为只有两个——明确地列举它们：
- en: '[PRE156]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Okay, so these correspond to the base cases of the type-checker. These are
    called axioms. Now let’s get to the conditionalcases, which are called (typing)
    rules. Remember our code for typing addition:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以这些对应于类型检查器的基例。这些被称为公理。现在让我们来看条件性案例，这些被称为（类型）规则。记住我们为加法类型编写的代码：
- en: '[PRE157]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'We can write it in this notation very concisely as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式非常简洁地写出它：
- en: '[PRE158]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We read the line as “if (what’s above) then (what’s below)”, and the space
    as “and”. So this says: “if `e1`has type `Num`and `e2`has type `Num`, then `(+
    e1 e2)`has type `Num`”. This is of course the exact same thing the code says,
    but with rather less noise.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这一行读作“如果（上面的内容）那么（下面的内容）”，并将空格读作“和”。所以这表示：“如果`e1`具有`Num`类型且`e2`具有`Num`类型，那么`(+
    e1 e2)`具有`Num`类型”。这当然是代码所说的完全相同的事情，但噪音要少得多。
- en: Terminology:The part above is called the antecedent(that which goes before)
    and the part below is called the consequent (that which comes after). Don’t call
    these the numerator and denominator!
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：上面部分称为前件（即先前的部分），下面部分称为后件（即随后的部分）。不要称这些为分子和分母！
- en: 'Growing Types: Division, Conditionals'
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型增长：除法，条件语句
- en: Handling Division
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理除法
- en: 'Addition, multiplication, and subtraction are totalfunctions over numbers:
    they consume two numbers and produce one. In contrast, division is a partial function:
    it isn’t defined when the denominator is zero. Therefore, we need a strategy for
    handling it. There are several available strategies:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 加法、乘法和减法是针对数字的全函数：它们消耗两个数字并产生一个。相比之下，除法是一个部分函数：当分母为零时，它没有定义。因此，我们需要一个处理它的策略。有几种可用的策略：
- en: We can declare that division doesn’t returna number but instead something else
    that captures its partiality, such as `(Optionof Number)`. This can work just
    fine. However, it means every single use of division will need to check whether
    it obtained a proper number or not. This can get quite onerous.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以声明除法不返回一个数字，而是返回其他一些捕获其部分性的东西，例如`(Option of Number)`。这可以很好地工作。然而，这意味着每次使用除法时都需要检查是否得到了一个合适的数字。这可能会变得相当繁琐。
- en: We can declare that division only consumesnon-zero numbers in its second argument.
    This is a major change to our type system, because until now we had lumped all
    numbers together into a single numeric type. This now affects all callers of division,
    who must now prove that they are not calling it on zero as the second argument.
    This is onerous in a different way. Observe that the type checker cannot automatically
    prove that a value is non-zero without error, because this is not decidable (see
    [Rice’s Theorem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&sa=D&source=editors&ust=1695232021350115&usg=AOvVaw1sfdnpfOgVLtiDbnXxEjlG)).
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以声明除法只消耗第二个参数中的非零数字。这对我们类型系统是一个重大改变，因为我们之前将所有数字都归入一个单一的数值类型。现在这影响了所有除法的调用者，他们现在必须证明他们没有将零作为第二个参数调用它。这以不同的方式变得繁琐。观察类型检查器不能在没有错误的情况下自动证明一个值是非零的，因为这是不可判定的（参见[Rice定理](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&sa=D&source=editors&ust=1695232021350115&usg=AOvVaw1sfdnpfOgVLtiDbnXxEjlG))。
- en: We give it the same type as other binary numeric operations, and declare that
    the exceptional case will be handled by an exception or error. This implicitly
    puts the burden on the rest of the program, which must be aware of this possibility
    and handle it.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们给它赋予与其他二进制数值操作相同的类型，并声明异常情况将由异常或错误处理。这隐式地将负担放在了程序的其他部分，这些部分必须意识到这种可能性并处理它。
- en: For more about general strategies for handling partial functions, see
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于处理部分函数的一般策略，请参阅
- en: '[https://dcic-world.org/2022-08-28/partial-domains.html](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&sa=D&source=editors&ust=1695232021350790&usg=AOvVaw1xa-O5dafyrpg45paMpzmj)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dcic-world.org/2022-08-28/partial-domains.html](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&sa=D&source=editors&ust=1695232021350790&usg=AOvVaw1xa-O5dafyrpg45paMpzmj)'
- en: Most programming languages have taken the third option above, which seems the
    most pragmatic. However, a growing number of languages are exploring the first
    two options. They get around Rice’s Theorem in the second case by trying to prove
    non-zero-ness and, when they cannot, putting the burden on the programmer. While
    this creates more effort for the programmer, it increases the program’s robustness.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都选择了上述第三个选项，这似乎是最实际的。然而，越来越多的语言正在探索前两个选项。在第二种情况下，它们通过尝试证明非零性来绕过Rice定理，当它们无法做到这一点时，就将负担放在程序员身上。虽然这给程序员带来了更多的工作，但它增加了程序的鲁棒性。
- en: Another Perspective on Types
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对类型的另一种看法
- en: We have already seen how we can think of types as abstractions of values, and
    type-checking as running a program over these abstract values. As we’ll soon see,
    the analogy will break down a bit.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们可以将类型视为值的抽象，将类型检查视为在这些抽象值上运行程序。正如我们很快就会看到的，这种类比将有点破裂。
- en: 'Another perspective is to think of types as a static discipline: a way of statically
    making judgments about programs. In a way, we have already been doing just this:
    it’s called parsing. A parser statically (i.e., before the program runs) passes
    judgment (i.e., decides that some programs are good and others are bad). Types
    can be viewed as an extension of this idea.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看法是将类型视为静态学科：一种静态判断程序的方式。在某种程度上，我们已经在做这件事了：它被称为解析。解析器在程序运行之前静态地做出判断（即决定某些程序是好的，而另一些是坏的）。类型可以被看作是这种想法的扩展。
- en: 'Aside:In computability theory terms, parsers are usually context-free, whereas
    types usually reflect context-sensitiveconstraints. Computability theory then
    helps us understand why we might separate these checks into two separate phases,
    and in particular why we might do one before the other. Essentially, the type-checker
    only needs to deal with programs that have already passed the parsing, i.e., context-free
    check, so it has much less complexity than if it had to do everything. We already
    saw this: our previous checker only consumed `Expr`s, which are produced by the
    parser.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：在可计算性理论术语中，解析器通常是上下文无关的，而类型通常反映上下文敏感约束。可计算性理论帮助我们理解为什么我们可能将这些检查分为两个单独的阶段，特别是为什么我们可能先做这个再做那个。本质上，类型检查器只需要处理已经通过解析的程序，即上下文无关检查，因此它的复杂性比必须做所有事情要小得多。我们之前已经看到了这一点：我们之前的检查器只消耗由解析器产生的`Expr`s。
- en: From Axioms and Rules to Judgments
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从公理和规则到判断
- en: 'When we need to apply type rules to a program, we compose them recursively,
    just as the type-checker runs. Consider this program:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要将类型规则应用于程序时，我们递归地组合它们，就像类型检查器运行的方式一样。考虑这个程序：
- en: '[PRE159]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To decide its type, we will use our current rules [[👉](PLAIVersion3.2.2_split_091.html#h.bd3i224rr6yk)].
    Observe that it does not fit any axiom, because the program does not match the
    syntax of a single number or string. Therefore, we have to use a conditional rule.
    We have seen only one so far, and fortunately this term does match the consequent:
    it requires two terms, and we have two terms, so `e1`is `5`and `e2`is `(+ 6 7)`.
    Therefore, applying this conditional rule, we get:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定其类型，我们将使用我们当前的规则 [[👉](PLAIVersion3.2.2_split_091.html#h.bd3i224rr6yk)]。观察它不符合任何公理，因为程序不符合单个数字或字符串的语法。因此，我们必须使用条件规则。我们迄今为止只看到了一个，幸运的是，这个术语与结果相匹配：它需要两个术语，我们有两个术语，所以`e1`是`5`，`e2`是`(+
    6 7)`。因此，应用这个条件规则，我们得到：
- en: '[PRE160]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'So far, so good. Now let’s look at the two terms in the antecedent. The first
    one now actually matches to an axiom; therefore, we’ll mark that in green and
    can stop with that:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在让我们看看前提中的两个术语。第一个现在实际上与一个公理相匹配；因此，我们将用绿色标记它，并可以停止：
- en: '|- 5 : Num`    |- (+ 6 7) : Num`'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 5 : Num`    |- (+ 6 7) : Num`'
- en: '[PRE161]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'For the other, we have to apply the same conditional rule again:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个，我们必须再次应用相同的条件规则：
- en: '[PRE162]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '|- 5 : Num`    |- (+ 6 7) : Num`'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 5 : Num`    |- (+ 6 7) : Num`'
- en: '[PRE163]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'These new terms also match the axiom for numbers, so we can mark them also
    in green:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新术语也符合数字的公理，因此我们也可以用绿色标记它们：
- en: '|- 6 : Num|- 7 : Num'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 6 : Num|- 7 : Num'
- en: '[PRE164]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '|- 5 : Num`    |- (+ 6 7) : Num`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 5 : Num`    |- (+ 6 7) : Num`'
- en: '[PRE165]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Every part of the tree now terminates in an axiom. We therefore consider this
    program to have successfully type-checked. This tree is called a judgment, because
    it passes judgment on the initial term: in this case, judging it to have type-checked
    and to produce a value of type `Num`.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 树的每一部分现在都以公理结束。因此，我们考虑这个程序已经成功通过了类型检查。这棵树被称为判断，因为它对初始项进行了判断：在这种情况下，判断它已经通过了类型检查并产生了一个
    `Num` 类型的值。
- en: Observe closely that this is the same pattern of execution we had with the type-checker!
    The difference is that we were able to skip the tedious details of passing and
    returning things, and instead simply used pattern-matching. This will save us
    a fair bit of work as we go forward.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，这与我们在类型检查器中遇到的执行模式相同！区别在于我们能够跳过传递和返回事物的繁琐细节，而是简单地使用模式匹配。这将在我们前进的过程中节省我们不少工作。
- en: Judgments and Errors
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 判断和错误
- en: 'Let’s see another example, which will illustrate an important principle:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，它将说明一个重要的原则：
- en: '[PRE166]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This proceeds analogously to the previous example. This leaves us with the
    following attempted judgment:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面的例子类似。这让我们得到了以下尝试的判断：
- en: '|- 6 : Num`    |- "hi" : Num`'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 6 : Num` |- "hi" : Num`'
- en: '[PRE167]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '|- 5 : Num`    |- (+ 6 "hi") : Num`'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 5 : Num` |- (+ 6 "hi") : Num`'
- en: '[PRE168]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'But now we have a problem: we need to type-check'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们遇到了一个问题：我们需要类型检查
- en: '[PRE169]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'but we don’t have a rule that matches. Therefore, we cannot construct a successful
    tree:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们没有匹配的规则。因此，我们无法构建一个成功的树：
- en: '|- 6 : Num|- "hi" : Num'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 6 : Num|- "hi" : Num'
- en: '[PRE170]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '|- 5 : Num`    |- (+ 6 "hi") :`'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 5 : Num` |- (+ 6 "hi") :`'
- en: '[PRE171]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Remember the “if … and … then” interpretation. Because we cannot satisfy all
    the antecedents, we cannot prove anything about the consequents, leaving the tree
    incomplete.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 记住“如果……并且……那么”的解释。因为我们无法满足所有前件，所以我们无法对后件进行任何证明，这使得树不完整。
- en: A type error is simply a failure to construct a judgment. It may not be the
    most satisfying user feedback, but our concern here is with a concise way of expressing
    ideas; going from this to an implementation is not too hard, and the user interface
    details can be added to the latter.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误简单地是指无法构建一个判断。这可能不是最令人满意的用户反馈，但我们的关注点在于以简洁的方式表达思想；从这一点到实现并不太难，用户界面细节可以添加到后面。
- en: 'This requires some clarification. We only call it a judgment if the tree is
    “checked off” completely: i.e., every antecedent is generated using given rules,
    and all the leaves are actual axioms. In this example, we are unable to check
    off the tree: there is no available rule oraxiom that lets us conclude that `"hi"`is
    a `Num`. Therefore, we cannot “judge” the initial expression. This is a technical
    meaning of the word judgment, not to be confused with potentially colloquial interpretations
    of the term.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些澄清。我们只有在树被“标记完成”时才称之为判断：即，每个前件都是使用给定规则生成的，并且所有叶子都是实际公理。在这个例子中，我们无法标记完成这棵树：没有可用的规则或公理让我们得出“hi”是
    `Num` 的结论。因此，我们无法“判断”初始表达式。这是“判断”一词的技术含义，不要与该术语可能存在的口语化解释混淆。
- en: 'Similarly, imagine that we started with this program:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，假设我们从一个程序开始：
- en: '[PRE172]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'We would get this far:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会走到这一步：
- en: '|- 5 : Num|- (- 6 7) : Num'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 5 : Num|- (- 6 7) : Num'
- en: '[PRE173]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Again we would fail, this time because we haven’t provided a (conditional) rule
    for `(- e1 e2)`. Obviously it’s not difficult to define one; we just haven’t done
    so yet, so our pattern-matcher would fail.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们会失败，这次是因为我们没有为 `(- e1 e2)` 提供一个（条件）规则。显然定义一个并不困难；我们只是还没有这样做，所以我们的模式匹配器会失败。
- en: Exercise:Construct the conditional rule for `++` (string concatenation). Compare
    it to the code in the type-checker.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：构建 `++`（字符串连接）的条件规则。将其与类型检查器中的代码进行比较。
- en: Typing Conditionals
  id: totrans-658
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型条件
- en: Now we’re ready to add a rule for `if`. As we have seen, different languages
    have different rules for what can go in the conditional clause. Since the goal
    of a type-checker is to catch type errors, it is common for languages with type-checkers
    to demand that the conditional be a Boolean (without a truthy/falsy set of Boolean
    values). Our goal here is not to make a value judgment but rather to illustrate
    how we would add a type rule for it.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备为 `if` 添加一个规则。正如我们所见，不同的语言有不同的规则来决定条件子句中可以放置的内容。由于类型检查器的目标是捕获类型错误，因此对于有类型检查器的语言来说，要求条件是布尔值（没有真/假布尔值集）是很常见的。我们的目标不是做出价值判断，而是要说明我们如何为它添加一个类型规则。
- en: 'By now, we can see that we will need a conditional rule (because we want to
    type-check more than just constants); following SImPl, and we will need the antecedent
    to say something about the sub-expressions. Clearly, we need at least:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们可以看到我们需要一个条件规则（因为我们想类型检查不仅仅是常量）；遵循SImPl，我们还需要前提对子表达式说些什么。显然，我们需要至少：
- en: '[PRE174]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Okay, what now? What is the type of the entire conditional expression? Technically,
    it should be whatever type is returned by the branch that was executed. However,
    a type-checker can’t know which branch will be executed; over time, both might.
    So we have to somehow capture the uncertainty in this situation. There are two
    common solutions:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，接下来是什么？整个条件表达式的类型是什么？技术上，它应该是执行分支返回的类型。然而，类型检查器无法知道哪个分支将被执行；随着时间的推移，两个都可能。因此，我们必须以某种方式捕捉这种情况的不确定性。有两种常见的解决方案：
- en: Introduce a new kind of type that stands for “this type orthat type” (a union).
    This is easy to introduce but creates a burden for every piece of code that will
    consume such a value.
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一种新的类型，代表“这个类型或那个类型”（一个联合）。这很容易引入，但会给消费这种值的每一块代码带来负担。
- en: Just rule that both branches should have the same type.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只规定两个分支应该具有相同的类型。
- en: The latter is a very elegant solution, because it eliminates the uncertainty
    entirely.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是一个非常优雅的解决方案，因为它完全消除了不确定性。
- en: 'Okay, so we need to do the following things:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们需要做以下事情：
- en: Compute the type of T.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算T的类型。
- en: Compute the type of E.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算E的类型。
- en: Make sure T and E have the same type.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保T和E具有相同的类型。
- en: Make this (same) type the result of the conditional.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这个（相同的）类型作为条件的结果。
- en: 'That seems like a lot: how will we express all that? Very easily, actually:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很多：我们如何表达所有这些？实际上非常简单：
- en: '[PRE175]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Here, `U`is a placeholder: it isn’t a concrete type but rather stands forwhatever
    type might go in that place. The repeated use of `U`accomplishes all of our goals
    above. Read this as: “if `C` has type `Bool`and `T`has type `U`and `E` has [the
    same] type `U`, then `(if C T E)`has [the same] type `U`”.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`U`是一个占位符：它不是一个具体的类型，而是代表可能放入该位置的任何类型。`U`的重复使用实现了我们上述的所有目标。可以这样理解：“如果`C`的类型是`Bool`，`T`的类型是`U`，`E`的类型也是`U`，那么`(if
    C T E)`的类型也是`U`”。
- en: 'Let’s see this in action on the following program:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的程序中看看这个是如何实现的：
- en: '[PRE176]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We get:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到：
- en: '|- true : Bool`    |- 1 : U    |- 2 : U`'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '|- true : Bool` |- 1 : U` |- 2 : U`'
- en: '[PRE177]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Either of the axioms for the other two antecedents tells us what U must be,
    which lets us fill in the result of U everywhere:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个前提的公理告诉我们U必须是什么，这让我们可以在U的每个地方填写结果：
- en: '|- true : Bool`    |- 1 : Num    |- 2 : Num`'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '|- true : Bool` |- 1 : Num` |- 2 : Num`'
- en: '[PRE178]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Fortunately, the other two antecedents are also axioms:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，其他两个前提也是公理：
- en: '|- true : Bool|- 1 : Num|- 2 : Num'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '|- true : Bool` |- 1 : Num` |- 2 : Num`'
- en: '[PRE179]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: This lets us conclude that the overall term is well-typed, and that it has type
    `Num`.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们得出结论，整个项是正确类型的，并且它的类型是`Num`。
- en: 'Now let’s look at:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看：
- en: '[PRE180]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Applying the conditional rule gives us:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 应用条件规则给出：
- en: '[PRE181]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'However, we do not have any axiom or conditional rule that lets us conclude
    that `4`has type `Bool` (because, in fact, it does not). Therefore, we cannot
    complete the judgment:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有任何公理或条件规则可以让我们得出`4`的类型是`Bool`（因为实际上它不是）。因此，我们无法完成这个判断：
- en: '|- 4 : Bool`    |- 1 : U    |- 2 : U`'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 4 : Bool` |- 1 : U` |- 2 : U`'
- en: '[PRE182]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: and the program is (rightly) judged to have a type error.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 并且程序被（正确地）判断为存在类型错误。
- en: 'One last example:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子：
- en: '[PRE183]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Again, applying the conditional rule and checking off the first antecedent:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，应用条件规则并检查第一个前提：
- en: '|- true : Bool`    |- 1 : U    |- "hi" : U`'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '|- true : Bool` |- 1 : U` |- "hi" : U`'
- en: '[PRE184]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'But now we have a problem. If we apply the axiom for numbers, we replace all
    instances of `U`with `Num` to get:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们有一个问题。如果我们应用数字的公理，我们将所有`U`的实例替换为`Num`以得到：
- en: '|- true : Bool|- 1 : Num|- "hi" : Num'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '|- true : Bool` |- 1 : Num` |- "hi" : Num`'
- en: '[PRE185]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Maybe we just tried the wrong axiom? We do have one more option! However, it
    ends up with the same net effect:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们只是尝试了错误的公理？我们确实还有一个选择！然而，最终效果是相同的：
- en: '|- true : Bool|- 1 : Str|- "hi" : Str'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '|- true : Bool` |- 1 : Str` |- "hi" : Str`'
- en: '[PRE186]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Because there is no way to construct a judgment for this program, it too has
    a type error.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有方法为这个程序构造一个判断，它也存在类型错误。
- en: 'Exercise: Let’s now add functions. We need two new constructs: one to introduce
    them (`lambda`) and one to use them (function application). Write down judgments
    for each. Hint: You may need to revisit the set of types, too.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：现在让我们添加函数。我们需要两个新的结构：一个用于引入它们（`lambda`）和一个用于使用它们（函数应用）。为每个写下来判断。提示：你可能还需要重新查看类型集。
- en: Observe that because `let`desugars into `lambda`, once we have this, in principle
    we also have a conditional rule for `let`. (For more sophisticated language constructs
    this is not so straightforward; [this paper](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pk-resuarging-types/&sa=D&source=editors&ust=1695232021368048&usg=AOvVaw3PHiJldDLQfYPUNuwxOBi_) works
    out some of the details.)
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，因为`let`会解构为`lambda`，一旦我们有了这个，原则上我们也有一个针对`let`的条件规则。（对于更复杂的语言结构，这并不那么直接；[这篇论文](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pk-resuarging-types/&sa=D&source=editors&ust=1695232021368048&usg=AOvVaw3PHiJldDLQfYPUNuwxOBi_)探讨了其中的一些细节。）
- en: Exercise: Add desugaring to the type-checker.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：向类型检查器添加解构功能。
- en: Where Types Diverge from Evaluation
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型与评估的差异
- en: Something very important, and subtle, happened above. Compare the type rulefor
    a conditional with the evaluation process [[👉](PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936)].
    If the rule is too abstract, just look at the example judgments (or failed judgments)
    above. The evaluator evaluates only onebranch out of `T`and `E`; indeed, that
    is the entire pointof a conditional. The type-checker, in contrast, traverses
    bothbranches! In other words, it looks at code that mightevaluate, not only code
    that absolutely doesevaluate.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 上面发生了一件非常重要且微妙的事情。比较条件类型规则与评估过程 [[👉](PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936)]。如果规则过于抽象，只需看看上面的示例判断（或失败的判断）。评估器只评估`T`和`E`中的一个分支；事实上，这正是条件的目的。相比之下，类型检查器遍历两个分支！换句话说，它查看可能评估的代码，而不仅仅是绝对会评估的代码。
- en: In other words, the idea that a type-checker is like an “evaluator that runs
    over simple values” is a convenient starting analogy, but it is in fact false.
    An evaluator and type-checker follow different traversal strategies. That is why
    a program like `(if true 1 "hi")` might run without any difficulty but is rejected
    by a type-checker. While this particular example may make the type-checker look
    overly pedantic, what if the same program were
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，认为类型检查器就像一个“运行在简单值上的评估器”是一个方便的起始类比，但实际上是错误的。评估器和类型检查器遵循不同的遍历策略。这就是为什么像`(if
    true 1 "hi")`这样的程序可能运行得毫无困难，但会被类型检查器拒绝。虽然这个特定的例子可能使类型检查器看起来过于迂腐，但如果同样的程序
- en: '[PRE187]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: What now? Should the type-checker pass the program every month? Should it consider
    the moon’s phase at the time of type-checking or at execution? Unfortunately,
    the type-checker doesn’t know when the program will run; indeed, the program is
    type-checked once but may run an arbitrary number of times. Therefore, a type-checker
    must necessarily be conservative.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在该怎么办？类型检查器是否应该每月通过程序？是否应该考虑类型检查或执行时的月相？不幸的是，类型检查器不知道程序何时运行；事实上，程序只进行一次类型检查，但可能运行任意次数。因此，类型检查器必然是保守的。
- en: This also lets us relate type-checking to testing. In software testing, making
    sure that all branches are visited is called branch coverage, and making sure
    all branches have coverage is both important and very difficult (because each
    branch may have additional branches which in turn may have even more branches
    which…). In contrast, a type-checker effortlessly covers both branches. The trade-off
    is that it does so only at the type level (and indeed, the abstraction of values
    to types is precisely what enables it to do this).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这也让我们将类型检查与测试联系起来。在软件测试中，确保所有分支都被访问称为分支覆盖率，确保所有分支都有覆盖率既重要又非常困难（因为每个分支可能有额外的分支，这些分支又可能有更多的分支……）。相比之下，类型检查器轻松地覆盖了两个分支。权衡是，它只在类型级别（实际上，值的抽象到类型的抽象正是它能够做到这一点的关键）这样做。
- en: Thus, testing and type-checking are complementary. Type-checking provides code
    coverage at a lightweight level; testing typically provides only partial coverage
    but at the deep level of specific values. In recent years, people have invented
    a notion of [concolic](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Concolic_testing&sa=D&source=editors&ust=1695232021370424&usg=AOvVaw1QJrbACLLfoZOf01gPppBi)—i.e.,
    “concrete” + “symbolic”—testing to try to create the best of both worlds.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试和类型检查是互补的。类型检查在轻量级上提供代码覆盖率；测试通常只提供部分覆盖率，但在特定值的深层级别。近年来，人们发明了一种名为[concolic](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Concolic_testing&sa=D&source=editors&ust=1695232021370424&usg=AOvVaw1QJrbACLLfoZOf01gPppBi)—即“具体”+“符号”——的测试，试图创造两者的最佳结合。
- en: 'Growing Types: Typing Functions'
  id: totrans-716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型增长：类型化函数
- en: 'Now we’re ready to grow our language further, to include functions. As we’ve
    noted before, concepts like functions come in pairs: a way to introduce them and
    a way to use (“eliminate”) them. As in our interpreter, we’ll use a `lambda`form
    to represent the former and application for the latter. We’ve already seen that
    once we have `lambda`, we use syntactic sugar to obtain other forms like `let`,
    so this suffices for our core language. (Mostly, as we’ll see…)'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进一步扩展我们的语言，以包括函数。正如我们之前所提到的，像函数这样的概念是成对出现的：一种引入它们的方式和一种使用（“消除”）它们的方式。就像我们的解释器一样，我们将使用`lambda`形式来表示前者，应用来表示后者。我们已经看到，一旦我们有了`lambda`，我们就使用语法糖来获得其他形式，如`let`，这对我们的核心语言来说已经足够了。（大多数情况下，正如我们将看到的……）
- en: So we have to come up with typing rules for application and `lambda`. Let’s
    do them in that order.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须为应用和`lambda`制定类型规则。让我们按这个顺序来做。
- en: Typing Function Applications
  id: totrans-719
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化函数应用
- en: 'A function application expression has two parts: the function and the arguments.
    For simplicity, we’re going to assume that we’re working with single-argument
    functions.'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用表达式有两个部分：函数和参数。为了简单起见，我们假设我们正在处理单参数函数。
- en: Exercise:Extend the rules below to deal with functions of arbitrary number of
    parameters (formally called arity).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：将以下规则扩展到处理任意数量参数的函数（正式称为阶数）。
- en: 'Because functions are first-class values, the function position is itself an
    expression. We have to check each sub-expression before we can type the whole
    expression. Therefore, function applications are conditional rules with two terms
    in the antecedent:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数是一等值，函数位置本身就是一个表达式。在我们能够类型化整个表达式之前，我们必须检查每个子表达式。因此，函数应用是具有两个前项的条件规则：
- en: '[PRE188]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'First, let’s notice that functions are different kinds of values than other
    values: a function is not itself a number, or string, or Boolean—it may produceone
    of those, but it is not itselfone of those (an important distinction). Therefore,
    we need a different type for functions, which reflects what functions consume
    and what they produce. A natural idea is to assume functions have some “function”
    type, here called `Fun`:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们注意到函数与其他值不同：函数本身不是一个数字、字符串或布尔值——它可能产生这些值之一，但它本身不是这些值中的任何一个（这是一个重要的区别）。因此，我们需要为函数使用不同的类型，这反映了函数消耗的内容和它们产生的结果。一个自然的想法是假设函数具有某种“函数”类型，这里称为`Fun`：
- en: '[PRE189]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: What do we know about the argument expression (the actual parameter)? It had
    better match the type demanded by the formal parameter. But how do we check that
    here? We’ve collapsed allfunctions in the world into a single type, `Fun`. That’s
    far too coarse.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对参数表达式（实际参数）了解多少？它最好与形式参数要求的类型相匹配。但在这里我们如何检查这一点？我们已经将世界上所有的函数压缩成一个单一的类型，`Fun`。这太粗糙了。
- en: 'Instead, following convention, we’ll use the “arrow” syntax for functions:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，遵循惯例，我们将使用“箭头”语法来表示函数：
- en: '[PRE190]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: (Technically, the arrow is a constructor of function types. It’s a two-place
    constructor, for reasons we will see below.)
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: （技术上，箭头是函数类型的构造函数。它是一个双参数构造函数，原因我们将在下面看到。）
- en: 'With this, we can now say that the function’s formal parameter’s type had better
    match up with the type of the actual argument. Which type, exactly? Functions
    could consume numbers, strings, even other functions…all we know is that these
    should be consistent. Notice that this is very similar to the consistency we expected
    of the branches of a conditional. We can again encode this by using the same placeholder
    in both places:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以说函数的正式参数类型最好与实际参数的类型相匹配。确切地说，是哪种类型？函数可以消耗数字、字符串，甚至是其他函数……我们所知道的是，这些应该是保持一致的。请注意，这与我们期望的条件语句分支的一致性非常相似。我们可以再次通过在两个地方使用相同的占位符来编码这一点：
- en: '[PRE191]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Now, what about what the function returns? Again, it could return values of
    any type. Whatever that type is, that is what the entire application produces.
    Again, we use a common placeholder to reflect this:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于函数返回的内容呢？同样，它可能返回任何类型的值。无论这个类型是什么，整个应用产生的就是它。再次，我们使用一个共同的占位符来反映这一点：
- en: '[PRE192]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'So here’s how we read this:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们是这样理解的：
- en: Type-check the `F` position. Make sure it’s a function type (`->`). Assuming
    it is, call the formal parameter’s type `T`and the return type `U`.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查`F`位置。确保它是一个函数类型（`->`）。假设它是，我们将形式参数的类型称为`T`，返回类型称为`U`。
- en: Type-check the actual parameter (the argument). Make sure it has the same type
    as what the function is expecting in its formal parameter.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查实际参数（参数）。确保它具有与函数在其形式参数中期望的类型相同的类型。
- en: If both of those hold, then the function’s return type is the type of the entire
    application.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这两个条件都成立，那么函数的返回类型是整个应用的类型。
- en: This list of steps is what a conventional type-checker would implement. Observe
    that again, a type error is the result of a failure to construct a judgment. If,
    for instance, the actual argument’s type doesn’t match that of the formal parameter,
    then the conditional rule above doesn’t apply(it applies only when we can write
    the same type for the `T` placeholder), which is how we learn that the program
    has a type error.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤列表是一个传统类型检查器会实现的。观察一下，再次，类型错误是构建判断失败的结果。例如，如果实际参数的类型与形式参数的类型不匹配，那么上面的条件规则就不适用（它只在我们可以为`T`占位符写出相同类型时适用），这就是我们如何知道程序有类型错误。
- en: Exercise: Construct an example to illustrate the above type-error case.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：构建一个示例来说明上述类型错误情况。
- en: Aside:We intentionally don’t use a numberedlist because formally, the semantics
    of judgments doesn’t say that these steps have to occur in this order! For instance,
    the argument can be type-checked before the function; if so, that determines what
    the placeholder `T`stands for, and the checking of `F`confirms that `F`’s type
    matches that.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：我们故意不使用编号列表，因为从形式上讲，判断的语义并没有说这些步骤必须按此顺序发生！例如，参数可以在函数之前进行类型检查；如果是这样，那么它就确定了占位符`T`代表什么，而`F`的检查确认`F`的类型与之匹配。
- en: Even more perversely, you can imagine checking the application, determining—from
    the context—what its type needsto be (e.g., if it’s in an addition, it had better
    produce a number), and using that to drive the checking of `F`. In fact, all of
    these things can happen if instead of a checker, we implement type-inference—as
    we will soon see.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 更为奇怪的是，你可以想象检查应用，从上下文中确定它的类型需要是什么（例如，如果它在加法中，它最好产生一个数字），并使用这个来驱动`F`的检查。实际上，所有这些事情都可以发生，如果我们不是实现检查器，而是实现类型推断——我们很快就会看到。
- en: Typing Function Definitions
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化函数定义
- en: 'Now we’re ready to type `lambda`. Here, we have to be careful about how many
    sub-expressions there are. Given `(lambda V B)`, it is tempting to think that
    there are two: `V`(the formal parameter) and `B`(the body). This is wrong! The
    formal parameter is a literal name, notan expression: we can’t replace that name
    with some larger expression, which is what it would mean for it to be an expression.
    Furthermore, we can’t evaluate it: it would (most likely) produce an unbound variable
    error, because its whole job is to bindthat variable, so it can’t assume it has
    already been bound. Therefore, there is only one sub-expression, the body.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好对`lambda`进行类型检查。在这里，我们必须小心有多少个子表达式。给定`(lambda V B)`，可能会觉得有两个：`V`（形式参数）和`B`（主体）。这是错误的！形式参数是一个字面量名称，不是一个表达式：我们不能用某个更大的表达式来替换这个名称，这就是它成为表达式的含义。此外，我们不能评估它：它（很可能会）产生一个未绑定变量错误，因为它的整个工作就是绑定这个变量，所以它不能假设它已经被绑定。因此，只有一个子表达式，即主体。
- en: 'Therefore, we expect to end up with a conditional rule that looks like this:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们期望最终得到一个看起来像这样的条件规则：
- en: '[PRE193]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'If we think about this for a moment, we can see that there’s going to be a
    problem.  We just said that the `lambda`introduces a binding for the variable
    in the `V`position. This is precisely so that the body, `B`, can make use of that
    variable. So let’s imagine the simplest function:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微思考一下，我们可以看到将会出现一个问题。我们刚才说`lambda`引入了`V`位置变量的绑定。这正是为了让主体`B`能够使用那个变量。所以让我们想象最简单的函数：
- en: '[PRE194]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: But we don’t have any typing rule that covers variables! Furthermore, we have
    no way of knowing what the type of any old variable will be. So we have a problem.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们没有任何类型规则来涵盖变量！此外，我们没有办法知道任何旧变量的类型。所以我们有一个问题。
- en: Typing Variables
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化变量
- en: 'Remember how we addressed this problem in our interpreter: we had an environmentfor
    recording the value bound to each variable. We will use this same idea again:
    we’ll have a type environmentfor recording the type of each variable. That is,
    just as our interpreter had the type'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在解释器中是如何处理这个问题的：我们有一个环境来记录每个变量所绑定值。我们将再次使用这个相同的概念：我们将有一个类型环境来记录每个变量的类型。也就是说，正如我们的解释器有类型一样
- en: '[PRE195]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: our type-checker will have the type
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类型检查器将有以下类型
- en: '[PRE196]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'In our type-checker notation, we will use a slightly different way of writing
    it, which will finally make make `|-` stop being silent and take it proper pronounciation,
    “proves”: all type rules will have the form'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类型检查符号中，我们将使用一种稍微不同的写法，这将最终使`|-`不再沉默，而是取其正确的发音，“证明”：所有类型规则都将具有以下形式
- en: 'Γ `|- e : T`'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- e : T`'
- en: where Γ, the capital Greek letter gamma, is conventionally used for the environment.
    We read this as “the environment Γproves that `e`has type `T`”. So in fact there’s
    been an environment hiding in all our judgments, but we didn’t have to worry about
    it when we didn’t have variables; but now we do, so from now on we have to make
    it explicit. Fortunately, in most cases the environment is unchanged, and just
    passes recursively to the sub-terms, as you would expect from writing the interpreter.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 其中Γ，大写希腊字母伽玛，传统上用于环境。我们读作“环境Γ证明`e`具有类型`T`”。所以实际上，所有我们的判断中都有一个环境隐藏着，但当我们没有变量时，我们不必担心它；但现在我们必须，所以从现在开始我们必须使其明确。幸运的是，在大多数情况下，环境保持不变，只是递归地传递到子项，正如你从编写解释器时预期的那样。
- en: 'With this, we can write a type for variables. What is the type of a variable?
    It’s whatever the environment says it is! We’ll treat the environment as a function,
    so we can just write the following axiom (where `v` stands for all the syntactically
    valid variable names):'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以为变量写一个类型。变量的类型是什么？它就是环境所说的那样！我们将把环境视为一个函数，因此我们可以直接写出以下公理（其中`v`代表所有语法上有效的变量名）：
- en: Γ `|- v :` Γ`(v)`
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: Γ `|- v :` Γ`(v)`
- en: Back to Typing Function Definitions
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到函数定义的类型
- en: 'Now we’re in a position to fill in the holes. When we check the body of the
    function, we should do it in an extended environment:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处于填补空缺的位置。当我们检查函数的主体时，我们应该在一个扩展的环境中这样做：
- en: 'Γ[V <- ???] `|- B : ???`'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ[V <- ???] `|- B : ???`'
- en: '[PRE197]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Γ `|- (lambda V B) : ???`'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (lambda V B) : ???`'
- en: 'where Γ[V <- _] is how we write “Γis extended with `V` bound to _”: this is
    the same environment-extension function that we’ve written before, for type environments
    instead of value environments, but operationally the same.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 其中Γ[V <- _]是我们如何写“Γ扩展了`V`绑定到_”：这是我们在类型环境中而不是值环境中写过的相同的环境扩展函数，但在操作上是一样的。
- en: 'Okay, but two questions: extend whichenvironment, and extend it with what?'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但有两个问题：扩展哪个环境，以及用什么是扩展它？
- en: 'Which is easy: it’s the environment of the function definition (static scope!).
    The repetition of Γ in both the consequent and antecedent accomplishes that.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单：它是函数定义的环境（静态作用域！）。在结论和前提中都重复Γ实现了这一点。
- en: 'In terms of what:  We need to provide a type for the variable so that, when
    we try to look up its type, the environment can return something. But we don’t
    know what to extend it with! The type-checker needs the programmer to tell it what
    type the function is expecting. This is one of the reasons why programming languages
    expect annotations in function and method definitions. (Another—equally good—reason
    is because it better documents the function for people who have to use it and
    maintain it.)'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么方面：我们需要为变量提供一个类型，这样当我们尝试查找其类型时，环境可以返回一些内容。但我们不知道要扩展什么！类型检查器需要程序员告诉它函数期望的类型。这就是为什么编程语言在函数和方法定义中期望注解的原因之一。（另一个——同样好的——原因是它更好地为必须使用和维护它的人记录了函数。）
- en: 'Therefore, we have to extend the syntax of functions to include a type annotation:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须扩展函数的语法以包括类型注解：
- en: '[PRE198]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'which says that `V`is expecting to be bound to a value of type `T`in body `B`.
    Once we accept this modification, we can make progress on the conditional rule:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`V`期望在主体`B`中被绑定到类型`T`的值。一旦我们接受这种修改，我们就可以在条件规则上取得进展：
- en: 'Γ[V <- T] `|- B : ???`'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ[V <- T] `|- B : ???`'
- en: '[PRE199]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Γ `|- (lambda V :` T` B) : ???`'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (lambda V :` T` B) : ???`'
- en: 'What type are we expecting for the function definition? Clearly it must be
    a function type:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望函数定义的类型是什么？显然它必须是一个函数类型：
- en: 'Γ[V <- T] `|- B : ???`'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ[V <- T] `|- B : ???`'
- en: '[PRE200]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Γ `|- (lambda V : T B) :` (??? -> ???)'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (lambda V : T B) :` (??? -> ???)'
- en: 'Furthermore, we know that the type expected by the function must be `T`:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们知道函数期望的类型必须是`T`：
- en: 'Γ[V <- T] `|- B : ???`'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ[V <- T] `|- B : ???`'
- en: '[PRE201]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Γ `|- (lambda V : T B) : (`T` -> ???)`'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (lambda V : T B) : (`T` -> ???)`'
- en: 'Given a value of type `T`, the function will return whatever the body produces:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个类型为`T`的值，函数将返回主体产生的任何内容：
- en: Γ[V <- T] `|- B :` U
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: Γ[V <- T] `|- B :` U
- en: '[PRE202]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Γ `|- (lambda V : T B) : (T ->` U`)`'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (lambda V : T B) : (T ->` U`)`'
- en: And that gives us our final rule for function definitions.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 这就给出了我们关于函数定义的最终规则。
- en: More Divergence Between Types and Evaluation
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型与评估之间的更多差异
- en: It is interesting to contrast the above pair of typing rules with the corresponding
    evaluation rules. In the evaluator, we visit the body of the function on every
    application—which could be as many as an infinite number of times in a program.
    In contrast, we visit the body of the function on definition, which happens only
    once. Therefore, even if the program runs forever, the type-checker is guaranteed
    to terminate!
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述成对的类型规则与相应的评估规则进行对比很有趣。在评估器中，我们在每次应用时都会访问函数体——在程序中可能多达无限次。相比之下，我们在定义时访问函数体，这只会发生一次。因此，即使程序运行无限期，类型检查器也保证会终止！
- en: Why can we get away with this? The evaluator has to run the body with the specific value
    it was given. The type-checker, however, has abstracted the concrete values away.
    Therefore, it only needs to make one pass through the body with the “abstract
    value”, the type.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们可以这样做？评估器必须运行体以使用给定的具体值。然而，类型检查器已经将具体值抽象掉了。因此，它只需要用“抽象值”，即类型，遍历一次体。
- en: 'Aside: Earlier, when we proposed the type `Fun`, we said that it collapsed
    all functions in the world into one type. This was too coarse, and we had to refine
    the type of a function. However, we are stillcollapsing an infinite number of
    functions into each of those function types—just as we collapse an infinite number
    of strings into `Str`, and so on. Both the strength and weakness of type-checking
    lies in this collapsing.'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：早些时候，当我们提出 `Fun` 类型时，我们说它将世界上所有的函数都折叠成了一个类型。这太粗糙了，我们必须细化函数的类型。然而，我们仍然将无限多的函数折叠到每个函数类型中——就像我们将无限多的字符串折叠到
    `Str` 中，等等。类型检查的强度和弱点都体现在这一点上。
- en: For the same reason, observe that a function application rule only cares about
    the typeof the function, not whichspecific function is being applied. Therefore,
    any function that has that type can be used. For that same reason, the type-checker
    cannot traverse the function’s body at application time—it doesn’t even know which
    function might be used! All communication between the function body and application
    must happen entirely through the type boundary.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，观察到一个函数应用规则只关心函数的类型，而不是正在应用的具体函数。因此，任何具有该类型的函数都可以使用。同样地，类型检查器在应用时不能遍历函数体——它甚至不知道可能使用哪个函数！函数体和应用之间的所有通信必须完全通过类型边界进行。
- en: Assume-Guarantee Reasoning
  id: totrans-792
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设-保证推理
- en: 'There is a delicate dance going on between these typing rules for application
    and definition (now updated to have the environment). We’ll use colors to highlight
    this:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用和定义（现在更新为包含环境）的这些类型规则之间进行着一场微妙的舞蹈。我们将使用颜色来突出这一点：
- en: Γ `|- F :` (T -> U)`Γ |- A :` T
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: Γ `|- F :` (T -> U) Γ `|- A :` T
- en: '[PRE203]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Γ `|- (F A) : U`'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (F A) : U`'
- en: 'Γ[V <- T] `|- B : U`'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ[V <- T] `|- B : U`'
- en: '[PRE204]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Γ `|- (lambda V : T B) :` (T -> U)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (lambda V : T B) :` (T -> U)'
- en: The rule for `lambda` assumesthe parameter will be given a value of type T;
    the application rule guaranteesthat that the actual parameter will indeed have
    the expected type. The application rule assumesthat the function, if given a `T`,
    will produce a `U`(because the type is (T -> U)); the `lambda`rule guarantees that
    the function will indeed perform that way.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 的规则假设参数将被赋予类型 T 的值；应用规则保证实际参数确实具有预期的类型。应用规则假设如果给函数一个 `T`，它将产生一个 `U`（因为类型是
    (T -> U)）；`lambda` 规则保证函数确实会那样执行。'
- en: Aside:The notation `(T -> U)`is not chosen at random. The `->`may remind you
    of the notation for implication in mathematics. That’s intentional. We can read
    the type as “giving the function a `T`implies that it will produce a `U`” (not
    giving it a `T`implies nothing about what it will do…). It is that implication that
    is assumed in the application rule, and that is guaranteed by the rule for lambda.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：`(T -> U)` 的表示法并非随机选择。`->` 可能会让你想起数学中蕴涵的表示法。这是故意的。我们可以将类型读作“给函数一个 `T` 意味着它将产生一个
    `U`”（不给它一个 `T` 对它将做什么没有任何暗示……）。正是这种蕴涵在应用规则中被假设，并由 `lambda` 规则保证。
- en: This assume-guarantee reasoning shows up in many places, so look out for this
    pattern in other places as well.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这种假设-保证推理出现在许多地方，所以也要在其他地方留意这种模式。
- en: Recursion and Infinite Loops
  id: totrans-803
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归与无限循环
- en: 'We alluded, earlier, to how we can desugar more interesting features into functions
    and application. Let’s take a look at a very specific feature: an infinite loop.
    Let’s first confirm that we can write an infinite loop. Here’s a program that
    does it:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，我们可以将更多有趣的功能特性简化为函数和应用。让我们看看一个非常具体的特性：无限循环。让我们首先确认我们能否编写一个无限循环。下面是一个实现这一功能的程序：
- en: '[PRE205]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'But this assumes we already have recursion. Can we write it without recursion?
    Actually we can! We’ll use historical names (ω is the lower-case Greek omega):'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 但这假设我们已经有递归了。我们能否不使用递归来实现它？实际上我们可以！我们将使用历史名称（ω 是小写希腊字母 omega）：
- en: '`(let ([`ω` (lambda (x) (x x))])`'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([`ω` (lambda (x) (x x))])`'
- en: '`  (`ωω`))`'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (`ωω`))`'
- en: Run this in Racket and confirm that it runs forever!
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中运行这个程序，确认它会无限循环！
- en: Do Now:Write a conditional type rule for `let`.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来做：为 `let` 编写一个条件类型规则。
- en: 'Now let’s see what happens when we try to type this. We have to provide a type
    annotation:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们尝试为这个程序进行类型检查时会发生什么。我们必须提供类型注解：
- en: '`(let ([`ω` (lambda (x : ???) (x x))])`'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([`ω` (lambda (x : ???) (x x))])`'
- en: '`  (`ωω`))`'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (`ωω`))`'
- en: Historically, the overall term is called Ω (the capital Greek omega).
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上讲，整体术语被称为 Ω（大写希腊字母 omega）。
- en: Okay, so what is the annotation? To determine a type for `x`, we have to see
    how it’s used. It’s used twice. One use is in a function application position,
    so we know that the type must be of the form `(T -> U)`; now we have to determine
    what `T`and `U`are. Let’s focus on the parameter type, `T`. But what are we passing
    in? We’re passing in `x`, whose type is `(T -> U)`. So we need a solution to the
    equation
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么注解是什么呢？为了确定 `x` 的类型，我们必须看看它是如何被使用的。它被使用了两次。一次是在函数应用位置，因此我们知道类型必须是 `(T ->
    U)` 的形式；现在我们必须确定 `T` 和 `U` 是什么。让我们专注于参数类型 `T`。但我们传递了什么？我们传递了 `x`，其类型是 `(T -> U)`。因此，我们需要一个解这个方程的方案
- en: '`T`= `(T -> U)`'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`= `(T -> U)`'
- en: with one coming from the application position and the other from the argument
    position. Of course, there is no finite type that can fit this equation! Therefore,
    it appears that this program cannot be typed!
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个来自应用位置，另一个来自参数位置。当然，没有有限类型能够满足这个方程！因此，似乎这个程序无法进行类型检查！
- en: 'Of course, this is not a proof. However, there is a formal property associated
    with this programming language, which is called the Simply Typed Lambda Calculus
    (STLC): the property is called strong normalization, and it means that all programs
    in this language terminate.'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一个证明。然而，与这种编程语言相关的一个形式属性被称为简单类型化λ演算（STLC）：这个属性被称为强归约，意味着这个语言中的所有程序都会终止。
- en: Aside: If you have heard about the Halting Problem, how does that square with
    what you just read?
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：如果你听说过停机问题，那么你刚刚读到的内容是如何与之相吻合的？
- en: It may seem rather useless to have a language in which all programs terminate—you
    can’t write an operating system, or Web server, or many other programs in such
    a language. However, that misses two things.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个所有程序都会终止的语言中，这似乎相当没有用——你无法用这样的语言编写操作系统、Web 服务器或许多其他程序。然而，这忽略了两个问题。
- en: 'First, there are many cases where we wantprograms to always terminate. You
    don’t want a network packet filter or a device driver or a compiler or a type-checker
    or … to run forever. Of course we also want them to run quickly, but it would
    be nice if we had a guarantee that no matter what we did, we cannot create an
    infinite loop. The STLC is very useful in some of these settings. Another example
    of a place where we want guaranteed termination is in program linking, and the
    module language of Standard ML is therefore built atop the STLC: it lets you even
    write higher-order programs, but the type language guarantees that all module
    compositions (linkages) will terminate.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有许多情况下我们希望程序总是终止。你不想让网络包过滤器、设备驱动程序、编译器、类型检查器等无限运行。当然，我们也希望它们运行得快，但如果有一个保证，无论我们做什么，我们都无法创建无限循环，那就更好了。STLC
    在这些设置中非常有用。另一个我们希望保证终止的例子是在程序链接中，因此标准 ML 的模块语言因此建立在 STLC 之上：它让你甚至可以编写高阶程序，但类型语言保证了所有模块组合（链接）都会终止。
- en: Second, many long-running programs are actually a composition of an infinite
    loop and a short-running program. Think about an operating system with device
    drivers, a Web server with a Web application, a GUI with callbacks, etc. In each
    case, there is a “spine” of an infinite loop that simply keeps the program reactive,
    and “ribs” of short computations that do a little specific work and terminate.
    In fact, on the Web these programs mustterminate quickly, otherwise the Web browser
    thinks the server has hung and offers to kill the window! These kinds of reactive
    systems are therefore a composition of a very generic infinite loop calling out
    to specific programs for which a termination guarantee will often be very useful.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，许多长时间运行的程序实际上是无限循环和短运行程序的组合。想想一个带有设备驱动程序的操作系统，一个带有 Web 应用的 Web 服务器，一个带有回调的
    GUI 等。在每种情况下，都有一个无限循环的“脊柱”，它只是保持程序的反应性，以及“肋骨”是短的计算，做一些具体的工作并终止。事实上，在 Web 上，这些程序必须快速终止，否则网络浏览器会认为服务器已挂起，并提议关闭窗口！因此，这类反应性系统因此是由一个非常通用的无限循环调用特定程序组成的，对于这些程序，终止保证通常非常有用。
- en: Finally, observe that we’ve learned something profound. Until now, we have probably
    thought of types as just a convenience or as a way of eliminating basic errors.
    However, we have just now seen that adding a type system can change the expressive
    power of a language. That is, these types are “semantic”.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意到我们学到了一些深刻的东西。到目前为止，我们可能认为类型只是方便或者消除基本错误的一种方式。然而，我们刚刚看到，添加类型系统可以改变语言的表达能力。也就是说，这些类型是“语义”的。
- en: Typing Recursion
  id: totrans-825
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化递归
- en: What went wrong above? The problem is that each application “uses up an arrow”
    in a function type; because a program text must be finite, it can contain at most
    a finite number of “arrows”, so eventually the program must terminate. To get
    around this, we need a way to effectively have an “infinite quiver”.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 上面出了什么问题？问题是每个应用“消耗一个函数类型中的箭头”；因为程序文本必须是有限的，它最多只能包含有限数量的“箭头”，所以程序最终必须终止。为了解决这个问题，我们需要一种有效地拥有“无限箭头”的方法。
- en: 'We typically do this by adding a recursive function construct to the language,
    and create a custom type for it. Let’s start with a type rule for the analogous,
    but simpler, `let`:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过向语言添加递归函数构造来做到这一点，并为它创建一个自定义类型。让我们从类似但更简单的 `let` 的类型规则开始：
- en: 'Γ `|- E : T    `Γ[V <- T] `|- B : U`'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- E : T   `Γ[V <- T] `|- B : U`'
- en: '[PRE207]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Γ `|- (let V : T E B) : U`'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (let V : T E B) : U`'
- en: Note that we’re going to expect an annotation in `let`for the same reason we
    do for function definitions. So this says that we’ll check that `E`actually does
    have the type promised in the declaration, `T`; when we extend the type environment
    with the `V`having type `T`, if the body `B`produces type `U`, then that’s the
    type of the whole expression.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将期望在 `let` 中有一个注解，原因和函数定义一样。所以这表示我们将检查 `E` 是否确实具有声明中承诺的类型 `T`；当我们用具有类型
    `T` 的 `V` 扩展类型环境时，如果主体 `B` 产生类型 `U`，那么这就是整个表达式的类型。
- en: 'Aside: Notice that there’s an assume-guarantee pair in the antecedent: the
    first term is guaranteeing the annotation, which the second term is assuming.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：注意，在前提中有一个假设-保证对：第一个项保证了注解，第二个项是假设的。
- en: Aside:Technically, the type of `E`could be calculated. Therefore, the `T` annotation
    is not strictly necessary.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：技术上，`E` 的类型可以计算。因此，`T` 注解并不是严格必要的。
- en: Observe that this is basically the type rule we would get from expanding the
    syntactic sugar for `let`. Therefore, this still doesn’t let us write a recursive
    definition. We need something more. Let’s introduce a new construct, `rec`, for
    recursive definitions. An example of a `rec` (in an untyped setting) might be
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这基本上是我们从展开 `let` 的语法糖中得到的类型规则。因此，这仍然不允许我们编写递归定义。我们需要更多。让我们引入一个新的构造，`rec`，用于递归定义。一个
    `rec`（在无类型环境中）的例子可能是
- en: '[PRE208]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: In the typed world, we’ll want rec to have the form
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型化的世界中，我们希望 `rec` 有以下形式
- en: '[PRE210]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: so we’d instead have to write
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们得改写为
- en: '[PRE211]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: where `V`is `fact`, `T`is `(Number -> Number)`, `E`is the big `lambda`term,
    and `B`is `(fact 10)`.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `V` 是 `fact`，`T` 是 `(Number -> Number)`，`E` 是大 `lambda` 表达式，而 `B` 是 `(fact
    10)`。
- en: So this introduces a recursive definition, and then uses it. How might we type
    this?
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这引入了一个递归定义，然后使用了它。我们该如何输入这个？
- en: ???
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: '[PRE213]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Γ `|- (rec V : T E B) : U`'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (rec V : T E B) : U`'
- en: 'Well, clearly one part of it must be the same: we have to type the body in
    the extended environment, and the environment must be extended with the annotated
    type:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，很明显其中一部分必须相同：我们必须在扩展环境中输入主体，并且环境必须通过注解类型进行扩展：
- en: '???    Γ[V <- T] `|- B : U`'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '??? Γ[V <- T] `|- B : U`'
- en: '[PRE214]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Γ `|- (rec V : T E B) : U`'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (rec V : T E B) : U`'
- en: 'We also know that we need to confirm that the annotation is correct:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道我们需要确认注释是正确的：
- en: '??? `|- E : T`Γ[V <- T] `|- B : U`'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '??? `|- E : T`Γ[V <- T] `|- B : U`'
- en: '[PRE215]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Γ `|- (rec V : T E B) : U`'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (rec V : T E B) : U`'
- en: 'But clearly, somethingneeds to be different, otherwise we’ve just reproduced
    `let`. Look at the example use of `rec`: the `E`term also needs to have `V`bound
    in it! In other words, both `E`and `B` are typed in the same environment:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 但显然，某些东西需要不同，否则我们只是重新实现了 `let`。看看 `rec` 的示例使用：`E` 项也需要在它里面绑定 `V`！换句话说，`E` 和
    `B` 都在同一个环境中进行类型化：
- en: 'Γ[V <- T] `|- E : T`Γ[V <- T] `|- B : U`'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ[V <- T] `|- E : T`Γ[V <- T] `|- B : U`'
- en: '[PRE216]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Γ `|- (rec V : T E B) : U`'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (rec V : T E B) : U`'
- en: 'From the type, we can read off how the recursion happens: the extended environment
    for `B` initiatesthe recursion, while that for `E` sustainsit. Essentially, the
    environment of `E` enables arbitrary recursive depth.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型中，我们可以读出递归是如何发生的：`B` 的扩展环境启动递归，而 `E` 的环境维持递归。本质上，`E` 的环境使得任意递归深度成为可能。
- en: In short, to obtain arbitrary recursion—and hence infinite loops—we have to
    add a special construct to the language and its type-checker; we cannot obtain
    it just through desugaring. Once we add `rec` to the STLC, however, we obtain
    a conventional programming language again.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，为了获得任意递归——从而产生无限循环——我们必须向语言及其类型检查器添加一个特殊构造；我们不能仅仅通过简化得到它。然而，一旦我们在 STLC
    中添加 `rec`，我们再次获得了一种传统的编程语言。
- en: Safety and Soundness
  id: totrans-861
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性和正确性
- en: 'A critical component of SMoL is the concept of safety: that some operations
    are partialover the set of all values, and that a SMoL language enforces this
    by reporting violations. Typical examples of partiality may include `+`applying
    only to certain types of values. However, I intentionally write “operations” rather
    than, say, “functions”, because these could be primitive operations like application
    (expecting the first position to be a function or method) as well. In fact, in
    some languages like JavaScript, there are very few violations, as the [Wat talk](https://www.google.com/url?q=https://www.destroyallsoftware.com/talks/wat&sa=D&source=editors&ust=1695232021400146&usg=AOvVaw1NOpkYKNjpy6IwTp-vrqEQ) shows.'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: SMoL 的一个关键组件是安全性的概念：某些操作在所有值的集合上是部分操作，SMoL 语言通过报告违规来强制执行这一点。部分性的典型例子可能包括 `+`
    只应用于某些类型的值。然而，我故意写“操作”而不是“函数”，因为这些可能是原始操作，比如应用操作（期望第一个位置是一个函数或方法）。实际上，在某些语言如 JavaScript
    中，违规非常少，正如 [Wat talk](https://www.google.com/url?q=https://www.destroyallsoftware.com/talks/wat&sa=D&source=editors&ust=1695232021400146&usg=AOvVaw1NOpkYKNjpy6IwTp-vrqEQ)
    所示。
- en: 'How must these be enforced? It can be either statically or dynamically. In
    Python and JavaScript, for instance, all safety violations are reported dynamically.
    In Java or OCaml, most of them are reported statically. Either way, safety means
    that data have integrity: there is some notion of “what they are”, and that identity
    is respected by operations. Put differently, data are not misinterpreted.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 这些必须如何强制执行？它可以是静态的，也可以是动态的。例如，在 Python 和 JavaScript 中，所有的安全性违规都是动态报告的。在 Java
    或 OCaml 中，大多数违规都是静态报告的。无论如何，安全性意味着数据具有完整性：存在某种“它们是什么”的概念，并且这种身份被操作所尊重。换句话说，数据不会被误解。
- en: These are all very abstract statements, which we will soon concretize.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是非常抽象的陈述，我们很快就会具体化。
- en: Revisiting the Basic Calculator
  id: totrans-865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视基本计算器
- en: 'We will start with a very basic calculator that has two types, numbers and
    strings, and an operation (addition and concatenation, respectively) on them.
    Note that it helps to have more than one type if we want to talk about safety.
    We will skip most of the boilerplate code and focus on the core of the calculator:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常基础的计算器开始，它有两种类型：数字和字符串，以及针对它们的操作（分别是加法和连接）。注意，如果我们想要讨论安全性，那么拥有多种类型是有帮助的。我们将跳过大部分样板代码，专注于计算器的核心：
- en: '[PRE217]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: You might have imagined the latter two functions to be merely convenient helpers,
    and hence wonder why they are part of the “core”. You will soon see why!
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为后两个函数仅仅是方便的辅助工具，因此会 wonder 为什么它们是“核心”的一部分。你很快就会看到原因！
- en: 'With a suitable parser, we can run tests such as the following:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合适的解析器，我们可以运行如下测试：
- en: '[PRE223]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The last two, in particular, show that the language is safe. The checks inside
    the primitives—in `num+`, for instance—are called safety checks.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是最后两个，显示了语言是安全的。原始操作内部的检查——例如在 `num+` 中——被称为安全性检查。
- en: Making Memory Explicit (Unsafely)
  id: totrans-877
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式化内存（不安全地）
- en: 'Now we’re going to do something fun: we’re going to make the memory allocation
    of values explicit. As we go through this, remember what we’ve said before: a
    value in SMoL is just a memory address.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要做一些有趣的事情：我们将使值的内存分配变得明确。在完成这个过程时，请记住我们之前说过的话：SMoL中的值只是一个内存地址。
- en: 'Let’s do this in stages. First, we’ll use a vector to represent memory:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分阶段来做这件事。首先，我们将使用一个向量来表示内存：
- en: '[PRE224]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The value `-1`is useful for identifying parts of memory that have not yet been
    touched (assuming, of course, we don’t write a program that produces `-1`—which
    we can avoid doing easily enough in this illustration).
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 值`-1`对于识别尚未被触及的内存部分很有用（当然，假设我们不编写产生`-1`的程序——在这个示例中我们可以很容易地避免这样做）。
- en: 'Aside: To run the code below, you will need to import some Racket primitives
    into plait:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：要运行下面的代码，您需要将一些Racket原语导入到plait中：
- en: '[PRE225]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'It will be useful to have a helper to use the next available bit of memory:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个助手来使用下一个可用的内存位将是有用的：
- en: '[PRE226]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Now let’s say we want to store a number in memory. We put it in the next available
    memory place, and return the addressof the place where the number was stored.
    Be careful here: the number we return is a memory address (which, here, is represented
    as an array index), which is not at all necessarily the same as the numeric value being
    stored.'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想在内存中存储一个数字。我们将其放在下一个可用的内存位置，并返回存储该数字的位置的地址。请注意：我们返回的数字是一个内存地址（在这里，它表示为数组索引），这并不一定与存储的数值相同。
- en: '[PRE227]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Correspondingly, when we want to read a number, we simply return what is at
    the address corresponding to the number.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，当我们想要读取一个数字时，我们只需返回与该数字对应的地址处的值。
- en: '[PRE228]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'We want the property that when we `read-num`from the address where we `store-num`a
    number, we get back that same number: for all `N`,'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个属性，即当我们从存储数字的地址`read-num`时，我们得到相同的数字：对于所有的`N`，
- en: '`(read-num (store-num N))`is `N`'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '`(read-num (store-num N))`等于`N`'
- en: Aside: This is not quite exactly how numbers are stored in most languages. As
    we will see when we update the calculator below, this means every time we produce
    a particular number—`1730`, say—we store it afresh in memory. That would be extremely
    wasteful. Rather, language implementations use representation tricks to make sure
    there is only one copy of numbers and that they don’t need to take up space on
    the heap at all, as we describe below [[👉](PLAIVersion3.2.2_split_114.html#h.dirpjggvkz7z)].
    However, we will continue to work with this simple model because this optimization
    is not the focus of this chapter. In addition, some numbers—that don’t fit in
    a small amount of space—do need to be stored on the heap.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：这并不是大多数语言中数字存储的准确方式。正如我们将在更新下面的计算器时看到的那样，这意味着每次我们产生一个特定的数字——比如`1730`——我们都会在内存中重新存储它。这将非常浪费。相反，语言实现使用表示技巧来确保只有一个数字的副本，并且它们不需要在堆上占用任何空间，正如我们下面所描述的
    [[👉](PLAIVersion3.2.2_split_114.html#h.dirpjggvkz7z)]。然而，我们将继续使用这个简单的模型，因为这种优化不是本章的重点。此外，一些不适合小量空间的数字确实需要存储在堆上。
- en: 'Now let’s look at strings. We are going to convert the string into a sequence
    of character codes, and store those codes explicitly:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看字符串。我们将把字符串转换成一系列字符码，并明确存储这些码：
- en: '[PRE229]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: In particular, the value stored at the address representing the string is the
    length of the string, followed by the individual characters. (Endless blood has
    been spent over whether strings should store their lengths at the front, or whether
    they should only be delimited by a special value, or both. The question is uninteresting
    here.) Thus, suppose with a fresh memory we run
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，存储在表示字符串的地址处的值是字符串的长度，然后是各个字符。（关于字符串是否应该在前面存储长度，或者是否只应该由一个特殊值分隔，或者两者都要，已经花费了无数的血本。这个问题在这里并不有趣。）因此，假设我们用一块新的内存运行
- en: '[PRE230]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: this would return the address `0`. The resulting value of MEMORY would be
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回地址`0`。结果，MEMORY的值将是
- en: '[PRE231]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'That is, at address `0`we have the length of the string, followed by five character
    codes; these six memory entries together constitute the five-character string
    `"hello"`. The rest of the memory remains untouched. To read a string we have
    to reassemble it:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 即，在地址`0`我们有字符串的长度，然后是五个字符码；这六个内存条目共同构成了五个字符的字符串`"hello"`。内存的其余部分保持不变。要读取一个字符串，我们必须重新组装它：
- en: '[PRE232]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Once again, we want the result of reading a written string to give us the same
    string.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们希望读取写入的字符串的结果给我们相同的字符串。
- en: 'Now let’s update the calculator. First, we’re in for a surprise: we no longer
    need (or want) a fancy Racket datatype to track values, because values are just
    addresses (i.e., array indices)! So:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新计算器。首先，我们会感到惊讶：我们不再需要（或想要）一个复杂的Racket数据类型来跟踪值，因为值只是地址（即，数组索引）！所以：
- en: '[PRE233]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The typeof the calculator doesn’t change; it still produces values. It’s just
    that the representation of values has changed…dramatically. (Recall, again, that
    these `Number`s are addresses, not numeric values in the interpreted language.)
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器的类型没有改变；它仍然产生值。只是值的表示方式发生了……巨大的变化。（再次回想，这些`Number`s是地址，而不是解释语言中的数值。）
- en: 'The calculator remains the same. What has changed is in the helper functions.
    In the primitive value cases, we have to explicitly allocate them—which is what
    we were doing when we called the previous definitions of `numV`and `strV` (which
    store data on the heap), except it may not have been so evident. We will make
    it explicit as follows:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器保持不变。变化的是辅助函数。在原始值情况下，我们必须显式地分配它们——这就是我们在调用`numV`和`strV`的先前定义（它们在堆上存储数据）时所做的事情，只不过可能不那么明显。我们将如下明确地这样做：
- en: '[PRE234]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Okay, now to update the helper functions. Let’s focus on `num+`. The core logic
    is currently
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在来更新辅助函数。让我们专注于`num+`。核心逻辑目前是
- en: '[PRE235]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Observe that now we’re calling it on the result of calling `calc`, i.e., on
    `Value`s. That means `num+` is going to get two addresses as arguments, and it
    needs to look up the corresponding numbers in memory, and then produce the resulting
    number:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们是在调用`calc`的结果上调用它，即，在`Value`s上。这意味着`num+`将得到两个地址作为参数，并且它需要查找内存中相应的数字，然后产生结果数字：
- en: '[PRE236]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Aside: In case you’re wondering: yes, we’re cheating a tiny bit. We’re using
    Racket numbers rather than dealing with even lower-level representations. We’ll
    give ourselves this little bit of leeway since this is not the point we’re trying
    to illustrate.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：如果你想知道：是的，我们又在稍微作弊了。我们使用Racket数字而不是处理更低级别的表示。由于这不是我们试图说明的点，我们可以给自己一点余地。
- en: 'Analogously, we can define concatenation as well:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以定义连接操作：
- en: '[PRE237]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Aside: Yes, we’re cheating again, and quite a bit. If we were less lazy, we’d
    write a big loop over `MEMORY` that copies all the values from the first and second
    strings into a new, third string, explicitly. But we’re lazy.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：是的，我们又在偷懒了，而且相当严重。如果我们不那么懒惰，我们就会在`MEMORY`上写一个大循环，将第一个和第二个字符串的所有值显式地复制到一个新的第三个字符串中。但我们很懒惰。
- en: 'Finally, we have to update our tests as well. Because `calc`now returns addresses,
    all our answers appear to be incorrect. Instead, we have to obtain the corresponding
    numbers or strings at those addresses. Once we do so, `calc` passes the tests:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更新我们的测试。因为`calc`现在返回地址，所以我们的所有答案似乎都是错误的。相反，我们必须获取那些地址对应的数字或字符串。一旦我们这样做，`calc`就通过了测试：
- en: '[PRE238]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Except…does it? These two tests do not pass:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 除了……它真的吗？这两个测试没有通过：
- en: '[PRE239]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: In fact, how can they? In all the above code, there are no errors left! Rather,
    when we run
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，他们怎么能呢？在所有上述代码中，都没有留下错误！相反，当我们运行
- en: '[PRE240]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'we get an address back (maybe `69`; it depends on what you ran earlier and
    hence what is in `MEMORY`). In fact, we can decide how we want to treat this:
    as a number?'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到一个地址（可能是`69`；这取决于你之前运行了什么，因此取决于`MEMORY`中的内容）。事实上，我们可以决定我们想要如何处理它：作为一个数字？
- en: '[PRE241]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'How can something be both a number and a string? Well, actually, the situation
    is a bit more confusing than that: `69`above is just an address in memory from
    which we can read off whatever we want however we want it(i.e., the content of
    that address is interpreted by the function that reads from it), which can result
    in garbage. It can get even worse:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 什么东西可以既是数字又是字符串呢？实际上，情况比这要复杂一些：上面的`69`只是一个内存地址，我们可以从中读取我们想要的任何东西（即，该地址的内容由读取它的函数解释），这可能导致垃圾数据。情况甚至可能更糟：
- en: '[PRE242]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '. . integer->char: contract violation'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: . . 整数到字符：合约违规
- en: 'expected: valid-unicode-scalar-value?'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 预期：有效的Unicode标量值？
- en: 'given: -1'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 给定：-1
- en: That is, we’ve tried to read “off the end of memory”. It was dumb luck that
    we had a `-1`as the initial value; the `-1`triggered an error when we tried to
    convert it to a character because Racket’s primitives are safe, which halted the
    program. If `integer->char` did not have a safety check, we would have gotten
    some garbled string instead.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们试图读取“内存的末尾”。我们有一个`-1`作为初始值纯属运气；当我们尝试将其转换为字符时，`-1`触发了错误，因为Racket的原始操作是安全的，这使程序停止。如果`integer->char`没有安全检查，我们就会得到一些混乱的字符串。
- en: In short, what we have created is an unsafe language. Data have no integrity.
    Any value can be treated as any kind of datum. This, in short, is the memory model
    of C, and it’s largely proven to be a disaster for modern programming, which is
    why SMoL languages evolved.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们创建的是一个不安全的语言。数据没有完整性。任何值都可以被当作任何类型的数。简而言之，这就是C语言的内存模型，它已被证明对现代编程是一个灾难，这就是为什么SMoL语言发展起来的原因。
- en: Recovering Safety
  id: totrans-930
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复安全性
- en: 'Fortunately, it does not take too much work to make the language safe again.
    What we’ve just written holds the key: every value needs to record what kind of
    value it is. And any use of that value needs to check that it’s the right kind
    of value. This information is called a tag; it takes a fixed amount of space,
    and represents metadata about the subsequent datum. All subsequent values are
    interpreted in accordance with the tag.'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使语言再次安全并不需要太多工作。我们刚刚写下的内容是关键：每个值都需要记录它是什么类型的值。并且任何使用该值的地方都需要检查它是否是正确的类型。这种信息被称为标签；它占用固定大小的空间，并代表后续数据的元数据。所有后续的值都根据标签进行解释。
- en: We need two tags for the two kinds of values. Let’s use
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个标签来表示两种类型的值。让我们使用
- en: '[PRE243]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: It’s important that the two tags be different, so they are unambiguous. However,
    we don’t need to worry about the tags themselves being confused with other data
    (e.g., numbers), because the tags will never be processed directly as program
    data (unless, of course, there is a bug in our implementation that accidentally
    does so…which is why language implementations need to be tested extensively).
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 两个标签必须不同，这样它们才不会产生歧义。然而，我们不需要担心标签本身与其他数据（例如，数字）混淆，因为标签永远不会被直接作为程序数据处理（除非，当然，我们的实现中存在意外导致这种情况的bug……这就是为什么语言实现需要广泛测试）。
- en: 'Now, when we allocate a number, we write its tag into the first address, followed
    by the actual numeric value:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们分配一个数字时，我们将它的标签写入第一个地址，然后是实际的数值：
- en: '[PRE244]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: (let ([a0 (write-and-bump NUMBER-TAG)])
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([a0 (write-and-bump NUMBER-TAG)])
- en: (begin
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: '[PRE245]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: a0))`)`
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: a0))`)`
- en: 'And when we try to read a number, we firstcheck that it really is a number,
    and only then obtain the actual numeric value:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试读取一个数字时，我们首先检查它确实是一个数字，然后才能获取实际的数值：
- en: '[PRE246]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: (if (= (vector-ref MEMORY a) NUMBER-TAG)
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= (vector-ref MEMORY a) NUMBER-TAG)
- en: '`(vector-ref MEMORY` (add1 `a`)`)`'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '`(vector-ref MEMORY (add1 `a`)`)`'
- en: (error 'number (number->string a)))`)`
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: (error 'number (number->string a)))`)`
- en: 'Strings are analogous:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是类似的：
- en: '[PRE247]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '`(let ([a0 (write-and-bump` STRING-TAG`)])`'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([a0 (write-and-bump STRING-TAG`)])`'
- en: '[PRE248]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: (write-and-bump (string-length s))
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: (write-and-bump (string-length s))
- en: '[PRE249]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: (if (= (vector-ref MEMORY a) STRING-TAG)
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= (vector-ref MEMORY a) STRING-TAG)
- en: '[PRE251]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '`(loop (vector-ref MEMORY` (add1 `a`)`) (+ a` 2`)))))`'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '`(loop (vector-ref MEMORY (add1 `a`)`) (+ a` 2`)))))`'
- en: (error 'string (number->string a)))`)`
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: (error 'string (number->string a)))`)`
- en: So now, starting from a fresh memory, running
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，从一个全新的内存开始运行
- en: '[PRE252]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'still produces `0`, but the content of `MEMORY` looks a bit different:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然产生`0`，但`MEMORY`的内容略有不同：
- en: '`''#(`5712'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '`''#(`5712'
- en: '[PRE253]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'That is, at address `0`we first encounter the tag for strings. Only then do
    we get the string’s length, followed by its contents. Observe that now, storing
    the length up front makes even more sense: the first two locations contain the
    tag and the length, both of which are metadata that help us interpret what comes
    later, with the second (the length) refining the first (the tag).'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是，在地址`0`我们首先遇到字符串的标签。然后我们才能得到字符串的长度，接着是它的内容。注意，现在，将长度放在前面存储更有意义：前两个位置包含标签和长度，这些都是元数据，有助于我们解释后续的内容，其中第二个（长度）细化了第一个（标签）。
- en: 'With this change, the interpreter stays unchanged, and effectively so do the
    helpers, other than using the new names we’ve chosen:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个变化，解释器保持不变，以及除了使用我们选择的新名称之外，辅助工具也保持不变：
- en: '[PRE254]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '`  (store-num (+ (`safe-`read-num la) (`safe-`read-num ra))))`'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (store-num (+ (`safe-`read-num la) (`safe-`read-num ra))))`'
- en: '[PRE255]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '`  (store-str (string-append (`safe-`read-str la) (`safe-`read-str ra))))`'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (store-str (string-append (`safe-`read-str la) (`safe-`read-str ra))))`'
- en: 'All our “good” tests still pass, but interestingly, our “bad” tests now fail:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的“良好”测试仍然通过，但有趣的是，我们的“不良”测试现在失败了：
- en: '[PRE256]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Exercise: You may notice the error message strings above have changed slightly.
    Why?'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：你可能注意到上面的错误信息字符串略有变化。为什么？
- en: What Price Safety?
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性有何价值？
- en: Our safe evaluator has, however, come at a price relative to the unsafe evaluator.
    In terms of running time, we are now clearly paying for the overhead of safety
    checks. In terms of space, we are paying for the tags. Thus, we have had to get
    worse space and time.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的安全评估器相对于不安全评估器来说是有代价的。在运行时间方面，我们现在明显是在为安全检查的开销付费。在空间方面，我们是在为标签付费。因此，我们不得不在空间和时间上做出牺牲。
- en: Nevertheless, the price of unsafe languages is so high—e.g., in the form of
    security problems—and the cost of safety is often so low, that programmers gladly
    pay this price (or do so without even particularly noticing it).
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，不安全语言的成本是如此之高——例如，以安全问题的形式——而安全性的成本通常很低，以至于程序员愿意支付这个代价（或者甚至没有特别注意到这一点）。
- en: 'Still, it would be nice if we didn’t have to pay the price at all. And there
    is a way to accomplish that: types.'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果我们根本不用付出代价那会更好。而且有一种方法可以实现这一点：类型。
- en: 'Look at our “bad” programs. These are programs that can staticallybe rejected
    by a type-checker. If we could reject all such programs, then—since no “bad” programs
    would be left—we can then run the program on the unsafe evaluator without worrying
    about negative consequences. This, in effect, is what most typed languages, like
    Java and OCaml, do. Thus we find another use for types: to improve program performance.
    But this requires care.'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的“坏”程序。这些是可以通过类型检查器静态拒绝的程序。如果我们能够拒绝所有这样的程序，那么——由于没有“坏”程序留下——我们就可以在不担心负面后果的情况下在不安全评估器上运行程序。这实际上就是大多数类型语言，如Java和OCaml所做的那样。因此我们发现类型还有另一个用途：提高程序性能。但这需要小心。
- en: Exercise:Usually, in computer science, we talk about a space-time tradeoff.
    Yet here we seem to have a situation where we’ve improved (i.e., reduced the use
    of) both the space and the time! How is that possible?
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：在计算机科学中，我们通常讨论空间-时间权衡。然而，这里我们似乎有一个情况，我们既改进了（即，减少了）空间和时间的使用！这是如何可能的？
- en: Soundness
  id: totrans-977
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确性
- en: Running on an unsafe evaluator is, as the name suggests, dangerous. Therefore,
    we should only do it if we can be sure that nothing can go wrong. That means that
    our type system needs to come with a guarantee.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 在不安全评估器上运行，正如其名称所暗示的，是危险的。因此，我们只有在能够确保没有任何事情会出错的情况下才应该这样做。这意味着我们的类型系统需要提供保证。
- en: The way this guarantee is usually formulated is as follows. Suppose we have
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保证通常是这样表述的。假设我们有
- en: '[PRE257]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: and suppose we evaluate it and find that
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们评估它，并发现
- en: '[PRE258]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: The latter—its value—is the ground truth. The type checker’s job is to make
    sure it matches what the evaluator produces. That is, we would ideally like that
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 后者——它的价值——是事实真相。类型检查器的任务是确保它与评估器产生的结果相匹配。也就是说，我们理想中希望
- en: '`e : t`if and only if `e -> v`and `v : t`'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '`e : t`当且仅当 `e -> v`且 `v : t`'
- en: 'This says that the type checker''s job is to perfectly mirror the evaluator:
    whatever type the program’s result value has is the same type the type-checker
    says it has.'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着类型检查器的任务是完美地反映评估器：程序结果值的类型与类型检查器所说的类型相同。
- en: Unfortunately, for a Turing-complete language, this full guarantee is impossible
    to obtain, because of [Rice’s Theorem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&sa=D&source=editors&ust=1695232021427399&usg=AOvVaw1_99VdJEVQ2qFHhOKxeYso).
    Instead, we have to compromise and see if we can get at least one of the two directions.
    When we think about it, we realize that, in a typed language, we’re only really
    interested in programs that pass the type-checker (i.e., have a type). Therefore,
    we expect that
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于图灵完备的语言，由于[里奇定理](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&sa=D&source=editors&ust=1695232021427399&usg=AOvVaw1_99VdJEVQ2qFHhOKxeYso)，这种完全保证是不可能的。相反，我们必须妥协，看看我们是否至少能获得两个方向中的一个。当我们思考时，我们会意识到，在一个类型语言中，我们真正感兴趣的是通过类型检查器（即，有类型）的程序。因此，我们期望
- en: 'If `e : t` then'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `e : t` 那么'
- en: 'if `e -> v`, then `v : t`'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `e -> v`，那么 `v : t`'
- en: This says that whatever type the type-checker predicted is exactly the type
    that the program has. That means we can rely on the type-checker’s prediction.
    Which in turn means that we can be sure there are no type violations. Which tells
    us we can safely run the program atop an unsafe evaluator! This property is called
    type soundness.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着类型检查器预测的任何类型都是程序的实际类型。这意味着我们可以依赖类型检查器的预测。这反过来又意味着我们可以确信没有类型违规。这告诉我们我们可以安全地在非安全评估器上运行程序！这种属性被称为类型正确性。
- en: 'Note that soundness is not a given: it’s a property that must be formally,
    mathematically proven of a given type-checker and evaluator. The proof can be
    quite complex. This is because the “shape” of program evaluation and that of type-checking
    can be very different, as we have seen before for conditionals [[👉](PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk)]
    and functions [[👉](PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg)]. And failure
    to prove it correctly—i.e., claiming it holds when in fact it doesn’t—means we’ve
    allowed a vulnerability to slip through. This can manifest as uncaught exceptions,
    crashes, segmentation faults, etc. In addition, a clever attacker can construct
    a program that exploits the vulnerability, and our system can be subjected to
    a security or other attack. Thus, any soundness violations are emergencies and
    result in panic.'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正确性不是自动保证的：它是一个必须对给定的类型检查器和评估器进行形式化、数学证明的性质。证明可能非常复杂。这是因为程序评估的“形状”和类型检查的“形状”可能非常不同，就像我们之前在条件
    [[👉](PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk)] 和函数 [[👉](PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg)]
    中看到的那样。未能正确证明——即声称它成立，而实际上并不成立——意味着我们允许一个漏洞溜走。这可能导致未捕获的异常、崩溃、段错误等。此外，一个聪明的攻击者可以构造一个利用这个漏洞的程序，我们的系统可能会受到安全或其他攻击。因此，任何正确性违规都是紧急情况，并导致恐慌。
- en: Generic Printing
  id: totrans-991
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用打印
- en: One of the consequences of our tagged representation is that when extracting
    a value from memory, we don’t haveto know whether to use `safe-read-num`or `safe-read-str`;
    the tag at the address can tell us which to use. That is, we can define
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标记表示的一个后果是，当我们从内存中提取一个值时，我们不必知道是否要使用 `safe-read-num` 或 `safe-read-str`；地址处的标记可以告诉我们使用哪一个。也就是说，我们可以定义
- en: '[PRE259]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Unfortunately, this code can’t be typed by plait because the two branches return
    different types. We can solve this in two ways:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个代码不能由 plait 类型化，因为两个分支返回不同的类型。我们可以用两种方法解决这个问题：
- en: 'We can use a hack: use `#lang plait #:untyped`, which provides the same syntactic
    language, features, and run-time behavior, but turns off the type-checker. (Curiously,
    we were using the type-checker to keep us disciplined: so that the only values
    we could store in `MEMORY` would be numbers! Therefore, it’s good to not use the
    untyped version often.)'
  id: totrans-995
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们可以使用一个技巧：使用 `#lang plait #:untyped`，它提供了相同的语法语言、特性和运行时行为，但关闭了类型检查器。（有趣的是，我们曾经使用类型检查器来保持我们的纪律：这样我们只能将数字存储在
    `MEMORY` 中！因此，不经常使用无类型版本是好的。）'
- en: 'Notice that in the end, what printers do is essentially print a string. Therefore,
    we just need to return a string in all cases: `(define (generic-read a)`'
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，最终，打印器所做的基本上是打印一个字符串。因此，我们只需要在所有情况下返回一个字符串：`(define (generic-read a)`
- en: '[PRE260]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'A consequence of having this function is that we can rewrite our tests to be
    more proper:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个函数的一个后果是，我们可以将我们的测试重写得更合适：
- en: '[PRE261]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: This is much closer to how we would write the test in the original interpreter;
    the only difference here is that the evaluator produces an address as the value,
    but we would like to inspect the value in a human-readable and -writable form,
    so we use `generic-read`.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在原始解释器中编写测试的方式非常接近；这里唯一的区别是评估器产生一个地址作为值，但我们希望以人类可读和可写的形式检查值，所以我们使用 `generic-read`。
- en: Alert:If you run these tests in addition to the preceding ones, you may need
    to enlarge `MEMORY`.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果您运行这些测试以及前面的测试，您可能需要扩大 `MEMORY`。
- en: The Representation of Numbers
  id: totrans-1002
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字表示
- en: Examining the content of `MEMORY`gives the impression that every single number
    we compute is stored afresh on the heap, and furthermore, if we compute a certain
    number (say `3`) twice, each instance will be stored and hence take up space.
    However, this is not the space consumption model of real implementations.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `MEMORY` 的内容给人留下的印象是，我们计算出的每一个数字都是新鲜存储在堆上的，而且更进一步，如果我们计算一个特定的数字（比如说 `3`）两次，每个实例都将被存储，因此会占用空间。然而，这并不是真实实现的空间消耗模型。
- en: 'On most modern architectures, values are stored at [“word” boundaries](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Data_structure_alignment&sa=D&source=editors&ust=1695232021431461&usg=AOvVaw1zfmzCHLp7ziOLweunTDXZ):
    depending on the machine, starting at addresses that are multiples of 4 or 8\.
    For the purposes of illustration, let’s say we have a 32-bit machine, with 4-byte
    alignment. (The reasons for this are due to details of computer architecture that
    are outside the scope of this book.) That means every legal memory address, when
    viewed in binary, ends in …00\. However, there are four legal values for those
    two bits, only one of which is being used. This creates an opportunity.'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代架构中，值存储在[“字”边界](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Data_structure_alignment&sa=D&source=editors&ust=1695232021431461&usg=AOvVaw1zfmzCHLp7ziOLweunTDXZ)：根据机器的不同，从地址的4或8的倍数开始。为了说明目的，让我们假设我们有一个32位机器，具有4字节对齐。
    (这背后的原因是超出本书范围的计算机架构的细节。)这意味着每个合法内存地址，当以二进制形式查看时，以…00结尾。然而，对于这两个位，有四个合法值，其中只有一个正在使用。这创造了一个机会。
- en: A common technique is to therefore use a pattern like …01 to be the tag for
    numbers. The actual number itself is stored in the remaining (say 30) bits of
    the “address”. That means, “addresses” that end in 01 are not true addresses,
    and must not be looked up; they are actually just numbers.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个常见的技巧是使用类似于…01的模式作为数字的标签。实际的数字本身存储在“地址”剩余的（比如说30）位中。这意味着以01结尾的“地址”不是真正的地址，不应查找；它们实际上是数字。
- en: Thus, in principle, the first thing to do with a value (that is, an address)
    is to test its 0’th bit. If this is 1, then shift the value right by 2 places.
    This drops the 01 tag, leaving the number in place. Similarly, when a number is
    constructed, provided it fits in 30 bits, it is shifted left by two places, and
    the last bit is made 1 (resulting in the 01 tag).
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原则上，处理一个值（即一个地址）的第一件事是测试其0位。如果是1，则将值右移2位。这将丢弃01标签，保留数字在原位。同样，当构建一个数字时，只要它适合30位，它就会左移两位，并将最后一位设置为1（从而产生01标签）。
- en: As a consequence, every number has a tag; but every number is also stored in
    registers and on the stack, not on the heap. All numbers with the same value have
    the same bit-pattern representation (the 30-bit numeric value followed by 01).
    Thus, there will be zero instances of them on the heap, and they can be accurately
    compared for equality in constant time.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个数字都有一个标签；但每个数字也存储在寄存器和栈上，而不是堆上。具有相同值的所有数字都有相同的位模式表示（30位数值后跟01）。因此，在堆上不会有它们的零实例，并且可以在常数时间内准确比较它们的相等性。
- en: Aside: Notice that the above technique only works for numbers that can fit in
    30 bits (or about 60 bits in a 64-bit machine). Larger numbers have to still be
    stored on the heap.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：请注意，上述技术仅适用于可以适应30位的数字（或在64位机器上约为60位）。较大的数字仍然必须存储在堆上。
- en: 'As you might imagine, we have further room to play: we still have the patterns
    …10 and …11\. Another good candidate for fitting entirely in the address is a
    Boolean, so the pattern …10 could be used for that. Very short strings might fit
    in a word. And so on. There are many architectural, instruction-set, and program
    considerations in designing these tags at the low level.'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，我们还有更多的空间可以发挥：我们仍然有…10和…11的模式。另一个适合完全放入地址的候选者是布尔值，因此可以使用…10模式。非常短的字符串可能适合一个字。等等。在设计这些标签时，有许多架构、指令集和程序考虑因素。
- en: Type Inference
  id: totrans-1010
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: Unannotated Programs and Types
  id: totrans-1011
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未注释的程序和类型
- en: 'Consider the following plait program:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下plait程序：
- en: '[PRE262]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'If we enter this program into plait, e.g., as follows, something remarkable
    happens:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此程序输入到plait中，例如如下所示，会发生一些显著的事情：
- en: '[PRE263]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'In response, plait figures outthe type of this function without our having
    to provide any annotations. This is in contrast to the type-checker we just wrote
    [[👉](PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg)], which required us to extend
    the syntax just to provide (required) type annotations. That tells us that something
    different—and more—must be happening under plait. In contrast, consider another
    example:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，plait无需我们提供任何注释就能确定此函数的类型。这与我们刚刚编写的类型检查器形成对比，该类型检查器要求我们扩展语法以提供（必需的）类型注释。这告诉我们，在plait中必须发生一些不同——更多的事情。相比之下，考虑另一个例子：
- en: '[PRE264]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: This produces an error, observing that we are using `x`both in a position that
    requires it to be a Boolean (in `if`) and a number (in the two additions). Again,
    plait has figured this out without our having to write any annotations at all!
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个错误，指出我们在一个需要它为布尔值（在`if`中）和一个数字（在两个加法中）的位置使用了`x`。再次，plait没有要求我们写任何注释就找到了这一点！
- en: 'The algorithm that sits underneath plait is essentially the same algorithm
    under OCaml, Haskell, and several other programming languages. These languages
    provide type inference: figuring out (inferring) types automatically from the
    program source. Now we’re going to see how this works.'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 位于plait之下的算法本质上与OCaml、Haskell和几种其他编程语言下的算法相同。这些语言提供类型推断：自动从程序源代码中推断类型。现在我们将看到它是如何工作的。
- en: The key idea is to break this seemingly very complex problem into two rather
    simple parts. In the first, we recursively visit each sub-expression of the program
    (following SImPl) and generate a set of constraintsthat formally do what we’ve
    been doing informally above. The second phase solvesthis set of constraints, using
    a process that is a generalization of the process you used for solving “systems
    of simultaneous equations” in school. The solution is a type for each variable.
    That lets us fill in the annotations that the programmer left blank.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是将这个看似非常复杂的问题分解成两个相对简单的部分。在第一个阶段，我们递归地访问程序中的每个子表达式（遵循SImPl），并生成一组约束，这些约束形式上做了我们之前非正式地所做的事情。第二个阶段通过一个过程解决这组约束，这个过程是你在学校解决“联立方程组”时所用过程的推广。解是一个类型，对于每个变量。这让我们能够填写程序员留下的空白注释。
- en: The process of generation will also have applied the type constraints, so there
    will be no further need to type-check the program; but we can use the annotations,
    for instance, in an IDE for tool-tips, in a compiler for optimization, etc. That
    is, with inference, we can program as if we’re in a “scripty” language without
    annotations, yet achieve most of the benefits of types. (I say “most” because
    one of the benefits is documentation; leaving off all annotations makes programs
    harder to read and understand. For that reason, inference should be used sparingly.)
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 生成过程也将应用类型约束，因此将不再需要检查程序的类型；但我们可以使用注释，例如在IDE中的工具提示，在编译器中的优化等。也就是说，通过推断，我们可以像在不需要注释的“脚本”语言中编程一样，同时获得类型的大多数好处。（我说“大多数”，因为好处之一是文档；省略所有注释会使程序更难阅读和理解。因此，推断应该谨慎使用。）
- en: Imagining a Solution
  id: totrans-1022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 想象一个解决方案
- en: 'Until now, our type checker has required us to annotate the parameter of every
    function. But let’s imagine someone handed us a piece of code without annotations;
    can we figure out the type anyway? For instance, consider:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的类型检查器要求我们对每个函数的参数进行注释。但让我们想象一下，有人给我们一段没有注释的代码；我们能否无论如何找出类型？例如，考虑：
- en: '[PRE265]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'We clearly know the type of this; even our type-checker can calculate it for
    us without any annotations. But of course that’s not surprising: there are no
    variables to annotate. So now consider this expression:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然知道这个表达式的类型；即使我们的类型检查器也可以在没有任何注释的情况下为我们计算它。但当然这并不奇怪：没有变量需要注释。现在考虑这个表达式：
- en: '[PRE266]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: With a moment’s inspection, we can tell that the function has type `(Num ->
    Num)`. But our type-checker couldn’t have calculated that, because it would have
    tripped on the empty annotation. So how can we figure it out?
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 通过片刻的检查，我们可以判断该函数的类型是`(Num -> Num)`。但我们的类型检查器不可能计算出这一点，因为它会在空注释上出错。那么我们如何找出它呢？
- en: Well, let’s see. First we have to figure out the type of `x`. To determine its
    type, we should look for usesof `x`. There is only one, and it’s used in an addition.
    But the rule for addition
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看。首先，我们必须找出`x`的类型。为了确定其类型，我们应该寻找`x`的使用。只有一个，它被用于加法中。但加法的规则
- en: 'Γ `|- e1 : Num    `Γ `|- e2 : Num`'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- e1 : Num` Γ `|- e2 : Num`'
- en: '[PRE267]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'Γ `|- (+ e1 e2) : Num`'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (+ e1 e2) : Num`'
- en: tells us that the term in that position must have type `Num`. There is no additional
    information we have about `x`(this remark will become clearer in a moment). Therefore,
    we can determine that its type must be `Num`. Furthermore, we know that the result
    of an addition is also a `Num`. From that, we can conclude that the function has
    type `(Num -> Num)`.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我们那个位置的项必须是类型`Num`。我们没有关于`x`的额外信息（这个评论将在一会儿变得清楚）。因此，我们可以确定它的类型必须是`Num`。此外，我们知道加法的结果也是一个`Num`。从这一点，我们可以得出结论，该函数的类型是`(Num
    -> Num)`。
- en: Unique Variable Names
  id: totrans-1033
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唯一变量名
- en: In what follows, we will assume that all variable names in the program are unique.
    That is, a given variable name is bound in at most one place in a program. This
    greatly simplifies the presentation below, because we can speak of the type of
    a variable and know which variable it refers to, instead of having to constantly
    qualify which variable of that name we mean.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将假设程序中所有变量名都是唯一的。也就是说，一个给定的变量名在一个程序中最多被绑定一次。这大大简化了下面的展示，因为我们可以谈论一个变量的类型，并知道它指的是哪个变量，而不是不得不不断说明我们指的是哪个同名的变量。
- en: 'This restriction does not actually preclude any programs in a language with
    static scope. Consider this program, which produces `7`:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制实际上并不排除静态作用域语言中的任何程序。考虑这个产生 `7` 的程序：
- en: '[PRE268]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'We can just as well consistently renameone of the `x`s to something else (heck,
    we can even use the DrRacket interface to have Racket do the renaming for us),
    and leave the program meaning exactly the same:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个 `x` 姓名一致地重命名为其他名称（嘿，我们甚至可以使用 DrRacket 界面让 Racket 帮我们重命名），而程序的意义保持完全相同：
- en: '[PRE269]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: This renaming process is called alpha conversionor alpha renaming.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重命名过程被称为 alpha 转换或 alpha 重命名。
- en: More Informal Examples
  id: totrans-1040
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更非正式的例子
- en: 'With that important detail out of the way, let’s return to our process of inferringor
    reconstructing the types of variables from the way they’re used in a program.
    Here’s another example with a two-parameter function:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这个重要细节之后，让我们回到从程序中变量的使用方式推断或重建变量类型的过程。这里有一个带有两个参数函数的例子：
- en: '[PRE270]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Once again, we can’t just calculate its type with our type-checker; instead,
    we must reconstruct the type from the function body. Let’s do that. What can we
    tell? Let’s again refer to the conditional rule:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们无法仅用类型检查器计算其类型；相反，我们必须从函数体中重建类型。让我们来做这件事。我们能知道什么？让我们再次参考条件规则：
- en: 'Γ `|- C : Bool    `Γ `|- T : U    `Γ `|- E : U`'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- C : Bool` Γ `|- T : U` Γ `|- E : U`'
- en: '[PRE271]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Γ `|- (if C T E) : U`'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (if C T E) : U`'
- en: This tells us that what’s in the `C`position—here, `x`—must be a `Bool`. Furthermore,
    both branches `(+ y 1)`and `(+ y 2)`must have the same type. That’s all we can
    learn from the rule for `if`! But now we can (and must) recur into the sub-expressions.
    Each one is an addition, and the addition rule tells us that both arguments must
    be `Num`s. Both of these indicate that the type of `y`must be `Num`. Furthermore,
    both indicate that the overall addition returns a `Num`. From that we can tell
    that the entire expression must have the type
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，位于 `C` 位置的元素——这里，是 `x`——必须是一个 `Bool` 类型。此外，分支 `(+ y 1)` 和 `(+ y 2)` 必须具有相同的类型。这就是我们从
    `if` 规则中能学到的所有内容！但现在我们可以（并且必须）递归到子表达式中。每一个都是一个加法操作，加法规则告诉我们两个参数都必须是 `Num` 类型。这两个都表明
    `y` 的类型必须是 `Num`。此外，这两个都表明整体加法操作返回一个 `Num` 类型。从这一点我们可以推断出整个表达式的类型必须是
- en: '[PRE272]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'By this process, we can figure out what types to put in the missing annotations.
    More subtly, notice that by running through this process, we have effectively
    applied all the typing rules; therefore, if we have successfully reconstructed
    the type annotations, we need not bother type-checking the program with those
    annotations: it will have to type-check.'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个过程，我们可以确定缺失的注解中应该放置的类型。更微妙的是，注意通过运行这个过程，我们实际上已经应用了所有类型规则；因此，如果我们已经成功重建了类型注解，我们就不必麻烦用这些注解来检查程序：它将必须通过类型检查。
- en: 'Now let’s consider a slight variation on the above program:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑上述程序的一个微小变化：
- en: '[PRE273]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'Now let’s figure out everything we can learn about `x` from the function’s
    body:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找出从函数体中关于 `x` 可以了解的所有信息：
- en: '`x`is used in the conditional position of an `if`. Therefore, it must have
    type `Bool`.'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 被用于 `if` 的条件位置。因此，它必须有 `Bool` 类型。'
- en: '`x`is used as a parameter to `+`. Therefore, it must have type `Num`.'
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 被用作 `+` 函数的参数。因此，它必须有 `Num` 类型。'
- en: '`x`is again used as a parameter to `+`. Therefore, it must have type `Num`.'
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 再次被用作 `+` 函数的参数。因此，它必须有 `Num` 类型。'
- en: 'Notice that each of these conclusions is perfectly fine on its own. However,
    when we put them together(which is what we meant by “additional information” above),
    there’s a problem: `x`cannot be both of those. That is, we are unable to find
    a single type for `x`. This inability to find a type for `x`means that the program
    has a type error. And indeed, there is no type we could have given that would
    have enabled this program to execute safely.'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，这些结论中的每一个单独来看都是完全正确的。然而，当我们把它们放在一起（这就是我们上面所说的“附加信息”），就有一个问题：`x`不能同时是这两个。也就是说，我们无法为`x`找到一个单一的类型。这种无法为`x`找到类型的能力意味着程序存在类型错误。确实，没有类型我们可以给出，可以使这个程序安全执行。
- en: Observe something subtle. While we can report that the program clearly has a
    type error, our error message must necessarily be much more ambiguous. Previously,
    when we had a type annotation on `x`, we could pinpoint where the error occurred.
    Now, all we can say is that the program is not type-consistent, but cannot blame
    one spot or the other without potentially misleading the programmer. Instead,
    we must report all these locations and let the programmer decide where the error
    is based on their unstated intent (in the form of a type annotation).
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一个微妙之处。虽然我们可以报告程序明显存在类型错误，但我们的错误信息必然会更加模糊。以前，当我们对`x`有类型注解时，我们可以确定错误发生的位置。现在，我们只能说程序不是类型一致的，但如果不误导程序员，就不能责怪某个地方或另一个地方。相反，我们必须报告所有这些位置，并让程序员根据他们未声明的意图（以类型注解的形式）决定错误发生的位置。
- en: Algorithmic Details
  id: totrans-1058
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法细节
- en: The details of this algorithm—called Hindley-Milner inference—are fascinating,
    and worked out in detail in both the first and second editions of [this book,
    PLAI](https://www.google.com/url?q=https://www.plai.org/&sa=D&source=editors&ust=1695232021443495&usg=AOvVaw1Jv2eQapvZVGeMGKdx7dFB) (Chapter
    30 in the first edition and Chapter 15.3.2 in the second edition). For several
    worked examples of both constraint generation and constraint solving, refer to
    the first edition. The first edition has a more algorithmic presentation, while
    the second provides code (it may be useful to compare the two). The prose in the
    second is different from that in the first, so different readers may prefer one
    over the other.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的细节——称为Hindley-Milner推理——非常迷人，在本书的第一版和第二版中都有详细阐述[这本书，PLAI](https://www.google.com/url?q=https://www.plai.org/&sa=D&source=editors&ust=1695232021443495&usg=AOvVaw1Jv2eQapvZVGeMGKdx7dFB)（第一版中的第30章和第二版中的第15.3.2章）。关于约束生成和约束求解的几个工作示例，请参阅第一版。第一版有更算法化的展示，而第二版提供了代码（可能需要比较两者）。第二版的散文与第一版不同，因此不同的读者可能更喜欢其中一个。
- en: Algebraic Datatypes
  id: totrans-1060
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数数据类型
- en: We have written numerous `define-type` definitions so far, e.g., for expressions.
    Now we will study this mechanism, which is increasingly found in many new programming
    languages, in more detail.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了大量的`define-type`定义，例如，用于表达式。现在我们将更详细地研究这种机制，这种机制越来越多地出现在许多新的编程语言中。
- en: 'To simplify things, consider a simple plait data definition of a binary tree
    of numbers:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，考虑一个简单的数字二叉树的数据定义：
- en: '[PRE274]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'The `define-type` construct here is doing three different things, and it’s
    worth teasing them apart:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`define-type`构造正在做三件事，值得将其分开：
- en: Giving a nameto a new type, `BT`.
  id: totrans-1065
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新类型命名，`BT`。
- en: Allowing the type to be defined by multiple cases or variants (`mt`and `node`).
  id: totrans-1066
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许类型通过多个案例或变体定义（`mt`和`node`）。
- en: Permitting a recursive definition (`BT`references `BT`).
  id: totrans-1067
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许递归定义（`BT`引用`BT`）。
- en: It’s worth asking whether all these pieces of functionality really have to be
    bundled together, or whether they can be handled separately. While they can indeed
    be separated, they often end up working in concert, especially when it comes to
    recursive definitions, which are quite common. A recursive definition needs a
    name for creating the recursion; therefore, the third feature requires the first.
    Furthermore, a recursive definition often needs a non-recursive case to “bottom
    out”; this requires there to be more than one variant, using the second feature.
    Putting the three together, therefore, makes a lot of sense.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 值得思考的是，所有这些功能功能是否真的必须捆绑在一起，或者它们是否可以单独处理。虽然它们确实可以分开，但它们通常最终会协同工作，尤其是在递归定义方面，这是相当常见的。递归定义需要一个名称来创建递归；因此，第三个特性需要第一个特性。此外，递归定义通常需要一个非递归的情况来“到底”；这需要存在多个变体，使用第二个特性。因此，将这三个特性结合起来是非常有意义的。
- en: 'This construct is called an algebraic datatype, sometimes also known as a “sum
    of products”. That is because the variants are read as an “or”: a `BT`is an `mt` ora
    `node`. Each variant is an “and” of its fields: a node has a `v` andan `l` andan
    `r`. In Boolean algebra, “or” is analogous to a sum and “and” is analogous to
    a product.'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构被称为代数数据类型，有时也称为“积之和”。这是因为变体被读取为“或”：一个`BT`是`mt`或`node`。每个变体是其字段的“与”：一个节点有`v`、`l`和`r`。在布尔代数中，“或”类似于和，“与”类似于积。
- en: Sometimes, you will also see this referred to as a tagged union. The word “union”
    is because we can conceptually think of a `BT`as a union of `mt`s and `node`s.
    The tag is the constructor. This term makes more sense once we compare it against
    “untagged” union types [[👉](PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt)].
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你也会看到它被称为带标签的联合。单词“联合”是因为我们可以从概念上认为`BT`是`mt`和`node`的联合。标签是构造函数。一旦我们将其与“未标记”的联合类型进行比较，这个术语就更有意义[[👉](PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt)]。
- en: Generated Bindings
  id: totrans-1071
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成绑定
- en: 'Now the question is, how do we type code that uses such a definition? First,
    let’s take an inventory of all the definitions that this might create. It at least
    creates two constructors:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何对使用这种定义的代码进行类型检查？首先，让我们列出所有可能由此产生的定义。它至少创建两个构造函数：
- en: '[PRE275]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'We have been starting our interpretation and type-checking with the empty environment,
    but there is no reason we need to, nor do we do so in practice: the primordial
    environment can contain all kinds of pre-defined values and their types. Thus,
    we can imagine the `define-type`above adding the above two definitions to the
    initial type environment, enabling uses of `mt`and `node` to be type-checked.'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直从空环境开始我们的解释和类型检查，但并没有必要这样做，实际上我们也没有这样做：原始环境可以包含各种预定义的值及其类型。因此，我们可以想象上面的`define-type`将上述两个定义添加到初始类型环境中，使得对`mt`和`node`的使用可以被类型检查。
- en: 'This much is standard across various languages. But less commonly, in plait
    you get two more families of functions: predicates for distinguishing between
    the variants:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 这在各种语言中都是标准的。但在plait中，你还可以得到两个更多函数家族：用于区分变体的谓词：
- en: '[PRE276]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'and accessors for getting the values out of fields:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 并且访问器用于从字段中获取值：
- en: '[PRE277]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Static Type Safety
  id: totrans-1079
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类型安全
- en: 'We should be troubled by the types of these accessors. They seem to indiscriminately
    try to pull out field values, whether the variant has them or not. For instance,
    we can write and type-check this program, which is appealing:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该对这种访问器的类型感到困扰。它们似乎不加区分地尝试提取字段值，无论变体是否有这些值。例如，我们可以编写并检查这个程序，它很有吸引力：
- en: '[PRE278]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'However, we can just as well type-check this program:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以对以下程序进行类型检查：
- en: '[PRE281]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: This should not type-check because it has a clear type-error. The type of `size-wrong` is
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该通过类型检查，因为它有一个明显的类型错误。`size-wrong`的类型是
- en: '[PRE282]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'so it is perfectly type-correct to write:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编写以下代码是完美的类型正确的：
- en: '[PRE283]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: But running this, of course, results in a run-time error, the very kind of error
    we might have hoped the type-checker would catch.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 但运行这个，当然，会导致运行时错误，这正是我们可能希望类型检查器捕获的错误。
- en: Pattern-Matching and Type-Checking
  id: totrans-1091
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配和类型检查
- en: 'This kind of error cannot occur naturally in languages like OCaml and Haskell.
    Instead of exposing all these predicates and accessors, instances of an algebraic
    datatype are deconstructed using pattern-matching. Thus, the size computation
    would be written as (`-pm` stands for “pattern matching”):'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误在OCaml和Haskell等语言中不会自然发生。代数数据类型的实例不是通过暴露所有这些谓词和访问器来解构的，而是使用模式匹配。因此，大小计算可以写成（`-pm`代表“模式匹配”）：
- en: '[PRE284]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'This might seem like a convenience—it certainly makes the code much more compact
    and perhaps also much more readable—but it’s also doing something more. The pattern-matcher
    is effectively baked into the way programs are type-checked. That is, the above
    algebraic datatype definition effectively adds the following typing rule to the
    type checker:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一种便利——它确实使代码更加紧凑，也许也更容易阅读——但它还在做更多的事情。模式匹配器实际上被嵌入到程序类型检查的方式中。也就是说，上述代数数据类型定义实际上向类型检查器添加了以下类型规则：
- en: Γ `|- e :` BT
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: Γ `|- e :` BT
- en: Γ `|- e1 :` T
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: Γ `|- e1 :` T
- en: Γ[V <- Number, L <- BT, R <- BT] `|- e2 :` T
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: Γ[V <- Number, L <- BT, R <- BT] `|- e2 :` T
- en: '[PRE286]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Γ `|- (type-case BT e`
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: Γ `|- (type-case BT e`
- en: '[PRE287]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'The first antecedent is clear: we have to confirm that the expression `e`evaluates
    to a BTbefore we pattern-match `BT`patterns against it. The second type-checks
    `e1`in the sameenvironment as in the consequent because the `mt`variant does not
    add any local bindings. The type of this expression needs to be the sameas the
    type from the other branch, due to how we’re handling conditionals. Finally, to
    type-check `e2`, we have to extendthe consequent’s type environment with the bound
    variables; their types we can read off directly from the data definition. In short,
    the above typing rule can be defined automatically by desugaring.'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个前提是明确的：在我们对`BT`模式进行模式匹配之前，我们必须确认表达式`e`评估为BT。第二个类型检查`e1`与后续部分相同的上下文中，因为`mt`变体没有添加任何局部绑定。由于我们处理条件的方式，这个表达式的类型需要与另一分支的类型相同。最后，为了类型检查`e2`，我们必须将后续的类型环境扩展到绑定变量；我们可以直接从数据定义中读取它们的类型。简而言之，上述类型规则可以通过去糖自动定义。
- en: 'Aside:Notice that there is also an assume-guarantee here: we type-check `e2`in
    an environment that assumesthe annotated types; this is guaranteedby the `node` constructor.'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句：注意这里也有一个假设-保证：我们在假设注解类型的上下文中类型检查`e2`；这是由`node`构造函数保证的。
- en: 'In particular, observe what we couldn’tdo! We didn’t have awkward selectors,
    like `node-v`, for which we had to come up with some type. By saying they consumed
    a `BT`, we had to let them statically consume any kind of `BT`, which caused a
    problem at run-time. Here, there is no selector: pattern-matching means we can
    only write pattern-variables in variants where the algebraic datatype definition
    permits it, and the variables automatically gets the right type. Thus, pattern-matching
    plays a crucial role in the statically safe handling of types.'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其要注意我们无法做什么！我们没有像`node-v`这样的尴尬选择器，我们需要为它想出某种类型。通过说它们消耗了`BT`，我们必须让它们静态地消耗任何类型的`BT`，这在运行时造成了问题。在这里，没有选择器：模式匹配意味着我们只能在代数数据类型定义允许的变体中写入模式变量，变量会自动获得正确的类型。因此，模式匹配在静态安全地处理类型中起着至关重要的作用。
- en: Algebraic Datatypes and Space
  id: totrans-1105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数数据类型和空间
- en: Earlier, we’ve seen that types can save us both time and space. We have to be
    a little more nuanced when it comes to algebraic datatypes.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了类型可以为我们节省时间和空间。当我们谈到代数数据类型时，我们必须更加细腻。
- en: 'The new type introduced by an algebraic datatype still enjoys the space saving.
    Because the type checker can tell a `BT`apart from every other type, at run-time
    we don’t need to record that a value is a `BT`: it doesn’t need a type-tag. However,
    we still need to tell apart the different variants: the function `size-pm` effectively
    desugars into (`-ds` stands for “desugared”):'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据类型引入的新类型仍然享有空间节省的好处。因为类型检查器可以区分`BT`与其他任何类型，在运行时我们不需要记录一个值是`BT`：它不需要类型标签。然而，我们仍然需要区分不同的变体：函数`size-pm`实际上去糖为（`-ds`代表“去糖”）：
- en: '[PRE288]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: (We’ve introduced the `let`to bind the names introduced by the pattern.) What
    this shows is that at run-time, there are conditional checks that need to know
    what kind of `BT`is bound to `t` on this iteration. Therefore, we need just enough
    tagging to tell the variants apart. In practice, this means we need as many bits
    as the logarithm of the number of variants; since this number is usually small,
    this information can often be squeezed into other parts of the data representation.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: （我们引入了`let`来绑定模式引入的名称。）这表明在运行时，有一些条件检查需要知道在这个迭代中`t`绑定的是什么类型的`BT`。因此，我们只需要足够的标记来区分变体。在实践中，这意味着我们需要与变体数量的对数一样多的位；由于这个数字通常很小，这些信息通常可以压缩到数据表示的其他部分。
- en: Union Types and Retrofitted Types
  id: totrans-1110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型和后置类型
- en: 'Typed Racket is an instance of a retrofittedtype system: adding a type system
    to a language that did not previously have types. The original language, which
    does not have a static type system, is usually called dynamic. There are now numerous
    retrofitted type systems: e.g., TypeScript for JavaScript and Static Python for
    Python. There are even multiple retrofitted type systems for some languages: e.g.,
    both TypeScript and Flow add types to JavaScript.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化的Racket是一个后置类型系统的实例：将类型系统添加到一个之前没有类型的语言中。原始语言没有静态类型系统，通常被称为动态。现在有众多的后置类型系统：例如，TypeScript为JavaScript，Static
    Python为Python。甚至有些语言有多个后置类型系统：例如，TypeScript和Flow都为JavaScript添加了类型。
- en: The goal of a retrofitted type system is to turn run-time errors into static
    type errors. Due to the Halting Problem, we cannot precisely turn every single
    run-time error into a static one, so the designer of the type system must make
    some decisions about which errors matter more than others. In addition, programmers
    have already written considerable code in many dynamic languages, so changes that
    require programmers to rewrite code significantly would not be adopted. Instead,
    as much as possible, type system designers need to accommodate idiomatic type-safe
    programs.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 改造后类型系统的目标是把运行时错误转换为静态类型错误。由于停机问题，我们无法精确地将每个运行时错误都转换为静态错误，因此类型系统的设计者必须就哪些错误比其他错误更重要做出一些决定。此外，程序员已经在许多动态语言中编写了大量代码，因此需要程序员大量重写代码的更改不会被采用。相反，尽可能多，类型系统设计者需要适应惯用类型安全程序。
- en: Algebraic datatypes present a good example. Typically, they have tended to not
    be found in dynamic languages. Instead, these languages have some kind of structure
    definition mechanism (such as classes, or lightweight variants thereof, like Python’s
    [dataclasses](https://www.google.com/url?q=https://docs.python.org/3/library/dataclasses.html&sa=D&source=editors&ust=1695232021455665&usg=AOvVaw2l-qHVAvQWW6klXtg2zXhU)).
    Therefore, the elegant typing that goes with algebraic datatypes and their pattern-matching
    does not apply. Because it is not practical to force dynamic language programmers
    to wholesale change to this “new” (to that dynamic language) style of programming,
    type system designers must find the idioms they use (that happen to be type-safe)
    and try to bless them. We will look at some examples of this.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据类型提供了一个很好的例子。通常，它们在动态语言中并不常见。相反，这些语言有一些结构定义机制（例如类，或者像Python的[dataclasses](https://www.google.com/url?q=https://docs.python.org/3/library/dataclasses.html&sa=D&source=editors&ust=1695232021455665&usg=AOvVaw2l-qHVAvQWW6klXtg2zXhU)这样的轻量级变体）。因此，与代数数据类型及其模式匹配相关的优雅类型化不适用。由于强制动态语言程序员全面改变这种“新”（对那种动态语言而言）的编程风格并不实用，类型系统设计者必须找到他们使用的惯用用法（碰巧是类型安全的）并尝试认可它们。我们将看看一些这样的例子。
- en: A good working example of a retrofitted typed language is Typed Racket, which
    adds types to Racket while trying to preserve idiomatic Racket programs. (This
    is in contrast to plait, which is also a typed form of Racket but does not try
    very hard to preserve Racket idioms. The accessors we saw earlier, for algebraic
    datatypes [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)], are forgiving
    in what they accept, at the cost of static safety.)
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的改造后类型化语言的例子是Typed Racket，它在尝试保留Racket惯用程序的同时为Racket添加类型。（这与plait形成对比，plait也是Racket的类型化形式，但它并不非常努力地保留Racket惯用用法。我们之前看到的用于代数数据类型的访问器[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)]在它们接受的方面很宽容，但这是以静态安全性为代价的。）
- en: You Get a Type! And You Get a Type! And You Get a Type!
  id: totrans-1115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你得到一个类型！你得到一个类型！你得到一个类型！
- en: 'Let’s return [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)] to our non-statically-type-safe
    accessors in plait: e.g.,'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到plait中非静态类型安全的访问器[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)：
- en: '[PRE289]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'In a way, it’s not fair to blame the accessor: the fault is really with the
    constructor, because'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，责备访问器是不公平的：真正的问题在于构造器，因为
- en: '[PRE290]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Once the `node`constructor creates a `BT`, the information about `node`-ness
    is lost, and there’s not much that the accessors can do. So perhaps the alternative
    is to notcreate a `BT`, but instead create a value of the `node` type.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`node`构造器创建了一个`BT`，关于`node`的信息就丢失了，访问器能做的也就不多。所以，也许的替代方案是不要创建`BT`，而是创建一个`node`类型的值。
- en: 'So let’s start over. This time, we’ll use a different typed language, Typed
    Racket:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们重新开始。这次，我们将使用不同的类型化语言，Typed Racket：
- en: '[PRE291]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'In Typed Racket, we can create products, called structures, which define a
    new type:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Typed Racket中，我们可以创建产品，称为结构体，它们定义了一个新类型：
- en: '[PRE292]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'This creates a constructor with the type we’d expect:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个我们预期的类型的构造器：
- en: '[PRE293]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'It also creates a predicate, whose type is a bit different; previously we had
    a function that could only take a `BT`, because it didn’t make sense to apply
    `mt?`to any other type. Now, however, there isn’t even a concept of a `BT`(yet),
    so `mt?` will take values of any type:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 它还创建了一个谓词，其类型略有不同；之前我们有一个只能接受`BT`的函数，因为将`mt?`应用于任何其他类型都没有意义。然而，现在甚至还没有`BT`的概念，所以`mt?`将接受任何类型的值：
- en: '[PRE294]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '(The additional text, `: mt`, is telling us when the Boolean is true; ignore
    this for now.)'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: （附加文本`： mt`告诉我们布尔值何时为真；现在先忽略它。）
- en: 'Now let’s try to define nodes. Here we run into a problem:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试定义节点。在这里，我们遇到了一个问题：
- en: '[PRE295]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Union Types
  id: totrans-1132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合类型
- en: 'Oops—what do we write here?!? We have to also introduce a notion of a binary
    tree. But we already have two existing types, `mt`and (in progress) `node`. Therefore,
    we need a way to define a binary tree that has a sum that combines these two existing
    types. This suggests that we have a way of describing a new type as a union of
    existing types:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——这里我们应该写什么？！？我们还需要引入一个二叉树的概念。但是，我们已经有两种现有的类型，`mt`和（正在进行的）`node`。因此，我们需要一种方法来定义一个结合这两种现有类型的二叉树。这表明我们有一种方法来描述一个新类型作为现有类型的联合：
- en: '[PRE296]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: Observe that in this case, there are no special constructors to distinguish
    between the two kinds of BT. Therefore, this is called an untagged union, in contrast
    to tagged unions [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)].
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，没有特殊的构造函数来区分两种类型的BT。因此，这被称为无标记联合，与标记联合相对 [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)]。
- en: 'Now we can go back and complete our definition of `node`:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到并完成我们对`node`的定义：
- en: '[PRE297]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'Now let’s look at what Typed Racket tells us are the types of `node`’s constructor,
    predicate, and selectors:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Typed Racket告诉我们`node`构造函数、谓词和选择器的类型：
- en: '[PRE298]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Using these definitions we can create trees: e.g.,'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些定义，我们可以创建树：例如，
- en: '[PRE299]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'But now let’s try to write a program to compute its size:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在让我们尝试编写一个计算其大小的程序：
- en: '[PRE300]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: It is not clear at all that this program should type-check. Consider the expression
    `(node-l t)`. The type of `node-l`expects its argument to be of type `node`. However,
    all we know is that `t`is of type `BT`. Yet this program type-checks!
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序应该通过类型检查并不明显。考虑表达式`(node-l t)`。`node-l`的类型期望其参数是`node`类型。然而，我们所知道的是`t`是`BT`类型。然而，这个程序通过了类型检查！
- en: The fact that this does type-check, however, should not fill us with too much
    joy. We saw how `size-wrong` type-checked, only to halt with an undesired run-time
    error. So what if we instead write its analog, which is this?
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个程序能够通过类型检查的事实，不应该让我们过于高兴。我们看到了`size-wrong`如何通过类型检查，但最终以不期望的运行时错误停止。那么，如果我们改写它的类似程序，会怎样呢？
- en: '[PRE301]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'This program does nottype-check! Instead, it gives us a type error of exactly
    the sort we would have expected: `node-l`and `node-r`both complain that they were
    expecting an `node`and were given a `BT`. So the wonder is not that `size-tr-wrong`has
    a type-error, but rather that `size-tr` does not!'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序没有通过类型检查！相反，它给出了我们预期的那种类型的错误：`node-l`和`node-r`都抱怨它们期望的是一个`node`，但是给出的是一个`BT`。所以，令人惊讶的不是`size-tr-wrong`有类型错误，而是`size-tr`没有！
- en: 'To understand why it type-checks, we have to go back to the types of the predicates:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么它通过类型检查，我们必须回到谓词的类型：
- en: '[PRE302]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Critically, the `: mt`and `: node`are Typed Racket’s way of saying that the
    Boolean will be true only when the input is an `mt`or `node`, respectively. This
    crucial refinementinformation is picked up by the type-checker. In the right-hand-side
    of the `cond`clauses, it narrowsthe type of `t`to be `mt`and `node`, respectively.
    Thus, `(node-l t)`is type-checked in a type environment where the type of `t`is
    `node`and not `BT`.'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '关键的是，`: mt`和`: node`是Typed Racket表示布尔值仅在输入是`mt`或`node`时为真的方式。这种关键的信息被类型检查器捕获。在`cond`子句的右侧，它将`t`的类型缩小到`mt`和`node`。因此，`(node-l
    t)`在`t`的类型是`node`而不是`BT`的类型环境中进行了类型检查。'
- en: 'To test this theory, we can try another wrong program:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个理论，我们可以尝试另一个错误的程序：
- en: '[PRE303]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Here, we have swapped the predicates. It is not only important that this version
    produces a type error, it is also instructive to understand why, by reading the
    type error. This explicitly says that the program expected an `node`(for instance,
    in `node-l`) and was given an `mt`(based on the `mt?`). This confirms that Typed
    Racket is refining the types in branches based on predicates.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们交换了谓词。这个版本不仅产生类型错误很重要，而且通过阅读类型错误来理解为什么也很具有教育意义。这明确表示程序期望一个`node`（例如，在`node-l`中），但是给出的是一个`mt`（基于`mt?`）。这证实了Typed
    Racket正在根据谓词在分支中细化类型。
- en: If-Splitting
  id: totrans-1154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果分支
- en: To summarize, `size-tr` type-checks is because the type-checker is doing something
    special when it sees the pattern
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`size-tr`通过类型检查是因为类型检查器在看到模式时做了特殊处理。
- en: '[PRE304]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'It knows that every `BT`is related to `mt`and `node`through the union. When
    it sees the predicate, it narrowsthe type from the full union to the branch of
    the union that the predicate has checked. Thus, in the `mt?`branch, it narrows
    the type of `t`from `BT`to `mt`; in the `node?`branch, similarly, it narrows the
    type of `t`to just `node`. Now, `node-l`, say, gets confirmation that it is indeed
    processing a `node`value, and the program is statically type-safe. In the absence
    of those predicates, in `size-tr-wrong`, the type of `t`does not get narrowed,
    resulting in the error. In `size-tr-w2`, swapping the predicates also gives an
    error. Here is one more version:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 它知道每个`BT`都通过联合与`mt`和`node`相关联。当它看到谓词时，它会将类型从完整的联合缩小到谓词检查的联合分支。因此，在`mt?`分支中，它将`t`的类型从`BT`缩小到`mt`；在`node?`分支中，类似地，它将`t`的类型缩小到仅仅是`node`。现在，`node-l`，比如说，得到了确认它确实正在处理一个`node`值，程序是静态类型安全的。在没有那些谓词的情况下，在`size-tr-wrong`中，`t`的类型没有得到缩小，导致错误。在`size-tr-w2`中，交换谓词也会产生错误。这里还有一个版本：
- en: '[PRE305]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: This program could go either way! It just so happens that it does type-check
    in typed/racket, because typed/racket is “smart” enough to determine that there
    are only two kinds of `BT`and one has been excluded, so in the `else`case, it
    must be the other kind. But one could also imagine a less clever checker that
    expects to see an explicit test of `node?` to be able to bless the second clause.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可以朝两个方向走！碰巧它在typed/racket中通过了类型检查，因为typed/racket足够“聪明”，能够确定只有两种`BT`，其中一种已被排除，所以在`else`情况下，它必须是另一种。但也可以想象一个不那么聪明的检查器，它期望看到显式的`node?`测试，以便能够认可第二个子句。
- en: In short, both the algebraic datatype and union type approaches need some special
    treatment of syntax by the type-checker to handle variants. In the former case
    it’s through pattern-matching. The narrowing technique above is sometimes called
    if-splitting, because an `if`(which `cond`and other conditional constructs desugar
    to) “splits” the union. You will sometimes also see the terms occurrence typingand
    flow typing to describe variants of the ideas in this chapter.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，代数数据类型和联合类型方法都需要类型检查器对语法进行一些特殊处理来处理变体。在前一种情况下是通过模式匹配。上述缩小技术有时被称为if-分割，因为`if`（`cond`和其他条件构造会简化为）"分割"了联合。你有时也会看到术语出现类型和流类型来描述本章中想法的变体。
- en: Aside:This idea was invented by [Typed Racket](https://www.google.com/url?q=https://docs.racket-lang.org/ts-guide/occurrence-typing.html&sa=D&source=editors&ust=1695232021469775&usg=AOvVaw0FOrR34cG9UC9PeiZoFxr8) by
    studying how programmers write code in Scheme and Racket programs. It has later
    proved to be relevant to many real-world retrofitted type systems.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：这个想法是通过研究程序员如何在Scheme和Racket程序中编写代码而发明的[Typed Racket](https://www.google.com/url?q=https://docs.racket-lang.org/ts-guide/occurrence-typing.html&sa=D&source=editors&ust=1695232021469775&usg=AOvVaw0FOrR34cG9UC9PeiZoFxr8)。后来证明它对许多现实世界的后置类型系统是相关的。
- en: Introducing Union Types
  id: totrans-1162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入联合类型
- en: 'As we discussed when evaluating conditionals [[👉](PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936)],
    union types can be useful to represent partial functions. There are several ways
    of handling them:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在评估条件时讨论的那样[[👉](PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936)]，联合类型可以用来表示部分函数。处理它们有几种方法：
- en: '[https://dcic-world.org/2022-08-28/partial-domains.html](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&sa=D&source=editors&ust=1695232021470794&usg=AOvVaw0tfeqewvVEB-EA9H442jKE)'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dcic-world.org/2022-08-28/partial-domains.html](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&sa=D&source=editors&ust=1695232021470794&usg=AOvVaw0tfeqewvVEB-EA9H442jKE)'
- en: 'Using an option type avoids the need for ad-hoc type unions. If we have unions
    anyway, however, then we can give types to partial functions: e.g., `(V U Boolean)`in
    Racket or `(V U None)`in Python, respectively, where `V`is the normal return type.
    Thus, Racket’s `string->number`can be given the type `(Number U Boolean)`.'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选项类型可以避免需要特定的类型联合。然而，如果我们已经有了联合，那么我们可以给部分函数赋予类型：例如，在Racket中是`(V U Boolean)`，在Python中是`(V
    U None)`，其中`V`是正常的返回类型。因此，Racket的`string->number`可以赋予类型`(Number U Boolean)`。
- en: 'What we’ve just seen is that with if-splitting, we can eliminate union types.
    That then raises the possibility that we can also introduce union types! One way
    is of course by giving union types to built-in functions, as above. But what about
    in user programs? Previously we had rejected such a solution: if we introduced
    a union, we had no way to deal with it. Now we can safely introduce them in languages
    that have solutions for deconstructing them.'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的是，通过if-拆分，我们可以消除联合类型。这然后提出了我们可以引入联合类型的可能性！一种方法当然是通过将联合类型赋予内置函数，如上所述。但在用户程序中呢？以前我们曾拒绝过这样的解决方案：如果我们引入了一个联合，我们就无法处理它。现在我们可以在有解构它们解决方案的语言中安全地引入它们。
- en: 'How do we introduce union types? Curiously, using the same construct that eliminates
    them! Observe that we no longer need both branches of a conditional to return
    the same type:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何引入联合类型？令人好奇的是，使用消除它们的相同构造！观察一下，我们不再需要条件语句的两个分支返回相同的类型：
- en: 'Γ `|- C : Bool    `Γ `|- T : V    `Γ `|- E : W`'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- C : Bool`   Γ `|- T : V`   Γ `|- E : W`'
- en: '[PRE306]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'Γ `|- (if C T E) : (U V W)`'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (if C T E) : (U V W)`'
- en: where our notation means “the union of the types represented by `V`and `W`”.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们的符号表示“由`V`和`W`表示的类型之并”。
- en: How Many Unions?
  id: totrans-1172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有多少个联合？
- en: When we wrote an algebraic datatype, the variants “belonged” to the new type.
    We had no mechanism for mixing-and-matching variants.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代数数据类型时，变体“属于”新类型。我们没有混合匹配变体的机制。
- en: In contrast, with union types, a new type is a collection of existing types.
    There’s nothing that prevents those existing types from engaging in several different
    unions. For instance, we had
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在使用联合类型时，一个新类型是现有类型的集合。没有任何东西阻止这些现有类型参与多个不同的联合。例如，我们有
- en: '[PRE307]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: But we could also write, say,
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以写成，比如说，
- en: '[PRE308]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: and reusing mt to define
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 并重新使用mt来定义
- en: '[PRE309]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Therefore, given an mt, what “is” it? Is it a `BT`? A `LinkedList`? It’s all
    those, but it’s also just an `mt`, which can participate in any number of unions.
    This provides a degree of flexibility that we don’t get with algebraic datatypes—since
    we can create ad-hoc unions of existing types—but that also means it becomes harder
    to tell all the ways a value might be used, and also complicates inferring types
    (if we see an `mt`constructed, are we also constructing a `BT`? a `LinkedList`?).
    The Hindley-Milner inference algorithm [[👉](PLAIVersion3.2.2_split_115.html#h.bheym24u3ntv)]
    doesn’t cover these cases, though it can be extended to do so.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定一个mt，它“是什么”？它是`BT`？`LinkedList`？它都是这些，但也是一个`mt`，它可以参与任意数量的联合。这提供了一种灵活性，我们在代数数据类型中得不到——因为我们可以创建现有类型的临时联合——但这同时也意味着更难确定一个值可能被使用的所有方式，并且也使得类型推断变得更加复杂（如果我们看到一个`mt`被构造，我们也在构造`BT`？`LinkedList`？）。Hindley-Milner推断算法[[👉](PLAIVersion3.2.2_split_115.html#h.bheym24u3ntv)]不涵盖这些情况，尽管它可以扩展以涵盖这些情况。
- en: Union Types and Space
  id: totrans-1181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合类型与空间
- en: Therefore, union types combined with if-splitting gives us an alternate approach
    of obtaining something akin to algebraic datatypes in our programming language.
    However, we don’t obtain the space benefits of the algebraic datatype definition.
    We created two distinct types; in principle, that’s not a problem. However, to
    write programs, we needed to have predicates (`mt?`and `node?`) that took anyvalue.
    Therefore, those predicates need type-tags on the values to be able to tell what
    kind of value they are looking at. Observe that these are typetags, not variant tags,
    so the amount of space they need is proportional to the number of types in the
    whole program, not just the number of variants in that particular algebraic datatype
    definition.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，联合类型与if-拆分结合给我们提供了另一种在编程语言中获得类似代数数据类型的方法。然而，我们没有获得代数数据类型定义的空间优势。我们创建了两种不同的类型；原则上，这并不是问题。然而，为了编写程序，我们需要有接受任何值的谓词（`mt?`和`node?`）。因此，这些谓词需要在值上附加类型标签，以便能够确定它们正在查看哪种类型的值。观察一下，这些是类型标签，而不是变体标签，所以它们所需的空间与整个程序中的类型数量成正比，而不仅仅是特定代数数据类型定义中的变体数量。
- en: If-Splitting with Control Flow
  id: totrans-1183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于控制流的If-Splitting
- en: This pattern, of dispatching based on type-tests and values, is quite common
    in dynamic (or “scripting”) languages. These languages do not have a static type
    system, but they do have safe run-times, which attach type tags to values and
    provide predicates that can check them. Programmers then adopt programming patterns
    that take advantage of this.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于类型测试和值的分派模式在动态（或“脚本”）语言中相当常见。这些语言没有静态类型系统，但它们确实有安全的运行时，这些运行时将类型标签附加到值上，并提供可以检查它们的谓词。然后程序员采用利用这种特性的编程模式。
- en: 'Aside:The term dynamiclanguage seems to have no clear fixed definition. It
    means, at least, that the language doesn''t have static types. Sometimes it''s
    implicit that the language is nevertheless safe. But some people use it to mean
    that the language has features that let you do things like inspect or even modify
    the program as it''s running (features like `eval`). In this book I use it in
    the second sense: not-statically typed, but still safe.'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：动态语言这个术语似乎没有明确的固定定义。它至少意味着该语言没有静态类型。有时它隐含地表示该语言仍然是安全的。但有些人用它来表示该语言具有允许你在程序运行时检查或甚至修改程序的功能（如`eval`）。在这本书中，我使用第二个意思：非静态类型，但仍然安全。
- en: 'Aside: What, then, is a “scripting” language? I use the term to mean a dynamic
    language that is also very liberal with its types: e.g., many operations are either
    overloaded and/or very forgiving of what a statically-typed language would consider
    an error. Scripting languages tend to be dynamic in all three senses: they do
    not have a static type-system, they are safe, and they tend to have rich features
    for introspection and even modification. They are designed to maximize expressiveness
    and thus minimize just about any useful static analysis.'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：那么，“脚本语言”究竟是什么意思呢？我使用这个术语来指代一种既动态又对其类型非常宽容的语言：例如，许多操作要么是重载的，要么对静态类型语言认为的错误非常宽容。脚本语言在所有三个意义上都倾向于动态：它们没有静态类型系统，它们是安全的，并且它们通常具有丰富的特性用于内省甚至修改。它们的设计目的是最大化表达性，从而最小化几乎所有有用的静态分析。
- en: For instance, here’s an example from JavaScript, of a serialization function.
    A serializer takes a value of (almost) any type and converts it into a string
    to be stored or transmitted. (This version is adapted from version 1.6.1 of Prototype.js.)
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个来自JavaScript的序列化函数的例子。序列化器接受（几乎）任何类型的值，并将其转换为字符串以存储或传输。（这个版本是从Prototype.js的1.6.1版本改编的。）
- en: '`function serialize(val) {`'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '`function serialize(val) {`'
- en: '[PRE310]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'Now suppose we’re trying to retrofit a type system onto JavaScript. We would
    need to type-check such programs. But before we even ask how to do it, we should
    know what answer to expect: i.e., is this program even type-safe?'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们正在尝试将类型系统应用到JavaScript上。我们需要对这样的程序进行类型检查。但在我们询问如何做之前，我们应该知道预期的答案：即，这个程序是否甚至类型安全？
- en: The answer is quite subtle. It uses JavaScript’s `typeof`operator to check the
    tags. For two kinds of values, it returns `false`(that is, the type of this function
    is not `Any -> String`, it’s actually `Any -> (String U Boolean)`, where the `false`value
    is used to signal that the value can’t be serialized—observe that an actual `false`value
    is serialized to `"false"`). For Booleans, numbers, and strings, it translates
    them appropriately into strings. In all these cases, execution returns. (Note,
    however, that the code also exploits JavaScript’s “fall-through” behavior in `switch`,
    so that `"undefined"`and `"function"` are treated the same without having to repeat
    code. The type-checker needs to understand this part of JavaScript semantics.)
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 答案相当微妙。它使用JavaScript的`typeof`运算符来检查标签。对于两种类型的值，它返回`false`（即，此函数的类型不是`Any ->
    String`，实际上是`Any -> (String U Boolean)`，其中`false`值用于表示该值无法序列化——注意，实际的`false`值被序列化为`"false"`）。对于布尔值、数字和字符串，它将它们适当地转换为字符串。在这些所有情况下，执行都会返回。（然而，请注意，代码还利用了JavaScript在`switch`中的“穿透”行为，因此`"undefined"`和`"function"`被同等对待，而无需重复代码。类型检查器需要理解JavaScript语义的这一部分。）
- en: If none of these cases apply, then execution falls through; we need to know
    enough JavaScript to know that this corresponds to the one other return from `typeof`,
    namely objects. Now the code splits between objects that are and aren’t `null`.
    In the non-`null` case, it iterates through each field, serializing it in turn.
    Therefore, this program is actually type-safe…but for very complicated reasons!
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些情况都不适用，则执行会穿透；我们需要了解足够的JavaScript知识，知道这对应于`typeof`的另一个返回值，即对象。现在代码在是和不是`null`的对象之间分裂。在非`null`的情况下，它会遍历每个字段，依次序列化它。因此，这个程序实际上是类型安全的……但原因非常复杂！
- en: If-Splitting with Control Flow and State
  id: totrans-1193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果-分割与控制流和状态
- en: 'Here’s another program, taken from the Python 2.5.2 standard library:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个来自Python 2.5.2标准库的程序示例：
- en: '[PRE311]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: This function inserts an element (`x`) into an already-sorted list (`a`). It
    also takes a low search interval index (`lo`), which defaults to `0`, and a high
    interval (`hi`), which defaults to `None`. It inserts the element into the right
    place in the array.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将一个元素（`x`）插入到一个已经排序的列表（`a`）中。它还接受一个低搜索区间索引（`lo`），默认为`0`，以及一个高区间（`hi`），默认为`None`。它将元素插入到数组中的正确位置。
- en: Now let’s ask whether this is actually type-correct. Observe that `lo`and `hi` are
    used in several arithmetic operations. These are the ones we’re most interested
    in.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来询问这实际上是否类型正确。观察一下`lo`和`hi`在几个算术运算中被使用。这些是我们最感兴趣的。
- en: 'If it helps, here’s the code with type annotations in [Static Python](https://www.google.com/url?q=https://github.com/facebookincubator/cinder&sa=D&source=editors&ust=1695232021481698&usg=AOvVaw2pIqSg2CpkTCGrPRBDemlf):'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有帮助，这里有一个带有类型注解的[静态Python](https://www.google.com/url?q=https://github.com/facebookincubator/cinder&sa=D&source=editors&ust=1695232021481698&usg=AOvVaw2pIqSg2CpkTCGrPRBDemlf)代码示例：
- en: '[PRE312]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: (In Static Python, `Optional[T]`is an abbreviation for `(T U None)`. So the
    annotation on `hi`above allows the user to pass in either an `int`or `None`. What
    makes the last two arguments optional is (perhaps confusingly) not the type `Optional` but
    rather the fact that they have default values in the function header.)
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: （在静态Python中，`Optional[T]`是`(T U None)`的缩写。所以`hi`上面的注释允许用户传入一个`int`或`None`。使最后两个参数成为可选的不是类型`Optional`，而是它们在函数标题中有默认值。）
- en: 'It’s easier to see what’s happening with `lo`: it’s allowed to be optional;
    if the optional argument is provided, it must be an `int`; and if it’s not provided,
    it has value `0`, which also has type `int`. So its type is effectively `(int
    U int)`, which is just `int`, so all uses of `lo`as an `int` are fine.'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`lo`，更容易看到正在发生什么：它允许是可选的；如果提供了可选参数，它必须是一个`int`；如果没有提供，它的值是`0`，这也是一个`int`类型。所以它的类型实际上是`(int
    U int)`，这仅仅是`int`，所以所有将`lo`用作`int`的使用都是可以的。
- en: But now consider the type of `hi`. It is also optional. If it is provided, it
    has to be an `int`, which would be fine. But if it’s notprovided, its value is
    `None`, which cannot be used in arithmetic. However, right at the top, the function
    checks whether it is `None`and, if so, changesit to the result of `len(a)`—which
    is an `int`. Therefore, once the if is done, no matter which path the program
    takes, `hi`is an `int`. Thus, the program is actually type-safe.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在考虑`hi`的类型。它也是可选的。如果提供了，它必须是一个`int`，这将是完美的。但是如果没有提供，它的值是`None`，这在算术中不能使用。然而，在最上面，函数检查它是否是`None`，如果是，就将其更改为`len(a)`的结果——它是一个`int`。因此，一旦if语句执行完毕，无论程序采取哪条路径，`hi`都是一个`int`。因此，程序实际上是类型安全的。
- en: That’s all well and good for us to reason about by hand. However, our job is
    to build a type-checker that will neither reject programs needlessly nor approve
    type-incorrect programs. This balance is very hard to maintain.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们手动推理来说，这一切都很好。然而，我们的任务是构建一个类型检查器，它既不会无端地拒绝程序，也不会批准类型不正确的程序。这种平衡非常难以维持。
- en: 'This represents the challenge retrofitted type system designers face: they
    must either reject idiomatic programs or add complexity to the type system to
    handle them. If we reject the program, we reject many other programs like it,
    which are idiomatically found in many “scripting” languages. The result would
    be very safe, but also very useless—indeed, safe because it would be very useless—type-checker
    (a type-checker that rejects every program would be extremely safe…). Instead,
    we need an even more complicated solution than what we have seen until now.'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了回溯类型系统设计者面临的挑战：他们必须要么拒绝惯用的程序，要么增加类型系统的复杂性来处理它们。如果我们拒绝程序，我们就会拒绝许多类似程序，这些程序在许多“脚本”语言中都是惯用的。结果将会非常安全，但也会非常无用——实际上，因为非常无用——类型检查器（一个拒绝所有程序的类型检查器将会非常安全……）。相反，我们需要一个比我们迄今为止看到的更复杂的解决方案。
- en: Aside:See [this paper](https://www.google.com/url?q=https://cs.brown.edu/people/sk/Publications/Papers/Published/gsk-flow-typing-theory/&sa=D&source=editors&ust=1695232021485488&usg=AOvVaw2-6nKeOUE7cQ6F3KqzAJ7z) for
    how to type such programs.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句：参见[这篇论文](https://www.google.com/url?q=https://cs.brown.edu/people/sk/Publications/Papers/Published/gsk-flow-typing-theory/&sa=D&source=editors&ust=1695232021485488&usg=AOvVaw2-6nKeOUE7cQ6F3KqzAJ7z)，了解如何为这样的程序进行类型检查。
- en: The Price of Retrofitting
  id: totrans-1207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回溯的成本
- en: Retrofitting a type-system onto an existing untyped language clearly puts a
    heavy burden on the creator of the type system. But it also puts a burden on developers.
    If the type system is to not reject a bunch of existing code, then it must be
    based on some heuristics about program structure. The more complex these heuristics
    grow (as we’ve seen hints of in this chapter), the stranger it will be when a
    program falls outside what they can handle.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型系统应用于现有的无类型语言显然给类型系统的创建者带来了沉重的负担。但它也给开发者带来了负担。如果类型系统不拒绝大量现有代码，那么它必须基于对程序结构的某些启发式方法。这些启发式方法越复杂（正如我们在本章中看到的一些线索），当程序超出它们能处理的范围时，就会变得越奇怪。
- en: 'You might argue that it was ever thus: when type-checking algebraic datatypes,
    too, we had to use pattern-matching to help the type-checker. The difference there
    is that the type-checker was around at program construction time, so we adhered
    to its rules from the very start; we didn’t try to add types after the fact. The
    problem arises when programmers are allowed to write code however they like, and
    the type-checker must retroactively try to bless them.'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，这始终如此：在检查代数数据类型时，我们也必须使用模式匹配来帮助类型检查器。那里的区别在于类型检查器在程序构建时间就存在了，所以我们从一开始就遵循其规则；我们没有试图事后添加类型。问题出现在程序员被允许以任何他们喜欢的方式编写代码，而类型检查器必须事后尝试批准它们。
- en: Types and Tags
  id: totrans-1210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型与标签
- en: Finally, we should clarify something important about the `typeof`operator in
    JavaScript, which is analogous to the `type`function in Python. When we impose
    a type system on JavaScript, we expect, say, the type `(Number -> String)`to be
    different from the type `(String -> Boolean)`. Similarly, an object that contains
    only the fields `x`and `y`is very different from the object that contains only
    the method `draw`.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该澄清关于JavaScript中`typeof`运算符的一个重要问题，它在Python中类似于`type`函数。当我们对JavaScript施加类型系统时，我们期望，比如说，类型`(Number
    -> String)`与类型`(String -> Boolean)`不同。同样，只包含字段`x`和`y`的对象与只包含方法`draw`的对象非常不同。
- en: 'However, these nuances are lost on `typeof`, which is innocent to even the
    existence of any such type systems. Therefore, all those functions are lumped
    under one tag, `"function"`, and all those objects are similarly treated uniformly
    as one tag, `"object"`(and analogously in Python). This is because their names
    are misleading: what they are reporting are not the typesbut rather the run-time
    tags.'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些细微差别在`typeof`中丢失了，它对任何这样的类型系统都一无所知。因此，所有这些函数都被归入一个标签`"function"`，所有这些对象也被统一地视为一个标签`"object"`（在Python中类似）。这是因为它们的名称具有误导性：它们报告的不是类型，而是运行时标签。
- en: The difference between types and tags can grow arbitrarily big. After all, the
    number of types in a program can grow without bound, and so can their size (e.g.,
    you can have a list of lists of arrays of functions from …). But the set of tags
    is fixed in many languages, though in those that allow you to define new (data)classes,
    this set might grow. Nevertheless, tags are meant to take up a fixed amount of
    space and be checked in a small constant amount of time.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 类型与标签之间的差异可以变得任意大。毕竟，程序中的类型数量可以无限增长，它们的尺寸也是如此（例如，你可以有一个函数数组列表）。但在许多语言中，标签集是固定的，尽管在允许你定义新（数据）类的语言中，这个集合可能会增长。然而，标签的目的是占据固定量的空间，并在很短的时间内进行检查。
- en: 'Of course, this difference is not inherently problematic. After all, even in
    statically-typed languages with algebraic datatypes, we still need space to track
    variants, which requires a kind of (intra-type) tag. The issue is rather with
    the choice of name: that `typeof`and `type`do not, actually, return “types”. A
    more accurate name for them would be something like `tagof`, leaving the term
    “type” free for actual static type systems.'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种差异本身并不是问题。毕竟，即使在具有代数数据类型的静态类型语言中，我们仍然需要空间来跟踪变体，这需要一种（类型内）标签。问题在于名称的选择：`typeof`和`type`实际上并不返回“类型”。它们更准确的名称可能是`tagof`，这样就可以将“类型”这个术语留给实际的静态类型系统。
- en: Nominal Types, Structural Types, and Subtyping
  id: totrans-1215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名义类型、结构类型和子类型
- en: Let’s go back to
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下
- en: '[PRE314]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: and ask how we could have represented this in Java.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 并询问我们如何用Java表示这个。
- en: Do Now: Represent this in Java!
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做：用Java表示这个！
- en: How did you do it? Did you create a single class with `null` for the empty case?
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 你是怎么做到的？你创建了一个只有一个`null`的单一类来表示空情况吗？
- en: Exercise: Why is that solution not object-oriented?
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：为什么那个解决方案不是面向对象的？
- en: Algebraic Datatypes Encoded With Nominal Types
  id: totrans-1222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用名义类型编码的代数数据类型
- en: 'We’ll take a different approach. Observe from the datatype definition that
    we have two constructors, and one type that represents their union. We can encode
    this in Java as:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取不同的方法。从数据类型定义中观察，我们有两个构造函数，一个表示它们的联合的类型。我们可以在 Java 中这样编码：
- en: '[PRE315]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'How is the “if-splitting” addressed here? It’s done in a hidden way, through
    dynamic dispatch. When we invoke a method, Java makes sure we run the right method:
    there are actually two concrete `size`methods, and the run-time picks the right
    one. Once that choice is made, the class in which the method resides automatically
    determines what is bound. Thus, the `size`in `node`can safely use `this.l`and
    `this.r`, and the type-checker knows that those fields exist.'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: “if 分割”在这里是如何处理的？这是通过隐式的方式，通过动态分派来完成的。当我们调用一个方法时，Java 确保我们运行的是正确的方法：实际上有两个具体的
    `size` 方法，运行时选择正确的一个。一旦做出选择，包含该方法的类会自动确定绑定的是什么。因此，`node` 中的 `size` 可以安全地使用 `this.l`
    和 `this.r`，类型检查器知道这些字段存在。
- en: 'This is, then, similar to, yet different from, our two prior solutions: using
    algebraic datatypes and union types. The solutions are structurally different,
    but they are all similar in that some syntactic pattern must be used to make the
    program statically type-able. With algebraic datatypes, it was pattern-matching;
    with union types, it was if-splitting; in Java, it’s the splitting of the code
    into separate methods.'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的前两种解决方案相似，但又不同：使用代数数据类型和联合类型。解决方案在结构上不同，但它们在某种程度上都是相似的，即必须使用某种语法模式来使程序在静态类型化。使用代数数据类型时是模式匹配；使用联合类型时是
    if 分割；在 Java 中是代码分割成单独的方法。
- en: The algebraic datatype and Java solutions are even more connected than we might
    imagine. With algebraic datatypes, we fixed the set of variants; but we were free
    to add new functions without having to edit existing code. In Java, we fix the
    set of behaviors (above, one method), but can add new variants without having
    to edit existing code. Therefore, neither has an inherent advantage over the other,
    and one’s strengths are the other’s weakness. How to do bothat once is the essence
    of the [Expression Problem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Expression_problem&sa=D&source=editors&ust=1695232021492211&usg=AOvVaw3l4_wQP5pOCFZHndfQMdbX).
    See also the concrete examples and approaches given in these two papers, one focusing
    on a [Java-based approach](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&sa=D&source=editors&ust=1695232021492633&usg=AOvVaw2Xm1yq3fY2pVUVr5sWjXEr)and
    another [function-centric](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kf-ext-sw-def/&sa=D&source=editors&ust=1695232021492914&usg=AOvVaw0SbXWoMkkqB5ySEJa9jMG3).
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据类型和 Java 解决方案比我们想象的联系更加紧密。使用代数数据类型，我们固定了变体的集合；但我们有自由添加新函数，而无需编辑现有代码。在 Java
    中，我们固定了行为的集合（上面，一个方法），但可以添加新的变体，而无需编辑现有代码。因此，两者都没有固有的优势，一个的优势是另一个的弱点。如何同时做到这两点是
    [表达式问题](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Expression_problem&sa=D&source=editors&ust=1695232021492211&usg=AOvVaw3l4_wQP5pOCFZHndfQMdbX)
    的本质。参见这两篇论文中给出的具体示例和方法，一篇侧重于 [基于 Java 的方法](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&sa=D&source=editors&ust=1695232021492633&usg=AOvVaw2Xm1yq3fY2pVUVr5sWjXEr)，另一篇
    [以函数为中心](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kf-ext-sw-def/&sa=D&source=editors&ust=1695232021492914&usg=AOvVaw0SbXWoMkkqB5ySEJa9jMG3)。
- en: Nominal Types
  id: totrans-1231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名类型
- en: The type system in Java is representative of an entire class of languages. These
    have nominaltypes, which means the nameof a class matters. (“Nominal” comes from
    the Latin nomen, or name.) It’s easiest to explain with an example.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的类型系统代表了一类语言。这些语言有命名类型，这意味着类的名称很重要。（“命名”来自拉丁语 nomen，或名称。）用例子来说明最容易。
- en: 'Above we have the following class:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 上面我们有以下类：
- en: '[PRE319]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'Let’s now suppose we create another class that is identical in every respect
    but its name:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们创建另一个在所有方面都相同但名称不同的类：
- en: '[PRE320]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'Let’s say we have a method that takes `mt` objects:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个接受 `mt` 对象的方法：
- en: '[PRE321]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'But observe that `empty`is a perfectly good substitute for `mt`: it too has
    a `size`method, which too takes no arguments, and it too returns an `int` (in
    fact, the very same value). Therefore, we try:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，`empty` 是 `mt` 的一个完美的替代品：它也有一个 `size` 方法，该方法同样不接受任何参数，并且它也返回一个 `int`（实际上，是相同的值）。因此，我们尝试：
- en: '[PRE322]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '`System.out.println(m(new` empty`()));`'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println(m(new empty()));`'
- en: '[PRE323]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: But Java rejects this. That’s because it expects an object that was constructed
    by the actual class `mt`, not just one that “looks like” it. That is, what matters
    is which actual (named) class, not what structure of class, created the value.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 但Java拒绝了这个。那是因为它期望的是一个由实际类`mt`构造的对象，而不仅仅是“看起来像”它的对象。也就是说，重要的是哪个实际的（命名的）类创建了值，而不是类的结构。
- en: Structural Types
  id: totrans-1244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构类型
- en: 'In contrast, we can imagine a different type system: one where the type of
    each of the above classes is not its name but rather a description of what fields
    and methods it has: i.e., it’s structure, or its “services”. For instance, we
    might have:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们可以想象一个不同的类型系统：其中一个类的类型不是它的名称，而是它拥有的字段和方法描述：即它的结构，或它的“服务”。例如，我们可能有一个：
- en: '[PRE324]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: That is, each of these is a collection of names (one name, to be precise), which
    is a method that takes no parameters and returns an `int`. Whenever two types
    are the same, objects of one can be used where objects of the other kind are expected.
    Indeed, it is unsurprising that both kinds of trees have the same type, because
    programs that process one will invariably also need to process the other because
    trees are a union of these two types. Similarly, we also have
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，这些每一个都是一个包含名称（确切地说是一个名称）的集合，这是一个不接受任何参数并返回`int`类型的方法。每当两种类型相同，一个类型的对象就可以用在期望另一个类型对象的地方。确实，两种类型的树有相同的类型并不令人惊讶，因为处理一种树的程序不可避免地也需要处理另一种树，因为树是这两种类型的联合。同样，我们也有
- en: '[PRE325]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'The above m method might be written as:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`m`方法可能被写成：
- en: '`static int m(o` : {size : (-> int)}`) {`'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '`static int m(o : {size : (-> int)}) {`'
- en: '[PRE326]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'That is, it only indicates what shape of object it expects, and doesn’t indicate
    which constructor should have made it. This is called structuraltyping, though
    the Internet appears to have decided to call this “duck” typing (though it’s hard
    to be clear: there is no actual theory of duck typing to compare against well-defined
    theories of structural typing: [Abadi and Cardelli](https://www.google.com/url?q=https://www.springer.com/gp/book/9780387947754&sa=D&source=editors&ust=1695232021498288&usg=AOvVaw3AweVzQ_7nSMI7klfzt2li)represent
    a classical viewpoint, and here’s an [extension](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/&sa=D&source=editors&ust=1695232021498703&usg=AOvVaw2EFVs5AkPquJx2jsIUl9pQ) for
    modern “scripting” languages).'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它只表明它期望的对象形状，并不表明应该使用哪个构造函数来创建它。这被称为结构类型，尽管互联网似乎已经决定将这称为“鸭子类型”（尽管很难说清楚：没有实际的鸭子类型理论可以与结构类型的有定义理论进行比较：[Abadi和Cardelli](https://www.google.com/url?q=https://www.springer.com/gp/book/9780387947754&sa=D&source=editors&ust=1695232021498288&usg=AOvVaw3AweVzQ_7nSMI7klfzt2li)代表了一个经典的观点，而这里有一个[扩展](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/&sa=D&source=editors&ust=1695232021498703&usg=AOvVaw2EFVs5AkPquJx2jsIUl9pQ) 用于现代“脚本”语言）。
- en: Nominal Subtyping
  id: totrans-1253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名义子类型
- en: 'We’ve been writing a bit gingerly about Java above: because we know that the
    `m`method will accept not only `mt`’s but also anything that is a sub-class of
    `mt`. Let’s explore this further.'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面的Java讨论中写得有些小心翼翼：因为我们知道`m`方法将接受不仅是`mt`的子类，还包括任何是`mt`子类的对象。让我们进一步探讨这个问题。
- en: 'To simplify things, let’s make some basic classes:'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，让我们创建一些基本的类：
- en: '[PRE327]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'We’ll also create a shell “runner”:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个外壳“运行器”：
- en: '[PRE328]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'and try filling in different values for the blanks and seeing what output we
    get:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试填充不同的值并查看我们得到什么输出：
- en: '`System.out.println((true ?` new B()`:` new B()`).who);`'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println((true ? new B() : new B()).who);`'
- en: 'Unsurprisingly, this prints `"B"`. What about:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这会打印出`"B"`。那么：
- en: '`System.out.println((true ?` new B()`:` new A()`).who);`'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println((true ? new B() : new A()).who);`'
- en: 'You might expect this to also print `"B"`, because that’s the value that we
    created. However, it actually prints `"A"`! Let’s see a few more examples:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望这也打印出`"B"`，因为这是我们创建的值。然而，它实际上打印出的是`"A"`！让我们看看更多的例子：
- en: '`System.out.println((true ?` new B()`:` new C()`).who);`'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println((true ? new B() : new C()).who);`'
- en: 'Will this print `"B"`? No, in fact, this also prints `"A"`! How about:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出`"B"`吗？不，实际上这也打印出`"A"`！那么：
- en: '`System.out.println((true ?` new B()`:` new D()`).who)`'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println((true ? new B() : new D()).who)`'
- en: '`System.out.println((true ?` new B()`:` 3`).who)`'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.println((true ? new B() : 3).who)`'
- en: 'Both of these produce a static error. It’s instructive to read the error message:
    in both cases they reference `Object`. In the former case, it’s because there
    is nothing else common to B and D. But in the latter case, the primitive value
    3 was effectively converted into an object—`new Integer(3)`—and those two object
    types were compared.'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都产生了一个静态错误。阅读错误信息是有教育意义的：在两种情况下它们都引用了`Object`。在前一种情况下，这是因为B和D之间没有其他共同点。但在后一种情况下，原始值3被有效地转换成了一个对象——`new
    Integer(3)`——并且比较了这两个对象类型。
- en: 'What is happening in the type system that causes this error? The cause is documented
    here:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 导致这种错误的类型系统中的情况是什么？原因在此处记录：
- en: '[https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3](https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html%23jls-15.25.3&sa=D&source=editors&ust=1695232021502810&usg=AOvVaw13Y12I72q4_WhlbdEUkvSr)'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3](https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html%23jls-15.25.3&sa=D&source=editors&ust=1695232021502810&usg=AOvVaw13Y12I72q4_WhlbdEUkvSr)'
- en: 'Specifically, the document says:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，文档说：
- en: The type of the conditional expression is the result of applying capture conversion
    (§5.1.10) to lub(T1, T2).
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式的类型是应用捕获转换（§5.1.10）到lub(T1, T2)的结果。
- en: 'where “lub” stands for “least upper bound”: the “lowest” class “above” all
    the given ones. This type is determined statically. That is, the type rule is
    essentially:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 其中“lub”代表“最小上界”：所有给定类型“之上”的“最低”类。这个类型是静态确定的。也就是说，类型规则本质上是这样的：
- en: 'Γ `|- C : Bool    `Γ `|- T : V    `Γ `|- E : W    X = lub(V, W)`'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- C : Bool` Γ `|- T : V` Γ `|- E : W` X = lub(V, W)'
- en: '[PRE329]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'Γ `|- (if C T E) : X`'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 'Γ `|- (if C T E) : X`'
- en: Contrast this to the other rules we’ve seen for conditionals! The first type
    rule we saw was the most rigid, but produced the most usable values (because there
    was no ambiguity). The second type rule, for union types, was less rigid, but
    as a result the output type could have a union that needed to be split. This type
    rule is even less rigid (in terms of what the two branches produce), but the result
    could be as general as `Object`, with which we can do almost nothing.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与其他我们看到的条件规则进行对比！我们看到的第一个类型规则是最严格的，但产生了最可用的值（因为没有歧义）。第二个类型规则，对于联合类型，不那么严格，但结果输出类型可能有一个需要拆分的联合。这个类型规则甚至更不严格（在两个分支产生的意义上），但结果可能像`Object`一样通用，我们几乎可以对它做任何事情。
- en: Subtyping
  id: totrans-1278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类型
- en: 'The general principle here is called subtyping: we say that type `X`is a subtype
    of `Y`, written `X <: Y`(read the `<:`like a “less than” or “contained”), whenever
    `X`can be used wherever a `Y`was expected: i.e., `X`can safelybe substitutedfor
    `Y`.'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的基本原则被称为子类型：我们说类型`X`是类型`Y`的子类型，写作`X <: Y`（读作“小于”或“包含”），当`X`可以在期望`Y`的任何地方使用时：即，`X`可以安全地替换`Y`。'
- en: Java chose to make sub-classes into sub-types. Not all object-oriented languages
    do this, and indeed many consider it to be a mistake, but that’s the design Java
    has. Therefore, a sub-class is expected to offer at least as many services as
    its super-class; and hence, it can be substituted where a super-class is expected.
    The lub computation above finds the most specific common super-type.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: Java选择将子类变成子类型。并不是所有的面向对象语言都这样做，实际上许多人认为这是一个错误，但这是Java的设计。因此，子类预期至少提供与超类一样多的服务；因此，它可以在期望超类的地方被替换。上面的lub计算找到了最具体的共同超类型。
- en: 'This is an account of how subtyping works for nominalsystems. This has the
    virtue of being fairly easy to understand. We can also define subtyping for structuralsystems,
    but that is rather more complex: some parts are easy to follow, other parts are
    a bit more tricky (but essential to obtain a sound type system). For a detailed
    explanation, with an illustrative example, see [section 33.6.1 of PAPL](https://www.google.com/url?q=https://papl.cs.brown.edu/2020/objects.html%23%2528part._subtyping%2529&sa=D&source=editors&ust=1695232021505625&usg=AOvVaw25ykJjwpXl83jpgPY6xeR9).'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对命名系统如何进行子类型工作的描述。这有一个优点，就是相对容易理解。我们也可以为结构化系统定义子类型，但这相当复杂：一些部分容易理解，其他部分则有点棘手（但为了获得一个有效的类型系统是必要的）。有关详细解释和示例，请参阅[PAPL的第33.6.1节](https://www.google.com/url?q=https://papl.cs.brown.edu/2020/objects.html%23%2528part._subtyping%2529&sa=D&source=editors&ust=1695232021505625&usg=AOvVaw25ykJjwpXl83jpgPY6xeR9)。
- en: Gradual Typing
  id: totrans-1282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐进类型
- en: From Scripts to Programs
  id: totrans-1283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从脚本到程序
- en: As dynamic language programs grow, they become increasingly hard to maintain.
    Programmers use types to define interfaces, communicate expectations of behavior,
    document, and so on, and in their absence, we need several ad hoc tools. Put differently,
    we want “scripts” to grow up and become “programs”.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 随着动态语言程序的增长，它们变得越来越难以维护。程序员使用类型来定义接口、传达行为期望、进行文档化等，在没有它们的情况下，我们需要一些专门的工具。换句话说，我们希望“脚本”成长并成为“程序”。
- en: Thus, one of the most visible trends in programming languages over the past
    ten years is dynamic languages adding a static counterpart. In principle, this
    is as simple as adding a type-system to an existing language. As we’ve already
    seen when discussing retrofitted types [[👉](PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt)],
    however, such a type system needs to take into account the idiomatic style of
    programming in the language; otherwise it would report as erroneous too many programs
    that are actually type-correct, and this high false-positive rate would make people
    not use the type system at all. Therefore, we discussed some patterns of code
    that need to be supported.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在过去十年中，编程语言中最明显的趋势之一是动态语言添加了静态的对应物。原则上，这就像向现有语言添加类型系统一样简单。然而，正如我们在讨论后置类型时已经看到的，这样的类型系统需要考虑语言中编程的惯用风格；否则，它会错误地报告太多实际上是类型正确的程序，这种高误报率会使人们根本不使用类型系统。因此，我们讨论了一些需要支持的代码模式。
- en: 'Another major obstacle to adoption is that people often have a large amount
    of code lying around, and it is simply impractical to convert all of it to a typed
    language in one go. In fact, some of it may not even be typeable by most reasonable
    type systems: e.g., the `eval`construct, which takes a dynamic string (e.g., one
    that may be constructed on-the-fly during program execution) and runs it. By definition,
    we statically do not know what this string is; without knowing it, we can’t possibly
    type it statically.'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的采用障碍是，人们通常有大量的代码散落在各处，一次性将所有这些代码转换为类型化语言是不切实际的。实际上，其中一些可能连大多数合理的类型系统都无法进行类型化：例如，`eval`结构，它接受一个动态字符串（例如，可能在程序执行过程中即时构建的字符串）并运行它。根据定义，我们静态上不知道这个字符串是什么；不知道它，我们就不可能静态地进行类型化。
- en: 'In short, there are two reasons why we cannot expect the whole program to make
    an instant transition from untyped to typed:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，有两个原因使我们不能期望整个程序能够立即从无类型转换为有类型：
- en: The program is too large, and programmers have other things to do with their
    time.
  id: totrans-1288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序太大，程序员还有其他事情要做。
- en: Some parts of the program may not even be typeable.
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的某些部分甚至可能无法进行类型化。
- en: (You don’t need `eval` to make things hard to type. Many dynamic constructs
    that look at program behavior and modify it have the same flavor. They enter the
    language because it’s dynamic and doesn’t have to worry about a static type discipline,
    and then create an obstacle for later typing.)
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: （您不需要`eval`来使代码难以输入。许多看起来是观察程序行为并修改它的动态结构具有相同的特性。它们进入语言是因为它是动态的，不需要担心静态类型纪律，然后为后续的输入创建障碍。）
- en: 'Despite this, type systems have been built for many real-world dynamic languages.
    These type systems exhibit a property called gradual typing: as the name suggests,
    you add types “gradually” to the program, hopefully making it more-and-more typed.
    What started out as an academic idea in the Scheme community (two papers in 2006
    introduced gradual typing for Scheme) is now [widely used in industry](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Gradual_typing&sa=D&source=editors&ust=1695232021507601&usg=AOvVaw0ZgqxCx2wfimBQuPFFxnVE).'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，许多现实世界的动态语言已经构建了类型系统。这些类型系统具有一种称为渐进式类型化的特性：正如其名所示，您将类型“逐渐”添加到程序中，希望使其越来越类型化。这最初是Scheme社区中的一个学术想法（2006年两篇论文为Scheme引入了渐进式类型化），现在[在工业界得到了广泛应用](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Gradual_typing&sa=D&source=editors&ust=1695232021507601&usg=AOvVaw0ZgqxCx2wfimBQuPFFxnVE)。
- en: Micro Versus Macro
  id: totrans-1292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微型与宏型
- en: In gradual typing, we are going to add annotations to programs and then type-check
    the program. Within this broad principle, there are two schools of thought.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 在渐进式类型中，我们将向程序添加注释，然后对程序进行类型检查。在这个广泛的原则下，有两种不同的观点。
- en: 'In “micro” gradual typing we can add annotations to any subset of the variables
    of the language. We saw this earlier in the Static Python example:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 在“微观”渐进式类型中，我们可以向语言的任何变量子集添加注释。我们之前在静态Python示例中看到了这一点：
- en: '[PRE330]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'Here, we have annotations on `lo`and `hi`, but not on `a`and `x`. Ergonomically,
    this is very convenient for the programmer: use annotations for the parts you
    care about, and not for the parts you don’t. Unfortunately, this comes at a cost:
    there is now a much more complex language where any parts of a program can be
    static and any other parts dynamic, and they can freely commingle in the same
    body of code, even in a single expression or line (e.g., from the same example:
    `hi = len(a)`). The type system needs to somehow deal with constructs it cannot
    meaningfully type (like `eval`). Also, previously we had a clean and simple soundness
    result for the typed program; now it is rather unclear what soundness means. In
    turn, that means that programmers may put a lot of effort into annotations, but
    without a clear guarantee of what they are getting in return. (A large body of
    literature now tries to make sense of this.)'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`lo`和`hi`上有注释，但没有在`a`和`x`上有注释。从程序员的角度来看，这非常方便：对关心的部分使用注释，而对不关心的部分则不使用。不幸的是，这带来了代价：现在有一个更加复杂的语言，其中程序中的任何部分都可以是静态的，任何其他部分都是动态的，它们可以自由地在相同的代码体中混合，甚至在单个表达式或行中（例如，从同一个例子：`hi
    = len(a)`）。类型系统需要以某种方式处理它无法有意义类型化的结构（如`eval`）。此外，之前我们对静态类型程序有一个干净简单的正确性结果；现在它到底是什么样的正确性并不清楚。反过来，这意味着程序员可能投入大量精力进行注释，但无法明确保证他们能得到什么回报。（现在有一大批文献试图弄清楚这一点。）
- en: 'In contrast, there is another approach, often called “macro” gradual typing.
    In the macro approach, there are two languages: the typed and the dynamic one.
    They are expected to be very similar—so similar that they have the same run-time
    system and can freely share values—so we’ll refer to them as “sibling” languages.
    However, they may not have the same constructs (e.g., the typed language would
    not contain `eval`). Instead of freely mixing code between typed and untyped,
    we only have to figure out what happens when values travel between the languages,
    not within each one. The expectation is that the programmer will gradually migrate
    part of their codebase from the dynamic to the typed language, typically a function
    at a time. Each language can import code from the other, but when importing into
    typed code, the programmer must specify a type for the imported code.'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，还有一种被称为“宏”渐变类型的方法。在宏方法中，有两种语言：静态类型和动态类型。它们预计将非常相似——相似到它们有相同的运行时系统并且可以自由共享值——因此我们将它们称为“兄弟”语言。然而，它们可能不具有相同的结构（例如，静态类型语言不会包含`eval`）。我们不需要在静态类型和未类型化代码之间自由混合代码，我们只需要弄清楚值在两种语言之间而不是在每种语言内部传递时会发生什么。预期程序员将逐渐将代码库的一部分从动态类型迁移到静态类型语言，通常是每次一个函数。每种语言都可以从另一种语言导入代码，但当我们导入到静态类型代码时，程序员必须指定导入代码的类型。
- en: A canonical example of this approach is Typed Racket. Because Typed Racket is
    one of the oldest and most developed gradually typed languages (technically, it’s
    the combination of Racket and Typed Racket that is gradually typed—Typed Racket
    itself is fully typed), and also offers some of the most interesting perspective
    on what happens when values travel between languages, we will use that as our
    exemplar for study.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的典型例子是Typed Racket。因为Typed Racket是最古老、最发达的渐变类型语言之一（技术上，它是Racket和Typed Racket的组合，是渐变类型——Typed
    Racket本身是完全类型化的），并且也提供了关于值在语言之间传递时发生的事情的一些最有趣的视角，我们将使用它作为我们的研究范例。
- en: Typed Racket at Work
  id: totrans-1299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Typed Racket的实际应用
- en: In what follows, it’s critical to pay attention to the exact details of error
    messages!
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，注意错误信息的精确细节至关重要！
- en: 'First, let’s write the following function in `#lang racket` and test it out:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`#lang racket`中编写以下函数并测试它：
- en: '[PRE331]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: As we would expect,
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，
- en: '[PRE332]'
  id: totrans-1304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: because the string represents a valid number,
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串代表一个有效的数字，
- en: '[PRE333]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: because the string doesn’t represent a valid number, and
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串不表示一个有效的数字，并且
- en: '[PRE334]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'string->number: contract violation'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 'string->number: 合同违规'
- en: 'expected: string?'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 预期：string?
- en: 'given: 5'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 给定：5
- en: because `5` isn’t a string at all.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`5`根本不是字符串。
- en: 'Now let’s define it in Typed Racket:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在Typed Racket中定义它：
- en: '`#lang typed/racket`'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '`#lang typed/racket`'
- en: '[PRE335]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: The type-checker confirms that this program is well-typed.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器确认这个程序是正确类型的。
- en: Exercise: As a test, try
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：作为一个测试，尝试
- en: '[PRE336]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: and see what happens.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后看看会发生什么。
- en: 'Now suppose we export this function from Typed Racket:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们从Typed Racket导出这个函数：
- en: '[PRE337]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'and import it into the Racket module:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其导入到Racket模块中：
- en: '[PRE338]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'Let’s try the same three tests. Predictably, two of them work the same:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试相同的三个测试。不出所料，其中两个工作方式相同：
- en: '[PRE339]'
  id: totrans-1325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'The third still produces an error, but a rather different kind of error:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数仍然会产生错误，但是一种相当不同的错误：
- en: '[PRE340]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'f: contract violation'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 'f: contract violation'
- en: 'expected: string?'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 'expected: string?'
- en: 'given: 5'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 'given: 5'
- en: 'in: the 1st argument of'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 'in: the 1st argument of'
- en: (-> string? any)
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: (-> string? any)
- en: 'contract from: typed.rkt'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 'contract from: typed.rkt'
- en: 'blaming: untyped.rkt'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 'blaming: untyped.rkt'
- en: (assuming the contract is correct)
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: (assuming the contract is correct)
- en: 'at: typed.rkt:5:9'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 'at: typed.rkt:5:9'
- en: Here’s what is happening. When we export f from Typed Racket, we don’t just
    export the function in its raw form. Rather, Typed Racket wraps the function in
    contracts that “protect” it in a dynamic setting. Thus, it is as if the function
    that was exported was
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在发生的事情是。当我们从类型化 Racket 导出 f 时，我们不仅仅导出函数的原始形式。相反，类型化 Racket 将函数包裹在合约中，这些合约在动态环境中“保护”它。因此，导出的函数就像
- en: '[PRE341]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '(with suitably different error messages). Notice that `wrapped-f`behaves exactly
    like our imported `f`does: the error when given `5` is from a contract check,
    rather than from an internal operation. Observe also that this wrapped version
    is quite easy to produce in a completely mechanical way, i.e., through desugaring:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: (with suitably different error messages). 注意到 `wrapped-f` 的行为与我们导入的 `f` 完全一样：给
    `5` 时的错误来自合约检查，而不是来自内部操作。观察一下，这个包装版本通过完全机械的方式很容易产生，即通过去糖化：
- en: '`(define (f [`s`:` String`]) :` Number'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (f [`s`:` String`]) :` Number'
- en: (+ 1 (or (string->number s) 0))`)`
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 1 (or (string->number s) 0))`)`
- en: became
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: became
- en: '`(define (wrapped-f` s`)`'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (wrapped-f` s`)`'
- en: '`  (if (`string?s`)`'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (if (`string?s`)`'
- en: '`(let ([b` (+ 1 (or (string->number s) 0))`])`'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([b` (+ 1 (or (string->number s) 0))`])`'
- en: '`        (if (`number?` b)`'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '`        (if (`number?` b)`'
- en: '[PRE342]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '`(error ''contract "returned value was not a` Number`")))`'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '`(error ''contract "returned value was not a` Number`")))`'
- en: '`(error ''contract "provided value was not a` String`")))`'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '`(error ''contract "provided value was not a` String`")))`'
- en: Exercise:Why do we bind `b` to the result of the body? Why not use the body
    expression directly?
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：为什么我们将 `b` 绑定到主体结果？为什么不直接使用主体表达式？
- en: The point of this wrapping is to put the type annotations to work in a dynamic
    setting. Essentially, the programmer who has put the effort to add annotations
    and get the program through the type-checker gets assurance that their function
    will not be abused through checks that are early and more informative than an
    internal error (that may not even occur, depending on the inputs, leaving the
    error to lurk!).
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包装的目的在于在动态环境中使用类型注解。本质上，那些努力添加注解并通过类型检查器的程序员可以确信他们的函数不会因为早期且更具有信息量的检查而被滥用（这种内部错误可能根本不会发生，取决于输入，让错误潜伏！）。
- en: 'Here is a more interesting example. We define the following typed function:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更有趣的例子。我们定义以下带类型的函数：
- en: '[PRE343]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'Here is its Racket counterpart:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其 Racket 对应版本：
- en: '[PRE344]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: 'Now let’s assume we are trying to use both of these from Racket. We first define
    a function that produces strings from strings, i.e., one that does notmatch the
    function expected by either `h`or `j`:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们正在尝试从 Racket 中使用这两个函数。我们首先定义一个从字符串生成字符串的函数，即一个不匹配 `h` 或 `j` 所期望的函数：
- en: '[PRE345]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'Now watch what happens when we run `(j str-dbl)`and `(h str-dbl)`. Both produce
    a run-time error, but very different ones. The former (which is entirely in Racket)
    gives an error at `+`: the “doubled” string is produced and makes it as far as
    `+`, which reports a violation. In contrast, in the latter case, the doubled string
    is produced but, when it tries to return from `(i "5")`, the type `(-> String
    Number)`has been turned into a contract, which halts execution saying that there
    is a contract violation!'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看当我们运行 `(j str-dbl)` 和 `(h str-dbl)` 时会发生什么。两者都会产生运行时错误，但非常不同。前者（完全在 Racket
    中）在 `+` 处产生错误：生成的“加倍”字符串到达 `+`，并报告违规。相比之下，在后一种情况下，生成了加倍字符串，但当它尝试从 `(i "5")` 返回时，类型
    `(-> String Number)` 已被转换为合约，这导致执行停止并指出存在合约违规！
- en: Aside:To get a sense of Racket’s contract system, see [Contracts](https://www.google.com/url?q=https://docs.racket-lang.org/guide/contracts.html&sa=D&source=editors&ust=1695232021518320&usg=AOvVaw3cHKDevH_K7R7ne4KDUsP7) in
    the Racket Guide.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：为了了解 Racket 的合约系统，请参阅 Racket 指南中的 [Contracts](https://www.google.com/url?q=https://docs.racket-lang.org/guide/contracts.html&sa=D&source=editors&ust=1695232021518320&usg=AOvVaw3cHKDevH_K7R7ne4KDUsP7)。
- en: 'Exercise: Another interesting static-dynamic language combination is Racket
    with plait. plait does not try very much to accommodate Racket idioms, though
    it does to some extent: recall the predicates and accessors in algebraic dataytypes
    [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)], though at the cost of static
    type safety. Largely, however, plait is trying to implement the Standard ML type
    language. Nevertheless, because plait lives in the context of Racket, its values
    can be exported and used from Racket. Try the above examples in plait!'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：另一种有趣的静态-动态语言组合是Racket与plait。虽然plait在一定程度上尝试适应Racket的惯用法，但它并不非常努力：回想一下代数数据类型中的谓词和访问器
    [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)]，但这是以静态类型安全为代价的。然而，plait主要试图实现标准ML类型语言。尽管如此，因为plait存在于Racket的上下文中，它的值可以从Racket导出并使用。在plait中尝试上面的示例！
- en: ••••• Non-Standard Models •••••
  id: totrans-1361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: •••••非常规模型•••••
- en: We have already seen some non-standard features, but they are in widespread
    use. Here we look at some that are less widely used (though some are growing in
    prominence, and others are enjoying a renaissance) but provide fascinating views
    of what programming languages can do.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些非标准特性，但它们被广泛使用。在这里，我们来看看一些使用较少（尽管其中一些正在日益突出，而另一些正在经历复兴）但提供了对编程语言能做什么的迷人视角。
- en: Relations
  id: totrans-1363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系
- en: A Language Genealogy
  id: totrans-1364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言谱系
- en: 'Suppose we want to record a genealogy of programming languages and determine
    which languages obtained ideas from which ones. We start by recording which languages
    directly borrowed ideas from which ones: e.g., Java directly borrowed from C++,
    and C++ directly borrowed from C. From that, we can also trace the descendants
    down a chain of borrowing.'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要记录编程语言的谱系，并确定哪些语言从哪些语言中获得了灵感。我们首先记录哪些语言直接从哪些语言中借鉴了想法：例如，Java直接借鉴了C++，而C++直接借鉴了C。从那以后，我们还可以沿着借鉴的链条追溯后代。
- en: 'We will write some of these in the following, maybe peculiar, syntax:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下内容中以可能奇特的方式编写一些这些内容：
- en: '[PRE346]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'means that the language `A`borrows from the language `B`(i.e., `A`is newer,
    `B`is older). For another peculiar reason, we will write constants not as quotes
    but as alphanumeric strings with a lower-case initial. Given that, here are some
    facts (with `cpp` standing for C++):'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 表示语言`A`借鉴了语言`B`（即，`A`较新，`B`较旧）。出于另一个奇特的原因，我们将常数不是写成引号，而是写成以小写字母开头的字母数字字符串。鉴于这一点，以下是一些事实（其中`cpp`代表C++）：
- en: '[PRE347]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'Now we can express the notion of being a descendant: there are two ways that
    `A`can be a descendant of `B`. One is if `A`borrows directly from `B`. The other
    is if it borrows from some language `Z`that is itself a descendant of `B`. We
    express these two rules using this syntax:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以表达成为后代的观念：`A`可以是`B`的后代有两种方式。一种方式是如果`A`直接从`B`借鉴。另一种方式是如果它从某个语言`Z`借鉴，而该语言本身是`B`的后代。我们使用这种语法表达这两个规则：
- en: '[PRE348]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'Congratulations, you’ve just written your first Prologprogram. To see this
    run, you can use [SWI Prolog online](https://www.google.com/url?q=https://swish.swi-prolog.org/&sa=D&source=editors&ust=1695232021521364&usg=AOvVaw3htfQEX93FhT5bpRmnE6re).
    But what does it mean to “run” this? Prolog answers questions: we can ask several
    questions like:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你刚刚编写了你的第一个Prolog程序。要运行此程序，你可以使用[SWI Prolog在线](https://www.google.com/url?q=https://swish.swi-prolog.org/&sa=D&source=editors&ust=1695232021521364&usg=AOvVaw3htfQEX93FhT5bpRmnE6re)。但“运行”这个意味着什么？Prolog回答问题：我们可以提出几个问题，例如：
- en: Does `cpp`borrow from `c`?
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpp`是否借鉴了`c`？'
- en: '[PRE349]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: → true
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: → true
- en: Does `cpp`borrow from `bcpl`?
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpp`是否借鉴了`bcpl`？'
- en: '[PRE350]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: → false
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: → false
- en: 'That is, we can see that Prolog is acting like a basic database. But we can
    do more:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 即，我们可以看到Prolog表现得像一个基本数据库。但我们还能做更多：
- en: Does `cpp`descend from `bcpl`?
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpp`是否从`bcpl`派生？'
- en: '[PRE351]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: → true
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: → true
- en: Does `bcpl`descend from `cpp`?
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcpl`是否从`cpp`派生？'
- en: '[PRE352]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: → false
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: → false
- en: 'Aha: so Prolog will not only query basic facts, it will also process queries
    through rules.'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 哎哈：所以Prolog不仅会查询基本事实，还会通过规则处理查询。
- en: 'But we can actually ask Prolog more sophisticated questions that look more
    like function applications. Consider:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们实际上可以向Prolog提出更复杂的问题，这些问题看起来更像函数应用。考虑：
- en: What does `cpp` borrow from?
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpp`借鉴了什么？'
- en: borrows(cpp, X).
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: borrows(cpp, X).
- en: →
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: →
- en: X= c
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: X= c
- en: This seems to treat borrows like a rather funny function, calling it with a
    variable (a name that begins with a capital letter) and letting Prolog fill in
    the variable. Does that work only for basic definitions, or also for rules?
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎将借鉴视为一个相当有趣的功能，通过一个变量（一个以大写字母开头的名字）调用它，并让Prolog填充变量。这仅适用于基本定义，还是也适用于规则？
- en: What does `cpp` descend from?
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpp`派生自什么？'
- en: descends(cpp, X).
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: descends(cpp, X).
- en: →
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: →
- en: X= c
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: X= c
- en: X= bcpl
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: X= bcpl
- en: Oh, this is interesting! Prolog didn’t return just one answer; it returned allthe
    answers. And this was done by using a variable(a name that begins with a capital
    letter). This naturally suggests the question, what if we did it the other way
    around?
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这很有趣！Prolog没有只返回一个答案；它返回了所有答案。这是通过使用一个变量（以大写字母开头的名字）来完成的。这自然引出了一个问题，如果我们反过来这样做会怎样？
- en: What descends from `cpp`?
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 从`cpp`中衍生出什么？
- en: descends(X, cpp).
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: descends(X, cpp).
- en: →
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: →
- en: X= java
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: X= java
- en: 'This is even stranger: it’s like passing a variable as an argument and asking
    what inputs will produce a particular result from the function!'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至更奇怪：这就像传递一个变量作为参数，并询问什么输入会产生函数的特定结果！
- en: In fact, a function is just the wrong way to think about any of this. What is
    happening in Prolog is that we’re defining relations. So borrows and descends
    are actually relations, where one (borrows) is defined by concrete examples and
    the other (descends) by abstract rules.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一个函数只是错误地思考这些事情的方式。在Prolog中发生的事情是，我们正在定义关系。所以，borrows和descends实际上是关系，其中一个是通过具体例子定义的（borrows），另一个是通过抽象规则定义的（descends）。
- en: 'Once we understand these are relations, we no longer need to limit ourselves
    to just one source of borrowing, to better reflect reality. That is, let’s say
    this is our set of facts:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们明白这些都是关系，我们就不再需要将自己限制在只从一个来源借用的范围内，以更好地反映现实。也就是说，让我们假设这是我们的事实集：
- en: '[PRE353]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'Now we can ask what all languages contributed to JavaScript:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以询问所有语言对JavaScript的贡献：
- en: '[PRE354]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'From this set of facts, we learn:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个事实集中，我们了解到：
- en: X= self
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: X= self
- en: X= scheme
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: X= scheme
- en: X= smalltalk
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: X= smalltalk
- en: X= simula
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: X= simula
- en: X= algol
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: X= algol
- en: X= lisp
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: X= lisp
- en: 'Similarly, we can ask how widely Lisp’s influence spread:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以询问Lisp的影响传播得多广：
- en: '[PRE355]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'And we learn that for this very limited set of languages:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，对于这个非常有限的语言集合：
- en: X= scheme
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: X= scheme
- en: X= javascript
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: X= javascript
- en: Encoding Type Rules
  id: totrans-1421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码类型规则
- en: You may have noticed that we’re writing rules that are quite similar to the
    typing rules we’ve written. Let’s see whether we can encode them directly.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们正在编写与我们已经编写的类型规则非常相似的规则。让我们看看我们是否可以直接编码它们。
- en: 'First, we need to encode the rules for syntactic constants:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编码句法常量的规则：
- en: '[PRE356]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: We will use the Prolog constant `numE` to stand for a syntactic numeric expression,
    and so on.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Prolog常量`numE`来表示一个句法数值表达式，等等。
- en: 'Now, using just what we already know, we can encode the conditional rules:'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仅凭我们已经知道的知识，我们可以编码条件规则：
- en: '[PRE357]'
  id: totrans-1427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: Note that this is literally just a syntactic transformation of the rules we
    wrote before!
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这实际上只是对我们之前写的规则进行了一种字面上的句法转换！
- en: 'With this, we can now use Prolog as a checker:'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们现在可以用Prolog作为一个检查器：
- en: '[PRE360]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: → true
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: → true
- en: 'and as a calculator:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 以及作为一个计算器：
- en: '[PRE361]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: →
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: →
- en: Y= numT
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: Y= numT
- en: 'But we can do something much more intriguing: what if we leave variables in
    the program?'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以做一些更有趣的事情：如果我们把变量留在程序中会怎样？
- en: tc(ifE(boolE, plusE(numE, Y), numE), numT).
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: tc(ifE(boolE, plusE(numE, Y), numE), numT).
- en: 'This is asking Prolog to come up with programs that will make this program
    have numeric type. Prolog responds with:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在请求Prolog提出程序，使这个程序具有数值类型。Prolog响应：
- en: Y= numE
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: Y= numE
- en: Y= plusE(numE, numE)
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: Y= plusE(numE, numE)
- en: Y= plusE(numE, plusE(numE, numE))
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: Y= plusE(numE, plusE(numE, numE))
- en: Y= plusE(numE, plusE(numE, plusE(numE, numE)))
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: Y= plusE(numE, plusE(numE, plusE(numE, numE)))
- en: (and many more; the structure of terms reveals something about how Prolog works).
    That is, Prolog is acting as a program synthesizer.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: （以及更多；项的结构揭示了关于Prolog如何工作的某些信息）。也就是说，Prolog正在充当程序合成器。
- en: 'Now let’s see how to extend this to include the type environment. For that,
    we have to enlarge our typing rules to include an environment as well. Recall
    that the environment doesn’t matter for the axioms, while the other rules just
    pass the environment through:'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何扩展它以包括类型环境。为此，我们必须扩大我们的类型规则，包括环境。回想一下，环境对于公理来说并不重要，而其他规则只是将环境传递下去：
- en: '[PRE362]'
  id: totrans-1447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-1448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-1450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'Now let’s add the three variable-oriented rules. We will use a list of `bind` relations
    to capture the environment. To look up a variable, we pattern-match on whether
    the variable is the first binding; if it is we can respond with the relevant type,
    otherwise we must search in the remaining bindings:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加三个面向变量的规则。我们将使用`bind`关系列表来捕获环境。为了查找一个变量，我们根据变量是否是第一个绑定进行模式匹配；如果是，我们可以响应相关的类型，否则我们必须在剩余的绑定中进行搜索：
- en: '[PRE366]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-1453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: The Prolog notation `[ … | … ]`means to decompose a list into a first, or head,
    element to the left of the `|`and the rest, or tail, to the right of the `|`.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: Prolog的符号`[ … | … ]`表示将列表分解为一个位于`|`左侧的第一个元素（或头元素）和位于`|`右侧的其余部分（或尾元素）。
- en: 'The other two rules look much more like the type rules we wrote earlier:'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个规则看起来更像是我们之前写的类型规则：
- en: '[PRE368]'
  id: totrans-1456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'Observe that in the above rule, we have done away with the type annotation!
    This rule looks more like what we would write with type inferencethan with type
    checking. Finally:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到在上述规则中，我们已经去掉了类型注解！这个规则看起来更像是我们会用类型推断而不是类型检查来写。最后：
- en: '[PRE369]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'We can now use these definitions with the example we used for type inference.
    Let’s translate this program (we have only single-argument functions) from before:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些定义来处理我们之前用于类型推断的例子。让我们将这个程序（我们只有单参数函数）翻译过来：
- en: '[PRE370]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'We pass this to the `tc` relation, encoded as follows, with the type environment
    and result type left variable:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个传递给`tc`关系，如下编码，类型环境和结果类型为变量：
- en: '[PRE371]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'Prolog produces the following output:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: Prolog产生了以下输出：
- en: T= funT(boolT, funT(numT, numT))
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: T= funT(boolT, funT(numT, numT))
- en: 'In other words, it has effectively inferred the type of the function: `v`has
    Boolean type, `w` has numeric type, and the result of the whole expression is
    a number.'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它实际上推断出了函数的类型：`v`具有布尔类型，`w`具有数值类型，整个表达式的结果是数字。
- en: 'In other words, it has inferred the types of the parameters. Now let’s consider
    some type-erroneous programs:'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它已经推断出了参数的类型。现在让我们考虑一些类型错误的程序：
- en: '[PRE372]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: → false
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: → false
- en: 'Here, Prolog tells us it can’t find any variable name that would satisfy this
    shape of program. But if instead we give it a program with holes to fill in for
    expressions:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Prolog告诉我们它找不到任何变量名可以满足这个程序形状。但如果我们给它一个带有要填充的表达式的程序：
- en: '[PRE373]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: 'Prolog tries to build bigger and bigger terms that might work, and goes into
    an infinite loop trying to find a program that is typeable! In general, this is
    a problem for synthesis systems: if the problem they are given has a solution
    they can often find one quickly, but if it does not have a solution, they have
    to spend a long time trying to find one—either very long, if it’s a large but
    finite space to search, or infinitely long, if the space is infinite. Often, synthesizers
    will use heuristics to truncate this search.'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: Prolog试图构建更大的可能工作的项，并进入一个无限循环，试图找到一个可类型化的程序！一般来说，这是合成系统的问题：如果他们给出的问题有解，他们通常可以很快找到，但如果它没有解，他们必须花费很长时间去寻找——要么非常长，如果搜索空间是大的但有限的，要么无限长，如果空间是无限的。通常，合成器会使用启发式方法来截断这个搜索。
- en: Generators
  id: totrans-1472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: A Canonical Example
  id: totrans-1473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个典型示例
- en: 'Consider the following canonical Python program that uses generators:'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下经典的Python程序，它使用了生成器：
- en: '[PRE374]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-1477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: produces `0 + 1 + 2`= `3`. But how does it work?
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 产生`0 + 1 + 2` = `3`。但它是如何工作的？
- en: At a textual level, we can understand it as follows. `nats`looks like a function,
    but it has the keyword `yield`in it. This makes it not a function but a generator.
    Its body initializes `n`to `0`, then goes into an infinite loop. Each time through
    the loop, it yieldsthe current value of `n`, then increments it, before continuing
    the loop.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本层面上，我们可以这样理解。`nats`看起来像是一个函数，但它包含关键字`yield`。这使得它不是一个函数，而是一个生成器。它的主体将`n`初始化为`0`，然后进入一个无限循环。每次循环通过时，它都会产生`n`的当前值，然后增加它，在继续循环之前。
- en: Outside the definition of `nats`, we define `g`to be an instanceof the generator,
    and each call to `next`gets the next yielded value. This explains the result.
    What we need to do is understand what is going on inside `nats`, and hence what
    happens with generators in general.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nats`的定义之外，我们定义`g`为生成器的一个实例，并且每次调用`next`都会获取下一个产生的值。这解释了结果。我们需要做的是理解`nats`内部发生了什么，以及一般生成器会发生什么。
- en: 'It is clear that we cannotthink of `nats`(or of the generator returned by it)
    as a function. If we do, then clearly it goes into an infinite loop. That means
    the very first `next`call would run forever; it would never produce a value, which
    enables the next `next` call, and then the third, producing the sum. To see this,
    imagine we had the following version instead:'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们不能将`nats`（或由它返回的生成器）视为函数。如果我们这样做，那么很明显它会进入一个无限循环。这意味着第一个`next`调用将永远运行；它永远不会产生一个值，这允许下一个`next`调用，然后是第三个，产生总和。为了理解这一点，想象我们有一个以下版本：
- en: '[PRE377]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: Here, even though natsr (“`nats`with `return`”) has an infinite loop, every
    time Python runs the `return`, it halts the function and returns. Furthermore,
    on the next call, we start again from the beginning of `natsr`. As a result, each
    call produces `0`so the sum is also `0`.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，尽管`natsr`（`nats`带有`return`）有一个无限循环，但每次Python运行`return`时，它都会停止函数并返回。此外，在下一次调用时，我们再次从`natsr`的开始处开始。因此，每次调用都会产生`0`，所以总和也是`0`。
- en: In contrast, that is clearly not what is happening in (the generator created
    by) `nats`. Rather, it’s clear that—as the name `yield`suggests—the computation
    is haltingwhen the `yield`occurs. When we call `next`, computation does not start
    at the top of `nats`; if it did, `n`would be `0`. Instead, it resumesfrom where
    it left off, so that the value of `n`is incremented and the next iteration of
    the `while` loop occurs.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，这显然不是`nats`（由`nats`创建的生成器）中发生的情况。相反，正如`yield`这个名字所暗示的，当`yield`发生时，计算会停止。当我们调用`next`时，计算不会从`nats`的顶部开始；如果它这样做，`n`将会是`0`。相反，它会从上次停止的地方继续，这样`n`的值就会增加，并且`while`循环的下一个迭代就会发生。
- en: If all of this sounds suspiciously like variables in a scope being held on to
    by a closure, you’re on the right track. To understand this more, though, we need
    to peer a bit more closely at the evaluation. While we could run this in the [Python
    Tutor](https://www.google.com/url?q=https://pythontutor.com/python-debugger.html%23mode%3Dedit&sa=D&source=editors&ust=1695232021543587&usg=AOvVaw1V3VjgOrP0CFbXmfhLsC-A),
    that tool does not really have the support necessary for us to understand what
    is happening in this program. Instead, we will turn to our Stacker.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来可疑地像闭包中保留作用域内的变量，你就在正确的道路上。然而，为了更好地理解这一点，我们需要更仔细地观察评估过程。虽然我们可以在[Python
    Tutor](https://www.google.com/url?q=https://pythontutor.com/python-debugger.html%3Fmode%3Dedit%26%23mode%3Dedit&sa=D&source=editors&ust=1695232021543587&usg=AOvVaw1V3VjgOrP0CFbXmfhLsC-A)中运行这个程序，但这个工具并没有真正提供我们理解这个程序中发生的事情所必需的支持。相反，我们将转向我们的Stacker。
- en: 'Aside: In Python, generators are merely syntactic sugar over the more general
    notion of iterators. Iterators respond to the `next`protocol. To learn how a generator
    desugars into an iterator, see [this StackOverflow post](https://www.google.com/url?q=https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators&sa=D&source=editors&ust=1695232021544241&usg=AOvVaw2tKB37Q1fKdFcreD_ejsF-).
    To understand Python generators in more depth, see sections 4.1 and 4.3 of [this
    paper](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&sa=D&source=editors&ust=1695232021544525&usg=AOvVaw1G24Y80eCAnFcayzoealQX).'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：在Python中，生成器只是更一般的概念迭代器上的语法糖。迭代器响应`next`协议。要了解生成器如何解糖成迭代器，请参阅[这个StackOverflow帖子](https://www.google.com/url?q=https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators&sa=D&source=editors&ust=1695232021544241&usg=AOvVaw2tKB37Q1fKdFcreD_ejsF-)。要深入了解Python生成器，请参阅[这篇论文](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&sa=D&source=editors&ust=1695232021544525&usg=AOvVaw1G24Y80eCAnFcayzoealQX)的第4.1节和第4.3节。
- en: Translating to SMoL
  id: totrans-1488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译到SMoL
- en: 'The following program is a rough simulation of the above Python program ifSMoL
    had a notion of `yield`, which it does not. To avoid unbound identifier errors,
    we will use the following simple definition of `yield`:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序是对上述Python程序的一个粗略模拟，如果SMoL有一个关于`yield`的概念，它就不会这样。为了避免未绑定标识符错误，我们将使用以下简单的`yield`定义：
- en: '[PRE379]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: 'We can then translate the above code as follows:'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将上述代码翻译如下：
- en: '[PRE380]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'For simplicity, we’re ignoring the step where we instantiate the generator:
    i.e., we can have only one copy of the generator in this version, whereas the
    Python version lets us instantiate multiple. We will return to this later.'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们忽略了实例化生成器的步骤：即在这个版本中，我们只能有一个生成器的副本，而Python版本允许我们实例化多个。我们稍后会回到这一点。
- en: Observe that running the above program goes into an infinite loop, because `yield` does
    not “yield”. However, because the Stacker shows us intermediate steps in the computation,
    it still provides something very useful.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，运行上述程序会进入无限循环，因为`yield`没有“yield”。然而，由于Stacker显示了计算过程中的中间步骤，它仍然提供了非常有用的信息。
- en: 'Now that we have this program, let’s run it through the Stacker. We will see
    a few preliminary states, and then one that looks like this:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个程序，让我们通过Stacker运行它。我们将看到几个初步状态，然后是一个看起来像这样的状态：
- en: '![](image10.png)'
  id: totrans-1497
  prefs: []
  type: TYPE_IMG
  zh: '![image10.png](image10.png)'
- en: At this point, the oldest frame represents the top-level expression, which is
    waiting for the first call to `gen`to compute. Inside `gen`, we have initialized
    `n`to `0`. Now we are about to start computing the (potentially) infinite loop.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，最老的框架代表顶层表达式，它正在等待对`gen`的第一个调用以进行计算。在`gen`内部，我们已经将`n`初始化为`0`。现在我们即将开始计算（可能）无限循环。
- en: 'A little bit later, we see the following:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，我们看到以下内容：
- en: '![](image20.png)'
  id: totrans-1500
  prefs: []
  type: TYPE_IMG
  zh: '![image20.png](image20.png)'
- en: This picture is the essence of generators. Understanding it is critical.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 这幅图是生成器的精髓。理解它是至关重要的。
- en: 'Here is what is happening here. The top-level computation is waiting for the
    call to `gen`to finish and produce an answer. Withinthe generator, the computation
    has initialized n and is about to yield its current value. What is critical is
    the context of this operation:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在发生的事情。顶级计算正在等待`gen`的调用完成并产生答案。在生成器内部，计算已经初始化了`n`并即将产生其当前值。关键在于这个操作的环境：
- en: '[PRE382]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: in @1678, which has no bindings and hence defers to @1909\. This binds `n`to
    `0`.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: in @1678，它没有任何绑定，因此推迟到@1909。这将`n`绑定到`0`。
- en: 'Now, suppose we could break up this stack into two parts (with the environment
    and store shared as needed):'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们可以将这个栈分成两部分（环境和存储按需共享）：
- en: '[PRE383]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: in @1233
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: in @1233
- en: '[PRE384]'
  id: totrans-1508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: in @1678
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: in @1678
- en: Observe that each part looks like a full-fledged stack in its own right! The
    environment @1233 refers to names that the top-level uses (such as `gen`), while
    the environment @1678 (and hence @1909) refers to ones that the generator uses
    (such as `n`).
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个部分本身看起来就像一个完整的栈！环境@1233引用的是顶级使用的名称（如`gen`），而环境@1678（以及因此@1909）引用的是生成器使用的名称（如`n`）。
- en: 'Until now, however, we have acted as if a program has only one stack. The simplest
    conceptual model for a generator is:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我们一直表现得好像程序只有一个栈。生成器的最简单概念模型是：
- en: Each generator has its own local stack.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生成器都有自己的局部栈。
- en: 'That is, the generator’s stack does not know about the computation in the main
    program or in any other generators. It only knows about the computation that it
    is performing. A `yield` does two things:'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是生成器栈不知道主程序或其他生成器中的计算。它只知道它正在执行的计算。`yield`做两件事：
- en: It transparently (i.e., without the programmer’s knowledge) stores the local stack
    with the generator data structure.
  id: totrans-1514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它透明地（即，在没有程序员知识的情况下）将局部栈与生成器数据结构存储在一起。
- en: It returns the yielded value to the stack that invoked the generator.
  id: totrans-1515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将产生的值返回到调用生成器的栈。
- en: Everything else—variables, aliasing, closures, growth and decline of the stack
    with functions calls and returns, etc.—stays exactly the same. The only difference
    is that calling a generator causes computation to start, or resume the context,
    in a separate, disconnected stack.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有东西——变量、别名、闭包、函数调用和返回时的栈的增长和减少等——都保持完全相同。唯一的不同之处在于调用生成器会导致计算在一个单独的、断开的栈中开始或恢复上下文。
- en: Thus, in the above model, after the first `yield` succeeds, the top-level stack
    frame would be
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上面的模型中，在第一次`yield`成功之后，顶级栈帧将是
- en: '[PRE385]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: in @1233
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: in @1233
- en: invoking the generator. This would resume the previous stack, so `n` would be
    set to 1, and the next iteration of the loop would run, which would
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 调用生成器。这将恢复之前的栈，所以`n`将被设置为1，并且循环的下一个迭代将运行，这将
- en: Store the generator’s stack (which, conceptually, is exactly the same—only the
    value of `n` has changed, but that is in the environment), and
  id: totrans-1521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储生成器的栈（从概念上讲，它与之前完全相同——只是`n`的值发生了变化，但这是在环境中），并且
- en: return the new value of `n`(i.e., `1`) to the top-level stack.
  id: totrans-1522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`n`的新值（即`1`）返回到顶级栈。
- en: This would result in
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致
- en: '[PRE386]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: in @1233
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: in @1233
- en: repeating the above process, and hence producing `3`.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 重复上述过程，从而产生`3`。
- en: A Richer Example
  id: totrans-1527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更丰富的例子
- en: 'Using what we have learned, let us consider another Python example:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们所学到的知识，让我们考虑另一个Python示例：
- en: '[PRE387]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'This program has two distinct generator creators: the one we’ve already seen
    for natural numbers, and one more that filters the natural numbers to produce
    only odd numbers.'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有两个不同的生成器创建者：我们已经看到的自然数生成器，以及一个过滤自然数以只产生奇数的生成器。
- en: We can now think of control proceeding as follows. First, we make an instance
    of `odds`and bind it to `g`. This immediately creates an instance of `nats`and
    binds it (within the instance of `odds`) to `ns`. Now all our generators are set
    up and ready to compute.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以这样思考控制流程。首先，我们创建一个`odds`的实例并将其绑定到`g`。这立即创建了一个`nats`的实例，并在`odds`的实例中将它绑定到`ns`。现在，我们所有的生成器都已经设置好，准备进行计算。
- en: We now begin the infinite loop in `odds`. This calls the natural number generator.
    At this point, the odd number generator’s local stack looks like
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始`odds`中的无限循环。这调用自然数生成器。在这个点上，奇数生成器的局部栈看起来像
- en: '[PRE391]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: in an environment where `ns`is bound to a generator and `n` is uninitialized
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: in an environment where `ns`is bound to a generator and `n` is uninitialized
- en: Because we have called a generator, not a function, computation now runs in
    that generator’s own stack. This is the natural number generator, which we have
    already studied. It binds `n`to `0`and then `yield`s, storing its local stack—
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们调用的是一个生成器而不是一个函数，计算现在在那个生成器自己的栈上运行。这是我们已经研究过的自然数生成器。它将 `n` 绑定到 `0` 然后产生，存储其局部栈——
- en: '[PRE392]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: in an environment where `n`is bound to `0`
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个环境中 `n` 被绑定到 `0`
- en: —and returning `0` to the odd number generator.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: ——并且返回 `0` 给奇数生成器。
- en: 'This resumes the odd generator’s stack. This binds n to 0 and performs the
    comparison. It fails, continuing the loop body:'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 这将恢复奇数生成器的栈。这将 `n` 绑定到 `0` 并执行比较。它失败了，继续循环体：
- en: '[PRE393]'
  id: totrans-1543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: Now we are again ready to invoke the natural number generator. The odd number
    generator’s localstack is unchanged from before (same context, same environment,
    except this time the environment does have a binding for `n`, to `0`). Meanwhile,
    the natural’s generator resumes from
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们又准备好调用自然数生成器了。奇数生成器的局部栈与之前没有变化（相同的上下文，相同的 环境，只是这次环境确实有一个对 `n` 的绑定，绑定到 `0`）。同时，自然生成器从
- en: '[PRE394]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: in an environment where `n`is bound to `0`
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个环境中 `n` 被绑定到 `0`
- en: 'This increments `n` and resumes the loop body:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 这将增加 `n` 并继续循环体：
- en: '[PRE395]'
  id: totrans-1548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: This immediately causes it to yield `1`, leaving the stack
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即导致它产生 `1`，留下栈
- en: '[PRE396]'
  id: totrans-1550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: in an environment where `n`is bound to `1`
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个环境中 `n` 被绑定到 `1`
- en: This resumes the odd generator’s stack. This binds `n`to `1`, so the conditional
    succeeds. Therefore, the stack at the point of yielding becomes
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 这将恢复奇数生成器的栈。这将 `n` 绑定到 `1`，因此条件成立。因此，在产生时的栈变为
- en: '[PRE397]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: in an environment where `ns`is bound to a generator and `n`is bound to `1`
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个环境中 `ns` 被绑定到一个生成器，而 `n` 被绑定到 `1`
- en: This completes the first call to `next(g)`, enabling the top-level stack frame
    to have the context
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对 `next(g)` 的第一次调用，使得顶层栈帧能够有上下文
- en: '[PRE398]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: From this, we can see the next two computations will produce `3`and `5`, and
    hence the total of `9`.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个中，我们可以看到接下来的两个计算将产生 `3` 和 `5`，因此总和为 `9`。
- en: Laziness
  id: totrans-1558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性
- en: Evaluation Strategies
  id: totrans-1559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估策略
- en: Back when we began to study evaluation [[👉](PLAIVersion3.2.2_split_015.html#h.nin2n4sergiw)],
    we saw that we had a choice when performing evaluation. During function application,
    we could substitute the actual parameter as an expressionor as a value. At that
    time, we indicated that SMoL is eager. Now we will investigate the other option,
    laziness.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们开始研究求值 [[👉](PLAIVersion3.2.2_split_015.html#h.nin2n4sergiw)] 的时候，我们看到了在执行求值时有一个选择。在函数应用期间，我们可以将实际参数作为表达式或值来替换。当时我们指出
    SMoL 是急切的。现在我们将研究另一个选项，惰性。
- en: 'Consider the following program:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序：
- en: '[PRE399]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-1564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-1565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: When run eagerly in the Stacker, we see calls like
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Stacker 中急切运行时，我们看到调用如下
- en: '![](image4.png)'
  id: totrans-1567
  prefs: []
  type: TYPE_IMG
  zh: '![](image4.png)'
- en: and the environment contents look like
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 环境内容看起来像
- en: '![](image9.png)'
  id: totrans-1569
  prefs: []
  type: TYPE_IMG
  zh: '![](image9.png)'
- en: Both the call and the environment reinforce that parameters are evaluated beforethe
    function body begins to execute, so names are bound to values.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 调用和环境都强化了参数在函数体开始执行之前被评估的观点，因此名称被绑定到值上。
- en: Why Lazy Evaluation
  id: totrans-1571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用惰性求值
- en: 'Suppose, instead, we evaluate this lazily. The evaluation would look like this:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，相反，我们以惰性方式评估它。评估看起来像这样：
- en: '[PRE403]'
  id: totrans-1573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: A natural question might be, why bother doing this?
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自然的问题可能是，为什么要费这个功夫？
- en: A reason people often cite is that it can save time, in that we don’t need to
    evaluate parameters we don’t need. For instance, suppose we have `(deffun (f x
    y z)  (if (zero? x)      y      z))` and we call f with two expensive-to-compute
    parameters in the last two positions. In an eager language, we have evaluated
    both whether we want to or not. In a lazy language, we only evaluate the one we
    need. As we will see below, this is actually not a very compelling argument.
  id: totrans-1575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人们经常引用的一个原因是它可以节省时间，因为我们不需要评估我们不需要的参数。例如，假设我们有 `(deffun (f x y z) (if (zero?
    x) y z))` 并且我们用两个计算成本高昂的参数调用 f 的最后两个位置。在急切的语言中，无论我们是否需要，我们都已经评估了它们。在惰性语言中，我们只评估我们需要的那个。正如我们下面将要看到的，这实际上不是一个很有说服力的论点。
- en: 'A second reason is that it enables us to add new, non-eager constructs to the
    language through functions. Consider `if`: in an eager language it can’t be a
    function because the whole point of `if`is to not evaluate one of the branches
    (which would become parameters that are evaluated). Again, this argument has somewhat
    limited merit: we have seen how we can add such constructs using macros, which
    can do a great deal more as well.'
  id: totrans-1576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个原因是它使我们能够通过函数向语言添加新的、非急切的结构。考虑一下`if`：在一个急切的语言中，它不能是一个函数，因为`if`的整个目的就是不要评估其中一个分支（这将成为要评估的参数）。再次强调，这个论点的价值有限：我们已经看到我们可以如何使用宏来添加这样的结构，而宏可以做更多的事情。
- en: 'The most interesting reason is probably that the set of equations that govern
    the language changes. Consider the following. Suppose we have the expressions
    `E`and `(lambda (x) (E x))`. Are they the “same”? It would seem, intuitively,
    that they are. Suppose `E`is a function. In any setting where we apply `E`to a
    parameter, the second expression does exactly the same: it takes that parameter,
    binds it to `x`, and then applies `E`to `x`, which has the same effect.'
  id: totrans-1577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最有趣的原因可能是控制语言的方程集合发生了变化。考虑以下情况。假设我们有表达式`E`和`(lambda (x) (E x))`。它们是“相同”的吗？直观上看，它们似乎是相同的。假设`E`是一个函数。在任何我们将`E`应用于参数的环境中，第二个表达式都会做完全相同的事情：它接受那个参数，将其绑定到`x`，然后对`x`应用`E`，这会产生相同的效果。
- en: However, note that `E`may not be a function! It could be a `print` statement,` (/
    1 0)`, and so on. In those cases, `E`evaluates right away and has some observable
    effect, but the version “hidden under the `lambda`” will not until it is used.
  id: totrans-1578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，请注意`E`可能不是一个函数！它可能是一个`print`语句，`(/ 1 0)`，等等。在这些情况下，`E`会立即评估并产生一些可观察的效果，但“隐藏在`lambda`之下”的版本则不会，直到它被使用。
- en: Why does this matter? It matters because many parts of programming implementations
    and tools want to replace some terms with other terms. An optimizing compiler
    does this (replacing a term with an equivalent one that is better by whatever
    optimizing criterion is in use), as do program refactoring engines, and more.
    Thus, the more terms that can be replaced, or the fewer conditions under which
    terms can be replaced, the better. Lazy languages allow more terms to be replaced.
  id: totrans-1579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这为什么重要呢？这是因为许多编程实现和工具的部分都希望用其他术语替换某些术语。优化编译器就是这样做的（用根据使用的优化标准更好的等效术语替换术语），程序重构引擎也是如此，等等。因此，可以替换的术语越多，或者术语可以替换的条件越少，就越好。惰性语言允许替换更多的术语。
- en: 'Terminology: This equivalence is called “rule eta” (η).'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：这种等价性被称为“η规则”（η）。
- en: 'Terminology: You may see some people say that lazy languages have “referential
    transparency”. If you ask them to define it, they may say something like “you
    can replace equals with equals”. Think about that for a moment: you can alwaysreplace
    equals with equals. That is (by some definitions) literally what equality means:
    two things are equal exactly when you can replace one with the other. So that
    phrase tells us nothing. In fact, every language has some degree of “referential
    transparency”: you can always replace some things with other equivalent things.
    In lazy languages, the set of things you can replace is usually bigger: the referential
    transparency relation is larger. That’s all.'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：你可能会看到有些人说惰性语言有“引用透明性”。如果你要求他们定义它，他们可能会说类似于“你可以用等于替换等于”的话。思考一下：你总是可以用等于替换等于。这正是（根据某些定义）等价性的字面意思：两个事物相等，当你可以用其中一个替换另一个时。所以那个短语并没有告诉我们什么。事实上，每种语言都有一定程度的“引用透明性”：你总是可以用一些等效的事物替换其他事物。在惰性语言中，你可以替换的事物集合通常更大：引用透明性关系更大。这就是全部。
- en: One very important, practical reason is to create potentially-infinite data
    structures. See the example on streams below.
  id: totrans-1582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个非常重要、实用的原因是创建可能无限的数据结构。请参见下面的流示例。
- en: More fundamentally, the famous paper [Why Functional Programming Matters](https://www.google.com/url?q=https://www.cse.chalmers.se/~rjmh/Papers/whyfp.html&sa=D&source=editors&ust=1695232021569949&usg=AOvVaw13ypvMWgaZXeEPuILJzYCX)argues
    that laziness is a modularity concept, and develops this argument through several
    beautiful examples.
  id: totrans-1583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更根本的是，著名的论文[为什么函数式编程很重要](https://www.google.com/url?q=https://www.cse.chalmers.se/~rjmh/Papers/whyfp.html&sa=D&source=editors&ust=1695232021569949&usg=AOvVaw13ypvMWgaZXeEPuILJzYCX)认为惰性是一种模块化概念，并通过几个漂亮的例子来发展这一论点。
- en: Strictness Points
  id: totrans-1584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格性要点
- en: 'Coming back to our example from earlier: when we run such a program in a language
    with lazy evaluation, when, if ever, does all this arithmetic resolve and print
    a value?'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子：当我们在一个具有惰性求值的语言中运行这样的程序时，何时以及是否所有这些算术运算会解析并打印出一个值？
- en: 'Before we answer that question, let us also observe that sometimes programs
    can’t really defer decisions indefinitely. For instance, consider this program:'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答那个问题之前，让我们也注意到，有时程序并不能真正无限期地推迟决策。例如，考虑这个程序：
- en: '[PRE404]'
  id: totrans-1587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: What happens when we try to evaluate it? Presumably substitution reduces this
    to
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试评估它时会发生什么？可能替换会将其简化为
- en: '[PRE406]'
  id: totrans-1590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: and now what? Presumably that could be considered “the answer”, but that doesn’t
    seem very useful; and in real programs, these terms would just grow larger and
    larger. Furthermore, suppose the program were
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在怎么办？可能这可以被认为是“答案”，但这似乎并不很有用；而且在实际程序中，这些术语会越来越大。此外，假设程序是
- en: '[PRE407]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: We can certainly produce as an answer
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以产生一个答案
- en: '[PRE409]'
  id: totrans-1595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: but…then what? And for that matter, what is `fact` in this response? This does
    not seem like a very useful programming language.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 但……然后呢？而且在这个问题上，`fact`是什么意思？这似乎不是一个很有用的编程语言。
- en: 'Instead, lazy programming languages define certain points in the language as
    strictnesspoints, which are points where expressions are forced to compute and
    produce an answer. Different choices of strictness points will result in languages
    that behave slightly differently. Conventionally, the following are considered
    useful strictness points:'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，惰性编程语言将语言中的某些点定义为严格性点，这些点是表达式被迫计算并产生答案的点。不同的严格性点选择将导致行为略有不同的语言。传统上，以下被认为是有用的严格性点：
- en: The conditional portion of a conditional expression. This enables the language
    to determine which branch to take and which branch to ignore.
  id: totrans-1598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件表达式的条件部分。这使语言能够确定要采取哪个分支以及要忽略哪个分支。
- en: Arithmetic. This avoids long chains of computations building up.
  id: totrans-1599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算术。这避免了长链计算的产生。
- en: The printer in an interactive environment. This makes the environment useful.
  id: totrans-1600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交互式环境中的打印器。这使得环境变得有用。
- en: All three of these are pragmatic choices. Notice that our first example above
    concerned the top-level printer, while the second example has to do with conditionals.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个都是实用主义的选择。注意，我们上面的第一个例子涉及顶层打印器，而第二个例子与条件语句有关。
- en: Because of these strictness points, a typical lazy language will in fact compute
    the programs we have seen above very similarly to an eager language. To get to
    something that really differentiates eagerness from laziness, we need to get to
    richer programs.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些严格性点，典型的惰性语言实际上会像急切语言一样计算我们上面看到的程序。要真正区分急切和惰性，我们需要更丰富的程序。
- en: Evaluating Without Substitution
  id: totrans-1603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不替换求值
- en: Above, we saw how we can think of lazy evaluation using substitution. While
    this is a useful mental model, as we have seen in earlier interpreters, we don’t
    really want to use substitution as our implementation strategy. That involves
    repeatedly rewriting program source, which is not how our interpreter worked.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们看到了如何使用替换来思考惰性求值。虽然这是一个有用的心理模型，正如我们在早期的解释器中看到的，但我们并不真的想将替换作为我们的实现策略。这涉及到反复重写程序源代码，而这并不是我们的解释器的工作方式。
- en: So let’s say we don’t pass the value but instead “the expression”. Does it mean
    the above sequence becomes this?
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不传递值，而是“表达式”。这意味着上面的序列变成这样吗？
- en: '[PRE410]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '`→ (g (+ x x))`where `x`is bound to `(+ 2 3)`'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '`→ (g (+ x x))`其中`x`被绑定到`(+ 2 3)`'
- en: '`→ (h (* y 2))`where `y`is bound to `(+ (+ 2 3) (+ 2 3)))`'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '`→ (h (* y 2))`其中`y`被绑定到`(+ (+ 2 3) (+ 2 3)))`'
- en: '`→ (+ x 5)`where `x`is bound to `(* (+ (+ 2 3) (+ 2 3)) 2)`'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: '`→ (+ x 5)`其中`x`被绑定到`(* (+ (+ 2 3) (+ 2 3)) 2)`'
- en: In fact, even this isn’t quite right. It should rather be
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这还不完全正确。它应该更像是
- en: '[PRE411]'
  id: totrans-1611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '`→ (g (+ x x))`where `x`is bound to `(+ 2 3)`'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '`→ (g (+ x x))`其中`x`被绑定到`(+ 2 3)`'
- en: '`→ (h (* y 2))`where `y`is bound to `(+ x x))`whose `x`is `(+ 2 3)`'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: '`→ (h (* y 2))`其中`y`被绑定到`(+ x x))`其中的`x`是`(+ 2 3)`'
- en: '`→ (+ x 5)`where `x`is bound to `(* y 2)`whose `y`is `(+ x x))`whose `x`is
    `(+ 2 3)`'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: '`→ (+ x 5)`其中`x`被绑定到`(* y 2)`其中的`y`是`(+ x x))`其中的`x`是`(+ 2 3)`'
- en: In other words, we want to pass the unevaluated expression…but you can probably
    see where this is going! If we’re not careful, we will end up with dynamic scope.
    Even setting that aside, we can’t just pass the expression on its own, because
    when we eventually get a strictness point, we simply will have no idea what value
    a variable resolves to.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们想要传递一个未评估的表达式……但你可能已经看到了这个趋势！如果我们不小心，我们最终会得到动态作用域。即使抛开这一点，我们也不能仅仅传递表达式本身，因为当我们最终达到严格性点时，我们根本不知道一个变量解析出的值是什么。
- en: However, the solution also presents itself very naturally. We don’t just pass
    an expression, we pass along its corresponding environment. An expression and
    environment combine to form a…closure! Of course, this closure does not take any
    parameters; its only job is to suspend the evaluation of the expressionuntil we
    reach a strictness point, and at that point, evaluate it in the right environment.
    Fortunately, we don’t need to do any new work here; closure application already
    does it for us.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解决方案本身也自然地呈现出来。我们不仅传递一个表达式，我们还传递其对应的环境。一个表达式和环境结合形成一个……闭包！当然，这个闭包不接收任何参数；它的唯一任务是挂起表达式的评估，直到我们达到严格性点，然后在那个点上，在正确的环境中评估它。幸运的是，我们在这里不需要做任何新的工作；闭包应用已经为我们做了。
- en: 'Laziness Via Closures: Beyond Numbers'
  id: totrans-1617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过闭包实现懒散：超越数字
- en: Laziness becomes more interesting when we consider data structures. Conventionally,
    data constructors are notstrict, so their arguments are not evaluated eagerly.
    We can illustrate this using lists, though technically we will be constructing
    streams (which are infinite, as opposed to lists, which are finite).
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑数据结构时，懒散变得更加有趣。传统上，数据构造函数不是严格的，因此它们的参数不会被立即评估。我们可以使用列表来说明这一点，尽管技术上我们将构建流（流是无限的，而列表是有限的）。
- en: 'First, read about streams represented using closures:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解使用闭包表示的流：
- en: '[https://dcic-world.org/2022-08-28/func-as-data.html#%28part._streams-from-funs%29](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/func-as-data.html%23%2528part._streams-from-funs%2529&sa=D&source=editors&ust=1695232021577933&usg=AOvVaw3xFcgFEVIzH5OuDVgtWddP)'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dcic-world.org/2022-08-28/func-as-data.html#%28part._streams-from-funs%29](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/func-as-data.html%23%2528part._streams-from-funs%2529&sa=D&source=editors&ust=1695232021577933&usg=AOvVaw3xFcgFEVIzH5OuDVgtWddP)'
- en: What would the same code look like in a language that was already lazy?
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个已经足够懒散的语言中，同样的代码会是什么样子呢？
- en: To experiment with that, we’ll now use the Racket language
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验这一点，我们现在将使用Racket语言
- en: '[PRE412]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-1624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-1626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: 'Observe how some of these values print:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这些值是如何打印的：
- en: '[PRE417]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'The word “promise” means these are thunksthat represent the stream. To view
    the thunk’s content, we need to “force” the “promise”, which we do using the `!` operator:'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: “承诺”这个词意味着这些thunks代表了流。要查看thunk的内容，我们需要“强制”执行“承诺”，我们使用`!`运算符来完成：
- en: '[PRE418]'
  id: totrans-1631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'In the case of `ones`, Racket is telling us that the rest of the stream is
    the samestream as the one we are viewing: i.e., it’s a cyclic stream. For `nats`,
    it tells us that the first element is `0`, followed by another promise. We can
    explore these streams a bit further:'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ones`的情况下，Racket告诉我们剩余的流与我们所查看的流是相同的：即，它是一个循环流。对于`nats`，它告诉我们第一个元素是`0`，然后是另一个承诺。我们可以进一步探索这些流：
- en: '[PRE419]'
  id: totrans-1633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'Unsurprisingly, `ones`does not change. But with `nats`, as we explore more
    of the stream, we run into more thunks. This is where `take`is useful: it gives
    us a finite prefix of the potentially infinite stream. Unfortunately, that also
    seems to just produce more thunks, and it seems like we would need to laboriously
    apply `!` to each part:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，`ones`没有变化。但是，随着我们对`nats`流探索得更多，我们会遇到更多的thunks。这就是`take`有用的地方：它给我们提供了可能无限流的有穷前缀。不幸的是，这也似乎只是产生了更多的thunks，我们似乎需要费力地应用`!`到每个部分：
- en: '[PRE420]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: 'For situations like this, where we knowthe output is going to be finite, we
    might want to resolve all the thunks. For this, Lazy Racket provides `!!`, which
    recursively applies strictness to all contained thunks:'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种我们知道输出将是有限的情况，我们可能想要解析所有的thunks。为此，Lazy Racket提供了`!!`，它递归地将严格性应用于所有包含的thunks：
- en: '[PRE421]'
  id: totrans-1637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: Sure enough, we get the expected answer.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，我们得到了预期的答案。
- en: Exercise:What happens if we apply `!!`to `ones`and to `nats`? Try it out, and
    explain what you see.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：如果我们对`ones`和`nats`应用`!!`会发生什么？试一试，并解释你所看到的结果。
- en: Tracing Laziness
  id: totrans-1640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪懒散
- en: 'Another way to understand laziness is to study the encoding of streams in the
    Stacker. Here is the code:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 理解懒散的另一种方法是研究在Stacker中流的编码。以下是代码：
- en: '[PRE422]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: Now run each of
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下每个：
- en: '[PRE426]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'and study whenevaluation happens and what is being held on to by the closures.
    (You may find it helpful to view just one of these at a time: the definition and
    use of `ones`, and separately of `nats`and `nats-from`.)'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 并研究何时发生评估以及闭包保留了什么。（你可能发现一次只查看其中一个是有帮助的：`ones`的定义和使用，以及`nats`和`nats-from`分别的使用。）
- en: Laziness and Side-Effects
  id: totrans-1649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰和副作用
- en: Given the (potential) benefits of lazy evaluation, why is laziness not more
    widely used?
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到懒惰评估的（潜在）好处，为什么懒惰没有被更广泛地使用？
- en: The problem is that laziness makes it much harder to predict what will happen
    in programs that use state. Therefore, popular lazy languages do not have state,
    or have it in very controlled forms. (This is not a bad thing! State should only
    be used in very controlled ways, and Haskell, for instance, has very interesting
    designs that help with that. But programmers have traditionally expected to have
    unfettered access to state.)
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，懒惰使得预测使用状态的程序会发生什么变得更加困难。因此，流行的懒惰语言没有状态，或者有非常受控的形式。（这不是坏事！状态应该只以非常受控的方式使用，例如，Haskell有非常有趣的设计来帮助实现这一点。但程序员传统上期望无拘无束地访问状态。）
- en: 'Consider, for instance, the following pair of functions:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一对函数：
- en: '[PRE427]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-1654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'On their own, they seem harmless. However, now consider this call:'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，它们似乎是无害的。然而，现在考虑这个调用：
- en: '[PRE429]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: 'In an eager language, we know both strings would be printed right away. However,
    in a lazy language, only one will, and we cannot tell which one. To understand
    which, we can no longer treat `f`as an abstraction but instead have to peer into
    its implementation, which in turn forces us to examine the source of `g` as well.
    We would have to examine every call, and track all the strictness points along
    the way, to determine which effects will occur and when. Here is another example:'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 在急切的语言中，我们知道两个字符串都会立即打印出来。然而，在懒惰语言中，只有一个会，我们无法确定是哪一个。为了理解是哪一个，我们不能再将`f`视为抽象，而必须窥视其实现，这反过来又迫使我们检查`g`的来源。我们必须检查每个调用，并跟踪沿途的所有严格性点，以确定哪些效果会发生以及何时发生。这里还有一个例子：
- en: '[PRE430]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'Again, if we ran this eagerly, we know `n`would be set back to `0`before the
    body of `f`even begins to evaluate. In lazy evaluation, we cannot be sure what
    value `n`will have: it could be `-1`or `1`. Furthermore if, tomorrow, `g` were
    altered to be'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们急切地执行这个操作，我们知道在`f`的主体开始评估之前，`n`会被设置回`0`。在懒惰评估中，我们无法确定`n`的值：它可能是`-1`或`1`。此外，如果明天`g`被修改为
- en: '[PRE431]'
  id: totrans-1660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: then `n`remains `0`—but we can’t know without examining its code!
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`n`仍然是`0`——但我们必须检查其代码才能知道！
- en: 'A natural reaction to reading these programs might be, “Don’t do that!” That
    is in fact an entirely legitimate reaction. The problem is not laziness: it’s
    the interaction between laziness and state. As we deprecate the use of unfettered
    state in programming, that increases the potential for laziness. Still, there
    are other situations—like errors—that we cannot avoid, and that can stay latent
    under lazy evaluation.'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这些程序的自然反应可能是，“不要这样做！”这实际上是一个完全合理的反应。问题不在于懒惰：它是懒惰与状态之间的相互作用。随着我们废弃在编程中使用无拘无束的状态，这增加了懒惰的潜力。然而，还有其他我们无法避免的情况——比如错误——它们可以在懒惰评估下保持潜伏。
- en: Caching Results
  id: totrans-1663
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存结果
- en: 'If we use lazy programming without side effects, we get a nice benefit: each
    expression always produces the same result. In that case, we don’t ever have to
    recompute an expression; we can just store its result and reuse it on subsequent
    accesses. That is, we can cache the result, enabling us to trade space for time.'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用无副作用的懒惰编程，我们会得到一个很好的好处：每个表达式总是产生相同的结果。在这种情况下，我们永远不需要重新计算一个表达式；我们只需存储其结果并在后续访问中重用它。也就是说，我们可以缓存结果，从而以空间换取时间。
- en: 'Aside: If you are not familiar with trading space for time in computation—as
    found in techniques such as memoization and dynamic programming—see DCIC: [https://dcic-world.org/2022-08-28/part_advtopics.html#%28part._avoid-recomp%29](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/part_advtopics.html%23%2528part._avoid-recomp%2529&sa=D&source=editors&ust=1695232021588822&usg=AOvVaw1pcTCRspVLqsEkkFNFbtyj)'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：如果你不熟悉在计算中交换空间和时间——如记忆化和动态规划等技术中找到的——请参阅DCIC：[https://dcic-world.org/2022-08-28/part_advtopics.html#%28part._avoid-recomp%29](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/part_advtopics.html%23%2528part._avoid-recomp%2529&sa=D&source=editors&ust=1695232021588822&usg=AOvVaw1pcTCRspVLqsEkkFNFbtyj)
- en: There are, however, two kinds of result caching one can perform.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种结果缓存方式可以执行。
- en: One is what happens in Lazy Racket, where each expression’s result is cached
    locally. This means that if the same source location is evaluated multiple times,
    the cached value can be reused. Other implementation strategies can look for the
    same expression even in a dynamic setting (as happens, for instance, in a Fibonacci
    function, which dynamically generates sub-problems). This requires a rather different
    implementation approach, but can yield even bigger time-space trade-offs.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 一个是 Lazy Racket 中的情况，其中每个表达式的结果都本地缓存。这意味着如果相同的源位置被多次评估，缓存的值可以被重用。其他实现策略甚至可以在动态环境中寻找相同的表达式（例如，在斐波那契函数中，它动态生成子问题）。这需要相当不同的实现方法，但可以产生更大的时间-空间权衡。
- en: Space Consumption
  id: totrans-1668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间消耗
- en: The ability to automatically memoize computation seems to show even more benefit
    to making lazy evaluation a default. Why not do it?
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 自动记忆化计算的能力似乎使惰性求值成为默认选项带来更多的好处。为什么不这样做呢？
- en: 'One problem is that lazy evaluation can often take up significant amounts of
    space, beyond the space consumed by memoization. To understand this, consider
    this squaring function:'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是，惰性求值往往需要占用大量的空间，这超出了记忆化消耗的空间。为了理解这一点，考虑这个平方函数：
- en: '[PRE432]'
  id: totrans-1671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: Because we are evaluating lazily, `x`is bound to an expression represented as
    a closure. Now suppose our program looks like
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们是惰性求值，`x` 被绑定到一个表示为闭包的表达式。现在假设我们的程序看起来像
- en: '[PRE433]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: and beyond this we make no further reference to `v`. In an eager language, we
    would extract the second element of `v`and can reclaim all the remaining storage.
    But in a lazy language, the entire vector needs to stay alive until the last use
    of the closure that refers to it. Seemingly straightforward programs that have
    an intuitive space model in an eager language can have much more subtle and complicated
    space models in lazy programming. Observe that the issue above has nothing to
    do with memoization; it’s inherent in laziness.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们不再对 `v` 进行进一步引用。在一个急切的语言中，我们会提取 `v` 的第二个元素，并且可以回收所有剩余的存储。但在一个惰性语言中，整个向量需要保持活跃，直到引用它的闭包的最后一次使用。看似简单的程序，在急切语言中有一个直观的空间模型，但在惰性编程中可能具有更加微妙和复杂的空间模型。注意，上述问题与记忆化无关；它是惰性固有的。
- en: Laziness in Eagerness
  id: totrans-1675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰中的渴望
- en: As a result of these issues, laziness has not gained popularity as a default
    option. At the same time, it is very useful in some settings. As we have seen
    above, we can always simulatelaziness by using thunks. This can, however, be syntactically
    unwieldy, so some languages provide syntactic support for it. In languages like
    Racket, for instance, `delay`is a syntactic form that thunks its expression, and
    `force` is a function that evaluates it (caching the result).
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，惰性并没有像默认选项那样获得普及。同时，它在某些设置中非常有用。正如我们上面所看到的，我们总是可以通过使用 thunks 来模拟惰性。然而，这可能在语法上难以处理，因此一些语言提供了对它的语法支持。例如，在
    Racket 这样的语言中，`delay` 是一个将表达式 thunks 的语法形式，而 `force` 是一个评估它（缓存结果）的函数。
- en: Control on the Web
  id: totrans-1677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络控制
- en: Server-Side Programming
  id: totrans-1678
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端编程
- en: 'Consider a program like this:'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个像这样的程序：
- en: print(read("First number") + read("Second number"))
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: print(read("First number") + read("Second number"))
- en: 'Imagine we were to run this program on a traditional command-line operating
    system. What happens when we call `read`? The operating system’s synchronousinput-reading
    commands are invoked: synchronous meaning that the program suspends its execution—that
    is, the stack stays intact—waiting for the user to respond (if ever they do),
    and when they do, the program’s stack resumes, with the value typed in by the
    user becoming the value returned by `read`.'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们在一个传统的命令行操作系统中运行这个程序。当我们调用 `read` 时会发生什么？操作系统会调用其同步输入读取命令：同步意味着程序会暂停其执行——也就是说，栈保持完整——等待用户响应（如果他们确实这样做），当用户这样做时，程序的栈会恢复，用户输入的值成为
    `read` 返回的值。
- en: 'This seems so straightforward that we might never think twice about how remarkable
    this ability is. To understand that, we should try to run this program on the
    Web. When we do, we run headlong into a central problem on the Web: that there
    is no such thing as a “read” operation. Why not?'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来如此简单，以至于我们可能从未想过这种能力有多么非凡。为了理解这一点，我们应该尝试在网络上运行这个程序。当我们这样做时，我们会直接遇到网络的一个核心问题：没有“读取”操作这样的东西。为什么没有？
- en: 'On the Web, a hypothetical `read`function can certainly send the prompt to
    the client. In principle, it should then wait for the client to respond with a
    value, which it returns. However, the statelessnature of the Web means that this
    can’t happen: the program has to terminate. This is an asynchronous operation.
    When the user responds (if they ever do), there is no computation waiting to go
    back to.'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web上，一个假设的`read`函数当然可以向客户端发送提示。原则上，它应该等待客户端响应一个值，然后返回它。然而，Web的无状态性质意味着这不可能发生：程序必须终止。这是一个异步操作。当用户响应（如果他们确实这样做）时，没有计算等待返回。
- en: Recording Contexts
  id: totrans-1684
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录上下文
- en: 'Therefore, a Web computation has to be arranged in a very different way. The
    programmer must manually remember the rest of the computation, and store it somewhere.
    For instance, we would break up the above program in the following way: what is
    going to be done next:'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Web计算必须以非常不同的方式安排。程序员必须手动记住剩余的计算，并将其存储在某个地方。例如，我们会将上述程序拆分成以下方式：接下来将要做什么：
- en: read("First number")
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: read("第一个数字")
- en: 'and what is waiting for the result:'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 以及等待结果的是什么：
- en: print(• + read("Second number"))
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: print(• + read("第二个数字"))
- en: '(This is, of course, our old friend, a context.) But whereas the context is
    implicit on the program’s stack, because the program must terminate, the context
    needs to be written out explicitly. Of course, • is not a program operation; rather,
    we can think of the context as a function of one argument:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: （这当然是我们的老朋友，一个上下文。）但是，尽管上下文在程序的栈中是隐式的，因为程序必须终止，上下文需要被显式地写出来。当然，•不是一个程序操作；相反，我们可以将上下文视为一个单参数的函数：
- en: 'lam(•1): print(•1 + read("Second number"))'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 'lam(•1): print(•1 + read("第二个数字"))'
- en: and this is the function that is stored in a way associated with the outgoing
    prompt. Then, when (if) the user responds, their response value is bound to •1,
    allowing the program to resume. Suppose, for instance, the user types `5`. Then
    this program effectively becomes
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是以与输出提示相关的方式存储的函数。然后，当（如果）用户响应时，他们的响应值被绑定到•1，允许程序恢复。例如，如果用户输入`5`，那么这个程序实际上变成了
- en: print(5 + read("Second number"))
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: print(5 + read("第二个数字"))
- en: This needs to also perform a Web interaction, so we again split it into what
    must happen now
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 这也需要执行Web交互，所以我们再次将其分成现在必须发生的事情
- en: read("Second number")
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: read("第二个数字")
- en: 'and what is waiting for the result:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 以及等待结果的是什么：
- en: print(5 + •)
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: print(5 + •)
- en: 'which we can represent as a function:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其表示为一个函数：
- en: 'lam(•2): print(5 + •2)'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 'lam(•2): print(5 + •2)'
- en: If and when the user resumes, this function is applied to the value they supply,
    and the result prints as we would expect.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户恢复，这个函数将应用于他们提供的值，并且结果将按预期打印。
- en: This explanation glosses over some important details. Real program evaluation,
    as we have seen, does not proceed by rewriting programs, so the second function
    is not really
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解释忽略了某些重要的细节。如我们所见，实际的程序评估并不是通过重写程序来进行的，因此第二个函数实际上
- en: 'lam(•2): print(5 + •2)'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 'lam(•2): print(5 + •2)'
- en: but rather a closure with the body
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一个具有体的闭包
- en: 'lam(•2): print(•1 + •2)'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 'lam(•2): print(•1 + •2)'
- en: closed over an environment where •1is bound to 5. Getting into these details
    is interesting from a Web architecture perspective, but for us, all we care about
    is that contexts must be saved and restored.
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个环境中终止，其中•1被绑定到5。从Web架构的角度来看，深入了解这些细节很有趣，但对我们来说，我们关心的是上下文必须被保存和恢复。
- en: Simulating in the Stacker
  id: totrans-1705
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Stacker中模拟
- en: 'We can simulate the above using the Stacker, provided we forego the input operation
    and pretend it always returns some constant:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放弃输入操作并假装它总是返回某个常数，我们可以使用Stacker来模拟上述情况：
- en: '[PRE434]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'At the point of the second call, we see that the state looks like this:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用点，我们看到状态看起来是这样的：
- en: '![](image23.png)'
  id: totrans-1711
  prefs: []
  type: TYPE_IMG
  zh: '![](image23.png)'
- en: Client-Side Termination
  id: totrans-1712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端终止
- en: 'On the client-side Web, in JavaScript, we see the same phenomenon, but for
    a completely different reason. Imagine we write a factorial computation in JavaScript:'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端Web，在JavaScript中，我们看到同样的现象，但原因完全不同。想象一下我们在JavaScript中编写一个阶乘计算：
- en: '[PRE437]'
  id: totrans-1714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'Notice that the loop checks for `n != 0`and not `n > 0`, so if we put this
    in a Web page and run it, the program will in principle run forever:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，循环检查的是`n != 0`而不是`n > 0`，所以如果我们把这个放在网页上运行，程序原则上会永远运行下去：
- en: '[PRE438]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: 'However, this creates a problem: the JavaScript virtual machine runs only one
    computation at a time, and the same JavaScript virtual machine also manages the
    page and the browser’s components. Therefore, if the program inside a page goes
    into an infinite loop, the entire page stops being responsive. For this reason,
    after a little while, the browser will pop up a window offering to kill the computation.'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这却带来了一个问题：JavaScript虚拟机一次只能运行一个计算，同一个JavaScript虚拟机还管理页面和浏览器的组件。因此，如果页面内的程序进入无限循环，整个页面将停止响应。因此，过了一会儿，浏览器会弹出一个窗口，提出要终止计算。
- en: There is a solution to this in JavaScript, but it is hardly elegant. The programmer
    creates a closure—called a callback—that represents the rest of the computation.
    The programmer then calls
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有一个解决方案，但它并不优雅。程序员创建了一个闭包——称为回调——它代表了剩余的计算。然后程序员调用
- en: '[PRE440]'
  id: totrans-1720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: or, in more modern programs,
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在更现代的程序中，
- en: '[PRE441]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: (though the former version perhaps makes a bit clearer what is happening), where
    `C`is the callback. This creates an event to run `C`as soon as possible (after
    `0` units of time). The programmer then—does this sound familiar?—terminates the
    program. This returns control to the JavaScript virtual machine. It runs any other
    pending events, then arrives at this event, which it runs immediately—i.e., it
    “calls back” into the computation using `C`. If `C` was constructed correctly,
    then this properly resumes the computation, as if it had never halted. Phew!
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: （尽管前一个版本可能使发生的事情更加清晰），其中`C`是回调。这创建了一个事件，以便在`0`个时间单位后尽快运行`C`。然后程序员——这听起来熟悉吗？——终止程序。这返回控制权给JavaScript虚拟机。它运行任何其他挂起的任务，然后到达这个事件，并立即运行它——即，它使用`C`“回调”到计算中。如果`C`构建正确，那么计算将正确恢复，就像它从未停止过一样。呼！
- en: Abstracting the Problem
  id: totrans-1724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象问题
- en: 'Thus, we have the same problem on both the server and client sides of the Web.
    The reasons are very different, but the net effect is the same: the programmer
    has to manually keep track of information that needs to persist, store it somewhere,
    halt the computation to return control to whatever called it and, when resumed,
    fetch information back from storage; all this code must run exactly as if an interruption
    had never occurred.'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Web的服务器和客户端都存在同样的问题。原因非常不同，但最终效果是相同的：程序员必须手动跟踪需要持久化的信息，将其存储在某个地方，停止计算以返回控制权给调用者，并在恢复时从存储中检索信息；所有这些代码必须像从未发生中断一样精确运行。
- en: This programming quandary is not new. Back in the early days of computing, programmers
    had to manually keep track of where in memory values resided; then we got compilers
    that did this for us. Then we had to manually keep track of allocation on the
    heap to later reclaim it; then we got garbage collectors to do this for us. The
    history of programming languages is full of tasks that programmers did manually
    until we learned to create language constructs and compilers that could do these
    automatically. It would be nice if we could do the same here to reduce the burden
    of writing such programs.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程难题并不新鲜。在计算机的早期，程序员必须手动跟踪值在内存中的位置；然后我们得到了为我们做这件事的编译器。然后我们必须手动跟踪堆上的分配，以便稍后回收它；然后我们得到了垃圾收集器来为我们做这件事。编程语言的历史充满了程序员手动执行的任务，直到我们学会了创建能够自动执行这些任务的编程语言构造和编译器。如果我们能在这里做同样的事情来减轻编写此类程序的负担那就太好了。
- en: To study these phenomena better, it would be helpful if we could abstract away
    from the details of servers, clients, JavaScript, Web pages, timeouts, and so
    on, and examine the phenomenon in its essence.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地研究这些现象，如果我们能从服务器、客户端、JavaScript、Web页面、超时等细节中抽象出来，并考察其本质，那将是有帮助的。
- en: Using Closures
  id: totrans-1728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用闭包
- en: 'We can simulate the solution by assuming a new primitive, `get-number/k`. Instead
    of taking one argument, the prompt string, it also takes a second argument. This
    second argument is a closure that represents the restof the computation—i.e.,
    it’s the stack represented as a closure. This function binds that closure to a
    variable, `resume`, and then…does nothing:'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过假设一个新的原始操作`get-number/k`来模拟这个解决方案。这个操作不仅接受一个参数，即提示字符串，还接受第二个参数。这个第二个参数是一个闭包，它代表了剩余的计算——即，它是作为闭包表示的栈。这个函数将这个闭包绑定到一个变量`resume`上，然后……什么也不做：
- en: '[PRE442]'
  id: totrans-1730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'Recall that we want the program to invoke this function and then halt; all
    remaining computation—the context—needs to be in the second parameter given to
    `get-number/k`. Thus, our program now looks like this:'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们希望程序调用这个函数然后停止；所有剩余的计算——上下文——需要作为`get-number/k`的第二个参数给出。因此，我们的程序现在看起来像这样：
- en: '[PRE444]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'Terminology: The second argument—embodying the entire rest of the computation—is
    called the continuation, and it’s traditional to use the letter `k` for it.'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：第二个参数——体现整个剩余计算的是延续，传统上用字母`k`表示它。
- en: 'Terminology: The program structure above has been turned inside-out: instead
    of the first operation being innermost and last operation outermost, the first
    one is outermost and the last one is innermost. This unwieldy program structure
    has a name: inversion of control. Instead of the client calling the helper function
    whose values it wants (in this case, `get-number`), the helper function (in this
    case `get-number/k`) calls the client. This leads to an unnatural, unwieldy, and
    error-prone programming style.'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 术语：上面的程序结构已经被翻转：不是第一个操作是最内层的，最后一个操作是最外层的，而是第一个操作是最外层的，最后一个操作是最内层的。这种难以驾驭的程序结构有一个名字：控制反转。不是客户端调用它想要的辅助函数（在这种情况下，`get-number`），而是辅助函数（在这种情况下，`get-number/k`）调用客户端。这导致了一种不自然、难以驾驭且容易出错的编程风格。
- en: 'Sure enough, when we run this program, it just…halts with no output. It is
    instructive to look at the state of the program when it ends:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，当我们运行这个程序时，它只是……停止，没有输出。当程序结束时查看程序的状态是有教育意义的：
- en: '![](image5.png)'
  id: totrans-1737
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](image5.png)'
- en: 'Notice that `resume` is bound to a function that is awaiting a number. If we
    invoke it:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`resume`绑定到一个等待数字的函数。如果我们调用它：
- en: '[PRE445]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'then our state (unfortunately, we had to re-run the program) becomes:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们的状态（不幸的是，我们不得不重新运行程序）变为：
- en: '![](image15.png)'
  id: totrans-1741
  prefs: []
  type: TYPE_IMG
  zh: '![图片15](image15.png)'
- en: 'Observe that resume is now bound to a closure whose environment remembers the
    value of `•1`. If we now resume again:'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`resume`现在绑定到一个闭包，其环境记得`•1`的值。如果我们现在再次恢复：
- en: '[PRE446]'
  id: totrans-1743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: 'the “program” halts naturally, with an output of `12`! (We use quotes around
    “program” because we have really fragmented our simple program into three: one
    that gets the prompts for the first input, one that remembers that value and prompts
    for the second, and the third that sums those two values.)'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: “程序”自然停止，输出为`12`！（我们在“程序”周围使用引号，因为我们实际上已经将简单的程序分解成了三个：一个获取第一个输入的提示，一个记住这个值并提示第二个输入，第三个将这两个值相加。）
- en: Using Racket
  id: totrans-1745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Racket
- en: It turns out that Racket also has tools for manipulating continuations.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Racket 也提供了操作延续的工具。
- en: 'Imagine we have two tabs in DrRacket. In the first (let’s suppose we save it
    as `"yielder.rkt"`) we have the following mysterious program:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们在 DrRacket 中有两个标签页。在第一个（让我们假设我们将其保存为`"yielder.rkt"`）中，我们有以下神秘的程序：
- en: '[PRE447]'
  id: totrans-1748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-1749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-1750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-1751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'The operation `let/cc`binds the named variable (here, `k`) to a continuation
    value: it turns the current stack into a value that can be treated as a function.'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: '`let/cc`操作将命名变量（在这里，`k`）绑定到一个延续值：它将当前栈转换成一个可以被视为函数的值。'
- en: 'In another tab, we will write a simple program that pretends to be our long-running
    computation: a factorial function. We can run this directly in Racket, of course.
    But `fact`could run for a very long time, depending on the input; so following
    the rules of JavaScript, we want it to halt periodically, let’s say every time
    `n`is divisible by `5` (i.e., roughly every five iterations). That is, we would
    like to run:'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个标签页中，我们将编写一个简单的程序，模拟我们的长时间运行的计算：一个阶乘函数。当然，我们可以在 Racket 中直接运行这个程序。但是`fact`可能需要非常长的时间才能运行完成，这取决于输入；所以按照
    JavaScript 的规则，我们希望它每隔一段时间就停止，比如说每次`n`能被`5`整除时（即大约每五次迭代）。也就是说，我们希望运行：
- en: '[PRE452]'
  id: totrans-1755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-1756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-1757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'where `(yield)`makes it pause in a way that, when we run `(resume)`, the computation
    will pick up exactly where it left off. Indeed, we see the following outcome:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`(yield)`使其暂停，当我们运行`(resume)`时，计算将正好从上次停止的地方继续。确实，我们看到以下结果：
- en: '[PRE455]'
  id: totrans-1759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: The first time it yields is when `n`is `5`. Yielding, in this case, means terminating the
    computation using the Racket exception mechanism. Resuming somehow causes computation
    to continue and run to completion but, remarkably, it produces the exact same
    answer as if computation had never halted at all!
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次产生`yield`是在`n`为`5`时。在这种情况下，`yield`意味着使用 Racket 异常机制终止计算。恢复以某种方式导致计算继续并运行到完成，但令人惊讶的是，它产生了与计算从未停止过完全相同的答案！
- en: 'Observe that thanks to the use of `let/cc`, we have been able to invert the
    inverted control, i.e., write the program in what is called direct style. The
    language has taken care of storing and restoring the computation without the user
    program having to do it manually. Thus, continuations are useful tools for inverting
    inverted control. We will also see another language mechanism that does this:
    [Non-SMoL: Reactivity](https://www.google.com/url?q=https://docs.google.com/document/d/1ECyFV88K-jU-i0qHLfUNjbIYthChzpcjZ0eiostD3d8/edit%23&sa=D&source=editors&ust=1695232021608622&usg=AOvVaw1WfaeEjiDupGmDBj0AuHdK).'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，多亏了`let/cc`的使用，我们能够反转反转控制，即以所谓的直接风格编写程序。语言已经负责存储和恢复计算，而无需用户程序手动完成。因此，延续是反转反转控制的有用工具。我们还将看到另一种实现这一点的语言机制：[Non-SMoL:
    Reactivity](https://www.google.com/url?q=https://docs.google.com/document/d/1ECyFV88K-jU-i0qHLfUNjbIYthChzpcjZ0eiostD3d8/edit%23&sa=D&source=editors&ust=1695232021608622&usg=AOvVaw1WfaeEjiDupGmDBj0AuHdK)。'
- en: Yielding on a Web Server
  id: totrans-1762
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Web服务器上产生
- en: 'The Racket Web server has a special primitive that does just this for the Web.
    We’ll build it up in stages. First, we’ll use a special Racket language, designed
    to make it easier to write server-side Web programs:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: Racket Web服务器有一个特殊的原语，专门为网络做这件事。我们将分阶段构建它。首先，我们将使用一种特殊的Racket语言，旨在使编写服务器端Web程序更容易：
- en: '[PRE456]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: 'Programs in this language must have a “main” function, called `start`, which
    is given an initial request (whatever information is provided when we first run
    the computation). This function is then written assuming a convenient fiction:
    the existence of a function `get-number`that will print a prompt, send out a Web
    page, wait for its response, extract the value entered, and return it as a number:'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言中的程序必须有一个“主”函数，称为`start`，它接受一个初始请求（当我们首次运行计算时提供的任何信息）。然后，这个函数被编写，假设了一个方便的虚构：存在一个名为`get-number`的函数，它将打印提示，发送网页，等待响应，提取输入的值，并将其作为数字返回：
- en: '[PRE457]'
  id: totrans-1766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '`(let ([result` (+ (get-number "first") (get-number "second"))`])`'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([result` (+ (get-number "first") (get-number "second"))`])`'
- en: '[PRE458]'
  id: totrans-1768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: 'If we can make this fiction reality, then we can write a program like the above:
    it calls `get-number` in a “deep” context, twice, adds the results, and then converts
    the result into a string to embed it into a Web page.'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能将这个虚构变成现实，那么我们可以编写一个像上面那样的程序：它在“深层”上下文中调用`get-number`两次，然后将结果相加，最后将结果转换为字符串以嵌入到网页中。
- en: The question, of course, is how such a function can exist. First, we have to
    discuss some Web mechanics. When we create a Web form, it needs a field called
    the `action`, which holds a URL. When the user submits the form, the browser bundles
    up the information entered into the fields of the form and sends them—effectively,
    as a set of key-value pairs—to the URL, i.e., to the server, requesting it to
    run the program at that URL and provide the key-value pairs to that program.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题是这样一个函数如何存在。首先，我们必须讨论一些网络机制。当我们创建一个Web表单时，它需要一个名为`action`的字段，该字段包含一个URL。当用户提交表单时，浏览器将表单字段中输入的信息捆绑起来，并将它们——实际上，作为一组键值对——发送到URL，即服务器，请求在该URL运行程序，并将键值对提供给该程序。
- en: Therefore, we can see that we’ve turned the problem of suspending the program’s
    execution into one of being able to fill in this URL with something meaningful.
    If the URL can somehow correspond to the stack, then perhaps the stack (and hence
    the computation) can be restored, and can be provided with these key-value pairs,
    from which the program can extract the required information.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，我们已经将程序执行挂起的难题转化为能够用有意义的内容填充这个URL的问题。如果URL能够以某种方式与堆栈相对应，那么堆栈（以及计算）可能被恢复，并且可以提供这些键值对，程序可以从这些键值对中提取所需的信息。
- en: 'The “secret sauce” that the Racket Web server provides is a primitive called
    `send/suspend`. It does the following:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: Racket Web服务器提供的“秘密配方”是一个名为`send/suspend`的原语。它执行以下操作：
- en: It takes a single-argument function as a parameter.
  id: totrans-1773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受一个单参数函数作为参数。
- en: It records the current stack as a value.
  id: totrans-1774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将当前的堆栈记录为一个值。
- en: It stores this stack in a hash-table, associated with a unique, unguessable
    string.
  id: totrans-1775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将这个堆栈存储在一个与唯一、不可猜测的字符串关联的哈希表中。
- en: It turns this string into a URL.
  id: totrans-1776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将这个字符串转换为一个URL。
- en: It then calls the given function with this URL string.
  id: totrans-1777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它使用这个URL字符串调用给定的函数。
- en: The resulting function can then use this URL string as the `action` field of
    the form.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的函数可以使用这个URL字符串作为表单的`action`字段。
- en: Aside: This is not the only way to use it. The URL could also, for instance,
    be sent in an email message. This is a handy way to validate email addresses.
    Because the URL is unique and unguessable, the only way for someone to resume
    the computation would be to receive that URL, i.e., to have access to the email
    address. Thus, resuming the computation can be thought of as having validated
    the email address (assuming, of course, that an intruder is not reading emails
    and clicking on validation links that the email’s owner would not have clicked
    on).
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：这并不是使用它的唯一方式。URL也可以通过电子邮件消息发送，例如。这是一种验证电子邮件地址的好方法。因为URL是唯一的且不可猜测的，某人要继续计算的唯一方法就是收到那个URL，即获得对电子邮件地址的访问。因此，继续计算可以被视为验证了电子邮件地址（当然，假设入侵者没有阅读电子邮件并点击电子邮件所有者不会点击的验证链接）。
- en: 'So here is an actual working implementation of get-number:'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是get-number的一个实际工作实现。
- en: '[PRE459]'
  id: totrans-1781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: (response/xexpr
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: (response/xexpr
- en: '`(html (head (title ,title))'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: '`(html (head (title ,title))'
- en: (body
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: (body
- en: (form ([action ,k-url])
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: (form ([action ,k-url])
- en: ',title ": "'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: ',title ": "'
- en: (input ([name "number"]))
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: (input ([name "number"]))
- en: (input ([type "submit"])))))`))))`
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: (input ([type "submit"])))))`))))`
- en: '[PRE460]'
  id: totrans-1789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: (extract-binding/single 'number
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: (extract-binding/single 'number
- en: (request-bindings req))`))`
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: (request-bindings req))`))`
- en: Observe that most of this function is just HTMLand APIbookkeeping. We have to
    construct the Web page with the relevant components. When (if) the computation
    resumes, it returns with the key-value pairs sent from the form. These are bound
    to `req`. From there, it’s a simple matter of extracting the right value using
    the APIs.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数的大部分只是HTML和API簿记。我们必须构建包含相关组件的Web页面。当（如果）计算继续时，它返回从表单发送的关键值对。这些绑定到`req`。从那里，使用API提取正确的值就很简单了。
- en: And that’s it! That gives us a full, working program.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这给了我们一个完整、工作的程序。
- en: Interaction with State
  id: totrans-1794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与状态的交互
- en: Now let’s think about how all this interacts with state. Let’s write a simple
    Web program that simply counts how many times we submitted a form.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来思考一下这一切是如何与状态交互的。让我们编写一个简单的Web程序，该程序简单地计算我们提交表单的次数。
- en: 'One natural way to write it is as follows. We’ll have a mutable variable, `count`,
    that keeps the count. We’ll have a page that shows the current count and provides
    the user a button. When they click it, computation resumes; the resumed computation
    increments the count, and loops:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 一种自然的方式是如下所示。我们将有一个可变变量`count`来保持计数。我们将有一个页面显示当前计数并提供用户一个按钮。当他们点击它时，计算继续；继续的计算增加计数，并循环：
- en: '[PRE461]'
  id: totrans-1797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-1798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-1799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: We’ll call it the stateful counter.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为状态计数器。
- en: This works as you might expect.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如你预期的那样工作。
- en: 'But now let’s think about a different way to write this same program. Instead
    of using a global mutable variable, we could instead keep the count as a local
    variable and functionally update it:'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在让我们考虑另一种编写相同程序的方法。我们不是使用全局可变变量，而是将计数作为一个局部变量并以函数方式更新它：
- en: '[PRE465]'
  id: totrans-1804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-1805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-1807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: We’ll call this the functional counter.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为函数计数器。
- en: This, too, works as you would expect. And it works the same as the previous
    program. And yet, somehow, these programs seem to be different. Are they in fact
    exactly the same?
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 这也正如你预期的那样工作。它和之前的程序工作方式相同。然而，不知何故，这些程序似乎有所不同。它们实际上是否完全相同？
- en: They’re not!
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不是！
- en: 'Exercise: Map out the stacks, environments, and stores to simulate how these
    programs would run.'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：绘制堆栈、环境和存储，以模拟这些程序将如何运行。
- en: Web Interactions
  id: totrans-1812
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web交互
- en: In conventional, desktop software, concurrency is an artifact of the program.
    If the program is not concurrent, we can’t really force it to behave concurrently.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的桌面软件中，并发性是程序的一个特性。如果程序不是并发的，我们实际上无法强迫它并发地表现。
- en: Not so on the Web. There, we can copy URLs, duplicate them, and replay them.
    Therefore, the same program state can be invoked multiple times, returned to,
    and so on.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Web上并非如此。在那里，我们可以复制URL，复制它们，并重新播放它们。因此，相同的程序状态可以被多次调用、返回等等。
- en: 'Consider the following sequence of interactions on the Web:'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在Web上的交互序列：
- en: A user visits a travel Web site.
  id: totrans-1816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问了一个旅行网站。
- en: They enter a city and search for hotels.
  id: totrans-1817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们输入一个城市并搜索酒店。
- en: They are given a list of hotels, L.
  id: totrans-1818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们得到了一个酒店列表，L。
- en: They click on one of the hotels, say L1.
  id: totrans-1819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们点击了其中一家酒店，比如说L1。
- en: This takes them to a page for L1.
  id: totrans-1820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将他们带到L1的页面。
- en: They click the reservation link.
  id: totrans-1821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们点击了预订链接。
- en: They obtain a reservation at L1\. All this seems perfectly normal.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 他们成功在L1处获得了一个预订。所有这一切看起来都很正常。
- en: 'Now suppose instead they do the following:'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设他们做了以下操作：
- en: A user visits a travel Web site.
  id: totrans-1824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问一个旅行网站。
- en: They enter a city and search for hotels.
  id: totrans-1825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们进入一个城市并寻找酒店。
- en: They are given a list of hotels, L.
  id: totrans-1826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们得到了一个酒店列表，L。
- en: They click on one of the hotels, say L1, in a new tab.
  id: totrans-1827
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们在一个新的标签页上点击一个酒店，比如L1。
- en: They click on another of the hotels, say L2, in another new tab.
  id: totrans-1828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们点击另一个酒店，比如L2，在另一个新的标签页上。
- en: They go back to L1’s tab.
  id: totrans-1829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们回到L1的标签页。
- en: They click the reservation link.
  id: totrans-1830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们点击预订链接。
- en: 'Think about these two questions:'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这两个问题：
- en: 'At which hotel would you like the reservation to be made: L1 or L2?'
  id: totrans-1832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想在哪个酒店预订：L1还是L2？
- en: 'Where do you expect the site to make the reservation: L1 or L2?'
  id: totrans-1833
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您预计网站会在哪里进行预订：L1还是L2？
- en: 'Naturally, we would expect the reservation at L1, because we clicked on the
    reservation link from L1’s page. But on many Web sites, you used to get a reservation
    at L2, not L1. This suggests that there is some interaction between the two tabs:
    specifically, there seems to be mutable state, the “current hotel”, that is shared
    between the two tabs. Opening a hotel’s page sets this. Thus, this is initially
    set to L1; the new tab for L2 sets it to L2; when we return to L1’s tab and make
    a reservation, this act reads the mutable state, which makes the reservation at
    the “current hotel”, namely L2.'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们预期L1的预订，因为我们从L1的页面上点击了预订链接。但在许多网站上，你过去会在L2而不是L1处获得预订。这表明两个标签页之间存在某种交互：具体来说，似乎存在可变状态，即“当前酒店”，在两个标签页之间共享。打开酒店的页面会设置这个状态。因此，这个状态最初设置为L1；L2的新标签页将其设置为L2；当我们返回到L1的标签页并预订时，这个行为读取可变状态，从而在“当前酒店”即L2处进行预订。
- en: Returning to the Counters
  id: totrans-1835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回到计数器
- en: Now let’s return to the two counters, armed with the ideas from the interactions
    above.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们带着上面交互中的想法回到两个计数器。
- en: Run the stateful counter program and submit, say, 3 times. After that, the page
    will list the count as 3, and the URL will look something like
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 运行有状态的计数器程序并提交，比如3次。之后，页面将列出计数为3，URL看起来像
- en: http://localhost:51264/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2097639995)%22))?
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: http://localhost:51264/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2097639995)%22))?
- en: 'Now copy this URL, create a newtab, paste it, and enter. This runs the computation
    associated with this URL. Perhaps surprisingly, this shows the count as 4\. Now
    go back to the previous tab and submit the form. That tab now shows a count not
    of 4 but of 5\. Return to the second tab and submit; it now shows 6\. The stacks
    help us see why: every return mutates the same `counter` variable.'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 现在复制这个URL，创建一个新标签页，粘贴并输入。这将运行与此URL相关的计算。也许令人惊讶的是，这显示了计数为4。现在回到上一个标签页并提交表单。这个标签页现在显示的计数不是4，而是5。回到第二个标签页并提交；它现在显示6。堆栈帮助我们理解原因：每次返回都会修改相同的`counter`变量。
- en: Now repeat the same process with the functional counter. After 3 submissions,
    we get a URL like
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用功能计数器重复相同的流程。提交3次后，我们得到一个类似的URL
- en: http://localhost:51379/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2028533532)%22))?
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: http://localhost:51379/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2028533532)%22))?
- en: which seems very similar. Now copy this URL into a new tab, and repeat the interactions
    above.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此URL复制到一个新的标签页，并重复上述交互。
- en: What we see is very different. Each tab has its own local “memory”, much as
    we expected of the pages on the travel Web site. The continuation does not mutate
    a single shared variable, but rather makes a new call to loop, which creates a
    new binding that is distinct from previous bindings. Each time we submit we make
    another call, which makes another stack frame and its corresponding environment
    frame, which are distinct.
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的情况非常不同。每个标签页都有自己的本地“内存”，就像我们预期的那样，旅行网站上的页面也是如此。延续不会修改单个共享变量，而是对循环进行新的调用，这创建了一个与先前绑定不同的新绑定。每次我们提交时，我们都会进行另一个调用，这会创建另一个堆栈帧及其对应的环境帧，它们是不同的。
- en: 'This distinction between creating a single, shared, mutable variable and creating
    distinct variables that each have their own immutable value should be familiar:
    it’s the exact same problem that we saw in the Loops assignment [[https://cs.brown.edu/courses/cs173/2022/loops.html](https://www.google.com/url?q=https://cs.brown.edu/courses/cs173/2022/loops.html&sa=D&source=editors&ust=1695232021622985&usg=AOvVaw0xjaprMcAAUZTQQEvCfWVs)].'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在创建单个、共享、可变变量和创建具有各自不可变值的独立变量之间的区别应该是熟悉的：这正是我们在循环作业中看到的问题[[https://cs.brown.edu/courses/cs173/2022/loops.html](https://www.google.com/url?q=https://cs.brown.edu/courses/cs173/2022/loops.html&sa=D&source=editors&ust=1695232021622985&usg=AOvVaw0xjaprMcAAUZTQQEvCfWVs)]。
- en: Mapping between Web and Programming Language Features
  id: totrans-1845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web和编程语言特性之间的映射
- en: Interestingly, there is a deep connection between features of Web programs and
    ideas from programming languages. On the Web, we have
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Web程序的特征与编程语言的思想之间存在着深刻的联系。在Web上，我们有
- en: '|  | Server-side | Client-side |'
  id: totrans-1847
  prefs: []
  type: TYPE_TB
  zh: '|  | 服务器端 | 客户端 |'
- en: '| Mutable | Database (page-independent) | Cookie (page-independent) |'
  id: totrans-1848
  prefs: []
  type: TYPE_TB
  zh: '| 可变 | 数据库（页面无关） | Cookie（页面无关） |'
- en: '| Immutable |  | Hidden field (page-specific) |'
  id: totrans-1849
  prefs: []
  type: TYPE_TB
  zh: '| 不可变 |  | 隐藏字段（页面特定） |'
- en: Observe that when we have a single mutable entry, the net result will be that
    all pages that share it will end up seeing the effects of each other. Therefore,
    the bad travel Web site pattern is inherent in this style of programming. Unfortunately,
    Web APIs make cookies very easy to use, leading to programs following this bad
    pattern. In contrast, when we have immutable data that is specific to the page
    (the field is on the page…it’s just hidden), then each page keeps its own information
    separate from all the other pages. Notice also that hidden fields are key-value
    mappings. Therefore, a collection of hidden fields is an environment. Since a
    page also has a reference to code to run, a page with hidden fields is effectively
    a closure! In contrast, a page with shared mutable state is using the store(or
    heap). The Racket Web server simply makes these implicit ideas explicit.
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们有一个单个可变条目时，最终的结果将是所有共享它的页面最终都会看到彼此的效果。因此，糟糕的旅行网站模式是这种编程风格固有的。不幸的是，Web
    API使Cookie的使用变得非常容易，导致程序遵循这种糟糕的模式。相比之下，当我们有特定于页面的不可变数据（字段在页面上……它只是隐藏的）时，每个页面都保持其信息与其他所有页面分离。还要注意，隐藏字段是键值映射。因此，隐藏字段的集合是一个环境。由于页面还有一个运行代码的引用，带有隐藏字段的页面实际上是一个闭包！相比之下，带有共享可变状态的页面正在使用存储（或堆）。Racket
    Web服务器只是将这些隐含的想法明确化。
- en: Readings
  id: totrans-1851
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读书籍
- en: 'The work in this chapter is elaborated in several papers:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的工作在几篇论文中进行了阐述：
- en: '[Automatically Restructuring Programs for the Web](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/&sa=D&source=editors&ust=1695232021626503&usg=AOvVaw0dteFuRcMEar0kOBZ7ejqS)'
  id: totrans-1853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自动重构Web程序](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/&sa=D&source=editors&ust=1695232021626503&usg=AOvVaw0dteFuRcMEar0kOBZ7ejqS)'
- en: '[Modeling Web Interactions and Errors](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/&sa=D&source=editors&ust=1695232021627009&usg=AOvVaw0OKynkecNBanIitj-dtIoI)'
  id: totrans-1854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[建模Web交互和错误](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/&sa=D&source=editors&ust=1695232021627009&usg=AOvVaw0OKynkecNBanIitj-dtIoI)'
- en: '[Implementation and Use of the PLT Scheme Web Server](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/&sa=D&source=editors&ust=1695232021627310&usg=AOvVaw2VVyDnhdzHGBVmpsp7j3xb)'
  id: totrans-1855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PLT Scheme Web服务器的实现和使用](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/&sa=D&source=editors&ust=1695232021627310&usg=AOvVaw2VVyDnhdzHGBVmpsp7j3xb)'
- en: '[Putting in All the Stops: Execution Control for JavaScript](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/bnpkg-stopify/&sa=D&source=editors&ust=1695232021627644&usg=AOvVaw0ZxiewB1AmM3Se5hWPXBGb)'
  id: totrans-1856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[全速前进：JavaScript的执行控制](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/bnpkg-stopify/&sa=D&source=editors&ust=1695232021627644&usg=AOvVaw0ZxiewB1AmM3Se5hWPXBGb)'
- en: Reactivity
  id: totrans-1857
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应性
- en: 'We learned early on that SMoL languages evaluate formal arguments at a function
    call. We then saw laziness as a contrast to this: an argument is evaluated zero times
    at the call, and is maybe only evaluated later. (Of course, if the result is not
    cached, it may be evaluated many times.)'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很早就了解到SMoL语言在函数调用时评估形式参数。然后我们看到了惰性作为这种对比：参数在调用时评估零次，可能只在之后评估。（当然，如果结果没有缓存，它可能被评估多次。）
- en: 'Now we will see another contrast to SMoL, focusing this time on the function
    call itself: where what syntactically looks like a single function call can actually
    be numerous, even an unbounded number.'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到SMoL的另一个对比，这次聚焦于函数调用本身：在语法上看似单个函数调用实际上可能是多个，甚至是无界的数量。
- en: GUIs through Callbacks
  id: totrans-1860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过回调实现GUI
- en: 'To do so, it helps to remind ourselves of the evaluation model in most graphical
    applications, these days embodied by JavaScript. Suppose we want to make a Web
    page with a timer that counts up every second, and whose value resets when we
    click on a Reset button:'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们不妨提醒自己大多数图形应用程序中的评估模型，如今由JavaScript体现。假设我们想要制作一个带有计时器的网页，该计时器每秒增加一次，并且当我们点击重置按钮时其值会重置：
- en: '![](image24.png)'
  id: totrans-1862
  prefs: []
  type: TYPE_IMG
  zh: '![](image24.png)'
- en: 'One version of the JavaScript code would look as follows:'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码的一个版本可能如下所示：
- en: '[PRE469]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-1865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-1866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'There are three parts to the logic here:'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑有三个部分：
- en: Updating the elapsed time every second.
  id: totrans-1868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每秒更新已过时间。
- en: Resetting the timer on a button-press.
  id: totrans-1869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮按下时重置计时器。
- en: Initiating the computation.
  id: totrans-1870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动计算。
- en: 'These are accomplished as follows:'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是通过以下方式实现的：
- en: When loaded, the Web page invokes `startTimer`.
  id: totrans-1872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当加载时，网页会调用`startTimer`。
- en: We use `elapsedTime`to record how much time has elapsed, and create a timer,
    referenced by `timerID`. This installs a timer (and records a reference to it
    in case we need it later, which we don’t in this program) that runs every second
    (1000 milliseconds). Whenever the timer goes off, it invokes the function `doEverySecond`.
    That function increments the elapsed time, and writes the current value into the
    Web page.
  id: totrans-1873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`elapsedTime`来记录已经过去的时间，并创建一个计时器，通过`timerID`引用。这安装了一个每秒运行（1000毫秒）的计时器（并且记录了一个引用，以防我们以后需要它，但在这个程序中我们不需要）。每当计时器响起时，它就会调用函数`doEverySecond`。该函数增加已过时间，并将当前值写入网页。
- en: Finally, the reset button has `resetElapsed`as its callback. This resets the
    value of `elapsedTime`, whose updated value is then shown the next time the display
    is updated. (In principle, we might want to update the display in this callback
    too.)
  id: totrans-1874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重置按钮的回调是`resetElapsed`。这会重置`elapsedTime`的值，而其更新的值将在下次更新显示时显示。（原则上，我们可能还想在这个回调中更新显示。）
- en: 'Let us suppose we were given this program to maintain. We want to ask a simple
    question: what is the value of the Web page’s `curTime` element? Observe the reasoning
    we have to perform:'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被分配了这个程序来维护。我们想问一个简单的问题：网页的`curTime`元素是什么值？观察我们必须执行的推理：
- en: It is set inside `doEverySecond`.
  id: totrans-1876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在`doEverySecond`内部设置。
- en: It’s set to the value of `elapsedTime`.
  id: totrans-1877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被设置为`elapsedTime`的值。
- en: That value is incremented in the previous statement.
  id: totrans-1878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个值在上一个语句中被增加。
- en: That increment takes place every time `doEverySecond` is called.
  id: totrans-1879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用`doEverySecond`时，都会发生增加。
- en: That call takes place in the first argument of `setInterval`.
  id: totrans-1880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个调用发生在`setInterval`的第一个参数中。
- en: That event is installed by `startTimer`.
  id: totrans-1881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个事件是通过`startTimer`安装的。
- en: Which is called on page load.
  id: totrans-1882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在页面加载时被调用。
- en: Wait. We also need to know the initial value, where `elapsedTime` is declared.
  id: totrans-1883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。我们还需要知道初始值，即`elapsedTime`声明的地方。
- en: Oh, but wait. We also see it reset.
  id: totrans-1884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哦，但是等等。我们还看到它被重置了。
- en: That happens inside `resetElapsed`.
  id: totrans-1885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那是在`resetElapsed`内部发生的。
- en: Which is called when the button is clicked.
  id: totrans-1886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在按钮点击时被调用。
- en: 'In short, we have to follow all this:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们必须遵循以下所有内容：
- en: '![](image19.png)'
  id: totrans-1888
  prefs: []
  type: TYPE_IMG
  zh: '![](image19.png)'
- en: Reactivity
  id: totrans-1889
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应性
- en: There is an alternative, called functional-reactive programming(FRP). We will
    see one particular instantiation, which is baked into Racket with an interesting
    user interface. The language is called FrTime. For technical reasons, we will
    not use a `#lang` but rather choose it from the Language menu (under Other Languages).
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个替代方案，称为函数式反应式编程（FRP）。我们将看到一个特定的实例化，它被嵌入到Racket中，并具有有趣的用户界面。该语言被称为FrTime。由于技术原因，我们不会使用`#lang`，而是从语言菜单（在“其他语言”下）中选择它。
- en: Do Now! Below are some expressions whose output is best experienced in DrRacket.
    Run them in DrRacket and see the output for yourself!
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 立即行动！以下是一些在DrRacket中运行输出效果最佳的表达式。在DrRacket中运行它们，亲自查看输出结果！
- en: 'FrTime essentially provides a basic version of Racket, so basic computations
    work exactly as we would expect:'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: FrTime本质上提供了一个基本的Racket版本，因此基本的计算工作方式与我们预期的完全一样：
- en: '[PRE472]'
  id: totrans-1893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'We can also ask for values like the current system time:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以请求像当前系统时间这样的值：
- en: '[PRE473]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'You will likely see a different value than the one shown above, because you
    are not reading this at the same time as when I wrote it. But that is a problem:
    indeed, even I am seeing a stale value, because time has passed since I ran the
    command.'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看到的值与上面显示的不同，因为你不是在我写的时候阅读的。但这确实是一个问题：实际上，即使是我也看到了一个过时的值，因为我运行命令后时间已经过去了。
- en: The typical solution is to use callbacks. We can imagine a timer that takes
    a callback, which is called every time the time changes. However, this would invert
    control, which is exactly what happens in our timer example.
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的解决方案是使用回调。我们可以想象一个计时器，它接受一个回调，该回调在时间变化时被调用。然而，这将反转控制，这正是我们在计时器示例中所发生的。
- en: 'But FrTime, following the principles of FRP, provides a special kind of value.
    Try it:'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 但FrTime遵循FRP的原则，提供了一种特殊类型的值。试一试：
- en: '[PRE474]'
  id: totrans-1899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: 'See what happens? `seconds`is a time-varying value: i.e., it is (technically:
    evaluates to) a value, but what it evaluates to changes over time. (It changes,
    in fact, every second.)'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 看看会发生什么？`seconds`是一个随时间变化的值：即，它是一个值（技术上：评估为）一个值，但它的评估值会随时间变化。（实际上，每秒都会变化。）
- en: 'Naturally, we should ask: if `seconds` evaluates to a value, we can use it
    in expressions, so what happens if we write expressions like these?'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们应该问：如果`seconds`评估为一个值，我们可以在表达式中使用它，那么如果我们编写这样的表达式会发生什么？
- en: '[PRE475]'
  id: totrans-1902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-1903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: Notice that both `add1`and `modulo`demand that their first argument be numbers.
    `seconds` is a time-varying value that at every point in time is a number. Therefore,
    these expressions are well-typed, producing no errors, and in fact produce the
    answer we might expect (but also perhaps be a bit surprised by).
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`add1`和`modulo`都要求它们的第一个参数必须是数字。`seconds`是一个随时间变化的值，在每一个时间点它都是一个数字。因此，这些表达式是正确类型的，不会产生错误，并且实际上产生了我们可能预期的答案（但也许也会有点惊讶）。
- en: 'Nothing prevents us from writing even longer expressions. Consider the function
    `build-list`:'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么阻止我们编写更长的表达式。考虑函数`build-list`：
- en: '[PRE477]'
  id: totrans-1906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: What happens if we now use a time-varying value?
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用一个随时间变化的值会发生什么？
- en: '[PRE478]'
  id: totrans-1908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: 'Or build an even deeper expression:'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 或者构建一个更深层的表达式：
- en: '[PRE479]'
  id: totrans-1910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: How Evaluation Works
  id: totrans-1911
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估是如何工作的
- en: Dataflow Graphs
  id: totrans-1912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据流图
- en: What happens when we write these expressions? FrTime rewrites the way function
    applications happen. If noargument to a function is time-varying, then the function
    evaluates just as it would in regular Racket. If, however, any of its arguments
    is time-varying, then FrTime constructs a node in a dataflow graph. This node
    is attached to the nodes corresponding to the time-varying arguments.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写这些表达式时会发生什么？FrTime会重写函数应用的方式。如果一个函数没有随时间变化的参数，那么它就像在常规Racket中一样进行评估。然而，如果它的任何参数是随时间变化的，那么FrTime会在数据流图中构建一个节点。这个节点连接到对应于随时间变化的参数的节点。
- en: 'Consider this expression:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个表达式：
- en: '[PRE480]'
  id: totrans-1915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: 'The act of calling length evaluates its argument, which is a call to build-list,
    which evaluates its two arguments. The second argument is an ordinary closure.
    The first argument is a call to modulo, which evaluates its two arguments. Again,
    the second argument is just a number, but the first argument is time-varying.
    Consequently, this turns into a dataflow graph node, where we use the context
    notation to indicate where time-varying values go:'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 调用长度的行为会评估其参数，这是一个对`build-list`的调用，它评估其两个参数。第二个参数是一个普通闭包。第一个参数是对`modulo`的调用，它评估其两个参数。再次，第二个参数只是一个数字，但第一个参数是随时间变化的。因此，这变成了一个数据流图节点，我们使用上下文符号来表示随时间变化的值所在的位置：
- en: '![](image6.png)'
  id: totrans-1917
  prefs: []
  type: TYPE_IMG
  zh: '![](image6.png)'
- en: 'Because `(modulo seconds 10)` evaluates to a time-varying value, so does the
    next outer expression:'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`(modulo seconds 10)`评估为一个随时间变化的值，所以下一个外层表达式也是随时间变化的：
- en: '![](image22.png)'
  id: totrans-1919
  prefs: []
  type: TYPE_IMG
  zh: '![](image22.png)'
- en: 'and finally the outermost one:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是外层的一个：
- en: '![](image8.png)'
  id: totrans-1921
  prefs: []
  type: TYPE_IMG
  zh: '![](image8.png)'
- en: The program source therefore evaluates to this dataflow graph. Now, each time-varying
    value may evaluate at different rates and for different reasons. `seconds`, naturally,
    updates once every second. When it does, its updated value is pushed to all the
    nodes that depend on it, which update their value and push their values, and so
    on all the way through the graph. Finally, values may arrive at the REPL, which
    in FrTime is designed to display them automatically updating.
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序源评估为这个数据流图。现在，每个随时间变化的值可能会以不同的速率和不同的原因进行评估。`seconds`自然地每秒更新一次。当它更新时，它的更新值会被推送到所有依赖于它的节点，这些节点更新它们的值并推送它们的值，以此类推，直到整个图。最后，值可能会到达REPL，在FrTime中设计为自动显示它们。
- en: Rewriting Application
  id: totrans-1923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写应用
- en: Essentially, we can think of reactivity being implemented by rewriting how function
    application works. In the simplest case, imagine we have a function application,
    `(f a)`. Let us assume that `f`is itself not a time-varying value. Then, this
    application rewrites `(f a)` as
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以将反应性视为通过重写函数应用的方式实现的。在最简单的情况下，想象我们有一个函数应用`(f a)`。让我们假设`f`本身不是一个随时间变化的值。那么，这个应用将`(f
    a)`重写为
- en: '[PRE481]'
  id: totrans-1925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: We will return to the `…`in a moment. Observe that this evaluates the argument
    expression and, if it is not currently a time-varying value, then computation
    proceeds exactly as it would have in regular Racket. This means that progams that
    don’t use time-varying values behave exactlyas they would in Racket, so this is
    a conservative extension of Racket.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会回到`…`。注意，这评估了参数表达式，如果它目前不是一个时变值，那么计算将像在常规Racket中那样进行。这意味着不使用时变值的程序的行为与在Racket中完全一样，因此这是一个保守的Racket扩展。
- en: 'Now let’s consider what happens if the parameter istime-varying. That means,
    instead of immediately computing an answer, we have to create a node in the dataflow
    graph. We can imagine a time-varying value is an object of the class `tvv%` (`tvv`for
    time-varying value, and `%`using the Racket convention for classes). We will first
    illustrate how this might be used, then show its definition. This class has two
    methods: `add-consumer`, which provides another object of `tvv%`that will receive
    updated values, and `update`, which receives updated values. We reproduce the
    bottom three parts of the above dataflow graph as follows and, to keep the output
    short, compute the remainder relative to `5`rather than `10`:'
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑如果参数是时变的会发生什么。这意味着，我们不是立即计算一个答案，而是必须在数据流图中创建一个节点。我们可以想象一个时变值是`tvv%`类（`tvv`代表时变值，`%`使用Racket的类约定）的一个对象。我们首先将展示如何使用它，然后展示其定义。这个类有两个方法：`add-consumer`，它提供了一个`tvv%`对象，该对象将接收更新的值，以及`update`，它接收更新的值。我们将以上数据流图的底部三部分重新表示如下，并且为了使输出简短，我们将相对于`5`而不是`10`计算剩余部分：
- en: '[PRE482]'
  id: totrans-1928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: In practice, `seconds`would be attached to a system timer that pushes an update
    every second. For simplicity, we make it an inert object that only changes when
    we manually call its `updater`.
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`seconds`将附加到一个系统计时器，每秒推送一个更新。为了简单起见，我们使其成为一个惰性对象，只有当我们手动调用其`updater`时才会改变。
- en: 'The remainder node now looks like this:'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 现在余数节点看起来是这样的：
- en: '[PRE483]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: 'That is, every time it receives a value from `seconds`, it computes that value
    `modulo` `5`. Of course, right now it has no way of knowing that it must listen
    to `seconds`; we have to register it as a consumer:'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 即，每次它从`seconds`接收一个值时，它都会计算该值`modulo``5`。当然，现在它不知道它必须监听`seconds`；我们必须将其注册为消费者：
- en: '[PRE484]'
  id: totrans-1933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'Similarly, the `build-list` expression creates a time-varying value object:'
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`build-list`表达式创建了一个时变值对象：
- en: '[PRE485]'
  id: totrans-1935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'which too we must attach to its value producer:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将其附加到其值生产者：
- en: '[PRE486]'
  id: totrans-1937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: Observe how the `v`parameters in `mod•5`and in `bl•id` correspond to the • in
    the dataflow graph.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`mod•5`和`bl•id`中的`v`参数如何对应于数据流图中的•。
- en: 'Finally, just as `seconds`is a source in the graph, we will define a sink that
    prints results, and send values from `bl•id` to it:'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如`seconds`是图中的一个源，我们将定义一个打印结果的汇点，并将`bl•id`的值发送到它：
- en: '[PRE487]'
  id: totrans-1940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-1941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: 'Now we’re ready to test it all! If we simulate `seconds` updating for the first
    ten seconds:'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好测试它了！如果我们模拟`seconds`在前十秒的更新：
- en: '[PRE489]'
  id: totrans-1943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: 'we see the following output printed, just as we would expect:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到以下输出被打印出来，正如我们所期望的：
- en: '[PRE490]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'So how did this work? The `tvv%`class keeps track of a list of consumers, of
    which above we have had only one per object. `add-consumer`merely augments this
    list. The `update`method receives a value, uses its `updater` function to compute
    a new current value, and broadcasts it to all of its consumers:'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？`tvv%`类跟踪一个消费者列表，其中我们上面每个对象只有一个。`add-consumer`只是增加这个列表。`update`方法接收一个值，使用它的`updater`函数计算一个新的当前值，并将其广播给所有消费者：
- en: '[PRE491]'
  id: totrans-1947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-1948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-1949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-1950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: 'That’s (most of) the core logic (but read on). This brings us back to the rewriting
    of applications: what goes in `…`? Well, we have to'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是（大部分）核心逻辑（但请继续阅读）。这使我们回到了应用程序的重写：`…`中是什么？嗯，我们必须
- en: make a new `tvv%` instance
  id: totrans-1952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的`tvv%`实例
- en: supply it an updater function that corresponds to `(f •)`
  id: totrans-1953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个与`(f •)`对应的更新器函数
- en: registers that node as a consumer to the `tvv%`object that `a-value` references
  id: totrans-1954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将该节点注册为`a-value`引用的`tvv%`对象的消费者
- en: return the new `tvv%` instance as the result of this function “application”
  id: totrans-1955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这个函数“应用”的结果返回为新的`tvv%`实例
- en: 'Exercise: Turn the above rewriting idea into a proper macro. If you can, turn
    it into the `#%app`of a `#lang` so that one can program a module in a FrTime-like
    style.'
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：将上述重写想法转换成一个合适的宏。如果你能，将其转换成`#lang`的`#%app`，这样就可以用类似FrTime的风格编写模块。
- en: Non-Linear Graphs
  id: totrans-1957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非线性图
- en: 'The above example may be a bit misleading in suggesting that an expression
    must always have at most one time-varying parameter. Consider this program:'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可能有点误导，暗示一个表达式必须始终只有一个时间变化的参数。考虑这个程序：
- en: '[PRE495]'
  id: totrans-1959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: Its dataflow graph looks like
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 它的数据流图看起来像
- en: '![](image13.png)'
  id: totrans-1961
  prefs: []
  type: TYPE_IMG
  zh: '![](image13.png)'
- en: On every update of `seconds`, both expressions that depend on it update, and
    their result flows to the equality comparison. Every 15 seconds, we would expect
    to see 12 consecutive false values followed by three consecutive true values,
    and that is what we see.
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 在`seconds`的每次更新中，依赖于它的两个表达式都会更新，并且它们的计算结果会流向等式比较。我们预计每15秒会出现12个连续的假值，然后是3个连续的真值，这正是我们所看到的。
- en: 'Exercise: Does the above definition of `tvv%` permit non-linear graphs? Can
    you write the above example with it? If so, show how. If not, modify it to allow
    such a definition.'
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：上述`tvv%`的定义允许非线性格式吗？你能用它写出上述示例吗？如果可以，请展示如何。如果不可以，请修改它以允许这样的定义。
- en: Avoiding Glitches
  id: totrans-1964
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免故障
- en: 'These forks in the graph, however, might be a cause for concern. Let us see
    an even simpler example:'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，图中的这些分支可能是一个令人担忧的原因。让我们看看一个更简单的例子：
- en: '[PRE496]'
  id: totrans-1966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: 'Let us first be clear about what we expect this to produce: we want it to always
    be `#true`.'
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先明确我们期望它产生什么：我们希望它始终为`#true`。
- en: 'However, let us view how a simplistic dataflow graph evaluator might work.
    Here is the graph:'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看一个简单的数据流图评估器可能如何工作。以下是该图：
- en: '![](image7.png)'
  id: totrans-1969
  prefs: []
  type: TYPE_IMG
  zh: '![](image7.png)'
- en: Suppose the value of `seconds`updates to become 10\. This value is pushed, as
    we would expect, to bothits listeners. This causes the `(add1 seconds)`node to
    update its value from `10`to `11`. However, the update to `seconds`might have
    caused the comparison to occur immediately. At that point FrTime would be evaluating
    `(< 10 10)`, which is clearly false. So for one instant this expression would
    evaluate to `#true`, before the update from `(add1 seconds)`arrives and it reverts
    to `#false`. This is called a glitch, a term borrowed from the same phenomenon
    in [electrical circuits](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Glitch&sa=D&source=editors&ust=1695232021650816&usg=AOvVaw2D-DrKG6J0VAjm-pDxm4Ri).
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`seconds`的值更新为10。这个值，正如我们所期望的，被推送到它的所有监听器。这导致`(add1 seconds)`节点将其值从`10`更新为`11`。然而，`seconds`的更新可能已经导致了比较立即发生。在那个时刻，FrTime正在评估`(<
    10 10)`，这显然是错误的。所以在这个表达式的计算结果在一瞬间会评估为`#true`，在`(add1 seconds)`的更新到达并使其重新变为`#false`之前。这被称为故障，这个术语是从[电路](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Glitch&sa=D&source=editors&ust=1695232021650816&usg=AOvVaw2D-DrKG6J0VAjm-pDxm4Ri)中的相同现象借用的。
- en: Avoiding glitches is actually quite simple. Rather than updating a node in this
    eager manner, FrTime schedules the graph to be updated in [topographical order](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Topological_sorting&sa=D&source=editors&ust=1695232021651423&usg=AOvVaw17recAG9rHgwYI9lEViEXR).
    That ensures that no node will ever see old, or “stale”, values, and the expression
    will evaluate correctly. Of course, we can only apply topological sorting to directed
    acyclic graphs, so handling cycles requires some additional work, which we do
    not discuss here.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 避免故障实际上相当简单。而不是以这种方式急切地更新节点，FrTime安排在[拓扑顺序](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Topological_sorting&sa=D&source=editors&ust=1695232021651423&usg=AOvVaw17recAG9rHgwYI9lEViEXR)中更新图。这确保了没有任何节点会看到旧的或“过时”的值，并且表达式将正确评估。当然，我们只能对有向无环图应用拓扑排序，因此处理循环需要一些额外的工作，这里我们不讨论。
- en: 'Exercise: Make the above definition of non-linear graphs behave glitch-free.'
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：使上述非线性格式的定义无故障运行。
- en: Other Time-Varying Values
  id: totrans-1973
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他时间变化的值
- en: 'So far we have seen only one basic time-varying value, `seconds`. FrTime provides
    many others. For instance, `mouse-pos` is the current position of the mouse. If
    we run the following program:'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了一个基本的时间变化值，即`seconds`。FrTime提供了许多其他的值。例如，`mouse-pos`是鼠标的当前位置。如果我们运行以下程序：
- en: '[PRE497]'
  id: totrans-1975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-1976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: we see a blue circle, and it automatically follows the mouse.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个蓝色圆圈，它会自动跟随鼠标。
- en: The function `display-shapes`in the FrTime animation library takes a list of
    shapes; above, we have only one. This function builds a list of (four) circles
    whose positions are determined by the mouse’s location, except each one is delayed,
    i.e., represents where the mouse used to be. (One might call this the Rhode Island
    mouse.) Therefore, as the mouse moves these circles appear to “follow” it around.
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: FrTime动画库中的`display-shapes`函数接受一个形状列表；上面，我们只有一个。这个函数构建一个由（四个）圆组成的列表，其位置由鼠标的位置确定，除了每个圆都有延迟，即代表鼠标曾经的位置。（有人可能会称之为罗德岛鼠标。）因此，当鼠标移动时，这些圆似乎“跟随”它移动。
- en: '[PRE499]'
  id: totrans-1979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: Even More Time-Varying Values
  id: totrans-1980
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多随时间变化的价值
- en: 'We have actually seen only one kind of time-varying value, called a behavior.
    There are actually two kinds of time-varying values, which is easy to see if we
    consider a few different kinds of stimuli from the world:'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上只看到一种时间变化的价值，称为行为。实际上有两种时间变化的价值，如果我们考虑世界中的几种不同类型的刺激，这很容易看出：
- en: Current mouse position
  id: totrans-1982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前鼠标位置
- en: Sequence of keystrokes
  id: totrans-1983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键序列
- en: Current user location
  id: totrans-1984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前用户位置
- en: Sequence of network responses
  id: totrans-1985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络响应序列
- en: Current status of mode keys
  id: totrans-1986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式键的当前状态
- en: Sequence of mouse-clicks
  id: totrans-1987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标点击序列
- en: Current time
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前时间
- en: Notice that several of those are “current…” and others are “sequence of…”. The
    former have the property that they always have a value, and the value may change
    at any time. The latter have the property that at any given moment they may not
    have a value—for instance, there may not be a “current keystroke”—and we don’t
    know when (or if) the next one will come, and there may be an infinite number
    of them. The latter are, of course, just streams, often called event streams.
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其中一些是“当前...”，而另一些是“序列...”。前者具有始终有值的属性，并且值可能随时改变。后者具有在任何给定时刻可能没有值的属性——例如，可能没有“当前按键”——我们不知道下一次（或是否）会来，并且可能有无限多个。后者当然是流，通常称为事件流。
- en: 'If we go back to our original counter example, we had both present. The elapsed
    time was a behavior (always has a value, which changes either when a second finishes
    or when a button is clicked). The sequence of button presses is, conversely, an
    event stream: at any given moment there may not be a press, we don’t know when
    or even if the next one will come, and there may be an unbounded number of them
    (from a very bored user). To learn more, see the papers about the design and implementation
    of [FrTime](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ck-frtime/&sa=D&source=editors&ust=1695232021655719&usg=AOvVaw1rTfSyu1ttBqGmZrO7l9th),
    and a similar language for JavaScript called [Flapjax](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mgbcgbk-flapjax/&sa=D&source=editors&ust=1695232021656156&usg=AOvVaw05OqgMykYggyiyBjsWWIJU).'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到最初的反例，我们同时拥有两种情况。经过的时间是一个行为（始终有一个值，这个值在每一秒结束时或按钮被点击时改变）。相反，按钮按下的序列是一个事件流：在任何给定时刻可能没有按下，我们不知道下一次按下会在何时甚至是否会发生，并且可能有无限多个（来自一个非常无聊的用户）。要了解更多信息，请参阅关于[FrTime](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ck-frtime/&sa=D&source=editors&ust=1695232021655719&usg=AOvVaw1rTfSyu1ttBqGmZrO7l9th)设计和实现的研究论文，以及一个类似的语言[Flapjax](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mgbcgbk-flapjax/&sa=D&source=editors&ust=1695232021656156&usg=AOvVaw05OqgMykYggyiyBjsWWIJU)（用于JavaScript）。
- en: Returning to Our Timer
  id: totrans-1991
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到我们的计时器
- en: We can write the original timer program using FrTime’s GUI library. Here is
    the program, explained.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用FrTime的GUI库编写原始的计时器程序。以下是程序，以及其解释。
- en: Elapsed Time Without Resetting
  id: totrans-1993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未重置的经过时间
- en: 'First we will write a simpler version that simply shows the elapsed time since
    the program began. To do so, we need to load the GUI library:'
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个更简单的版本，它只显示程序开始以来的经过时间。要做到这一点，我们需要加载GUI库：
- en: '[PRE500]'
  id: totrans-1995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: and then we need to determine how much time has elapsed. It may be tempting
    to write
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要确定已经过去了多少时间。可能有人会想写
- en: '[PRE501]'
  id: totrans-1997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: 'and then make a GUI display object that presents this (after converting the
    number into a string):'
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个GUI显示对象来展示这个（在将数字转换为字符串之后）：
- en: '[PRE502]'
  id: totrans-1999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: 'When we run this, however, we get a rather disappointing display that seems
    to always show `0`. That is because that’s what we asked for! We can check this
    by asking for the value of `init-time` in the REPL:'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行这个程序时，我们得到一个相当令人失望的显示，似乎总是显示`0`。这是因为这就是我们请求的！我们可以通过在REPL中请求`init-time`的值来检查这一点：
- en: '[PRE503]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: 'When we do, we see that it is constantly changing. But that’s what we should
    expect: we defined it to be the same as `seconds`! Instead, we need to hold on
    to the value of `seconds` at the timewe started the program: i.e., we do not want
    it to automatically update. For that, we instead write'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们看到它一直在变化。但这是我们应有的预期：我们定义了它与 `seconds` 相同！相反，我们需要保留 `seconds` 在我们开始程序时的值：即我们不想它自动更新。为此，我们改写为
- en: '[PRE504]'
  id: totrans-2003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: and then the rest of the program works as we would expect.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序的其余部分按我们预期的方式工作。
- en: Adding Resets
  id: totrans-2005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加重置
- en: 'Now let’s add the button. We create a button object, which returns an event
    stream of its clicks:'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加按钮。我们创建一个按钮对象，它返回其点击的事件流：
- en: '[PRE505]'
  id: totrans-2007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: 'Every time there’s a click, we want the elapsed time to reset to `0`. That
    is, we want to keep track of when the reset occurred. Note that again we need
    to use `value-now`to get the time when it occurred, not the current time. We use
    `map-e` to map over event streams:'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有点击时，我们希望已过时间重置为 `0`。也就是说，我们想要记录重置发生的时间。请注意，我们再次需要使用 `value-now` 来获取它发生的时间，而不是当前时间。我们使用
    `map-e` 来映射事件流：
- en: '[PRE506]'
  id: totrans-2009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: 'So we have two kinds of events: the start of the program, and the clicks. We
    want a single behavior that reflects when these occurred: starting with when the
    program began, and updating whenever there’s a click. The function `switch` does
    this, “switching” the behavior’s value whenever an event occurs:'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种类型的事件：程序开始和点击。我们想要一个单一的行为来反映这些事件发生的时间：从程序开始时开始，并在每次点击时更新。函数 `switch`
    就是这样做的，每当发生事件时，“切换”行为值：
- en: '[PRE507]'
  id: totrans-2011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'At this point, the elapsed time to show is how far the current time is from
    the last event:'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，显示的已过时间是当前时间与最后事件之间的距离：
- en: '[PRE508]'
  id: totrans-2013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'Visually:'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉上：
- en: '![](image16.png)'
  id: totrans-2015
  prefs: []
  type: TYPE_IMG
  zh: '![](image16.png)'
- en: 'Putting this all together, and adding the output directive:'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，并添加输出指令：
- en: '[PRE509]'
  id: totrans-2017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-2018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-2019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: 'Observe that in this program, there are two kinds of changes that can occur:'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到在这个程序中，可能发生两种变化：
- en: Another second elapses. Thus, `seconds`changes; so does `elapsed-time`; and
    so `make-message` updates its output.
  id: totrans-2021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一秒过去了。因此，`seconds` 发生了变化；同样，`elapsed-time` 也发生了变化；因此 `make-message` 也更新了其输出。
- en: The user clicks the button. Then `reset-clicks`has an event, so `click-times`has
    an event, `event-times`updates, and so does `elapsed-time`, thereby also causing
    `make-message` to also update its output.
  id: totrans-2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击按钮。然后 `reset-clicks` 有一个事件，所以 `click-times` 有一个事件，`event-times` 更新，同样 `elapsed-time`
    也更新，从而也导致 `make-message` 更新其输出。
- en: In both cases `elapsed-time`updates, triggering a change in the output. But
    there are two inputs to the subtraction in `elapsed-time`, and they update for
    different reasons.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`elapsed-time` 都会更新，从而触发输出的变化。但在 `elapsed-time` 的减法中有两个输入，并且它们由于不同的原因而更新。
- en: 'What may be lost in the above presentation, which is incremental to enhance
    readability, is that we actually have deeply nested expressions that we can think
    of algebraically. To make that clearer, here is the whole program written as a
    single expression, with each name replaced with the expression it was bound to
    (though this is almost certainly a less readable version):'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述展示中可能丢失的是，为了提高可读性而逐步增强的结构，我们实际上有深度嵌套的表达式，我们可以从代数的角度来思考。为了使这一点更清晰，这里是将整个程序作为一个单一表达式编写的，每个名称都替换为其所绑定到的表达式（尽管这几乎肯定是一个更难以阅读的版本）：
- en: '[PRE512]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: The interested reader can prove properties of the time shown based purely on
    the rules of algebra, perhaps even identifying a slightly unsatisfying behavior
    in the time shown by the timer (which was also a problem with the callback version).
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 对此感兴趣的读者可以根据代数规则证明显示时间的性质，也许甚至可以识别出计时器显示的时间中存在的一点点令人不满意的行为（这也是回调版本的问题）。
- en: This example shows that we really can compose expressions in a conventional
    manner even though we are writing a reactive program using a GUI library. It is
    worth comparing the structure of this program against the callback-based version
    that we started with.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，即使我们正在使用 GUI 库编写反应式程序，我们仍然可以以传统的方式组合表达式。将这个程序的架构与我们在开始时使用的基于回调的版本进行比较是值得的。
- en: '[This paper](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ick-adapt-oo-fwk-frp/&sa=D&source=editors&ust=1695232021664301&usg=AOvVaw1WOPAKU7HpkFtzRQxaaDl3) shows
    how the GUI library was given a functional-reactive interface by exploiting the
    encapsulation of object-oriented state.'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: '[这篇论文](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ick-adapt-oo-fwk-frp/&sa=D&source=editors&ust=1695232021664301&usg=AOvVaw1WOPAKU7HpkFtzRQxaaDl3)
    展示了如何通过利用面向对象状态的封装，给 GUI 库提供了一个函数式反应式接口。'
- en: ••••• What’s Next? •••••
  id: totrans-2029
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ••••• 接下来是什么？ •••••
- en: You have just finished a detailed look at the landscape of programming languages.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚详细地审视了编程语言的领域。
- en: It’s a broad and rich landscape with many, many dimensions to consider.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个广阔而丰富的领域，需要考虑的维度非常多。
- en: 'This book has largely eschewed programming language theory, because there are
    already many wonderful books about that. I recommend:'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书在很大程度上避开了编程语言理论，因为已经有许多关于这个主题的精彩书籍。我推荐：
- en: 'Felleisen, Findler, Flatt: [Semantics Engineering with PLT Redex](https://www.google.com/url?q=https://mitpress.mit.edu/9780262062756/semantics-engineering-with-plt-redex/&sa=D&source=editors&ust=1695232021665409&usg=AOvVaw1KqS_Jy_nK815yWIVBp7ex)'
  id: totrans-2033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 费莱森、芬德勒、弗拉特：[使用PLT Redex进行语义工程](https://www.google.com/url?q=https://mitpress.mit.edu/9780262062756/semantics-engineering-with-plt-redex/&sa=D&source=editors&ust=1695232021665409&usg=AOvVaw1KqS_Jy_nK815yWIVBp7ex)
- en: 'Harper: [Practical Foundations for Programming Languages](https://www.google.com/url?q=https://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/practical-foundations-programming-languages-2nd-edition?format%3DHB%26isbn%3D9781107150300&sa=D&source=editors&ust=1695232021665792&usg=AOvVaw1AAwlEjddhBK-I2YGlk71l)'
  id: totrans-2034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈珀：[编程语言的实际基础](https://www.google.com/url?q=https://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/practical-foundations-programming-languages-2nd-edition?format%3DHB%26isbn%3D9781107150300&sa=D&source=editors&ust=1695232021665792&usg=AOvVaw1AAwlEjddhBK-I2YGlk71l)
- en: 'Pierce: [Types and Programming Languages](https://www.google.com/url?q=https://mitpress.mit.edu/9780262162098/types-and-programming-languages/&sa=D&source=editors&ust=1695232021666106&usg=AOvVaw3g2h6FqQKLiHwO8ZNmsd-O)'
  id: totrans-2035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 皮尔斯：[类型与编程语言](https://www.google.com/url?q=https://mitpress.mit.edu/9780262162098/types-and-programming-languages/&sa=D&source=editors&ust=1695232021666106&usg=AOvVaw3g2h6FqQKLiHwO8ZNmsd-O)
- en: for three rather different, but all foundational, perspectives on the further
    study of the subject.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 从三个相当不同，但都是基础性的角度来进一步研究这个主题。
- en: Equally, programming languages are more popular than ever before. Working programmers
    not only contribute to their development but also put a great deal of effort into
    understanding more advanced features and distilling them for others. Their work
    tends to be found on blogs or at various conferences (such as those [listed here](https://www.google.com/url?q=https://twitter.com/ShriramKMurthi/status/1600574419914854400&sa=D&source=editors&ust=1695232021666661&usg=AOvVaw0QxljIxYwpEq2ec0JQcfOL)).
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编程语言比以往任何时候都更受欢迎。工作程序员不仅为它们的发展做出贡献，而且投入大量精力去理解更高级的功能，并将它们提炼出来供他人使用。他们的工作往往可以在博客或各种会议（例如[这里列出的](https://www.google.com/url?q=https://twitter.com/ShriramKMurthi/status/1600574419914854400&sa=D&source=editors&ust=1695232021666661&usg=AOvVaw0QxljIxYwpEq2ec0JQcfOL))找到。
- en: We’re done! I hope you’ve enjoyed reading this as much as I enjoyed writing
    it!
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！我希望你阅读这篇文档的乐趣和我写作时的乐趣一样多！

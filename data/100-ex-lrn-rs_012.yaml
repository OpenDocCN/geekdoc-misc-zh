- en: Case-by-case behavior
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况化行为
- en: 原文：[https://rust-exercises.com/100-exercises/02_basic_calculator/09_saturating.html](https://rust-exercises.com/100-exercises/02_basic_calculator/09_saturating.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/02_basic_calculator/09_saturating.html](https://rust-exercises.com/100-exercises/02_basic_calculator/09_saturating.html)
- en: '`overflow-checks` is a blunt tool: it''s a global setting that affects the
    whole program.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`overflow-checks` 是一个粗糙的工具：它是一个全局设置，影响整个程序。'
- en: 'It often happens that you want to handle integer overflows differently depending
    on the context: sometimes wrapping is the right choice, other times panicking
    is preferable.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你可能希望根据上下文以不同的方式处理整数溢出：有时环绕是正确的选择，而其他时候恐慌更可取。
- en: '[`wrapping_` methods](#wrapping_-methods)'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[环绕方法](#wrapping_-methods)'
- en: You can opt into wrapping arithmetic on a per-operation basis by using the `wrapping_`
    methods^([1](#footnote-method)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `wrapping_` 方法来逐个操作选择进入环绕算术^([1](#footnote-method))。
- en: 'For example, you can use `wrapping_add` to add two integers with wrapping:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `wrapping_add` 来进行带环绕的整数加法：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[`saturating_` methods](#saturating_-methods)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[饱和方法](#saturating_-methods)'
- en: Alternatively, you can opt into **saturating arithmetic** by using the `saturating_`
    methods.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过使用 `saturating_` 方法选择进入**饱和算术**。
- en: 'Instead of wrapping around, saturating arithmetic will return the maximum or
    minimum value for the integer type. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与环绕不同，饱和算术将返回整数类型的最大或最小值。例如：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since `255 + 1` is `256`, which is bigger than `u8::MAX`, the result is `u8::MAX`
    (255).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `255 + 1` 是 `256`，这比 `u8::MAX` 大，所以结果是 `u8::MAX`（255）。
- en: 'The opposite happens for underflows: `0 - 1` is `-1`, which is smaller than
    `u8::MIN`, so the result is `u8::MIN` (0).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下溢，情况相反：`0 - 1` 是 `-1`，这比 `u8::MIN` 小，所以结果是 `u8::MIN`（0）。
- en: You can't get saturating arithmetic via the `overflow-checks` profile setting—you
    have to explicitly opt into it when performing the arithmetic operation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能通过 `overflow-checks` 配置文件设置获得饱和算术——你必须在进行算术操作时明确选择进入。
- en: '[Exercise](#exercise)'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`02_basic_calculator/09_saturating`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于 `02_basic_calculator/09_saturating`。[链接](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating)
- en: '* * *'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: You can think of methods as functions that are "attached" to a specific type.
    We'll cover methods (and how to define them) in the next chapter. [↩](#fr-method-1)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将方法视为“附加”到特定类型上的函数。我们将在下一章中介绍方法（以及如何定义它们）。[↩](#fr-method-1)

- en: Ownership
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html](https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html](https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html)
- en: 'If you solved the previous exercise using what this course has taught you so
    far, your accessor methods probably look like this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用到目前为止课程中学到的知识解决了前面的练习，你的访问器方法可能看起来像这样：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Those methods compile and are enough to get tests to pass, but in a real-world
    scenario they won''t get you very far. Consider this snippet:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以编译，并且足以让测试通过，但在实际场景中它们不会让你走得很远。考虑这个片段：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you try to compile it, you''ll get an error:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译它，你会得到一个错误：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Congrats, this is your first borrow-checker error!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，这是你的第一个借用检查器错误！
- en: '[The perks of Rust''s ownership system](#the-perks-of-rusts-ownership-system)'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Rust 所有权系统的优势](#the-perks-of-rusts-ownership-system)'
- en: 'Rust''s ownership system is designed to ensure that:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的所有权系统旨在确保：
- en: Data is never mutated while it's being read
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在读取过程中永远不会被变异
- en: Data is never read while it's being mutated
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在变异过程中不会被读取
- en: Data is never accessed after it has been destroyed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在被销毁后永远不会被访问
- en: These constraints are enforced by the **borrow checker**, a subsystem of the
    Rust compiler, often the subject of jokes and memes in the Rust community.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束由 **借用检查器** 强制执行，这是 Rust 编译器的一个子系统，通常是 Rust 社区中笑话和模因的主题。
- en: 'Ownership is a key concept in Rust, and it''s what makes the language unique.
    Ownership enables Rust to provide **memory safety without compromising performance**.
    All these things are true at the same time for Rust:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权是 Rust 的一个关键概念，也是使该语言独特的原因。所有权使 Rust 能够在 **不牺牲性能的情况下提供内存安全**。对于 Rust，以下所有事情都是真的：
- en: There is no runtime garbage collector
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有运行时垃圾回收器
- en: As a developer, you rarely have to manage memory directly
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一名开发者，你很少需要直接管理内存
- en: You can't cause dangling pointers, double frees, and other memory-related bugs
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能造成悬垂指针、双重释放和其他内存相关错误
- en: Languages like Python, JavaScript, and Java give you 2\. and 3., but not 1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 Python、JavaScript 和 Java 这样的语言提供了 2. 和 3.，但没有 1.
- en: Language like C or C++ give you 1., but neither 2\. nor 3.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 C 或 C++ 这样的语言提供了 1.，但既没有 2. 也没有 3.
- en: 'Depending on your background, 3\. might sound a bit arcane: what is a "dangling
    pointer"? What is a "double free"? Why are they dangerous?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的背景，3. 可能听起来有点晦涩：什么是“悬垂指针”？什么是“双重释放”？为什么它们是危险的？
- en: 'Don''t worry: we''ll cover these concepts in more details during the rest of
    the course.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心：我们将在课程剩余部分更详细地介绍这些概念。
- en: For now, though, let's focus on learning how to work within Rust's ownership
    system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们专注于学习如何在 Rust 的所有权系统中工作。
- en: '[The owner](#the-owner)'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[所有者](#the-owner)'
- en: In Rust, each value has an **owner**, statically determined at compile-time.
    There is only one owner for each value at any given time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，每个值都有一个 **所有者**，在编译时静态确定。在任何给定时间，每个值只有一个所有者。
- en: '[Move semantics](#move-semantics)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[移动语义](#move-semantics)'
- en: Ownership can be transferred.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权可以被转移。
- en: 'If you own a value, for example, you can transfer ownership to another variable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有一个值，例如，你可以将所有权转移到另一个变量：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Rust''s ownership system is baked into the type system: each function has to
    declare in its signature *how* it wants to interact with its arguments.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的所有权系统内置于类型系统中：每个函数都必须在其签名中声明它想要如何与其参数交互。
- en: 'So far, all our methods and functions have **consumed** their arguments: they''ve
    taken ownership of them. For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的方法和函数都 **消耗** 了它们的参数：它们获取了它们的所有权。例如：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Ticket::description` takes ownership of the `Ticket` instance it''s called
    on.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket::description` 获取了它所调用的 `Ticket` 实例的所有权。'
- en: 'This is known as **move semantics**: ownership of the value (`self`) is **moved**
    from the caller to the callee, and the caller can''t use it anymore.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 **移动语义**：值的所有权（`self`）从调用者移动到被调用者，调用者不能再使用它。
- en: 'That''s exactly the language used by the compiler in the error message we saw
    earlier:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在之前的错误信息中看到的编译器使用的语言：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In particular, this is the sequence of events that unfold when we call `ticket.status()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在我们调用 `ticket.status()` 时，会发生以下事件序列：
- en: '`Ticket::status` takes ownership of the `Ticket` instance'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ticket::status` 获取了 `Ticket` 实例的所有权'
- en: '`Ticket::status` extracts `status` from `self` and transfers ownership of `status`
    back to the caller'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ticket::status` 从 `self` 中提取 `status` 并将 `status` 的所有权转回调用者'
- en: The rest of the `Ticket` instance is discarded (`title` and `description`)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的 `Ticket` 实例被丢弃（`title` 和 `description`）
- en: 'When we try to use `ticket` again via `ticket.title()`, the compiler complains:
    the `ticket` value is gone now, we no longer own it, therefore we can''t use it
    anymore.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次尝试通过 `ticket.title()` 使用 `ticket` 时，编译器会报错：现在 `ticket` 值已经消失了，我们不再拥有它，因此不能再使用它了。
- en: To build *useful* accessor methods we need to start working with **references**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建**有用的**访问器方法，我们需要开始使用**引用**。
- en: '[Borrowing](#borrowing)'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[借用](#borrowing)'
- en: It is desirable to have methods that can read the value of a variable without
    taking ownership of it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以读取变量的值而不获取其所有权是很有用的。
- en: Programming would be quite limited otherwise. In Rust, that's done via **borrowing**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 否则编程将会相当受限。在 Rust 中，这是通过**借用**来实现的。
- en: Whenever you borrow a value, you get a **reference** to it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你借用一个值时，你都会得到它的**引用**。
- en: 'References are tagged with their privileges^([1](#footnote-refine)):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 引用被标记为它们的权限^([1](#footnote-refine))：
- en: Immutable references (`&`) allow you to read the value, but not to mutate it
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变引用 (`&`) 允许你读取值，但不能修改它
- en: Mutable references (`&mut`) allow you to read and mutate the value
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变引用 (`&mut`) 允许你读取和修改值
- en: 'Going back to the goals of Rust''s ownership system:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Rust 所有权系统的目标：
- en: Data is never mutated while it's being read
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在读取时永远不会被修改
- en: Data is never read while it's being mutated
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据在修改时永远不会被读取
- en: 'To ensure these two properties, Rust has to introduce some restrictions on
    references:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这两个特性，Rust 必须对引用引入一些限制：
- en: You can't have a mutable reference and an immutable reference to the same value
    at the same time
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能同时拥有对同一值的可变引用和不可变引用
- en: You can't have more than one mutable reference to the same value at the same
    time
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能同时拥有对同一值的多个可变引用
- en: The owner can't mutate the value while it's being borrowed
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当值被借用时，所有者不能修改该值
- en: You can have as many immutable references as you want, as long as there are
    no mutable references
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要没有可变引用，你可以拥有任意多的不可变引用
- en: In a way, you can think of an immutable reference as a "read-only" lock on the
    value, while a mutable reference is like a "read-write" lock.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，你可以将不可变引用视为对值的“只读”锁，而可变引用则像“读写”锁。
- en: All these restrictions are enforced at compile-time by the borrow checker.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些限制都由借用检查器在编译时强制执行。
- en: '[Syntax](#syntax)'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[语法](#syntax)'
- en: How do you borrow a value, in practice?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你是如何借用一个值的？
- en: 'By adding `&` or `&mut` **in front a variable**, you''re borrowing its value.
    Careful though! The same symbols (`&` and `&mut`) in **front of a type** have
    a different meaning: they denote a different type, a reference to the original
    type.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在变量前添加 `&` 或 `&mut` **符号**，你是在借用它的值。不过要小心！在类型**前面**的相同符号 (`&` 和 `&mut`) 有不同的意义：它们表示不同的类型，是对原始类型的引用。
- en: 'For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same concept applies to function arguments and return types:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念也适用于函数参数和返回类型：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Breathe in, breathe out](#breathe-in-breathe-out)'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[深呼吸，呼气](#breathe-in-breathe-out)'
- en: Rust's ownership system can be a bit overwhelming at first.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的所有权系统一开始可能会有些令人不知所措。
- en: 'But don''t worry: it''ll become second nature with practice.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心：随着练习，这会变得自然而然。
- en: And you're going to get a lot of practice over the rest of this chapter, as
    well as the rest of the course! We'll revisit each concept multiple times to make
    sure you get familiar with them and truly understand how they work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分以及整个课程中，你将会有很多练习机会，我们将多次回顾每个概念，以确保你熟悉它们，并真正理解它们是如何工作的。
- en: Towards the end of this chapter we'll explain *why* Rust's ownership system
    is designed the way it is. For the time being, focus on understanding the *how*.
    Take each compiler error as a learning opportunity!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将解释 Rust 所有权系统**为什么**被设计成这样。目前，专注于理解**如何**。将每个编译器错误视为一个学习机会！
- en: '[Exercise](#exercise)'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`03_ticket_v1/06_ownership`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/06_ownership)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`03_ticket_v1/06_ownership`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/06_ownership)
- en: '* * *'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This is a great mental model to start out, but it doesn't capture the *full*
    picture. We'll refine our understanding of references [later in the course](/100-exercises/07_threads/06_interior_mutability).
    [↩](#fr-refine-1)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个很好的起点，但它并没有捕捉到**完整**的图景。我们将在课程[稍后](/100-exercises/07_threads/06_interior_mutability)进一步细化对引用的理解。[↩](#fr-refine-1)

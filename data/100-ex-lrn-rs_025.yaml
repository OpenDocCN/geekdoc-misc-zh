- en: Destructors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 析构函数
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html](https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html](https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html)
- en: When introducing the heap, we mentioned that you're responsible for freeing
    the memory you allocate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当引入堆时，我们提到你需要释放你分配的内存。
- en: When introducing the borrow-checker, we also stated that you rarely have to
    manage memory directly in Rust.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当引入借用检查器时，我们也指出在 Rust 中你很少需要直接管理内存。
- en: These two statements might seem contradictory at first. Let's see how they fit
    together by introducing **scopes** and **destructors**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个陈述一开始可能看起来有些矛盾。让我们通过引入**作用域**和**析构函数**来了解它们是如何结合在一起的。
- en: '[Scopes](#scopes)'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[作用域](#scopes)'
- en: The **scope** of a variable is the region of Rust code where that variable is
    valid, or **alive**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的**作用域**是 Rust 代码中该变量有效或**存活**的区域。
- en: 'The scope of a variable starts with its declaration. It ends when one of the
    following happens:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域从其声明开始。它结束于以下情况之一：
- en: the block (i.e. the code between `{}`) where the variable was declared ends
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明变量的块（即 `{}` 之间的代码）结束
- en: '[PRE0]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ownership of the variable is transferred to someone else (e.g. a function or
    another variable)
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的所有权被转移给其他人（例如一个函数或另一个变量）
- en: '[PRE1]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Destructors](#destructors-1)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[析构函数](#destructors-1)'
- en: When the owner of a value goes out of scope, Rust invokes its **destructor**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当值的所有者超出作用域时，Rust 会调用其**析构函数**。
- en: The destructor tries to clean up the resources used by that value—in particular,
    whatever memory it allocated.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数试图清理该值使用的资源——特别是它分配的任何内存。
- en: You can manually invoke the destructor of a value by passing it to `std::mem::drop`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将其传递给 `std::mem::drop` 来手动调用值的析构函数。
- en: That's why you'll often hear Rust developers saying "that value has been **dropped**"
    as a way to state that a value has gone out of scope and its destructor has been
    invoked.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是为什么你经常会听到 Rust 开发者说“那个值已经被**释放**”作为一种方式来表明一个值已经超出作用域并且其析构函数已被调用。
- en: '[Visualizing drop points](#visualizing-drop-points)'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[可视化掉落点](#visualizing-drop-points)'
- en: 'We can insert explicit calls to `drop` to "spell out" what the compiler does
    for us. Going back to the previous example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以插入显式的 `drop` 调用来“说明”编译器为我们做的事情。回到之前的例子：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s equivalent to:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它相当于：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s look at the second example instead, where `s`''s ownership is transferred
    to `compute`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二个例子，其中 `s` 的所有权被传递给 `compute`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s equivalent to this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它相当于这样：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice the difference: even though `s` is no longer valid after `compute` is
    called in `main`, there is no `drop(s)` in `main`. When you transfer ownership
    of a value to a function, you''re also **transferring the responsibility of cleaning
    it up**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意区别：尽管在 `main` 中调用 `compute` 之后 `s` 就不再有效，但在 `main` 中没有 `drop(s)`。当你将一个值的所有权传递给一个函数时，你也在**转移清理它的责任**。
- en: This ensures that the destructor for a value is called **at most^([1](#footnote-leak))
    once**, preventing [double free bugs](https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory)
    by design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了值的析构函数最多被调用一次，通过设计防止了[双重释放漏洞](https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory)。
- en: '[Use after drop](#use-after-drop)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用释放后](#use-after-drop)'
- en: What happens if you try to use a value after it's been dropped?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在释放之后使用一个值会发生什么？
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you try to compile this code, you''ll get an error:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译此代码，你会得到一个错误：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Drop **consumes** the value it's called on, meaning that the value is no longer
    valid after the call.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Drop **消耗** 被调用时的值，这意味着调用之后该值就不再有效。
- en: The compiler will therefore prevent you from using it, avoiding [use-after-free
    bugs](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将因此阻止你使用它，避免[使用已释放内存的漏洞](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)。
- en: '[Dropping references](#dropping-references)'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[释放引用](#dropping-references)'
- en: What if a variable contains a reference?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量包含一个引用怎么办？
- en: 'For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you call `drop(y)`... nothing happens.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `drop(y)`... 没有发生任何事情。
- en: 'If you actually try to compile this code, you''ll get a warning:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实际上尝试编译此代码，你会得到一个警告：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It goes back to what we said earlier: we only want to call the destructor once.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这回到了我们之前所说的：我们只想调用析构函数一次。
- en: 'You can have multiple references to the same value—if we called the destructor
    for the value they point at when one of them goes out of scope, what would happen
    to the others? They would refer to a memory location that''s no longer valid:
    a so-called [**dangling pointer**](https://en.wikipedia.org/wiki/Dangling_pointer),
    a close relative of [**use-after-free bugs**](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).
    Rust''s ownership system rules out these kinds of bugs by design.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对同一个值有多个引用——如果我们在一个引用超出作用域时调用它们指向的值的析构函数，会发生什么？它们会引用一个不再有效的内存位置：所谓的[**悬垂指针**](https://en.wikipedia.org/wiki/Dangling_pointer)，它是[**使用后释放漏洞**](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)的近亲。Rust
    的所有权系统通过设计排除了这类漏洞。
- en: '[Exercise](#exercise)'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`03_ticket_v1/11_destructor`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/11_destructor)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`03_ticket_v1/11_destructor`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/11_destructor)
- en: '* * *'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Rust doesn't guarantee that destructors will run. They won't, for example, if
    you explicitly choose to [leak memory](/100-exercises/07_threads/03_leak). [↩](#fr-leak-1)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rust 不保证析构函数会运行。例如，如果你明确选择[泄露内存](/100-exercises/07_threads/03_leak)，它们就不会运行。[↩](#fr-leak-1)

- en: Simulating an Interpreter by Hand
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ‰‹åŠ¨æ¨¡æ‹Ÿè§£é‡Šå™¨
- en: Since we have decided to write an interpreter, letâ€™s start by understanding
    whatwe are trying to get it to do, before we start to investigate howÂ we will
    make it do it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬å·²ç»å†³å®šç¼–å†™ä¸€ä¸ªè§£é‡Šå™¨ï¼Œè®©æˆ‘ä»¬é¦–å…ˆäº†è§£æˆ‘ä»¬æƒ³è¦è®©å®ƒåšä»€ä¹ˆï¼Œç„¶åå†å»ç ”ç©¶æˆ‘ä»¬å°†å¦‚ä½•è®©å®ƒåšåˆ°è¿™ä¸€ç‚¹ã€‚
- en: 'Letâ€™s consider the following program:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹ç¨‹åºï¼š
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What does it produce? We can all guess that it produces `3`. Now suppose weâ€™re
    asked, whydoes it produce `3`? What might you say?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä¼šäº§ç”Ÿä»€ä¹ˆï¼Ÿæˆ‘ä»¬éƒ½å¯ä»¥çŒœåˆ°å®ƒä¼šäº§ç”Ÿ `3`ã€‚ç°åœ¨å‡è®¾æˆ‘ä»¬è¢«é—®åŠï¼Œä¸ºä»€ä¹ˆå®ƒä¼šäº§ç”Ÿ `3`ï¼Ÿä½ å¯èƒ½ä¼šè¯´ä»€ä¹ˆï¼Ÿ
- en: 'Thereâ€™s a good chance youâ€™ll say that itâ€™s because x gets replaced with 2 in
    the body of f, then we compute the body, and thatâ€™s the answer:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å¾ˆå¤§å¯èƒ½æ€§ä½ ä¼šè¯´è¿™æ˜¯å› ä¸º x åœ¨ f çš„ä¸»ä½“ä¸­è¢«æ›¿æ¢æˆäº† 2ï¼Œç„¶åæˆ‘ä»¬è®¡ç®—ä¸»ä½“ï¼Œè¿™å°±æ˜¯ç­”æ¡ˆï¼š
- en: â†’Â `(f 2)`
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(f 2)`
- en: â†’ `(+ x 1)`where `x`is replaced by `2`
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ x 1)`å…¶ä¸­ `x` è¢«æ›¿æ¢ä¸º `2`
- en: â†’ `(+ 2 1)`
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 2 1)`
- en: â†’ `3`
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `3`
- en: 'These programs are written in Racket. You can put these programs into DrRacket
    in an early student language level (like Beginning Student) and watch them run,
    step-by-step, using the Step button in the menu bar:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç¨‹åºæ˜¯ç”¨ Racket ç¼–å†™çš„ã€‚ä½ å¯ä»¥å°†è¿™äº›ç¨‹åºæ”¾å…¥ DrRacket çš„æ—©æœŸå­¦ç”Ÿè¯­è¨€çº§åˆ«ï¼ˆå¦‚ Beginning Studentï¼‰ä¸­ï¼Œå¹¶ä½¿ç”¨èœå•æ ä¸­çš„
    Step æŒ‰é’®é€æ­¥è¿è¡Œå®ƒä»¬ï¼š
- en: '![](image21.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](image21.png)'
- en: 'Now letâ€™s look at an extended version of the program:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹ç¨‹åºçš„æ‰©å±•ç‰ˆæœ¬ï¼š
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can use the same process:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç›¸åŒçš„è¿‡ç¨‹ï¼š
- en: â†’Â `(g 5)`
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(g 5)`
- en: â†’ (`f (+ z 4))`where `z`is replaced by `5`
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(f (+ z 4))`å…¶ä¸­ `z` è¢«æ›¿æ¢ä¸º `5`
- en: â†’ `(f (+ 5 4))`
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(f (+ 5 4))`
- en: â†’ `(f 9)`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(f 9)`
- en: â†’ `(+ x 1)`where `x`is replaced by `9`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ x 1)`å…¶ä¸­ `x` è¢«æ›¿æ¢ä¸º `9`
- en: â†’ `(+ 9 1)`
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 9 1)`
- en: â†’ `10`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `10`
- en: Terminology:We call the variables in the function header the formal parametersand
    the expressions in the function call the actual parameters. So in `f`, `x`is the
    formal parameter, while `9`is an actual parameter. Some people also use argumentin
    place of parameter, but thereâ€™s no real difference between these terms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¯è¯­ï¼šæˆ‘ä»¬ç§°å‡½æ•°å¤´ä¸­çš„å˜é‡ä¸ºå½¢å¼å‚æ•°ï¼Œå‡½æ•°è°ƒç”¨ä¸­çš„è¡¨è¾¾å¼ä¸ºå®é™…å‚æ•°ã€‚æ‰€ä»¥ï¼Œåœ¨ `f` ä¸­ï¼Œ`x` æ˜¯å½¢å¼å‚æ•°ï¼Œè€Œ `9` æ˜¯å®é™…å‚æ•°ã€‚æœ‰äº›äººä¹Ÿç”¨ argumentï¼ˆè®ºå…ƒï¼‰ä»£æ›¿
    parameterï¼ˆå‚æ•°ï¼‰ï¼Œä½†è¿™äº›æœ¯è¯­ä¹‹é—´æ²¡æœ‰çœŸæ­£çš„åŒºåˆ«ã€‚
- en: 'Observe that we had a choice: we could have gone either'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„æˆ‘ä»¬æœ‰ä¸€ä¸ªé€‰æ‹©ï¼šæˆ‘ä»¬å¯ä»¥é€‰æ‹©
- en: â†’ `(f (+ 5 4))`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(f (+ 5 4))`
- en: â†’ `(f 9)`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(f 9)`
- en: or
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…
- en: â†’ `(f (+ 5 4))`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(f (+ 5 4))`
- en: â†’ `(+ x 1)`where `x`is replaced by `(+ 5 4)`
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ x 1)`å…¶ä¸­ `x` è¢«æ›¿æ¢ä¸º `(+ 5 4)`
- en: For now, both will produce the same answer, but this is actually a very consequential
    decision! It is in fact one of the most profound choices in programming language
    design.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰ï¼Œè¿™ä¸¤ä¸ªéƒ½ä¼šäº§ç”Ÿç›¸åŒçš„ç­”æ¡ˆï¼Œä½†è¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„å†³å®šï¼è¿™å®é™…ä¸Šæ˜¯åœ¨ç¼–ç¨‹è¯­è¨€è®¾è®¡ä¸­æœ€é‡è¦çš„é€‰æ‹©ä¹‹ä¸€ã€‚
- en: 'Terminology:The former choice is called eagerevaluation: think of it as â€œeagerlyâ€
    reducing the actual parameter to a value before starting the function call. The
    latter choice is called lazyÂ evaluation: think of it as not rushing to perform
    the evaluation.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¯è¯­ï¼šå‰è€…è¢«ç§°ä¸º eager evaluationï¼ˆæ€¥åˆ‡æ±‚å€¼ï¼‰ï¼šæŠŠå®ƒæƒ³è±¡æˆåœ¨å¼€å§‹å‡½æ•°è°ƒç”¨ä¹‹å‰â€œæ€¥åˆ‡â€åœ°å°†å®é™…å‚æ•°å‡å°‘åˆ°å€¼ã€‚åè€…è¢«ç§°ä¸º lazy evaluationï¼ˆæƒ°æ€§æ±‚å€¼ï¼‰ï¼šæŠŠå®ƒæƒ³è±¡æˆä¸æ€¥äºæ‰§è¡Œè¯„ä¼°ã€‚
- en: SMoL is eager. There are good reasons for this, which we will explore later
    [[ğŸ‘‰](PLAIVersion3.2.2_split_151.html#h.9cpi3w9pvb34)].
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SMoL æ˜¯ eagerï¼ˆæ€¥åˆ‡ï¼‰ã€‚è¿™æœ‰å¾ˆå¥½çš„ç†ç”±ï¼Œæˆ‘ä»¬å°†åœ¨åé¢æ¢è®¨ [[ğŸ‘‰](PLAIVersion3.2.2_split_151.html#h.9cpi3w9pvb34)]ã€‚
- en: 'Okay, so back to evaluation. Letâ€™s do one more step:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œæ‰€ä»¥å›åˆ°è¯„ä¼°ã€‚è®©æˆ‘ä»¬å†èµ°ä¸€æ­¥ï¼š
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once again, we can look at the steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹çœ‹è¿™äº›æ­¥éª¤ï¼š
- en: â†’Â `(h 6 7)`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(h 6 7)`
- en: â†’ (+ `(g z) (g w))`where `z`is replaced by `6`and `w`is replaced by `7`
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ (g z) (g w))`å…¶ä¸­ `z` è¢«æ›¿æ¢ä¸º `6` å’Œ `w` è¢«æ›¿æ¢ä¸º `7`
- en: â†’ `(+ (g 6) (g 7))`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ (g 6) (g 7))`
- en: â†’ `(+ (f (+ y 4)) (g 7))`where `y`is replaced by `6`
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ (f (+ y 4)) (g 7))`å…¶ä¸­ `y` è¢«æ›¿æ¢ä¸º `6`
- en: â†’ `(+ (f (+ 6 4)) (g 7))`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ (f (+ 6 4)) (g 7))`
- en: â†’ `(+ (f 10) (g 7))`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ (f 10) (g 7))`
- en: â†’ `(+ (+ x 1) (g 7))`where `x`is replaced by `10`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ (+ x 1) (g 7))`å…¶ä¸­ `x` è¢«æ›¿æ¢ä¸º `10`
- en: â†’ `(+ (+ 10 1) (g 7))`
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ (+ 10 1) (g 7))`
- en: â†’ `(+ 11 (g 7))`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 11 (g 7))`
- en: â†’ `(+ 11 (f (+ y 4)))`where `y`is replaced by `7`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 11 (f (+ y 4)))`å…¶ä¸­ `y` è¢«æ›¿æ¢ä¸º `7`
- en: â†’ `(+ 11 (f (+ 7 4)))`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 11 (f (+ 7 4)))`
- en: â†’ `(+ 11 (f 11))`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 11 (f 11))`
- en: â†’ `(+ 11 (+ x 1))`where `x`is replaced by `11`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 11 (+ x 1))`å…¶ä¸­ `x` è¢«æ›¿æ¢ä¸º `11`
- en: â†’ `(+ 11 (+ 11 1))`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 11 (+ 11 1))`
- en: â†’ `(+ 11 12)`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `(+ 11 12)`
- en: â†’ `23`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ `23`
- en: 'Observe that we again had some choices:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„æˆ‘ä»¬å†æ¬¡æœ‰ä¸€äº›é€‰æ‹©ï¼š
- en: Do we replace both calls at once, or do one at a time?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ˜¯ä¸€æ¬¡æ›¿æ¢ä¸¤ä¸ªè°ƒç”¨ï¼Œè¿˜æ˜¯é€ä¸ªæ›¿æ¢ï¼Ÿ
- en: If the latter, do we do the left or the right one first?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ˜¯åè€…ï¼Œæˆ‘ä»¬æ˜¯å…ˆåšå·¦è¾¹çš„è¿˜æ˜¯å³è¾¹çš„ï¼Ÿ
- en: 'Languages have to make decisions about these, too! Above, weâ€™ve again done
    what SMoL does: it finishes one call before starting the other, which makes SMoL
    sequential. Had we replaced both calls at once, weâ€™d be exploring a parallelÂ language.
    Conventionally, most languages choose a left-to-right order, so thatâ€™s what we
    choose in SMoL.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¯­è¨€ä¹Ÿéœ€è¦åœ¨è¿™äº›æ–¹é¢åšå‡ºå†³å®šï¼ä¸Šé¢ï¼Œæˆ‘ä»¬åˆåšäº†SMoLæ‰€åšçš„äº‹æƒ…ï¼šåœ¨å¼€å§‹ä¸‹ä¸€ä¸ªè°ƒç”¨ä¹‹å‰å®Œæˆä¸€ä¸ªè°ƒç”¨ï¼Œè¿™ä½¿å¾—SMoLæ˜¯é¡ºåºçš„ã€‚å¦‚æœæˆ‘ä»¬åŒæ—¶æ›¿æ¢è¿™ä¸¤ä¸ªè°ƒç”¨ï¼Œæˆ‘ä»¬å°±ä¼šæ¢ç´¢ä¸€ç§å¹¶è¡Œè¯­è¨€ã€‚ä¼ ç»Ÿä¸Šï¼Œå¤§å¤šæ•°è¯­è¨€é€‰æ‹©ä»å·¦åˆ°å³çš„é¡ºåºï¼Œå› æ­¤æˆ‘ä»¬åœ¨SMoLä¸­ä¹Ÿé€‰æ‹©äº†è¿™ç§é¡ºåºã€‚

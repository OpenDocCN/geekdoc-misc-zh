- en: What Is a Query Engine?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是查询引擎？
- en: 原文：[https://howqueryengineswork.com/01-what-is-a-query-engine.html](https://howqueryengineswork.com/01-what-is-a-query-engine.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://howqueryengineswork.com/01-what-is-a-query-engine.html](https://howqueryengineswork.com/01-what-is-a-query-engine.html)
- en: If you have written code to search through a list or filter items in an array,
    you have already implemented a tiny query engine. A query engine is simply software
    that retrieves and processes data based on some criteria. The difference between
    your `for` loop and a production query engine is scale, generality, and optimization,
    but the core idea is the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经编写了代码来遍历列表或过滤数组中的项目，你实际上已经实现了一个微型查询引擎。查询引擎简单来说就是根据某些标准检索和处理数据的软件。你的`for`循环和实际查询引擎之间的区别在于规模、通用性和优化，但核心思想是相同的。
- en: 'Consider this Python code that finds all students with a GPA above 3.5:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Python代码，它查找所有GPA高于3.5的学生：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is querying data. Now imagine you need to do this across millions of records
    stored in files, join data from multiple sources, group results, and compute aggregates,
    all while keeping response times reasonable. That is what query engines do.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在查询数据。现在想象你需要跨数百万条存储在文件中的记录执行此操作，从多个来源连接数据，分组结果，并计算聚合，同时保持合理的响应时间。这正是查询引擎所做的事情。
- en: '[From Code to Queries](#from-code-to-queries)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[从代码到查询](#from-code-to-queries)'
- en: The code above works, but it has limitations. What if you want to change the
    filter condition? You would need to modify and recompile the code. What if someone
    without programming experience needs to analyze the data?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是有效的，但它有限制。如果你想要更改过滤条件怎么办？你需要修改和重新编译代码。如果有人没有编程经验需要分析数据怎么办？
- en: 'Query languages like SQL solve this by providing a declarative way to express
    what data you want, without specifying how to get it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语言如SQL通过提供一种声明式的方式来表达你想要的数据，而不需要指定如何获取它：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This query expresses the same logic as our Python loop, but the query engine
    decides how to execute it efficiently. This separation of “what” from “how” is
    powerful. The same query can run against a small file or a distributed cluster
    of servers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询表达了我们Python循环中的相同逻辑，但查询引擎决定如何高效地执行它。这种“是什么”与“如何做”的分离非常强大。相同的查询可以运行在小型文件或分布式服务器集群上。
- en: '[Anatomy of a Query Engine](#anatomy-of-a-query-engine)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[查询引擎的解剖结构](#anatomy-of-a-query-engine)'
- en: 'A query engine transforms a query (like the SQL above) into actual results
    through several stages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查询引擎通过几个阶段将查询（如上面的SQL）转换为实际结果：
- en: 'Parsing: Convert the query text into a structured representation (like an abstract
    syntax tree)'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析：将查询文本转换为结构化表示（如抽象语法树）
- en: 'Planning: Determine which operations are needed (scan, filter, join, aggregate)'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规划：确定需要的操作（扫描、过滤、连接、聚合）
- en: 'Optimization: Reorder and transform operations for efficiency'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化：重新排序和转换操作以提高效率
- en: 'Execution: Actually process the data and produce results'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行：实际上处理数据并产生结果
- en: This pipeline might remind you of a compiler, and that is no coincidence. Query
    engines are essentially specialized compilers that translate declarative queries
    into efficient execution plans.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道可能会让你想起编译器，这并非巧合。查询引擎本质上是一种专门的编译器，它将声明式查询转换为高效的执行计划。
- en: '[A Concrete Example](#a-concrete-example)'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[一个具体的例子](#a-concrete-example)'
- en: 'Let us look at a slightly more complex query:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个稍微复杂一点的查询：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This query:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询：
- en: Scans the `employees` table
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描`employees`表
- en: Filters to only recent hires
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只过滤最近雇佣的员工
- en: Groups employees by department
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按部门分组员工
- en: Computes the average salary per department
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个部门的平均工资
- en: Sorts results by that average
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按平均工资排序结果
- en: A query engine must determine the most efficient way to execute these operations.
    Should it filter before or after grouping? How should it store intermediate results?
    These decisions significantly impact performance, especially with large datasets.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查询引擎必须确定执行这些操作的最有效方式。应该在分组之前还是之后进行过滤？应该如何存储中间结果？这些决策对性能有重大影响，尤其是在大数据集上。
- en: '[SQL: The Universal Query Language](#sql-the-universal-query-language)'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[SQL：通用的查询语言](#sql-the-universal-query-language)'
- en: 'SQL (Structured Query Language) has been the dominant query language since
    the 1970s. You will encounter it in:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SQL（结构化查询语言）自20世纪70年代以来一直是主导的查询语言。你将在以下场景中遇到它：
- en: Relational databases (PostgreSQL, MySQL, SQLite)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库（PostgreSQL、MySQL、SQLite）
- en: Data warehouses (Snowflake, BigQuery, Redshift)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据仓库（Snowflake、BigQuery、Redshift）
- en: Big data systems (Apache Spark, Presto, Hive)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大数据系统（Apache Spark、Presto、Hive）
- en: Even embedded analytics (DuckDB)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是嵌入式分析（DuckDB）
- en: 'Here are two more examples showing SQL’s expressiveness:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有两个示例展示了 SQL 的表达能力：
- en: 'Finding the top 5 most visited pages yesterday:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 找到昨天访问量最高的前5个页面：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Calculating month-over-month growth:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 计算月度增长：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Beyond SQL: DataFrame APIs](#beyond-sql-dataframe-apis)'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[超越 SQL：DataFrame API](#beyond-sql-dataframe-apis)'
- en: Whilst SQL is ubiquitous, many query engines also provide programmatic APIs.
    These are especially popular in data science where queries are often built dynamically
    or mixed with custom code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQL 应用广泛，但许多查询引擎也提供了程序化 API。这些 API 在数据科学中特别受欢迎，因为查询通常动态构建或与自定义代码混合使用。
- en: 'Here is the same query expressed using Apache Spark’s DataFrame API in Scala:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 Apache Spark 的 DataFrame API 在 Scala 中表达相同查询的示例：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The DataFrame API provides the same logical operations as SQL but expressed
    as method calls. Under the hood, both approaches generate the same query plan.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame API 提供了与 SQL 相同的逻辑操作，但以方法调用的形式表达。在底层，这两种方法生成相同的查询计划。
- en: '[Why Build a Query Engine?](#why-build-a-query-engine)'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[为什么构建查询引擎？](#why-build-a-query-engine)'
- en: 'Understanding query engines helps you:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理解查询引擎有助于你：
- en: Write better queries, because knowing how queries execute helps you write efficient
    ones
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写更好的查询，因为了解查询的执行方式有助于你编写高效的查询
- en: Debug performance issues, because understanding the optimizer helps diagnose
    slow queries
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试性能问题，因为理解优化器有助于诊断慢查询
- en: Appreciate database internals, because query engines are at the heart of every
    database
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏数据库内部结构，因为查询引擎是每个数据库的核心
- en: Build data tools, because many applications need query-like functionality
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建数据工具，因为许多应用程序需要类似查询的功能
- en: 'Query engines also touch many areas of computer science: parsing and compilers,
    data structures, algorithms, distributed systems, and optimization. Building one
    is excellent practice.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查询引擎还涉及计算机科学的许多领域：解析器和编译器、数据结构、算法、分布式系统和优化。构建一个查询引擎是极佳的实践。
- en: '[What This Book Covers](#what-this-book-covers)'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[本书涵盖的内容](#what-this-book-covers)'
- en: 'This book walks through building a complete query engine from scratch. We will
    implement:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书从零开始构建完整的查询引擎。我们将实现：
- en: A type system for representing data
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于表示数据的类型系统
- en: Data source connectors for reading files
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于读取文件的源数据连接器
- en: Logical and physical query plans
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑和物理查询计划
- en: A SQL parser and planner
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 解析器和规划器
- en: Query optimization rules
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询优化规则
- en: Parallel and distributed execution
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行和分布式执行
- en: The query engine (called KQuery) is intentionally simple, optimized for learning
    rather than production use. But the concepts apply directly to real systems like
    Apache Spark, Presto, and DataFusion.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 查询引擎（称为 KQuery）故意设计得简单，优化用于学习而非生产使用。但这些概念直接适用于像 Apache Spark、Presto 和 DataFusion
    这样的真实系统。
- en: '*This book is also available for purchase in ePub, MOBI, and PDF format from
    [https://leanpub.com/how-query-engines-work](https://leanpub.com/how-query-engines-work)*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书也以 ePub、MOBI 和 PDF 格式在 [https://leanpub.com/how-query-engines-work](https://leanpub.com/how-query-engines-work)
    上提供购买。*'
- en: '**Copyright © 2020-2025 Andy Grove. All rights reserved.**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**版权所有 © 2020-2025 安迪·格鲁夫。保留所有权利。**'

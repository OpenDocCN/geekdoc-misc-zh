- en: Terminology
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语
- en: 'It is common, on the Web, to read people speak of “interpreted languages” and
    “compiled languages”. These terms are nonsense. That isn’t just a judgment; that’s
    a literal statement: they do not make sense. Interpretation and compilation are
    techniques one uses to evaluate programs. A language (almost) never specifies
    how it should be evaluated. As a result, each implementer is free to choose whatever
    strategy they want.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，人们常常提到“解释型语言”和“编译型语言”。这些术语是没有意义的。这不仅仅是一种判断，而是一个字面上的陈述：它们没有意义。解释和编译是人们用来评估程序的技术。一种语言（几乎）从不指定应该如何评估。因此，每个实现者都可以自由选择他们想要的任何策略。
- en: Just as an example, C is often chosen as a canonically “compiled language”,
    while Scheme is often presented as an “interpreted language”. However, there have
    been (a handful of) interpreters for C; indeed, I used one when I first learned
    C. Likewise, there are numerous compilers for Scheme; I used one when I first
    learned Scheme. Python has several interpreters and compilers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，C通常被选为规范上的“编译型语言”，而Scheme通常被描述为“解释型语言”。然而，C也有（少数）解释器；实际上，我第一次学习C时就是用的一个。同样，Scheme也有许多编译器；我第一次学习Scheme时也使用了一个。Python有几个解释器和编译器。
- en: Furthermore, this seemingly hard distinction is frequently broken down in practice.
    Many languages now have a “JIT”, which stands for just-in-time compilation. That
    is, the evaluator starts out as an interpreter. If it finds itself interpreting
    the same code over and over, it compiles it and uses the compiled code instead.
    When and how to do this is a complex and fascinating topic, but it makes clear
    that the distinction is not a bright line.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种看似明显的区分在实践中经常被打破。许多语言现在都有“即时编译”（JIT），即即时编译。也就是说，评估者最初是一个解释器。如果它发现自己反复解释相同的代码，它就会编译它，并使用编译后的代码。何时以及如何这样做是一个复杂而有趣的话题，但它清楚地表明这种区分并不是一条明确的界限。
- en: Some people are confused by the interfacethat an implementation presents. Many
    languages provide a read-eval-print loop(REPL), i.e., an interactive interface.
    It is often easier for an interpreter to do this. However, many systems with such
    an interface accept code at a prompt, compile it, run it, and present the answer
    back to the user; they mask all these steps. Therefore, the interface is not an
    indicator of what kind of implementation you are seeing. It is perhaps meaningful
    to refer to an implementation as “interactive” or “non-interactive”, but that
    is not a reflection of the underlying language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人被实现提供的界面所困惑。许多语言提供读取-评估-打印循环（REPL），即交互式界面。对于解释器来说，这样做通常更容易。然而，许多具有这种界面的系统会在提示符处接受代码，编译它，运行它，并将答案返回给用户；它们掩盖了所有这些步骤。因此，界面并不是你所看到的实现类型的指示器。将实现称为“交互式”或“非交互式”可能是有意义的，但这并不是对底层语言的反映。
- en: 'In short, please remember:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，请记住：
- en: (Most) Languages do not dictate implementations. Different platforms and other
    considerations dictate what implementation to use.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （大多数）语言并不规定实现方式。不同的平台和其他考虑因素决定了使用哪种实现方式。
- en: Implementations usually use one of two major strategies—interpretation and compilation—but
    many are also hybrids of these.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现通常使用两种主要策略之一——解释和编译——但许多也是这些策略的混合体。
- en: A specific implementation may offer an interactive or non-interactive interface.
    However, this does not automatically reveal the underlying implementation strategy.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的实现可能提供交互式或非交互式界面。然而，这并不自动揭示其背后的实现策略。
- en: Therefore, the terms “interpreted language” and “compiled language” are nonsensical.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，“解释型语言”和“编译型语言”这两个术语是没有意义的。

- en: The Design Space of Conditionals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ¡ä»¶è¯­å¥çš„è®¾è®¡ç©ºé—´
- en: 'Even the simplest conditional exposes us to many variations in language design.
    The intent is that test-expression is evaluated first; if it results in a true
    value then (only) the then-expression is evaluated, else (only) the else-expression
    is evaluated. (We usually refer to these two parts as branches, since the programâ€™s
    control must take one or the other.) However, even this simple construct results
    in at least three different, mostly independent design decisions:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿æ˜¯æœ€ç®€å•çš„æ¡ä»¶è¯­å¥ä¹Ÿæš´éœ²äº†è¯­è¨€è®¾è®¡ä¸­è®¸å¤šä¸åŒçš„å˜ä½“ã€‚å…¶æ„å›¾æ˜¯é¦–å…ˆè¯„ä¼°æµ‹è¯•è¡¨è¾¾å¼ï¼›å¦‚æœç»“æœæ˜¯çœŸå€¼ï¼Œé‚£ä¹ˆï¼ˆä»…ï¼‰è¯„ä¼°thenè¡¨è¾¾å¼ï¼Œå¦åˆ™ï¼ˆä»…ï¼‰è¯„ä¼°elseè¡¨è¾¾å¼ã€‚ï¼ˆæˆ‘ä»¬é€šå¸¸å°†è¿™ä¸¤éƒ¨åˆ†ç§°ä¸ºåˆ†æ”¯ï¼Œå› ä¸ºç¨‹åºçš„æ§åˆ¶å¿…é¡»é‡‡å–å…¶ä¸­ä¹‹ä¸€ã€‚ï¼‰ç„¶è€Œï¼Œå³ä½¿è¿™ä¸ªç®€å•çš„ç»“æ„ä¹Ÿå¯¼è‡´äº†è‡³å°‘ä¸‰ä¸ªä¸åŒçš„ã€ä¸»è¦ç‹¬ç«‹çš„è®¾è®¡å†³ç­–ï¼š
- en: What kind of values can the test-expression be? In some languages they must
    be Boolean values (two values, one representing truth and the other falsehood).
    In other languages this expression can evaluate to just about any value, with
    some setâ€”colloquially called truthyâ€”representing truth (i.e., they result in execution
    of the then-expression) while the remaining ones are falsy, meaning they cause
    the else-expression to run.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æµ‹è¯•è¡¨è¾¾å¼å¯ä»¥æ˜¯å“ªç§ç±»å‹çš„å€¼ï¼Ÿåœ¨ä¸€äº›è¯­è¨€ä¸­ï¼Œå®ƒä»¬å¿…é¡»æ˜¯å¸ƒå°”å€¼ï¼ˆä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªä»£è¡¨çœŸï¼Œå¦ä¸€ä¸ªä»£è¡¨å‡ï¼‰ã€‚åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œè¿™ä¸ªè¡¨è¾¾å¼å¯ä»¥è¯„ä¼°ä¸ºå‡ ä¹ä»»ä½•å€¼ï¼Œå…¶ä¸­ä¸€äº›é›†åˆâ€”â€”ä¿—ç§°ä¸ºçœŸå€¼â€”â€”ä»£è¡¨çœŸï¼ˆå³ï¼Œå®ƒä»¬ä¼šå¯¼è‡´æ‰§è¡Œthenè¡¨è¾¾å¼ï¼‰ï¼Œè€Œå…¶ä½™çš„åˆ™æ˜¯å‡å€¼ï¼Œæ„å‘³ç€å®ƒä»¬ä¼šå¯¼è‡´elseè¡¨è¾¾å¼æ‰§è¡Œã€‚
- en: 'Initially, it may seem attractive to design a language with several truthy
    and falsy values: after all, this appears to give the programmer more convenience,
    permitting non-Boolean-valued functions and expressions to be used in conditionals.
    However, this can lead to bewildering inconsistencies across languages:'
  id: totrans-3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: åˆå§‹æ—¶ï¼Œè®¾è®¡ä¸€ä¸ªå…·æœ‰å¤šä¸ªçœŸå€¼å’Œå‡å€¼çš„è¯­è¨€å¯èƒ½çœ‹èµ·æ¥å¾ˆæœ‰å¸å¼•åŠ›ï¼šæ¯•ç«Ÿï¼Œè¿™ä¼¼ä¹ç»™ç¨‹åºå‘˜æä¾›äº†æ›´å¤šä¾¿åˆ©ï¼Œå…è®¸éå¸ƒå°”å€¼å‡½æ•°å’Œè¡¨è¾¾å¼åœ¨æ¡ä»¶ä¸­ä½¿ç”¨ã€‚ç„¶è€Œï¼Œè¿™å¯èƒ½å¯¼è‡´è·¨è¯­è¨€ä¹‹é—´ä»¤äººå›°æƒ‘çš„ä¸ä¸€è‡´æ€§ï¼š
- en: '| Value | JavaScript | Perl | PHP | Python | Ruby |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| å€¼ | JavaScript | Perl | PHP | Python | Ruby |'
- en: '|'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '| truthy | truthy | truthy | truthy | truthy |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| çœŸå€¼ | çœŸå€¼ | çœŸå€¼ | çœŸå€¼ | çœŸå€¼ |'
- en: '|'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| falsy | falsy | falsy | falsy | truthy |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| å‡å€¼ | å‡å€¼ | å‡å€¼ | å‡å€¼ | çœŸå€¼ |'
- en: '|'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| falsy | falsy | falsy | falsy | truthy |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| å‡å€¼ | å‡å€¼ | å‡å€¼ | å‡å€¼ | çœŸå€¼ |'
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| truthy | falsy | falsy | truthy | truthy |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| çœŸå€¼ | å‡å€¼ | å‡å€¼ | çœŸå€¼ | çœŸå€¼ |'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| falsy | truthy | truthy | truthy | truthy |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| å‡å€¼ | çœŸå€¼ | çœŸå€¼ | çœŸå€¼ | çœŸå€¼ |'
- en: '| `nil`, `null`, `None`, undefined | falsy | falsy | falsy | falsy | falsy
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `nil`ã€`null`ã€`None`ã€æœªå®šä¹‰ | å‡å€¼ | å‡å€¼ | å‡å€¼ | å‡å€¼ | å‡å€¼ |'
- en: '|'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| truthy | truthy | falsy | falsy | truthy |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| çœŸå€¼ | çœŸå€¼ | å‡å€¼ | å‡å€¼ | çœŸå€¼ |'
- en: '| empty map or object | truthy | falsy | falsy | falsy | truthy |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| ç©ºæ˜ å°„æˆ–å¯¹è±¡ | çœŸå€¼ | å‡å€¼ | å‡å€¼ | å‡å€¼ | çœŸå€¼ |'
- en: 'Of course, it need not be so complex. Scheme, for instance, has only one value
    that is falsy: false itself (written as `#false`). Everyother value is truthy.
    For those who value allowing non-Boolean values in conditionals, this represents
    an elegant trade-off: it means a function need not worry that a type-consistent
    value resulting from a computation might cause a conditional to reverse itself.
    (For instance, if a function returns strings, it need not worry that the empty
    string might be treated differently from every other string.) Note that Ruby,
    which is inspired in part by Scheme, adopted this simple model. Lua, another Scheme-inspired
    language, is also spartan in its falsy values.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸å¿…å¦‚æ­¤å¤æ‚ã€‚ä¾‹å¦‚ï¼ŒSchemeè¯­è¨€åªæœ‰ä¸€ä¸ªå‡å€¼ï¼šfalseæœ¬èº«ï¼ˆå†™ä½œ`#false`ï¼‰ã€‚å…¶ä»–æ‰€æœ‰å€¼éƒ½æ˜¯çœŸå€¼ã€‚å¯¹äºé‚£äº›é‡è§†åœ¨æ¡ä»¶ä¸­å…è®¸éå¸ƒå°”å€¼çš„äººæ¥è¯´ï¼Œè¿™ä»£è¡¨äº†ä¸€ç§ä¼˜é›…çš„æƒè¡¡ï¼šè¿™æ„å‘³ç€ä¸€ä¸ªå‡½æ•°ä¸éœ€è¦æ‹…å¿ƒè®¡ç®—ç»“æœä¸­å¯èƒ½å¼•èµ·æ¡ä»¶åè½¬çš„ç±»å‹ä¸€è‡´å€¼ã€‚ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°è¿”å›å­—ç¬¦ä¸²ï¼Œå®ƒä¸éœ€è¦æ‹…å¿ƒç©ºå­—ç¬¦ä¸²å¯èƒ½ä¸å…¶ä»–å­—ç¬¦ä¸²è¢«ä¸åŒå¯¹å¾…ã€‚ï¼‰è¯·æ³¨æ„ï¼Œå—Schemeéƒ¨åˆ†å¯å‘çš„Rubyè¯­è¨€é‡‡ç”¨äº†è¿™ä¸ªç®€å•çš„æ¨¡å‹ã€‚å¦ä¸€ä¸ªå—Schemeå¯å‘çš„è¯­è¨€Luaï¼Œåœ¨å‡å€¼æ–¹é¢ä¹Ÿå¾ˆç®€æ´ã€‚
- en: 'What kind of terms are the branches? Some languages make a distinction between
    statementsand expressions; in such languages, designers need to decide which of
    these are permitted. In some languages, there are even two syntactic forms of
    conditional to reflect these two choices: e.g., in C, `if`Â uses statements (and
    does not return any value) while the â€œternary operatorâ€ (`(...?...:...)`) permits
    expressions and returns a value.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ†æ”¯æœ‰å“ªäº›æœ¯è¯­ï¼Ÿä¸€äº›è¯­è¨€åœ¨è¯­å¥å’Œè¡¨è¾¾å¼ä¹‹é—´åšå‡ºåŒºåˆ†ï¼›åœ¨è¿™äº›è¯­è¨€ä¸­ï¼Œè®¾è®¡è€…éœ€è¦å†³å®šå“ªäº›æ˜¯å…è®¸çš„ã€‚åœ¨ä¸€äº›è¯­è¨€ä¸­ï¼Œç”šè‡³æœ‰ä¸¤ç§è¯­æ³•å½¢å¼çš„æ¡ä»¶æ¥åæ˜ è¿™ä¸¤ç§é€‰æ‹©ï¼šä¾‹å¦‚ï¼Œåœ¨Cè¯­è¨€ä¸­ï¼Œ`if`ä½¿ç”¨è¯­å¥ï¼ˆå¹¶ä¸”ä¸è¿”å›ä»»ä½•å€¼ï¼‰ï¼Œè€Œâ€œä¸‰å…ƒè¿ç®—ç¬¦â€ï¼ˆ`(...?...:...)`ï¼‰å…è®¸è¡¨è¾¾å¼å¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚
- en: If the branches are expressions and hence allowed to evaluate to values, how
    do the values relate? Many (but not all) languages with static type systems expect
    the two branches to have the same type [[ğŸ‘‰](PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk)].
    Languages without static type systems usually place no restrictions.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦‚æœåˆ†æ”¯æ˜¯è¡¨è¾¾å¼å¹¶ä¸”å› æ­¤å¯ä»¥è¯„ä¼°ä¸ºå€¼ï¼Œè¿™äº›å€¼ä¹‹é—´æ˜¯å¦‚ä½•ç›¸å…³çš„ï¼Ÿè®¸å¤šï¼ˆä½†å¹¶éæ‰€æœ‰ï¼‰å…·æœ‰é™æ€ç±»å‹ç³»ç»Ÿçš„è¯­è¨€éƒ½æœŸæœ›ä¸¤ä¸ªåˆ†æ”¯å…·æœ‰ç›¸åŒçš„ç±»å‹ [[ğŸ‘‰](PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk)]ã€‚æ²¡æœ‰é™æ€ç±»å‹ç³»ç»Ÿçš„è¯­è¨€é€šå¸¸ä¸è®¾ç½®ä»»ä½•é™åˆ¶ã€‚
- en: 'Aside: While writing an earlier version of this very chapter, I stumbled on
    a strange bug in the Pyret programming language: all numeric s-expressions parsed
    as `s-num`values except `0`, which parsed as a `s-sym`. Eventually Justin Pombrio
    reported: â€œItâ€™s a silly bug with an `if`in JavaScript thatâ€™s getting `0`Â and thinking
    itâ€™s false.â€ Seems fitting.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æ—ç™½ï¼šåœ¨æ’°å†™æœ¬ç« çš„æ—©æœŸç‰ˆæœ¬æ—¶ï¼Œæˆ‘åœ¨ Pyret ç¼–ç¨‹è¯­è¨€ä¸­é‡åˆ°äº†ä¸€ä¸ªå¥‡æ€ªçš„é”™è¯¯ï¼šæ‰€æœ‰æ•°å€¼ s-è¡¨è¾¾å¼éƒ½è¢«è§£æä¸º `s-num` å€¼ï¼Œé™¤äº† `0`ï¼Œå®ƒè¢«è§£æä¸º
    `s-sym`ã€‚æœ€ç»ˆ Justin Pombrio æŠ¥å‘Šè¯´ï¼šâ€œè¿™æ˜¯ä¸€ä¸ªæ„šè ¢çš„é”™è¯¯ï¼Œåœ¨ JavaScript ä¸­çš„ `if` è¯­å¥ä¸­ï¼Œå®ƒå°† `0` è¯¯è®¤ä¸ºæ˜¯
    falseã€‚â€è¿™ä¼¼ä¹å¾ˆåˆé€‚ã€‚

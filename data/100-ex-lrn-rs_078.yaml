- en: Leaking data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泄露数据
- en: 原文：[https://rust-exercises.com/100-exercises/07_threads/03_leak.html](https://rust-exercises.com/100-exercises/07_threads/03_leak.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/07_threads/03_leak.html](https://rust-exercises.com/100-exercises/07_threads/03_leak.html)
- en: 'The main concern around passing references to spawned threads is use-after-free
    bugs: accessing data using a pointer to a memory region that''s already been freed/de-allocated.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于向生成的线程传递引用的主要担忧是使用后释放（use-after-free）错误：使用指向已释放/已重新分配的内存区域的指针访问数据。
- en: 'If you''re working with heap-allocated data, you can avoid the issue by telling
    Rust that you''ll never reclaim that memory: you choose to **leak memory**, intentionally.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理堆分配的数据，你可以通过告诉 Rust 你永远不会回收该内存来避免这个问题：你选择**泄露内存**，故意为之。
- en: 'This can be done, for example, using the `Box::leak` method from Rust''s standard
    library:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 Rust 标准库中的 `Box::leak` 方法来完成：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Data leakage is process-scoped](#data-leakage-is-process-scoped)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[数据泄露是进程范围内的](#data-leakage-is-process-scoped)'
- en: 'Leaking data is dangerous: if you keep leaking memory, you''ll eventually run
    out and crash with an out-of-memory error.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 泄露数据是危险的：如果你持续泄露内存，最终你会耗尽内存并因内存不足错误而崩溃。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the same time, memory leaked via `leak` method is not truly forgotten.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，通过 `leak` 方法泄露的内存并不是真正被遗忘的。
- en: The operating system can map each memory region to the process responsible for
    it. When the process exits, the operating system will reclaim that memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统可以将每个内存区域映射到负责它的进程。当进程退出时，操作系统将回收该内存。
- en: 'Keeping this in mind, it can be OK to leak memory when:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，当以下情况发生时，泄露内存可能是可以接受的：
- en: The amount of memory you need to leak is bounded/known upfront, or
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要泄露的内存量是有限的/事先已知的，或者
- en: Your process is short-lived and you're confident you won't exhaust all the available
    memory before it exits
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的进程是短暂的，并且你确信在它退出之前不会耗尽所有可用内存
- en: '"Let the OS deal with it" is a perfectly valid memory management strategy if
    your usecase allows for it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的用例允许，"让操作系统处理它"是一个完全有效的内存管理策略。
- en: '[Exercise](#exercise)'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`07_threads/03_leak`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`07_threads/03_leak`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak)

- en: Sync
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sync
- en: 原文：[https://rust-exercises.com/100-exercises/07_threads/14_sync.html](https://rust-exercises.com/100-exercises/07_threads/14_sync.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/07_threads/14_sync.html](https://rust-exercises.com/100-exercises/07_threads/14_sync.html)
- en: 'Before we wrap up this chapter, let''s talk about another key trait in Rust''s
    standard library: `Sync`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，让我们谈谈 Rust 标准库中的另一个关键特性：`Sync`。
- en: '`Sync` is an auto trait, just like `Send`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sync` 是一个自动特性，就像 `Send` 一样。'
- en: It is automatically implemented by all types that can be safely **shared** between
    threads.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它被所有可以在线程之间安全**共享**的类型自动实现。
- en: 'In other words: `T` is Sync if `&T` is `Send`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：如果 `&T` 是 `Send`，则 `T` 是 `Sync`。
- en: '[`T: Sync` doesn''t imply `T: Send`](#t-sync-doesnt-imply-t-send)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`T: Sync` 不意味着 `T: Send`](#t-sync-doesnt-imply-t-send)'
- en: It's important to note that `T` can be `Sync` without being `Send`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`T` 可以是 `Sync` 而不是 `Send`。
- en: 'For example: `MutexGuard` is not `Send`, but it is `Sync`.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：`MutexGuard` 不是 `Send`，但它确实是 `Sync`。
- en: It isn't `Send` because the lock must be released on the same thread that acquired
    it, therefore we don't want `MutexGuard` to be dropped on a different thread.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是 `Send`，因为锁必须在获取它的同一个线程上释放，所以我们不希望 `MutexGuard` 在不同的线程上被丢弃。
- en: But it is `Sync`, because giving a `&MutexGuard` to another thread has no impact
    on where the lock is released.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但它是 `Sync`，因为将 `&MutexGuard` 传递给另一个线程不会影响锁释放的位置。
- en: '[`T: Send` doesn''t imply `T: Sync`](#t-send-doesnt-imply-t-sync)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`T: Send` 不意味着 `T: Sync`](#t-send-doesnt-imply-t-sync)'
- en: 'The opposite is also true: `T` can be `Send` without being `Sync`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也是真的：`T` 可以是 `Send` 而不是 `Sync`。
- en: 'For example: `RefCell<T>` is `Send` (if `T` is `Send`), but it is not `Sync`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：`RefCell<T>` 是 `Send`（如果 `T` 是 `Send`），但它不是 `Sync`。
- en: '`RefCell<T>` performs runtime borrow checking, but the counters it uses to
    track borrows are not thread-safe. Therefore, having multiple threads holding
    a `&RefCell` would lead to a data race, with potentially multiple threads obtaining
    mutable references to the same data. Hence `RefCell` is not `Sync`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`RefCell<T>` 执行运行时借用检查，但它用来跟踪借用的计数器不是线程安全的。因此，多个线程持有 `&RefCell` 会导致数据竞争，可能多个线程会获得对同一数据的可变引用。因此
    `RefCell` 不是 `Sync`。'
- en: '`Send` is fine, instead, because when we send a `RefCell` to another thread
    we''re not leaving behind any references to the data it contains, hence no risk
    of concurrent mutable access.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send` 是可以的，相反，因为当我们将一个 `RefCell` 发送到另一个线程时，我们没有留下对它包含的数据的任何引用，因此没有并发可变访问的风险。'
- en: '[Exercise](#exercise)'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`07_threads/14_sync`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/14_sync)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于 [07_threads/14_sync](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/14_sync)

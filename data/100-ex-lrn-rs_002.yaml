- en: Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法
- en: 原文：[https://rust-exercises.com/100-exercises/01_intro/01_syntax.html](https://rust-exercises.com/100-exercises/01_intro/01_syntax.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/01_intro/01_syntax.html](https://rust-exercises.com/100-exercises/01_intro/01_syntax.html)
- en: Don't jump ahead!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不要急于求成！
- en: Complete the exercise for the previous section before you start this one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这一部分之前，请完成上一部分的练习。
- en: It's located in `exercises/01_intro/00_welcome`, in the [course GitHub's repository](https://github.com/mainmatter/100-exercises-to-learn-rust).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它位于 `exercises/01_intro/00_welcome`，在 [课程 GitHub 仓库](https://github.com/mainmatter/100-exercises-to-learn-rust)
    中。
- en: Use [`wr`](/100-exercises/01_intro/00_welcome#wr-the-workshop-runner) to start
    the course and verify your solutions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wr`（/100-exercises/01_intro/00_welcome#wr-the-workshop-runner）开始课程并验证你的解决方案。
- en: The previous task doesn't even qualify as an exercise, but it already exposed
    you to quite a bit of Rust **syntax**. We won't cover every single detail of Rust's
    syntax used in the previous exercise. Instead, we'll cover *just enough* to keep
    going without getting stuck in the details.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的任务甚至不算是练习，但它已经让你接触到了相当多的 Rust **语法**。我们不会涵盖之前练习中使用的 Rust 语法的每一个细节。相反，我们将只涵盖
    *足够多* 的内容，以便在不陷入细节的情况下继续前进。
- en: One step at a time!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一步一步来！
- en: '[Comments](#comments)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[注释](#comments)'
- en: 'You can use `//` for single-line comments:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `//` 进行单行注释：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Functions](#functions)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[函数](#functions)'
- en: Functions in Rust are defined using the `fn` keyword, followed by the function's
    name, its input parameters, and its return type. The function's body is enclosed
    in curly braces `{}`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的函数使用 `fn` 关键字定义，后跟函数名称、输入参数和返回类型。函数体被大括号 `{}` 包围。
- en: 'In previous exercise, you saw the `greeting` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，你看到了 `greeting` 函数：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`greeting` has no input parameters and returns a reference to a string slice
    (`&''static str`).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting` 没有输入参数，并返回一个字符串切片的引用 (`&''static str`)。'
- en: '[Return type](#return-type)'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[返回类型](#return-type)'
- en: 'The return type can be omitted from the signature if the function doesn''t
    return anything (i.e. if it returns `()`, Rust''s unit type). That''s what happened
    with the `test_welcome` function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数不返回任何内容（即返回 Rust 的单元类型 `()`），则可以省略返回类型。这就是 `test_welcome` 函数的情况：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The above is equivalent to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码等同于：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Returning values](#returning-values)'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[返回值](#returning-values)'
- en: 'The last expression in a function is implicitly returned:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的最后一个表达式会隐式返回：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also use the `return` keyword to return a value early:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `return` 关键字来提前返回一个值：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is considered idiomatic to omit the `return` keyword when possible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下省略 `return` 关键字被认为是惯用的。
- en: '[Input parameters](#input-parameters)'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[输入参数](#input-parameters)'
- en: Input parameters are declared inside the parentheses `()` that follow the function's
    name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数在函数名称后面的圆括号 `()` 内声明。
- en: Each parameter is declared with its name, followed by a colon `:`, followed
    by its type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都通过其名称、冒号 `:` 和其类型来声明。
- en: 'For example, the `greet` function below takes a `name` parameter of type `&str`
    (a "string slice"):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的 `greet` 函数接受一个类型为 `&str`（“字符串切片”）的 `name` 参数：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If there are multiple input parameters, they must be separated with commas.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个输入参数，它们必须用逗号分隔。
- en: '[Type annotations](#type-annotations)'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[类型注解](#type-annotations)'
- en: 'Since we''ve been mentioned "types" a few times, let''s state it clearly: Rust
    is a **statically typed language**.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经多次提到“类型”，让我们明确指出：Rust 是一种 **静态类型语言**。
- en: Every single value in Rust has a type and that type must be known to the compiler
    at compile-time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的每个值都有一个类型，并且这个类型必须在编译时为编译器所知。
- en: Types are a form of **static analysis**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是一种 **静态分析** 的形式。
- en: You can think of a type as a **tag** that the compiler attaches to every value
    in your program. Depending on the tag, the compiler can enforce different rules—e.g.
    you can't add a string to a number, but you can add two numbers together. If leveraged
    correctly, types can prevent whole classes of runtime bugs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将类型视为编译器附加到程序中每个值的 **标签**。根据标签，编译器可以强制执行不同的规则——例如，你不能将字符串加到数字上，但你可以将两个数字相加。如果正确利用，类型可以防止整个类别的运行时错误。
- en: '[Exercise](#exercise)'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`01_intro/01_syntax`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于 [01_intro/01_syntax](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax)

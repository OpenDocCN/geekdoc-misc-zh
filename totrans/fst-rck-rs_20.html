<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>There Can Be Only One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>There Can Be Only One</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/there_can_be_only_one.html">https://freddiehaddad.github.io/fast-track-to-rust/there_can_be_only_one.html</a></blockquote>
                        
<p>Currently, our entire rustle program is contained within the <code>main</code> function.
This approach was chosen to address the challenges of teaching a course in a way
that introduces important concepts logically and in an easily digestible manner.
However, the time has come to refactor some of the code from the <code>main</code> function
into separate functions.</p>
<p>Let's start by creating a function to handle the work of finding all the lines
in the input that contain the specified pattern. Here is the function signature:</p>
<pre><code class="language-rust noplayground">fn find_matching_lines(lines: Vec&lt;&amp;str&gt;, pattern: &amp;str) -&gt; Vec&lt;usize&gt;</code></pre>
<p>This is the code that we'll transfer into the new function:</p>
<pre><code class="language-rust noplayground">// store the 0-based line number for any matched line
let match_lines: Vec&lt;_&gt; = lines
    .iter()
    .enumerate()
    .filter_map(|(i, line)| match line.contains(pattern) {
        true =&gt; Some(i),
        false =&gt; None,
    })
    .collect(); // turns anything iterable into a collection</code></pre>
<p>Here is the revised code with the changes implemented. Review it and run the
code.</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::iter::FromIterator; // this line addresses a rust playground bug
</span><span class="boring">
</span>fn find_matching_lines(lines: Vec&lt;&amp;str&gt;, pattern: &amp;str) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match line.contains(pattern) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
        // The return keyword is unnecessary when the returned value is the
        // final expression in a function. In this scenario, the semicolon (;)
        // is omitted.
}

fn main() {
    let poem = "I have a little shadow that goes in and out with me,
                And what can be the use of him is more than I can see.
                He is very, very like me from the heels up to the head;
                And I see him jump before me, when I jump into my bed.

                The funniest thing about him is the way he likes to grow -
                Not at all like proper children, which is always very slow;
                For he sometimes shoots up taller like an india-rubber ball,
                And he sometimes gets so little that there's none of him at all.";

    // command line arguments
    let pattern = "all";
    let before_context = 1;
    let after_context = 1;

    // convert the poem into lines
    let lines = Vec::from_iter(poem.lines());

    // store the 0-based line number for any matched line
    let match_lines = find_matching_lines(lines, pattern);

    // create intervals of the form [a,b] with the before/after context
    let mut intervals: Vec&lt;_&gt; = match_lines
        .iter()
        .map(|line| {
            (
                line.saturating_sub(before_context),
                line.saturating_add(after_context),
            )
        })
        .collect();

    // merge overlapping intervals
    intervals.dedup_by(|next, prev| {
        if prev.1 &lt; next.0 {
            false
        } else {
            prev.1 = next.1;
            true
        }
    });

    // print the lines
    for (start, end) in intervals {
        for (line_no, line) in
            lines.iter().enumerate().take(end + 1).skip(start)
        {
            println!("{}: {}", line_no + 1, line)
        }
    }
}</code></pre>
<h2 id="uh-oh"><a class="header" href="#uh-oh">Uh-oh!</a></h2>
<p>A minor code change caused an issue with the program. Fortunately, the Rust
compiler offers helpful information for diagnosing the problem. However, if
you're not familiar with Rust's ownership rules, understanding this error can be
challenging. Let's break down the error and understand what went wrong. Here are
the key details from the error message, cleaned up for readability:</p>
<pre><code class="language-text">error[E0382]: borrow of moved value: `lines`
    --&gt; src/main.rs:63:13
     |
34   |     let lines = Vec::from_iter(poem.lines());
     |         ----- move occurs because `lines` has type `Vec&lt;&amp;str&gt;`, which
     |               does not implement the `Copy` trait
...
37   |     let match_lines = find_matching_lines(lines, pattern);
     |                                           ----- value moved here
...
63   |             lines.iter().enumerate().take(end + 1).skip(start)
     |             ^^^^^^^^^^^^ value borrowed here after move
     |
</code></pre>
<h3 id="unpacking-the-error"><a class="header" href="#unpacking-the-error">Unpacking the Error</a></h3>
<p>Copy trait, value moved, value borrowed. What the heck does all this mean?</p>
<h4 id="copy-trait"><a class="header" href="#copy-trait">Copy Trait</a></h4>
<p>We'll explore <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a> in more detail later in the course. For now, just know
that when a type implements the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait, its values are duplicated when
assigned to a new variable. This means that after an assignment, both the
original and the new variable can be used independently.</p>
<p>The <code>lines</code> vector we passed to the <code>find_matching_lines</code> function does <em>not</em>
implement the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait.</p>
<h4 id="value-moved"><a class="header" href="#value-moved">Value Moved</a></h4>
<p>By default, variable bindings in Rust follow <em>move semantics</em>.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> When a value
is <em>moved</em>, its ownership is transferred to the new variable, rendering the
original variable invalid and unusable.</p>
<p>Since the <code>lines</code> vector does not implement the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait, its value was
<em>moved</em>, rendering the original value in <em>main</em> invalid.</p>
<h4 id="value-borrowed"><a class="header" href="#value-borrowed">Value Borrowed</a></h4>
<p>Because the <code>lines</code> variable in <code>main</code> becomes invalid due to the <em>move</em>, any
attempt to <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing"><em>borrow</em></a> or reference its value is invalid. This is why the
compiler generates the message "value borrowed here after move".</p>
<blockquote>
<p>Move Semantics</p>
<p>Rust's move semantics play an integral part in ensuring memory safety by
detecting common memory-related errors, like null pointer dereferencing,
buffer overflows, and use-after-free, during compile time, thereby preventing
them from happening at runtime.</p>
</blockquote>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>There are some exceptions in Rust. For example, most primitive types
implement the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait. <a href="#fr-1-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
- en: Slices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/10_slices.html](https://rust-exercises.com/100-exercises/06_ticket_management/10_slices.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/10_slices.html](https://rust-exercises.com/100-exercises/06_ticket_management/10_slices.html)
- en: 'Let''s go back to the memory layout of a `Vec`:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`Vec`的内存布局：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We already remarked how `String` is just a `Vec<u8>` in disguise.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，`String`实际上是一个伪装成`Vec<u8>`的结构。
- en: 'The similarity should prompt you to ask: "What''s the equivalent of `&str`
    for `Vec`?"'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相似性可能会让你问：“`Vec`的`&str`等价物是什么？”
- en: '[`&[T]`](#t)'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`&[T]`](#t)'
- en: '`[T]` is a **slice** of a contiguous sequence of elements of type `T`.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`[T]`是类型`T`的连续元素序列的**切片**。'
- en: It's most commonly used in its borrowed form, `&[T]`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它最常见的形式是借用形式，即`&[T]`。
- en: 'There are various ways to create a slice reference from a `Vec`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以从`Vec`创建切片引用：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Vec` implements the `Deref` trait using `[T]` as the target type, so you can
    use slice methods on a `Vec` directly thanks to deref coercion:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec`通过使用`[T]`作为目标类型实现了`Deref`特质，因此你可以直接在`Vec`上使用切片方法，这得益于解引用强制转换：'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Memory layout](#memory-layout)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[内存布局](#memory-layout)'
- en: A `&[T]` is a **fat pointer**, just like `&str`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`&[T]`是一个**胖指针**，就像`&str`一样。'
- en: It consists of a pointer to the first element of the slice and the length of
    the slice.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它由指向切片第一个元素的指针和切片的长度组成。
- en: 'If you have a `Vec` with three elements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含三个元素的`Vec`：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'and then create a slice reference:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个切片引用：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'you''ll get this memory layout:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到这样的内存布局：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[`&Vec<T>` vs `&[T]`](#vect-vs-t)'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`&Vec<T>` 与 `&[T]`](#vect-vs-t)'
- en: When you need to pass an immutable reference to a `Vec` to a function, prefer
    `&[T]` over `&Vec<T>`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将`Vec`的不可变引用传递给函数时，优先选择`&[T]`而不是`&Vec<T>`。
- en: This allows the function to accept any kind of slice, not necessarily one backed
    by a `Vec`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得函数可以接受任何类型的切片，而不仅仅是基于`Vec`的切片。
- en: 'For example, you can then pass a subset of the elements in a `Vec`. But it
    goes further than that—you could also pass a **slice of an array**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以传递`Vec`中元素的一个子集。但不仅如此——你还可以传递一个**数组的切片**：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Array slices and `Vec` slices are the same type: they''re fat pointers to a
    contiguous sequence of elements. In the case of arrays, the pointer points to
    the stack rather than the heap, but that doesn''t matter when it comes to using
    the slice.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数组切片和`Vec`切片是同一类型：它们都是指向连续元素序列的胖指针。在数组的情况下，指针指向栈而不是堆，但在使用切片时这并不重要。
- en: '[Exercise](#exercise)'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`06_ticket_management/10_slices`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/10_slices)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`06_ticket_management/10_slices`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/10_slices)

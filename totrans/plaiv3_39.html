<html><head></head><body>
<h2 class="c27" id="h.fys2e964672z"><span class="c4">An Evaluator for Local Binding</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now that we’ve seen what behavior we want, we should implement it. That is, we’ll extend our calculator to handle local binding (a feature you may well have wished your calculator had). To reflect that our calculator is growing up, from now on we’ll call it an </span><span class="c7">interpreter</span><span class="calibre3">, abbreviated in code to </span><code>interp</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s start with the new AST. For simplicity, we’ll ignore conditionals, which are anyway orthogonal to our goal of handling local binding. Recall that we added two new branches to the BNF, so we’ll want two new corresponding branches to the AST:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type Exp
  [numE (n : Number)]
  [plusE (left : Exp) (right : Exp)]
  [varE (name : Symbol)]
  [let1E (var : Symbol)
         (value : Exp)
         (body : Exp)])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can also copy over our previous calculator, but we pretty quickly run into trouble:</span></p><p class="c3"><span class="c4"/></p><pre>(define (interp e)
  (type-case (Exp) e
    [(numE n) n]
    [(varE s) …]
    [(plusE l r) (+ (interp l) (interp r))]
    [(let1E var val body) …]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What do we do when we encounter a </span><code>let1E</code><span class="c4">? For that matter, what do we do when we encounter a variable? In fact, these two should be intimately connected: the variable binding introduced by the former should substitute the variable use in the latter.</span></p></body></html>
["```\nlam(x): x * x\n```", "```\nsq(3)\n```", "```\n  [lamE (var : Symbol) (body : Exp)]\n  [appE (fun : Exp) (arg : Exp)]\n```", "```\n{let1 {f {lam x {+ x x}}}\n      {f 3}}\n```", "```\n{let1 {x 3}\n      {let1 {f {lam y {+ x y}}}\n            {f 3}}}\n```", "```\n(let1E 'f (lamE 'x (plusE (varE 'x) (varE 'x))) \n       (appE (varE 'f) (numE 3)))\n```", "```\n(let1E 'x (numE 3) \n       (let1E 'f (lamE 'y (plusE (varE 'x) (varE 'y))) \n              (appE (varE 'f) (numE 3))))\n```", "```\n{lam x {+ x x}}\n```", "```\n(lamE 'x (plusE (varE 'x) (varE 'x)))\n```", "```\n> (lambda (x) (+ x x))\n#<procedure>\n> (number? (lambda (x) (+ x x)))\n#f\n```", "```\n>>> lambda x: x + x\n<function <lambda> at 0x108fd16a8>\n>>> isinstance(lambda x: x + x, numbers.Number)\nFalse\n```", "```\n(define-type Value\n  [numV (the-number : Number)]\n  [boolV (the-boolean : Boolean)]\n  [funV])\n```", "```\n{{if0 x\n      {lam x {+ x 1}}\n      {lam x {- x 2}}}\n 5}\n```", "```\n(define-type Value\n  [numV (the-number : Number)]\n  [boolV (the-boolean : Boolean)]\n  [funV (var : Symbol) (body : Exp)])\n```", "```\n    [(lamE v b) (funV v b)]\n```", "```\n    [(appE f a) (let ([fv (interp f nv)]\n                      [av (interp a nv)])\n```", "```\n    [(appE f a) (let ([fv (interp f nv)]\n                      [av (interp a nv)])\n                  (type-case Value fv\n                    [(funV v b)\n```", "```\n                    [else (error 'app \"didn't get a function\")]))]\n```", "```\n    [(appE f a) (let ([fv (interp f nv)]\n                      [av (interp a nv)])\n                  (type-case Value fv\n                    [(funV v b)\n```", "```\n                    [else (error 'app \"didn't get a function\")]))]\n```", "```\n(interp : (Exp Env -> Value))\n```", "```\n(define (interp e nv)\n  (type-case Exp e\n    [(numE n) (numV n)]\n    [(varE s) (lookup s nv)]\n    [(plusE l r) (add (interp l nv) (interp r nv))]\n    [(lamE v b) (funV v b)]\n    [(appE f a) (let ([fv (interp f nv)]\n                      [av (interp a nv)])\n                  (type-case Value fv\n                    [(funV v b)\n                     (interp b (extend nv v av))]\n                    [else (error 'app \"didn't get a function\")]))]\n    [(let1E var val body)\n     (let ([new-env (extend nv\n                            var\n                            (interp val nv))])\n       (interp body new-env))]))\n```", "```\n(let1E 'x (numE 1)\n       (let1E 'f (lamE 'y (varE 'x))\n              (let1E 'x (numE 2)\n                     (appE (varE 'f) (numE 10)))))\n```", "```\n(let ([x 1])\n  (let ([f (lambda (y) x)])\n    (let ([x 2])\n      (f 10))))\n```", "```\n(let1E 'f (lamE 'y (varE 'x))\n       (let1E 'x (numE 1)\n              (appE (varE 'f) (numE 10))))\n```", "```\n(let ([f (lambda (y) x)])\n  (let ([x 5])\n    (f 3)))\n```", "```\n(let ([x 1])\n  (let ([f (lambda (y) x)])\n    (let ([x 2])\n      (f 10))))\n```", "```\n  (let ([f (lambda (y) 1)])\n    (let ([x 2])\n      (f 10)))\n```", "```\n    (let ([x 2])\n      ((lambda (y) 1) 10))\n```", "```\n      ((lambda (y) 1) 10)\n```", "```\n(define-type Value\n  [numV (the-number : Number)]\n  [boolV (the-boolean : Boolean)]\n```", "```\n    [(appE f a) (let ([fv (interp f nv)]\n                      [av (interp a nv)])\n                  (type-case Value fv\n```", "```\n                     (interp b (extend nv v av))]\n                    [else (error 'app \"didn't get a function\")]))]\n```", "```\n((let ([x 3])\n   (lambda (y) (+ x y)))\n 4)\n```", "```\n 4)\n```", "```\n(test (interp (appE (let1E 'x (numE 3)\n                           (lamE 'y (plusE (varE 'x) (varE 'y))))\n                    (numE '4))\n              mt-env)\n      (numV 7))\n```", "```\n((let ([y 3])\n   (lambda (y) (+ y 1)))\n 5)\n```", "```\nfor(x = 0; x < 10; x++) {\n  sum += x;\n}\n```", "```\nx = 0;\nwhile (x < 10) {\n  sum += x;\n  x++;\n}\n```", "```\nfor(INITIAL; CONDITIONAL; UPDATE) {\n  sum += x;\n}\n```", "```\nINITIAL;\nwhile (CONDITIONAL) {\n  sum += x;\n  UPDATE;\n}\n```", "```\n#lang racket\n```", "```\n(define (strict-if C T E)\n  (if (boolean? C)\n      (if C T E)\n      (error 'strict-if \"expected a boolean\")))\n```", "```\n(strict-if true 1 2)\n(strict-if 0 1 2)\n```", "```\n(strict-if true 1 (/ 1 0))\n```", "```\n(if true 1 (/ 1 0))\n```", "```\n(define-syntax strict-if\n  (syntax-rules ()\n    [(strict-if C T E)\n     (if (boolean? C)\n         (if C T E)\n         (error 'strict-if \"expected a boolean\"))]))\n```", "```\n(strict-if true 1 (/ 1 0))\n```", "```\n(if (boolean? true)\n    (if true 1 (/ 1 0))\n    (error 'strict-if \"expected a boolean\"))\n```", "```\n(let1 (x 3) (+ x x))\n```", "```\n(define-syntax my-let1\n  (syntax-rules ()\n    [(my-let1 (var val) body)\n     …]))\n```", "```\n(define-syntax my-let1\n  (syntax-rules ()\n    [(my-let1 (var val) body)\n     ((lambda (var) body) val)]))\n```", "```\n(my-let1 (x 3) (+ x x))\n```", "```\n(define-syntax my-let1\n  (syntax-rules ()\n    [(my-let1 (var val) body)\n     ((lambda (var) val) body)]))\n```", "```\n(my-let1 (x 3) (+ x x))\n```", "```\n(define-syntax my-let2\n  (syntax-rules ()\n    [(my-let2 ([var val] ...) body)\n     ((lambda (var ...) body) val ...)]))\n```", "```\n(my-let2 ([x 3] [y 4]) (+ x y))\n```", "```\n(define (sign n)\n  (my-cond\n   [(< n 0) \"negative\"]\n   [(= n 0) \"zero\"]\n   [(> n 0) \"positive\"]))\n```", "```\n(define-syntax my-cond\n  (syntax-rules ()\n    [(my-cond) (error 'my-cond \"should not get here\")]\n    [(my-cond [q0 a0] [q1 a1] ...)\n     (if q0\n         a0\n         (my-cond [q1 a1] ...))]))\n```", "```\n(define-syntax unless\n  (syntax-rules ()\n    [(_ cond body ...)\n     (if (not cond)\n         (begin\n           body\n           ...)\n         (void))]))\n```", "```\n(unless false\n  (println 1)\n  (println 2))\n```", "```\n(let ([not (λ (v) v)])\n  (unless false\n    (println 1)\n    (println 2)))\n```", "```\n(let ([not (λ (v) v)])\n  (if (not false)\n      (begin\n        (println 1)\n        (println 2))\n      (void)))\n```", "```\n(define-syntax or-2\n  (syntax-rules ()\n    [(_ e1 e2)\n     (if e1\n         true\n         e2)]))\n```", "```\n(or-2 true false)\n(or-2 false false)\n(or-2 false true)\n```", "```\n(member 'y '(x y z))\n```", "```\n(or-2 (member 'y '(x y z)) \"not found\")\n```", "```\n(define-syntax or-2\n  (syntax-rules ()\n    [(_ e1 e2)\n     (if e1\n         e1\n         e2)]))\n```", "```\n(or-2 (member 'y '(x y z)) \"not found\")\n```", "```\n(or-2 (print \"hello\") \"not found\")\n```", "```\n(define-syntax or-2\n  (syntax-rules ()\n    [(_ e1 e2)\n     (let ([v e1])\n       (if v v e2))]))\n```", "```\n(let ([v 1])\n  (or-2 false v))\n```", "```\n(let ([v 1])\n  (let ([v false])\n    (if v\n        v\n        v)))\n```", "```\n(let ([v0 1])\n  (let ([v1 false])\n    (if v1\n        v1\n        v0)))\n```", "```\n(define-syntax orN\n  (syntax-rules ()\n    [(_ e1 e2 ...)\n     (let ([v e1])\n       (if v v (orN e2 ...)))]))\n```", "```\n(let ([v true])\n  (orN false v))\n```", "```\n(define-syntax orN\n  (syntax-rules ()\n    [(_) false]\n    [(_ e1 e2 ...)\n     (let ([v e1])\n       (if v v (orN e2 ...)))]))\n```", "```\n(require [only-in plait test print-only-errors])\n```", "```\n(define o\n  (lambda (m)\n    (case m\n      [(add1) (lambda (x) (+ x 1))]\n      [(sub1) (lambda (x) (- x 1))])))\n```", "```\n(test ((o 'add1) 5) 6)\n```", "```\n(define (msg o m . a)\n  (apply (o m) a))\n```", "```\n(test (msg o 'add1 5) 6)\n```", "```\n(test (msg o (first '(add1)) 5) 6)\n```", "```\n  (lambda (m)\n    (case m\n      … dispatch on each of the members …))\n```", "```\n(define (o-constr x)\n  (lambda (m)\n    (case m\n      [(addX) (lambda (y) (+ x y))])))\n\n(test (msg (o-constr 5) 'addX 3) 8)\n(test (msg (o-constr 2) 'addX 3) 5)\n```", "```\n(define (class constructor-params)\n  … the object pattern …)\n```", "```\n(define (mk-o-state count)\n  (lambda (m)\n    (case m\n      [(inc) (lambda () (set! count (+ count 1)))]\n      [(dec) (lambda () (set! count (- count 1)))]\n      [(get) (lambda () count)])))\n```", "```\n(test (let ([o (mk-o-state 5)])\n        (begin (msg o 'inc)\n                   (msg o 'inc)\n               (msg o 'dec)\n               (msg o 'get)))\n      6)\n```", "```\n(test (let ([o1 (mk-o-state 3)]\n            [o2 (mk-o-state 3)])\n        (begin (msg o1 'inc)\n               (msg o1 'inc)\n               (+ (msg o1 'get)\n                  (msg o2 'get))))\n      (+ 5 3))\n```", "```\n(define (mk-o-state/priv init)\n  (let ([count init])\n    (lambda (m)\n      (case m\n        [(inc) (lambda () (set! count (+ count 1)))]\n        [(dec) (lambda () (set! count (- count 1)))]\n        [(get) (lambda () count)]))))\n```", "```\n(define (class-w/-private constructor-params)\n  (let ([private-vars …] …)\n    … the object pattern …))\n```", "```\n(define class-w/-private\n  (lambda (constructor-params)\n    (let ([private-vars …] …)\n      … the object pattern …)))\n```", "```\n(define mk-o-static\n  (let ([counter 0])\n    (lambda (amount)\n      (begin\n        (set! counter (+ 1 counter))\n        (lambda (m)\n          (case m\n            [(inc) (lambda (n) (set! amount (+ amount n)))]\n            [(dec) (lambda (n) (set! amount (- amount n)))]\n            [(get) (lambda () amount)]\n            [(count) (lambda () counter)]))))))\n```", "```\n(test (let ([o (mk-o-static 1000)])\n        (msg o 'count))\n      1)\n\n(test (let ([o (mk-o-static 0)])\n        (msg o 'count))\n      2)\n```", "```\n#lang stacker/smol/hof\n```", "```\n(defvar mk-o-static\n  (let ([counter 0])\n    (lambda (amount)\n      (begin\n        (set! counter (+ 1 counter))\n        (lambda (m)\n          (if (equal? m \"get\")\n              (lambda () amount)\n              (if (equal? m \"count\")\n                  counter\n                  (error \"no such member\"))))))))\n```", "```\n(defvar o1 (mk-o-static 1000))\n(defvar o2 (mk-o-static 0))\n(o1 \"count\")\n(o2 \"count\")\n```", "```\n(define class-w/-private&static\n  (let ([static-vars …] …)\n    (lambda (constructor-params)\n      (let ([private-vars …] …)\n        … the object pattern …))))\n```", "```\n(define class-w/-private&static\n  (let ([static-vars …] …)\n    … the class-w/-private pattern …))\n```", "```\n(define o-self!\n  (let ([self 'dummy])\n    (begin\n      (set! self\n            (lambda (m)\n              (case m\n                [(first) (lambda (x) (msg self 'second (+ x 1)))]\n                [(second) (lambda (x) (+ x 1))])))\n      self)))\n```", "```\n(test (msg o-self! 'first 5) 7)\n```", "```\n#lang stacker/smol/hof\n```", "```\n(defvar o-self!\n  (let ([self 0])\n    (begin\n      (set! self\n            (lambda (m)\n              (if (equal? m \"first\")\n                  (lambda (x) ((self \"second\") (+ x 1)))\n                  (if (equal? m \"second\")\n                      (lambda (x) (+ x 1))\n                      (error \"no such member\")))))\n      self)))\n```", "```\n((o-self! \"first\") 5)\n```", "```\n(define o-self-no!\n  (lambda (m)\n    (case m\n      [(first) (lambda (self x) (msg/self self 'second (+ x 1)))]\n      [(second) (lambda (self x) (+ x 1))])))\n```", "```\n(define (msg/self o m . a)\n  (apply (o m) o a))\n```", "```\n(test (msg/self o-self-no! 'first 5) 7)\n```", "```\n(define (mt)\n  (let ([self 'dummy])\n    (begin\n      (set! self\n            (lambda (m)\n              (case m\n                [(sum) (lambda () 0)])))\n      self)))\n```", "```\n(define (node v l r)\n  (let ([self 'dummy])\n    (begin\n      (set! self\n            (lambda (m)\n              (case m\n                [(sum) (lambda () (+ v\n                                     (msg l 'sum)\n                                     (msg r 'sum)))])))\n      self)))\n```", "```\n(define a-tree\n  (node 10\n        (node 5 (mt) (mt))\n        (node 15 (node 6 (mt) (mt)) (mt))))\n```", "```\n(test (msg a-tree 'sum) (+ 10 5 15 6))\n```", "```\n(case m\n  ...\n  [else (parent-object m)])\n```", "```\nclass Mt   { … Mt()          { … } sum() { … } }\nclass Node { … Node(v, l, r) { … } sum() { … } }\n```", "```\nclass MtSize   extends Mt   { … size() { … } … }\nclass NodeSize extends Node { … size() { … } … }\n```", "```\nclass Pt2 {\n    Pt2(int x, int y) {\n        System.out.println(\"Pt2 with \" + x + \" and \" + y);\n    }\n}\n```", "```\nclass Main {\n    public static void main(String[] args) {\n        Pt2 p2 = new Pt2(1, 2);\n    }\n}\n```", "```\nclass Pt3 extends Pt2 {\n    Pt3(int x, int y, int z) {\n        System.out.println(\"Pt3 with \" + z);\n    }\n}\n```", "```\nclass Pt2 {\n   Pt2() {\n       System.out.println(\"default constructor\");\n   }\n    Pt2(int x, int y) {\n        System.out.println(\"Pt2 with \" + x + \" and \" + y);\n    }\n}\n```", "```\nclass Main {\n  public static void main(String[] args) {\n    Pt3 p3 = new Pt3(1, 2, 3);\n  }\n}\n```", "```\nclass Pt3 extends Pt2 {\n    Pt3(int x, int y, int z) {\n        System.out.println(\"Pt3 with \" + z);\n        super(x, y);\n    }\n}\n```", "```\nclass Pt2 {\n    public int x;\n    Pt2(int x, int y) {\n        this.x = x - 3;\n        System.out.println(\"Pt2 with \" + x + \" and \" + y);\n    }\n}\n```", "```\nclass Pt3 extends Pt2 {\n    public int x;\n    Pt3(int x, int y, int z) {\n        super(x, y);\n        this.x = x + 7;\n        System.out.println(\"Pt3 with \" + z);\n    }\n}\n```", "```\nclass Main {\n    public static void main(String[] args) {\n        Pt3 p3345 = new Pt3(3, 4, 5);\n        Pt3 p3678 = new Pt3(6, 7, 8);\n    }\n}\n```", "```\n        System.out.println(p3345.x);\n        System.out.println(p3678.x);\n```", "```\n        System.out.println(((Pt2)p3345).x);\n        System.out.println(((Pt2)p3678).x);\n```", "```\n(define (node/size parent-object v l r)\n  ...)\n```", "```\n(define (node v l r)\n  ...)\n```", "```\n(define (node/size parent-maker v l r)\n  (let ([parent-object (parent-maker v l r)]\n        [self 'dummy])\n    (begin\n      (set! self\n            (lambda (m)\n              (case m\n                [(size) (lambda () (+ 1\n                                     (msg l 'size)\n                                     (msg r 'size)))]\n                [else (parent-object m)])))\n      self)))\n\n(define (mt/size parent-maker)\n  (let ([parent-object (parent-maker)]\n        [self 'dummy])\n    (begin\n      (set! self\n            (lambda (m)\n              (case m\n                [(size) (lambda () 0)]\n                [else (parent-object m)])))\n      self)))\n```", "```\n(define a-tree/size\n  (node/size node\n             10\n             (node/size node 5 (mt/size mt) (mt/size mt))\n             (node/size node 15\n                        (node/size node 6 (mt/size mt) (mt/size mt))\n                        (mt/size mt))))\n```", "```\n(test (msg a-tree/size 'sum) (+ 10 5 15 6))\n(test (msg a-tree/size 'size) 4)\n```", "```\nclass NodeSize extends Node { ... }\n```", "```\nclass C extends B { ... }\n```", "```\nclassext E { ... }\n```", "```\nclass C = E(B)\n```", "```\nclass C1 = E(B1);\nclass C2 = E(B2);\n```", "```\nmixin M extends I1 implements I2 { ... }\n```", "```\nM :: I1 -> I2\n```", "```\n(define-type BinOp\n  [plus])\n```", "```\n(define-type Expr\n  [binE (operator : BinOp)\n        (left  : Exp)\n        (right : Exp)]\n  [numE (value : Number)])\n```", "```\n(calc : (Exp -> Number))\n```", "```\n(define (calc e)\n  (type-case Exp e\n    [(binE o l r)\n     (type-case BinOp o\n       [(plus) (+ (calc l) (calc r))])]\n    [(numE v) v]))\n```", "```\n(test (calc (binE (plus) (numE 5) (numE 6))) 11)\n```", "```\n  (type-case Exp e\n    [(binE o l r)\n     (type-case BinOp o\n```", "```\n(define-type BinOp\n```", "```\n(define-type Expr\n  [binE (operator : BinOp)\n        (left  : Exp)\n        (right : Exp)]\n  [numE (value : Number)]\n```", "```\n(define (tc e)\n  (type-case Exp e\n    [(binE o l r)\n     (type-case BinOp o\n       [(plus) (and (tc l) (tc r))]\n```", "```\n    [(numE v) #true]\n```", "```\n(test (tc (binE (++) (numE 5) (numE 6))) #false)\n(test (tc (binE (plus) (strE \"hello\") (strE \"world\"))) #false)\n```", "```\n(define-type Type [numT] [strT])\n```", "```\n(define (tc e)\n  (type-case Exp e\n    [(binE o l r)\n     (type-case BinOp o\n       [(plus) (if (and (numT? (tc l)) (numT? (tc r)))\n                   (numT)\n                   (error 'tc \"not both numbers\"))]\n       [(++)   (if (and (strT? (tc l)) (strT? (tc r)))\n                   (strT)\n                   (error 'tc \"not both strings\"))])]\n    [(numE v) (numT)]\n    [(strE v) (strT)]))\n```", "```\n(test (tc (binE (plus) (numE 5) (numE 6))) (numT))\n(test (tc (binE (++) (strE \"hello\") (strE \"world\"))) (strT))\n```", "```\n(test/exn (tc (binE (++) (numE 5) (numE 6))) \"strings\")\n(test/exn (tc (binE (plus) (strE \"hello\") (strE \"world\"))) \"numbers\")\n```", "```\n|- e : T\n```", "```\n|- n : Num\n|- s : Str\n```", "```\n    [(numC n) (numT)]\n```", "```\n|- b : Bool\n```", "```\n|- true : Bool\n|- false : Bool\n```", "```\n       [(plus) (if (and (numT? (tc l)) (numT? (tc r)))\n                   (numT)\n                   (error 'tc \"not both numbers\"))]\n```", "```\n|- e1 : Num    |- e2 : Num\n--------------------------\n|- (+ e1 e2) : Num\n```", "```\n(+ 5 (+ 6 7))\n```", "```\n|- 5 : Num    |- (+ 6 7) : Num\n----------------------\n|- (+ 5 (+ 6 7)) : Num\n```", "```\n----------------------\n|- (+ 5 (+ 6 7)) : Num\n```", "```\n              |- 6 : Num    |- 7 : Num\n              ------------------------\n```", "```\n----------------------\n|- (+ 5 (+ 6 7)) : Num\n```", "```\n              ------------------------\n```", "```\n----------------------\n|- (+ 5 (+ 6 7)) : Num\n```", "```\n(+ 5 (+ 6 \"hi\"))\n```", "```\n              ---------------------------\n```", "```\n-------------------------\n|- (+ 5 (+ 6 \"hi\")) : Num\n```", "```\n|- \"hi\" : Num\n```", "```\n              ---------------------------\n```", "```\n-------------------------\n|- (+ 5 (+ 6 \"hi\")) : \n```", "```\n(+ 5 (- 6 7))\n```", "```\n----------------------\n|- (+ 5 (- 6 7)) : Num\n```", "```\n|- C : Bool    …\n------------------\n|- (if C T E) : …\n```", "```\n|- C : Bool    |- T : U    |- E : U\n-----------------------------------\n|- (if C T E) : U\n```", "```\n(if true 1 2)\n```", "```\n--------------------------------------\n|- (if true 1 2) : U\n```", "```\n------------------------------------------\n|- (if true 1 2) : Num\n```", "```\n------------------------------------------\n|- (if true 1 2) : Num\n```", "```\n(if 4 1 2)\n```", "```\n|- 4 : Bool    |- 1 : U    |- 2 : U\n-----------------------------------\n|- (if 4 1 2) : U\n```", "```\n-----------------------------------\n|- (if 4 1 2) : U\n```", "```\n(if true 1 \"hi\")\n```", "```\n-----------------------------------------\n|- (if true 1 \"hi\") : U\n```", "```\n---------------------------------------------\n|- (if true 1 \"hi\") : Num\n```", "```\n---------------------------------------------\n|- (if true 1 \"hi\") : Str\n```", "```\n(if (is-full-moon) 1 \"hi\")\n```", "```\n|- F : ???    |- A : ???\n------------------------\n|- (F A) : ???\n```", "```\n|- F : Fun    |- A : ???\n------------------------\n|- (F A) : ???\n```", "```\n|- F : (??? -> ???)    |- A : ???\n---------------------------------\n|- (F A) : ???\n```", "```\n|- F : (T -> ???)    |- A : T\n-----------------------------\n|- (F A) : ???\n```", "```\n|- F : (T -> U)    |- A : T\n---------------------------\n|- (F A) : U\n```", "```\n|- B : ???\n---------------------\n|- (lambda V B) : ???\n```", "```\n|- x : ???\n---------------------\n|- (lambda x x) : ???\n```", "```\n(interp : (Exp Env -> Value))\n```", "```\n(tc : (Exp TEnv -> Type))\n```", "```\n-----------------------\n```", "```\n(lambda V : T B)\n```", "```\n---------------------------\n```", "```\n------------------------------------\n```", "```\n----------------------------------\n```", "```\n--------------------------------\n```", "```\n-------------------------------\n```", "```\n--------------------------------\n```", "```\nfun f():\n  f()\n```", "```\nf()\n```", "```\n--------------------------------\n```", "```\n(rec ([inf-loop (lambda (n) (inf-loop n))])\n  (inf-loop 0))\n```", "```\n(rec ([fact (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))])\n  (fact 10))\n```", "```\n(rec V : T E B)\n```", "```\n(rec inf-loop : (Number -> Number)\n     (lambda (n) (inf-loop n))\n  (inf-loop 0))\n```", "```\n(rec fact : (Number -> Number)\n     (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))\n  (fact 10))\n```", "```\n------------------------\n```", "```\n-------------------------\n```", "```\n----------------------------------\n```", "```\n----------------------------------------\n```", "```\n(define-type Exp\n  [num (n : Number)]\n  [str (s : String)]\n  [plus (l : Exp) (r : Exp)]\n  [cat (l : Exp) (r : Exp)])\n```", "```\n(define-type Value\n  (numV (n : Number))\n  (strV (s : String)))\n```", "```\n(calc : (Exp -> Value))\n```", "```\n(define (calc e)\n  (type-case Exp e\n    [(num n) (numV n)]\n    [(str s) (strV s)]\n    [(plus l r) (num+ (calc l) (calc r))]\n    [(cat l r) (str++ (calc l) (calc r))]))\n```", "```\n(define (num+ lv rv)\n  (type-case Value lv\n    ((numV ln)\n     (type-case Value rv\n       ((numV rn) (numV (+ ln rn)))\n       (else (error '+ \"right not a number\"))))\n    (else (error '+ \"left not a number\"))))\n```", "```\n(define (str++ lv rv)\n  (type-case Value lv\n    ((strV ls)\n     (type-case Value rv\n       ((strV rs) (strV (string-append ls rs)))\n       (else (error '++ \"right not a string\"))))\n    (else (error '++ \"left not a string\"))))\n```", "```\n(test (calc (plus (num 1) (num 2))) (numV 3))\n(test (calc (plus (num 1) (plus (num 2) (num 3)))) (numV 6))\n(test (calc (cat (str \"hel\") (str \"lo\"))) (strV \"hello\"))\n(test (calc (cat (cat (str \"hel\") (str \"l\")) (str \"o\"))) (strV \"hello\"))\n(test/exn (calc (cat (num 1) (str \"hello\"))) \"left\")\n(test/exn (calc (plus (num 1) (str \"hello\"))) \"right\")\n```", "```\n(define MEMORY (make-vector 100 -1))\n```", "```\n(require (typed-in racket/base\n                   [char->integer : (Char -> Number)]\n                   [integer->char : (Number -> Char)]\n                   [number->string : (Number -> String)]))\n```", "```\n(define next-addr 0)\n(define (write-and-bump v)\n  (let ([n next-addr])\n    (begin\n      (vector-set! MEMORY n v)\n      (set! next-addr (add1 next-addr))\n      n)))\n```", "```\n(define (store-num n)\n  (write-and-bump n))\n```", "```\n(define (read-num a)\n  (vector-ref MEMORY a))\n```", "```\n(define (store-str s)\n  (let ([a0 (write-and-bump (string-length s))])\n    (begin\n      (map write-and-bump\n           (map char->integer (string->list s)))\n      a0)))\n```", "```\n(store-str \"hello\")\n```", "```\n'#(5\n   104\n   101\n   108\n   108\n   111\n   -1\n   -1\n   -1\n   …)\n```", "```\n(define (read-str a)\n  (letrec ([loop\n            (lambda (count a)\n              (if (zero? count)\n                  empty\n                  (cons (vector-ref MEMORY a)\n                        (loop (sub1 count) (add1 a)))))])\n    (list->string\n     (map integer->char\n          (loop (vector-ref MEMORY a) (add1 a))))))\n```", "```\n(define-type-alias Value Number)\n```", "```\n(define numV store-num)\n(define strV store-str)\n```", "```\n       [(numV rn) (numV (+ ln rn))]\n```", "```\n(define (num+ la ra)\n  (numV (+ (read-num la) (read-num ra))))\n```", "```\n(define (str++ la ra)\n  (strV (string-append (read-str la) (read-str ra))))\n```", "```\n(test (read-num (calc (plus (num 1) (num 2)))) 3)\n(test (read-num (calc (plus (num 1) (plus (num 2) (num 3))))) 6)\n(test (read-str (calc (cat (str \"hel\") (str \"lo\")))) \"hello\")\n(test (read-str (calc (cat (cat (str \"hel\") (str \"l\")) (str \"o\")))) \"hello\")\n```", "```\n(test/exn (calc (cat (num 1) (str \"hello\"))) \"left\")\n(test/exn (calc (plus (num 1) (str \"hello\"))) \"right\")\n```", "```\n(calc (cat (num 1) (str \"hello\")))\n```", "```\n> (read-num 69)\n- Number\n6\n> (read-str 69)\n- String\n\"\\u0005hello\"\n```", "```\n> (read-num (calc (plus (num 1) (str \"hello\"))))\n- Number\n6\n> (read-str (calc (plus (num 1) (str \"hello\"))))\n- String\n```", "```\n(define NUMBER-TAG 1337)\n(define STRING-TAG 5712)\n```", "```\n(define (store-num n)\n```", "```\n      (write-and-bump n)\n```", "```\n(define (safe-read-num a)\n```", "```\n(define (store-str s)\n```", "```\n    (begin\n```", "```\n      (map write-and-bump\n           (map char->integer (string->list s)))\n      a0)))\n```", "```\n(define (safe-read-str a)\n```", "```\n      (letrec ([loop\n                (lambda (count a)\n                  (if (zero? count)\n                      empty\n                      (cons (vector-ref MEMORY a)\n                            (loop (sub1 count) (add1 a)))))])\n        (list->string\n         (map integer->char\n```", "```\n(store-str \"hello\")\n```", "```\n   5\n   104\n   101\n   108\n   108\n   111\n   -1\n   -1\n   -1\n   …)\n```", "```\n(define (num+ la ra)\n```", "```\n(define (str++ la ra)\n```", "```\n(test/exn (calc (cat (num 1) (str \"hello\"))) \"string\")\n(test/exn (calc (plus (num 1) (str \"hello\"))) \"number\")\n```", "```\ne : t\n```", "```\ne -> v\n```", "```\n(define (generic-read a)\n  (let ([tag (vector-ref MEMORY a)])\n    (cond\n      [(= tag NUMBER-TAG) (safe-read-num a)]\n      [(= tag STRING-TAG) (safe-read-str a)]\n      [else (error 'generic-print \"invalid tag\")])))\n```", "```\n  (let ([tag (vector-ref MEMORY a)])\n    (cond\n      [(= tag NUMBER-TAG) (number->string (safe-read-num a))]\n      [(= tag STRING-TAG) (safe-read-str a)]\n      [else (error 'generic-print \"invalid tag\")])))\n```", "```\n(test (generic-read (calc (plus (num 1) (num 2)))) \"3\")\n(test (generic-read (calc (plus (num 1) (plus (num 2) (num 3))))) \"6\")\n(test (generic-read (calc (cat (str \"hel\") (str \"lo\")))) \"hello\")\n(test (generic-read (calc (cat (cat (str \"hel\") (str \"l\")) (str \"o\")))) \"hello\")\n```", "```\n(lambda (x y)\n  (if x\n      (+ y 1)\n      (+ y 2)))\n```", "```\n> (lambda (x y)\n    (if x\n        (+ y 1)\n        (+ y 2)))\n- (Boolean Number -> Number)\n#<procedure>\n```", "```\n(lambda (x)\n    (if x\n        (+ x 1)\n        (+ x 2)))\n```", "```\n(+ 1 2)\n```", "```\n(lambda (x : ___) (+ x 1))\n```", "```\n------------------------------\n```", "```\n(let ([x 3])\n  (+ (let ([x 4])\n       x)\n     x))\n```", "```\n(let ([x 3])\n  (+ (let ([y 4])\n       y)\n     x))\n```", "```\n(lambda ((x : ___) (y : ___))\n  (if x\n      (+ y 1)\n      (+ y 2)))\n```", "```\n-----------------------------------------\n```", "```\n(Bool Num -> Num)\n```", "```\n(lambda (x : ___)\n  (if x\n      (+ x 1)\n      (+ x 2)))\n```", "```\n(define-type BT\n  [mt]\n  [node (v : Number) (l : BT) (r : BT)])\n```", "```\n(mt : ( -> BT))\n(node : (Number BT BT -> BT))\n```", "```\n(mt? : (BT -> Boolean))\n(node? : (BT -> Boolean))\n```", "```\n(node-v : (BT -> Number))\n(node-l : (BT -> BT))\n(node-r : (BT -> BT))\n```", "```\n(size-correct : (BT -> Number))\n```", "```\n(define (size-correct (t : BT))\n  (if (mt? t)\n      0\n      (+ 1 (+ (size-correct (node-l t)) (size-correct (node-r t))))))\n```", "```\n(test (size-correct (mt)) 0)\n```", "```\n(define (size-wrong (t : BT))\n  (+ 1 (+ (size-wrong (node-l t)) (size-wrong (node-r t)))))\n```", "```\n(size-wrong : (BT -> Number))\n```", "```\n(size-wrong (mt))\n```", "```\n(size-pm : (BT -> Number))\n```", "```\n(define (size-pm t)\n  (type-case BT t\n    [(mt) 0]\n    [(node v l r) (+ 1 (+ (size-pm l) (size-pm r)))]))\n```", "```\n-----------------------------------------\n```", "```\n       [(mt) e1]\n       [(node V L R) e2]) : T\n```", "```\n(define (size-pm-ds (t : BT))\n  (cond\n    [(mt? t) 0]\n    [(node? t)\n     (let ([v (node-v t)]\n           [l (node-l t)]\n           [r (node-r t)])\n       (+ 1 (+ (size-pm-ds l) (size-pm-ds r))))]))\n```", "```\n(node-v : (BT -> Number))\n```", "```\n(node : (Number BT BT -> BT))\n```", "```\n#lang typed/racket\n```", "```\n(struct mt ())\n```", "```\n> mt\n- : (-> mt)\n#<procedure:mt>\n```", "```\n> mt?\n- : (-> Any Boolean : mt)\n#<procedure:mt?>\n```", "```\n(struct node ([v : Number] [l : \n```", "```\n(define-type-alias BT (U mt node))\n```", "```\n(struct node ([v : Number] [l : BT] [r : BT]))\n```", "```\n> node\n- : (-> Number BT BT node)\n> node-v\n- : (-> node Number)\n> node-l\n- : (-> node BT)\n> node-r\n- : (-> node BT)\n```", "```\n(define t1\n  (node 5\n        (node 3\n              (node 1 (mt) (mt))\n              (mt))\n        (node 7\n              (mt)\n              (node 9 (mt) (mt)))))\n```", "```\n(define (size-tr [t : BT]) : Number\n  (cond\n    [(mt? t) 0]\n    [(node? t) (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))\n```", "```\n(define (size-tr-wrong [t : BT]) : Number\n  (+ 1 (size (node-l t)) (size (node-r t))))\n```", "```\n> mt?\n- : (-> Any Boolean : mt)\n> node?\n- : (-> Any Boolean : node)\n```", "```\n(define (size-tr-w2 [t : BT]) : Number\n  (cond\n    [(node? t) 0]\n    [(mt? t) (+ 1 (size-tr-w2 (node-l t)) (size-tr-w2 (node-r t)))]))\n```", "```\n(define (size-tr [t : BT]) : Number\n  (cond\n    [(mt? t) …]\n    [(node? t) …]))\n```", "```\n(define (size-tr-else [t : BT]) : Number\n  (cond\n    [(mt? t) 0]\n    [else (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))\n```", "```\n-----------------------------------------\n```", "```\n(define-type-alias BT (U mt node))\n```", "```\n(struct link ((v : Number) (r : LinkedList)))\n```", "```\n(define-type-alias LinkedList (U mt link))\n```", "```\n  switch (typeof val) {\n    case \"undefined\":\n    case \"function\": \n      return false;\n    case \"boolean\":\n      return val ? \"true\" :\n                   \"false\";\n    case \"number\":\n      return \"\" + val;\n    case \"string\":\n      return val;\n  }\n  if (val === null)\n    { return \"null\"; } \n\n  var fields = [ ];\n  for (var p in val) {\n    var v = serialize(val[p]);\n    if (typeof v === \"string\") {\n      fields.push(p + \": \" + v);\n    }\n  }\n  return \"{ \" + \n         fields.join(\", \") + \n         \" }\";\n}\n```", "```\ndef insort_right(a, x, lo=0, hi=None):\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n```", "```\nfrom typing import Optional\n```", "```\ndef insort_right(a, x, lo: int = 0, hi: Optional[int] = None):\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]:\n            hi = mid\n        else:\n            lo = mid+1\n    a.insert(lo, x)\n```", "```\n(define-type BT\n  [mt]\n  [node (v : Number) (l : BT) (r : BT)])\n```", "```\nabstract class BT {\n  abstract public int size();\n}\n```", "```\nclass mt extends BT {\n  public int size() {\n    return 0;\n  }\n}\n```", "```\nclass node extends BT {\n  int v;\n  BT l, r;\n  node(int v, BT l, BT r) {\n    this.v = v;\n    this.l = l;\n    this.r = r;\n  }\n  public int size() {\n    return 1 + this.l.size() + this.r.size();\n  }\n}\n```", "```\nclass Main {\n  public static void main(String[] args) {\n    BT t = new node(5, new node(3, new mt(), new mt()), new mt());\n    System.out.println(t.size());\n  }\n}\n```", "```\nclass mt extends BT {\n  public int size() {\n    return 0;\n  }\n}\n```", "```\nclass empty extends BT {\n  public int size() {\n    return 0;\n  }\n}\n```", "```\nclass Main {\n  static int m(mt o) {\n    return o.size();\n  }\n  public static void main(String[] args) {\n    System.out.println(m(new mt()));\n  }\n}\n```", "```\nclass Main {\n  static int m(mt o) {\n    return o.size();\n  }\n  public static void main(String[] args) {\n```", "```\n  }\n}\n```", "```\nmt : {size : ( -> int)}\nnode : {size : ( -> int)}\n```", "```\nempty : {size : ( -> int)}\n```", "```\n  return o.size();\n}\n```", "```\nclass A { String who = \"A\"; }\nclass B extends A { String who = \"B\"; }\nclass C extends A { String who = \"C\"; }\nclass D { String who = \"D\"; }\n```", "```\nclass Main {\n public static void main(String[] args) {\n   System.out.println((true ? _____ : _____).who);\n }\n}\n```", "```\n----------------------------------------------------------\n```", "```\ndef insort_right(a, x, lo: int = 0, hi: Optional[int] = None):\n```", "```\n(define (g s)\n  (+ 1 (or (string->number s) 0)))\n```", "```\n> (g \"5\")\n6\n```", "```\n> (g \"hi\")\n1\n```", "```\n> (g 5)\n```", "```\n(define (f [s : String]) : Number\n  (+ 1 (or (string->number s) 0)))\n```", "```\n(define (f [s : String]) : Number\n  (+ 1 (string->number s)))\n```", "```\n(provide f)\n```", "```\n(require \"typed.rkt\") ;; or whatever filename you’ve chosen\n```", "```\n> (f \"5\")\n6\n> (f \"hi\")\n1\n```", "```\n> (f 5)\n```", "```\n(define (wrapped-f s)\n  (if (string? s)\n      (let ([b (+ 1 (or (string->number s) 0))])\n        (if (number? b)\n            b\n            (error 'contract \"returned value was not a Number\")))\n      (error 'contract \"provided value was not a String\")))\n```", "```\n            b\n```", "```\n(define (h [i : (-> String Number)]) : Number\n  (+ (i \"5\") 1))\n```", "```\n(define (j i)\n  (+ (i \"5\") 1))\n```", "```\n(define (str-dbl s) (string-append s s))\n```", "```\nborrows(A, B)\n```", "```\nborrows(java, cpp).\nborrows(cpp, c).\nborrows(c, bcpl).\nborrows(pascal, algol).\n```", "```\ndescends(A, B) :- borrows(A, B).\ndescends(A, B) :- borrows(A, Z), descends(Z, B).\n```", "```\nborrows(cpp, c).\n```", "```\nborrows(cpp, bcpl).\n```", "```\ndescends(cpp, bcpl).\n```", "```\ndescends(bcpl, cpp).\n```", "```\nborrows(java, cpp).\nborrows(cpp, c).\nborrows(cpp, simula).\nborrows(smalltalk, simula).\nborrows(self, smalltalk).\nborrows(c, bcpl).\nborrows(pascal, algol).\nborrows(scheme, algol).\nborrows(scheme, lisp).\nborrows(javascript, self).\nborrows(javascript, scheme).\n```", "```\ndescends(javascript, X).\n```", "```\ndescends(X, lisp).\n```", "```\ntc(numE, numT).\ntc(strE, strT).\ntc(boolE, boolT).\n```", "```\ntc(plusE(L, R), numT) :-\n    tc(L, numT),\n    tc(R, numT).\n```", "```\ntc(catE(L, R), strT) :-\n    tc(L, strT),\n    tc(R, strT).\n```", "```\ntc(ifE(C, T, E), Ty) :-\n    tc(C, boolT),\n    tc(T, Ty),\n    tc(E, Ty).\n```", "```\ntc(ifE(boolE, plusE(numE, numE), numE), numT).\n```", "```\ntc(ifE(boolE, plusE(numE, numE), numE), Y).\n```", "```\ntc(numE, _, numT).\ntc(strE, _, strT).\ntc(boolE, _, boolT).\n```", "```\ntc(plusE(L, R), Env, numT) :-\n    tc(L, Env, numT),\n    tc(R, Env, numT).\n```", "```\ntc(catE(L, R), Env, strT) :-\n    tc(L, Env, strT),\n    tc(R, Env, strT).\n```", "```\ntc(ifE(C, T, E), Env, Ty) :-\n    tc(C, Env, boolT),\n    tc(T, Env, Ty),\n    tc(E, Env, Ty).\n```", "```\ntc(varE(V), [bind(V, T) | _], T).\n```", "```\ntc(varE(V), [bind(_, _) | RestTEnv], T) :-\n   tc(varE(V), RestTEnv, T).\n```", "```\ntc(lamE(V, B), TEnv, funT(A, R)) :-\n    tc(B, [bind(V, A) | TEnv], R).\n```", "```\ntc(appE(F, A), TEnv, U) :-\n    tc(F, TEnv, funT(T, U)),\n    tc(A, TEnv, T).\n```", "```\n(lambda (v)\n  (lambda (w)\n    (if v\n        (+ w 1)\n        (+ w 2))))\n```", "```\ntc(lamE(v, \n     lamE(w, \n       ifE(varE(v), \n           plusE(varE(w), numE),\n           plusE(varE(w), numE)))), TEnv, T)\n```", "```\ntc(lamE(v, ifE(boolE, strE, numE)), _, _)\n```", "```\ntc(lamE(w, ifE(A, strE, numE)), _, _)\n```", "```\ndef nats():\n  n = 0\n  while True:\n    yield n\n    n += 1\n```", "```\ng = nats()\n```", "```\nnext(g) + next(g) + next(g)\n```", "```\ndef natsr():\n  n = 0\n  while True:\n    return n\n    n += 1\n```", "```\nnatsr() + natsr() + natsr()\n```", "```\n(deffun (yield n)\n  n)\n```", "```\n(deffun (gen)\n  (defvar n 0)\n  (deffun (loop)\n    (yield n)\n    (set! n (+ n 1))\n    (loop))\n  (loop))\n```", "```\n(+ (gen) (gen) (gen))\n```", "```\n(begin\n  •\n  (set! n (+ n 1))\n  (loop))\n```", "```\n(+ • (gen) (gen))\n```", "```\n(begin\n  •\n  (set! n (+ n 1))\n  (loop))\n```", "```\n(+ 0 • (gen))\n```", "```\n(+ 0 1 •)\n```", "```\ndef nats():\n  n = 0\n  while True:\n    yield n\n    n += 1\n```", "```\ndef odds():\n  ns = nats()\n  while True:\n    n = next(ns)\n    if n % 2:\n      yield n\n```", "```\ng = odds()\n```", "```\nnext(g) + next(g) + next(g)\n```", "```\nwhile True:\n  n = •\n  if n % 2:\n    yield n\n```", "```\nwhile True:\n  •\n  n += 1\n```", "```\n    n = next(ns)\n    if n % 2:\n      yield n\n```", "```\nwhile True:\n  •\n  n += 1\n```", "```\n    yield n\n    n += 1\n```", "```\nwhile True:\n  •\n  n += 1\n```", "```\n  while True:\n    n = next(ns)\n    if n % 2:\n      •\n```", "```\n1 + • + next(g)\n```", "```\n(deffun (f x)\n  (g (+ x x)))\n```", "```\n(deffun (g y)\n  (h (* y 2)))\n```", "```\n(deffun (h x)\n  (+ x 5))\n```", "```\n(f (+ 2 3))\n```", "```\n  (f (+ 2 3))\n→ (g (+ (+ 2 3) (+ 2 3)))\n→ (h (* (+ (+ 2 3) (+ 2 3))) 2))\n→ (+ (* (+ (+ 2 3) (+ 2 3))) 2) 5)\n```", "```\n(deffun (f x)\n  (if (even? x)\n      7\n      11))\n```", "```\n(f (+ 2 3))\n```", "```\n(if (even? (+ 2 3))\n    7\n    11)\n```", "```\n(deffun (fact n)\n  (if (zero? n)\n      1\n      (* n (fact (- n 1)))))\n```", "```\n(fact 5)\n```", "```\n  (if (zero? 5)\n      1\n      (* 5 (fact (- 5 1)))))\n```", "```\n  (f (+ 2 3))\n```", "```\n  (f (+ 2 3))\n```", "```\n#lang lazy\n```", "```\n(define ones (cons 1 ones))\n```", "```\n(define (nats-from n)\n  (cons n (nats-from (add1 n))))\n```", "```\n(define nats (nats-from 0))\n```", "```\n(define (take n s)\n  (if (zero? n)\n      empty\n      (cons (first s) (take (sub1 n) (rest s)))))\n```", "```\n> ones\n#<promise:ones>\n> nats\n#<promise:nats>\n```", "```\n> (! ones)\n#0='(1 . #<promise!#0#>)\n> (! nats)\n'(0 . #<promise:...e/pkgs/lazy/base.rkt:299:29>)\n```", "```\n> (! (rest ones))\n#0='(1 . #<promise!#0#>)\n> (! (rest (rest (rest ones))))\n#0='(1 . #<promise!#0#>)\n> (! (rest nats))\n'(#<promise:...e/pkgs/lazy/base.rkt:299:29> . #<promise:...e/pkgs/lazy/base.rkt:299:29>)\n> (! (rest (rest (rest nats))))\n'(#<promise:...e/pkgs/lazy/base.rkt:299:29> . #<promise:...e/pkgs/lazy/base.rkt:299:29>)\n```", "```\n> (take 10 ones)\n'(#<promise:...e/pkgs/lazy/base.rkt:299:29> . #<promise:...e/pkgs/lazy/base.rkt:299:29>)\n> (take 10 nats)\n'(#<promise:...e/pkgs/lazy/base.rkt:299:29> . #<promise:...e/pkgs/lazy/base.rkt:299:29>)\n```", "```\n> (!! (take 10 ones))\n'(1 1 1 1 1 1 1 1 1 1)\n> (!! (take 10 nats))\n'(0 1 2 3 4 5 6 7 8 9)\n```", "```\n#lang stacker/smol/hof\n```", "```\n(deffun (lz-first s) (left s))\n(deffun (lz-rest s) ((right s)))\n(deffun (take n s)\n  (if (equal? n 0)\n      empty\n      (cons (lz-first s) (take (- n 1) (lz-rest s)))))\n```", "```\n(defvar ones (mpair 1 (λ () ones)))\n```", "```\n(deffun (nats-from n)\n  (mpair n (λ () (nats-from (+ n 1)))))\n(defvar nats (nats-from 0))\n```", "```\n(take 3 ones)\n(take 3 nats)\n```", "```\n(define (f x y)\n  (g x y))\n```", "```\n(define (g x y)\n  (if (zero? (random 2)) x y))\n```", "```\n(f (print \"X\") (print \"Y\"))\n```", "```\n(define n 0)\n(f (set! n (add1 n)) (set! n (sub1 n)))\n```", "```\n(define (g x y)\n  (if (zero? (random 2)) \"X\" \"Y\"))\n```", "```\n(define (sq x)\n  (* x x))\n```", "```\n(define v (make-vector 1000 0))\n(sq (vector-ref v 2))\n```", "```\n#lang stacker/smol/hof\n```", "```\n(deffun (get-number s)\n  5)\n```", "```\n(+ (get-number \"first\") (get-number \"second\"))\n```", "```\nfunction fact(n) {\n  ans = 1;\n  while (n != 0) {\n    ans = ans * n;\n    n = n - 1;\n  }\n  return ans;\n}\n```", "```\n<script type=\"application/javascript\">\nfunction fact(n) {\n  ans = 1;\n  while (n != 0) {\n    ans = ans * n;\n    n = n - 1;\n  }\n  return ans;\n}\nfunction show() {\n  window.alert('here');\n  ans = fact(-1);\n  window.alert(ans);\n  document.getElementById('answer').innerHTML = ans;\n\n}\n</script>\n</head>\n```", "```\n<body>\n<button onclick=\"show()\">Click me</button>\n<div id=\"answer\"></div>\n```", "```\nsetTimeout(C, 0)\n```", "```\nrequestAnimationFrame(C)\n```", "```\n(defvar yielder #false)\n```", "```\n(deffun (get-number/k s rest)\n  (set! resume rest))\n```", "```\n(get-number/k \"first\"\n              (λ (•1)\n                (get-number/k \"second\"\n                              (λ (•2)\n                                (+ •1 •2)))))\n```", "```\n(resume 5)\n```", "```\n(resume 7)\n```", "```\n#lang racket\n```", "```\n(provide yield resume)\n```", "```\n(define resumer #false)\n```", "```\n(define (yield)\n  (let/cc k\n    (set! resumer k)\n    (raise 'yield)))\n```", "```\n(define (resume)\n  (resumer 'dummy))\n```", "```\n#lang racket\n```", "```\n(require \"yielder.rkt\")\n```", "```\n(define (fact n)\n  (if (= n 0)\n      1\n      (if (zero? (modulo n 5))\n          (begin\n            (yield)\n            (* n (fact (- n 1))))\n          (* n (fact (- n 1))))))\n```", "```\n> (fact 7)\nuncaught exception: 'yield\n> (resume)\n5040\n```", "```\n#lang web-server/insta\n```", "```\n(define (start req)\n```", "```\n    (response/xexpr\n     `(html (body (p \"The result is \" ,(number->string result)))))))\n```", "```\n(define (get-number which)\n  (define title (format \"What is the ~a number?\" which))\n  (define req\n    (send/suspend\n     (lambda (k-url)\n```", "```\n  (string->number\n```", "```\n#lang web-server/insta\n```", "```\n(define count 0)\n```", "```\n(define (show-count)\n  (send/suspend\n     (lambda (k-url)\n       (response/xexpr\n        `(html (head \"Counter\")\n               (body\n                (p () \"The current count is \" ,(number->string count))\n                (form ([action ,k-url])\n                      (input ([type \"submit\"])))))))))\n```", "```\n(define (start req)\n  (show-count)\n  (set! count (add1 count))\n  (start 'dummy))\n```", "```\n#lang web-server/insta\n```", "```\n(define (show-count count)\n  (send/suspend\n     (lambda (k-url)\n       (response/xexpr\n        `(html (head \"Counter\")\n               (body\n                (p () \"The current count is \" ,(number->string count))\n                (form ([action ,k-url])\n                      (input ([type \"submit\"])))))))))\n```", "```\n(define (loop count)\n  (show-count count)\n  (loop (add1 count)))\n```", "```\n(define (start req)\n  (loop 0))\n```", "```\n<script type=\"text/javascript\">\nvar timerID = null;\nvar elapsedTime = 0;\n```", "```\nfunction doEverySecond() {\n  elapsedTime += 1;\n  document.getElementById('curTime').innerHTML = elapsedTime; }\nfunction startTimer() {\n  timerId = setInterval(doEverySecond, 1000); }\nfunction resetElapsed() {\n  elapsedTime = 0; }\n</script>\n```", "```\n<body onload=\"startTimer()\">\n  <center>Elapsed time</center>\n  <center>\n    <div id='curTime'>&nbsp;</div>\n  </center>\n  <center>\n    <input id=\"reset\" type=\"button\" value=\"Reset\" onclick=\"resetElapsed()\" />\n  </center>\n</body>\n```", "```\n> 5\n5\n> (+ 2 3)\n5\n> (string-length \"hello\")\n5\n```", "```\n> (current-seconds)\n1668363009\n> (add1 (current-seconds))\n1668363010\n```", "```\n> seconds\n```", "```\n> (add1 seconds)\n```", "```\n> (modulo seconds 10)\n```", "```\n> (build-list 5 (lambda (n) n))\n'(0 1 2 3 4)\n```", "```\n> (build-list (modulo seconds 10) (lambda (n) n))\n```", "```\n> (length (build-list (modulo seconds 10) (lambda (n) n)))\n```", "```\n(length (build-list (modulo seconds 10) (lambda (n) n)))\n```", "```\n(let ([a-value a])\n  (if (time-varying? a-value)\n    …\n    (f a-value)))\n```", "```\n(define seconds\n  (new tvv% [updater (λ (v) v)]))\n```", "```\n(define mod•5\n  (new tvv% [updater (λ (v) (modulo v 5))]))\n```", "```\n(send seconds add-consumer mod•5)\n```", "```\n(define bl•id\n  (new tvv% [updater (λ (v) (build-list v (λ (n) n)))]))\n```", "```\n(send mod•5 add-consumer bl•id)\n```", "```\n(define show\n  (new tvv% [updater (λ (v) (println v))]))\n```", "```\n(send bl•id add-consumer show)\n```", "```\n(for-each (λ (n) (send seconds update n)) (range 0 10))\n```", "```\n'()\n'(0)\n'(0 1)\n'(0 1 2)\n'(0 1 2 3)\n'()\n'(0)\n'(0 1)\n'(0 1 2)\n'(0 1 2 3)\n```", "```\n(define tvv%\n  (class object%\n    (init updater)\n    (define updater-function updater)\n```", "```\n    (super-new)\n```", "```\n    (define consumers empty)\n    (define/public (add-consumer new-consumer)\n      (set! consumers (cons new-consumer consumers)))\n```", "```\n    (define/public (update pushed-value)\n      (let ([new-current-value (updater-function pushed-value)])\n        (for-each (λ (c) (send c update new-current-value))\n                  consumers)))))\n```", "```\n(= (modulo seconds 3) (modulo seconds 5))\n```", "```\n(< seconds (add1 seconds))\n```", "```\n(require frtime/animation)\n```", "```\n(display-shapes\n (list\n  (make-circle mouse-pos 10 \"blue\")))\n```", "```\n(display-shapes\n (let ([n 4])\n   (build-list\n    n\n    (lambda (i)\n      (make-circle (delay-by mouse-pos (* 200 (- (- n 1) i)))\n                   10\n                   \"green\")))))\n```", "```\n(require frtime/gui)\n```", "```\n(define init-time seconds)\n(define elapsed-time (- seconds init-time))\n```", "```\n(make-message (number->string elapsed-time))\n```", "```\n> init-time\n```", "```\n(define init-time (value-now seconds))\n```", "```\n(define reset-clicks (make-button \"Reset\"))\n```", "```\n(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))\n```", "```\n(define event-times (switch click-times init-time))\n```", "```\n(define elapsed-time (- seconds event-times))\n```", "```\n(define init-time (value-now seconds))\n```", "```\n(define reset-clicks (make-button \"Reset\"))\n(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))\n(define event-times (switch click-times init-time))\n(define elapsed-time (- seconds event-times))\n```", "```\n(make-message (number->string elapsed-time))\n```", "```\n(make-message (number->string\n               (- seconds\n                  (switch\n                   (map-e (lambda (_) (value-now seconds))\n                          (make-button \"Reset\"))\n                   (value-now seconds)))))\n```"]
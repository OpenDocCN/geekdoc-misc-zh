["```rs\nSELECT e.name, d.dept_name\nFROM employees e\nJOIN departments d ON e.dept_id = d.id\nWHERE e.state = 'CO' \n```", "```rs\nBefore optimization:\n  Filter: state = 'CO'\n    Join: e.dept_id = d.id\n      Scan: employees\n      Scan: departments\n\nAfter optimization:\n  Join: e.dept_id = d.id\n    Filter: state = 'CO'\n      Scan: employees\n    Scan: departments \n```", "```rs\ninterface OptimizerRule {\n    fun optimize(plan: LogicalPlan): LogicalPlan\n}\n\nclass Optimizer {\n    fun optimize(plan: LogicalPlan): LogicalPlan {\n        var result = plan\n        result = ProjectionPushDownRule().optimize(result)\n        // Additional rules would be applied here\n        return result\n    }\n} \n```", "```rs\nfun extractColumns(expr: LogicalExpr, input: LogicalPlan, accum: MutableSet<String>) {\n    when (expr) {\n        is Column -> accum.add(expr.name)\n        is ColumnIndex -> accum.add(input.schema().fields[expr.i].name)\n        is BinaryExpr -> {\n            extractColumns(expr.l, input, accum)\n            extractColumns(expr.r, input, accum)\n        }\n        is Alias -> extractColumns(expr.expr, input, accum)\n        is CastExpr -> extractColumns(expr.expr, input, accum)\n        is LiteralString, is LiteralLong, is LiteralDouble -> { }\n        else -> throw IllegalStateException(\"Unsupported: $expr\")\n    }\n} \n```", "```rs\nclass ProjectionPushDownRule : OptimizerRule {\n\n    override fun optimize(plan: LogicalPlan): LogicalPlan {\n        return pushDown(plan, mutableSetOf())\n    }\n\n    private fun pushDown(plan: LogicalPlan, columnNames: MutableSet<String>): LogicalPlan {\n        return when (plan) {\n            is Projection -> {\n                extractColumns(plan.expr, plan.input, columnNames)\n                val input = pushDown(plan.input, columnNames)\n                Projection(input, plan.expr)\n            }\n            is Selection -> {\n                extractColumns(plan.expr, plan.input, columnNames)\n                val input = pushDown(plan.input, columnNames)\n                Selection(input, plan.expr)\n            }\n            is Aggregate -> {\n                extractColumns(plan.groupExpr, plan.input, columnNames)\n                extractColumns(plan.aggregateExpr.map { it.expr }, plan.input, columnNames)\n                val input = pushDown(plan.input, columnNames)\n                Aggregate(input, plan.groupExpr, plan.aggregateExpr)\n            }\n            is Scan -> {\n                val validFields = plan.dataSource.schema().fields.map { it.name }.toSet()\n                val projection = validFields.filter { columnNames.contains(it) }.sorted()\n                Scan(plan.path, plan.dataSource, projection)\n            }\n            else -> throw IllegalStateException(\"Unsupported: $plan\")\n        }\n    }\n} \n```", "```rs\nProjection: #id, #first_name, #last_name\n    Filter: #state = 'CO'\n        Scan: employee; projection=None \n```", "```rs\nProjection: #id, #first_name, #last_name\n    Filter: #state = 'CO'\n        Scan: employee; projection=[first_name, id, last_name, state] \n```", "```rs\nProjection: #dept_name, #first_name, #last_name\n    Filter: #state = 'CO'\n        Join: #employee.dept_id = #dept.id\n            Scan: employee\n            Scan: dept \n```", "```rs\nProjection: #dept_name, #first_name, #last_name\n    Join: #employee.dept_id = #dept.id\n        Filter: #state = 'CO'\n            Scan: employee\n        Scan: dept \n```", "```rs\nSELECT sum(price * qty) AS total_price,\n       sum(price * qty * tax_rate) AS total_tax\nFROM sales \n```", "```rs\nAggregate: sum(#price * #qty), sum(#price * #qty * #tax_rate)\n    Scan: sales \n```", "```rs\nAggregate: sum(#subtotal), sum(#subtotal * #tax_rate)\n    Projection: #price * #qty AS subtotal, #tax_rate\n        Scan: sales \n```"]
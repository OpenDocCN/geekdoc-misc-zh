- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/traits.html](https://freddiehaddad.github.io/fast-track-to-rust/traits.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the previous section, we specified trait bounds to restrict the types that
    can be used with our `Interval`. Let''s formalize what a trait is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A trait is officially defined as a collection of methods for an unknown type:
    `Self`.^([1](#footnote-1))'
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, a trait allows you to define shared behavior in an abstract
    way. It specifies a set of methods that a type must implement, similar to interfaces
    in other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: The [Rust By Example](https://doc.rust-lang.org/rust-by-example/) book includes
    many examples of [traits](https://doc.rust-lang.org/rust-by-example/trait.html)
    and explores their usage in depth. Reviewing this material is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler can automatically provide basic implementations for certain traits
    using the derive (`#[derive]`) [attribute](https://doc.rust-lang.org/reference/attributes.html).
    However, if more complex behavior is needed, these traits can still be manually
    implemented. Here is a list of derivable traits:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Comparison traits: [`Eq`](https://doc.rust-lang.org/std/cmp/trait.Eq.html),
    [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html), Ord, [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html), to create
    `T` from `&T` via a copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html), to give a type
    *copy semantics* instead of *move semantics*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Hash`](https://doc.rust-lang.org/std/hash/trait.Hash.html), to compute a
    hash from `&T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html), to create
    an empty instance of a data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html), to format a
    value using the `{:?}` formatter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deriving a Trait](#deriving-a-trait)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Someone using our `Interval` might find it helpful to have an easy way to compare
    them. For instance, a user may want to check if two intervals are equal. The [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)
    trait, part of the [`cmp`](https://doc.rust-lang.org/std/cmp/index.html) module,
    specifies two methods that any type must define to implement the `PartialEq` trait.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice the comment above the `ne` method that says "Provided method." This indicates
    that if we manually implement this trait, we only need to provide an implementation
    for `eq`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here's our revised `Interval` with support for `PartialEq`, thanks to the derive
    attribute and the Rust compiler. Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: The `Debug` trait has also been derived, enabling intervals to be printed in
    a programmer-facing context using the `:?` operator. This common pattern in Rust
    provides more helpful output in the program below.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: use interval::Interval;
  prefs: []
  type: TYPE_NORMAL
- en: pub mod interval {
  prefs: []
  type: TYPE_NORMAL
- en: '/// A list specifying general categories of Interval errors.    #[derive(Debug)]'
  prefs: []
  type: TYPE_NORMAL
- en: pub enum IntervalError {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals
    to be merged do not overlap NonOverlappingInterval, }
  prefs: []
  type: TYPE_NORMAL
- en: '/// A closed-interval [`start`, `end`] type used for representing a range of
    /// values between `start` and `end` inclusively. /// /// # Examples /// /// You
    can create an `Interval` using `new`. /// /// [PRE2]    #[derive(Debug, PartialEq)]'
  prefs: []
  type: TYPE_NORMAL
- en: pub struct Interval<T> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub start: T, pub end: T, }   impl<T: Copy + PartialOrd> Interval<T> { ///
    Creates a new `Interval` set to `start` and `end`. /// /// # Examples /// ///
    [PRE3] pub fn new(start: T, end: T) -> Result<Self, IntervalError> { if start
    <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid)
    } }   /// Checks if two intervals overlap. Overlapping intervals have at least
    /// one point in common. /// /// # Examples /// /// [PRE4] /// /// [PRE5] ///
    /// [PRE6] pub fn overlaps(&self, other: &Interval<T>) -> bool { self.end >= other.start
    }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval`
    range includes the union of ranges from each /// `Interval`. /// /// # Examples
    /// /// [PRE7] pub fn merge(&self, other: &Self) -> Result<Self, IntervalError>
    { if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) }
    else { Err(IntervalError::NonOverlappingInterval) } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let a = Interval::new(1, 5).unwrap(); // unwrap returns the Ok value or panics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let b = Interval::new(1, 5).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let c = Interval::new(2, 4).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Comparing intervals with eq and ne.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{:?} == {:?} => {}", a, b, a.eq(&b));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{:?} == {:?} => {}", a, c, a.eq(&c));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{:?} != {:?} => {}", a, b, a.ne(&b));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{:?} != {:?} => {}", a, c, a.ne(&c));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Rust supports operator overloading too!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{:?} == {:?} => {}", a, b, a == b);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{:?} != {:?} => {}", a, c, a != c);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The [`unwrap()`](https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap)
    method is implemented by `Result` and other types like `Option`. For `Result`,
    it returns the `Ok` value or panics if the value is `Err`. Its usage is generally
    discouraged and is only used here for brevity.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Operator Overloading
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You might have noticed the comparison between intervals using `==` and `!=`.
    This works because Rust includes support for operator overloading! You can find
    all the detailed information in the [Operator Overloading](https://doc.rust-lang.org/rust-by-example/trait/ops.html)
    section of the [Rust by Example](https://doc.rust-lang.org/rust-by-example/) book
    and in the [`ops`](https://doc.rust-lang.org/std/ops/index.html) module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Implementing a Trait](#implementing-a-trait)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as comparing traits for equality can be helpful, so can generating a user-facing
    representation of an `Interval`. By implementing the [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html)
    trait, we can achieve this quite efficiently. Additionally, implementing the `Display`
    trait automatically implements the [`ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html)
    trait, enabling the use of the `to_string()` method. Let's enhance our `Interval`
    code to print an interval in the form `[x, y]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the trait definition for `Display`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `<'_>` suffix next to `Formatter` is known as *lifetime annotation syntax*.^([2](#footnote-2))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here's our revised `Interval` with the `Display` trait implemented. Give it
    a try!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: use interval::Interval;
  prefs: []
  type: TYPE_NORMAL
- en: pub mod interval {
  prefs: []
  type: TYPE_NORMAL
- en: '/// A list specifying general categories of Interval errors. #[derive(Debug)]
    pub enum IntervalError { /// Start is not less than or equal to end StartEndRangeInvalid,
    /// Two intervals to be merged do not overlap NonOverlappingInterval, }   ///
    A closed-interval [`start`, `end`] type used for representing a range of /// values
    between `start` and `end` inclusively. /// /// # Examples /// /// You can create
    an `Interval` using `new`. /// /// [PRE11] #[derive(Debug, PartialEq)] pub struct
    Interval<T> { pub start: T, pub end: T, }      use std::fmt;'
  prefs: []
  type: TYPE_NORMAL
- en: 'impl<T: fmt::Display> fmt::Display for Interval<T> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn fmt(&self, f: &mut std::fmt::Formatter<''_>) -> fmt::Result {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: write!(f, "[{}, {}]", self.start, self.end)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'impl<T: Copy + PartialOrd> Interval<T> { /// Creates a new `Interval` set to
    `start` and `end`. /// /// # Examples /// /// [PRE12] pub fn new(start: T, end:
    T) -> Result<Self, IntervalError> { if start <= end { Ok(Self { start, end })
    } else { Err(IntervalError::StartEndRangeInvalid) } }   /// Checks if two intervals
    overlap. Overlapping intervals have at least /// one point in common. /// ///
    # Examples /// /// [PRE13] /// /// [PRE14] /// /// [PRE15] pub fn overlaps(&self,
    other: &Interval<T>) -> bool { self.end >= other.start }   /// Merges two intervals
    returning a new `Interval`. /// /// The merged `Interval` range includes the union
    of ranges from each /// `Interval`. /// /// # Examples /// /// [PRE16] pub fn
    merge(&self, other: &Self) -> Result<Self, IntervalError> { if self.overlaps(other)
    { Ok(Self { start: self.start, end: other.end, }) } else { Err(IntervalError::NonOverlappingInterval)
    } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let a = Interval::new(1, 5).unwrap(); // unwrap returns the Ok value or panics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let b = Interval::new(1, 5).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let b_str = b.to_string();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let c = Interval::new(2, 4).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Comparisons between three intervals: {}, {}, {}...",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: a, b_str, c
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: );
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Comparing intervals with eq and ne.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{} == {} => {}", a, b, a.eq(&b));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{} == {} => {}", a, c, a.eq(&c));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{} != {} => {}", a, b, a.ne(&b));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{} != {} => {}", a, c, a.ne(&c));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Rust supports operator overloading too!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{} == {} => {}", a, b, a == b);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{} != {} => {}", a, c, a != c);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our interval module has been enhanced to support several new capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can print programmer-facing intervals using the `Debug` trait and user-facing
    intervals using the `Display` trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have limited support for comparing intervals through the `PartialEq` and
    `PartialOrd` traits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trait defines shared behavior abstractly, specifying methods a type must implement,
    similar to interfaces in other languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler can automatically provide basic implementations for certain traits
    using the `#[derive]` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust includes support for operator overloading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement the [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)
    trait for `Interval`. To keep the code simple, you can return `None` for overlapping
    intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: use interval::Interval;
  prefs: []
  type: TYPE_NORMAL
- en: pub mod interval {
  prefs: []
  type: TYPE_NORMAL
- en: /// A list specifying general categories of Interval errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[derive(Debug)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pub enum IntervalError {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Start is not less than or equal to end
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: StartEndRangeInvalid,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Two intervals to be merged do not overlap
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: NonOverlappingInterval,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// A closed-interval [`start`, `end`] type used for representing a range of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// values between `start` and `end` inclusively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// You can create an `Interval` using `new`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE19]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[derive(Debug, PartialEq)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pub struct Interval<T> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub start: T,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub end: T,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use std::fmt;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'impl<T: fmt::Display> fmt::Display for Interval<T> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn fmt(&self, f: &mut std::fmt::Formatter<''_>) -> fmt::Result {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: write!(f, "[{}, {}]", self.start, self.end)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'impl<T: Copy + PartialOrd> Interval<T> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Creates a new `Interval` set to `start` and `end`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE20]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub fn new(start: T, end: T) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if start <= end {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self { start, end })
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::StartEndRangeInvalid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Checks if two intervals overlap. Overlapping intervals have at least
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// one point in common.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE21]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE22]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE23]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub fn overlaps(&self, other: &Interval<T>) -> bool {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.end >= other.start
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Merges two intervals returning a new `Interval`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// The merged `Interval` range includes the union of ranges from each
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// `Interval`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE24]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if self.overlaps(other) {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'start: self.start,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: other.end,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::NonOverlappingInterval)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: use std::cmp::Ordering::{Equal, Greater, Less};
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let a = Interval::new(0, 1).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let b = Interval::new(0, 1).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert_eq!(a.partial_cmp(&b), Some(Equal));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert_eq!(b.partial_cmp(&a), Some(Equal));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let a = Interval::new(0, 1).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let b = Interval::new(2, 3).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert_eq!(a.partial_cmp(&b), Some(Less));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert_eq!(b.partial_cmp(&a), Some(Greater));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("Nice Work!");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <details><summary>Solution</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: use interval::Interval;   pub mod interval {
  prefs: []
  type: TYPE_NORMAL
- en: '/// A list specifying general categories of Interval errors. #[derive(Debug)]
    pub enum IntervalError { /// Start is not less than or equal to end StartEndRangeInvalid,
    /// Two intervals to be merged do not overlap NonOverlappingInterval, }   ///
    A closed-interval [`start`, `end`] type used for representing a range of /// values
    between `start` and `end` inclusively. /// /// # Examples /// /// You can create
    an `Interval` using `new`. /// /// [PRE27] #[derive(Debug, PartialEq)] pub struct
    Interval<T> { pub start: T, pub end: T, }   use std::fmt; impl<T: fmt::Display>
    fmt::Display for Interval<T> { fn fmt(&self, f: &mut std::fmt::Formatter<''_>)
    -> fmt::Result { write!(f, "[{}, {}]", self.start, self.end) } }      use std::cmp::Ordering;'
  prefs: []
  type: TYPE_NORMAL
- en: 'impl<T: PartialEq + PartialOrd> PartialOrd for Interval<T> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn partial_cmp(&self, other: &Self) -> Option<Ordering> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if self == other {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(Ordering::Equal)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if self.end < other.start {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(Ordering::Less)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if self.start > other.end {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(Ordering::Greater)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: None // Intervals overlap
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'impl<T: Copy + PartialOrd> Interval<T> { /// Creates a new `Interval` set to
    `start` and `end`. /// /// # Examples /// /// [PRE28] pub fn new(start: T, end:
    T) -> Result<Self, IntervalError> { if start <= end { Ok(Self { start, end })
    } else { Err(IntervalError::StartEndRangeInvalid) } }   /// Checks if two intervals
    overlap. Overlapping intervals have at least /// one point in common. /// ///
    # Examples /// /// [PRE29] /// /// [PRE30] /// /// [PRE31] pub fn overlaps(&self,
    other: &Interval<T>) -> bool { self.end >= other.start }   /// Merges two intervals
    returning a new `Interval`. /// /// The merged `Interval` range includes the union
    of ranges from each /// `Interval`. /// /// # Examples /// /// [PRE32] pub fn
    merge(&self, other: &Self) -> Result<Self, IntervalError> { if self.overlaps(other)
    { Ok(Self { start: self.start, end: other.end, }) } else { Err(IntervalError::NonOverlappingInterval)
    } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: use std::cmp::Ordering::{Equal, Greater, Less};   let a = Interval::new(0, 1).unwrap();
    let b = Interval::new(0, 1).unwrap(); assert_eq!(a.partial_cmp(&b), Some(Equal));
    assert_eq!(b.partial_cmp(&a), Some(Equal));   let a = Interval::new(0, 1).unwrap();
    let b = Interval::new(2, 3).unwrap(); assert_eq!(a.partial_cmp(&b), Some(Less));
    assert_eq!(b.partial_cmp(&a), Some(Greater));   println!("Nice Work!"); }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered traits, let's ensure our projects are synchronized before
    we proceed to exploring attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the completed code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)]'
  prefs: []
  type: TYPE_NORMAL
- en: extern crate regex; // this is needed for the playground
  prefs: []
  type: TYPE_NORMAL
- en: use interval::{Interval, IntervalError};
  prefs: []
  type: TYPE_NORMAL
- en: use itertools::Itertools;
  prefs: []
  type: TYPE_NORMAL
- en: use regex::Regex;
  prefs: []
  type: TYPE_NORMAL
- en: use std::fs::File;
  prefs: []
  type: TYPE_NORMAL
- en: use std::io::Read;
  prefs: []
  type: TYPE_NORMAL
- en: use std::io::{BufRead, BufReader};
  prefs: []
  type: TYPE_NORMAL
- en: use std::process::exit;
  prefs: []
  type: TYPE_NORMAL
- en: 'fn find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match regex.is_match(line) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect() // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'before_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'after_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Result<Vec<Interval<usize>>, IntervalError> {
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let start = line.saturating_sub(before_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let end = line.saturating_add(after_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Interval::new(start, end)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn merge_intervals(intervals: Vec<Interval<usize>>) -> Vec<Interval<usize>>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .into_iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .coalesce(|p, c| p.merge(&c).map_err(|_| (p, c)))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_results(intervals: Vec<Interval<usize>>, lines: Vec<String>) {'
  prefs: []
  type: TYPE_NORMAL
- en: for interval in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in lines
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .take(interval.end + 1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .skip(interval.start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what can be the use of him is more than I can see.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: He is very, very like me from the heels up to the head;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And I see him jump before me, when I jump into my bed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The funniest thing about him is the way he likes to grow -
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not at all like proper children, which is always very slow;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For he sometimes shoots up taller like an india-rubber ball,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And he sometimes gets so little that there's none of him at all.";
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let mock_file = std::io::Cursor::new(poem);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // command line arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let pattern = "(all)|(little)";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let before_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let after_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // attempt to open the file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let lines = read_file(mock_file);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //let lines = match File::open(filename) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    // convert the poem into lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    Ok(file) => read_file(file),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    Err(e) => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '//        eprintln!("Error opening {filename}: {e}");'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //        exit(1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //};
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // compile the regular expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let regex = match Regex::new(pattern) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(re) => re, // bind re to regex
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(e) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: eprintln!("{e}"); // write to standard error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // store the 0-based line number for any matched line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let match_lines = find_matching_lines(&lines, regex);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // create intervals of the form [a,b] with the before/after context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let intervals =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match create_intervals(match_lines, before_context, after_context) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(intervals) => intervals,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(_) => {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: eprintln!("An error occurred while creating intervals");
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let intervals = merge_intervals(intervals);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // print the lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_results(intervals, lines);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: pub mod interval {
  prefs: []
  type: TYPE_NORMAL
- en: /// A list specifying general categories of Interval errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[derive(Debug)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pub enum IntervalError {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Start is not less than or equal to end
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: StartEndRangeInvalid,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Two intervals to be merged do not overlap
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: NonOverlappingInterval,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// A closed-interval [`start`, `end`] type used for representing a range of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// values between `start` and `end` inclusively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// You can create an `Interval` using `new`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE35]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[derive(Debug, PartialEq)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pub struct Interval<T> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub start: T,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub end: T,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'impl<T: Copy + PartialOrd> Interval<T> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Creates a new `Interval` set to `start` and `end`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE36]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub fn new(start: T, end: T) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if start <= end {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self { start, end })
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::StartEndRangeInvalid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Checks if two intervals overlap. Overlapping intervals have at least
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// one point in common.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE37]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE38]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE39]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub fn overlaps(&self, other: &Interval<T>) -> bool {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.end >= other.start
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Merges two intervals returning a new `Interval`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// The merged `Interval` range includes the union of ranges from each
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// `Interval`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE40]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if self.overlaps(other) {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'start: self.start,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: other.end,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::NonOverlappingInterval)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use std::fmt;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'impl<T: fmt::Display> fmt::Display for Interval<T> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn fmt(&self, f: &mut std::fmt::Formatter<''_>) -> fmt::Result {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: write!(f, "[{}, {}]", self.start, self.end)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use std::cmp::Ordering;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'impl<T: PartialEq + PartialOrd> PartialOrd for Interval<T> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn partial_cmp(&self, other: &Self) -> Option<Ordering> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if self == other {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(Ordering::Equal)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if self.end < other.start {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(Ordering::Less)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if self.start > other.end {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(Ordering::Greater)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: None // Intervals overlap
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: https://doc.rust-lang.org/rust-by-example/trait.html [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a separate topic that you can learn more about in the [Validating References
    with Lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html) section
    of the [Rust Programming Language](https://doc.rust-lang.org/stable/book/) and
    the [Lifetimes](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html)
    section of [Rust By Example](https://doc.rust-lang.org/rust-by-example/). [↩](#fr-2-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

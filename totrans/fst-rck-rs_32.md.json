["```rs\nlet pattern = \"[Ee]xample\";\nlet re = Regex::new(pattern);\n```", "```rs\nfn new(re: &str) -> Result<Regex, Error>\n```", "```rs\nextern crate regex; // this is needed for the playground\nuse regex::Regex;\nuse std::process::exit;\n\nfn main() {\n    let pattern = \"(missing the closing parenthesis\"; // invalid expression\n\n    // compile the regular expression\n    match Regex::new(pattern) {\n        // the underscore (_) means we are ignoring the value returned by new\n        Ok(_) => println!(\"{pattern} is a valid regular expression!\"),\n\n        // e is the error value returned by new\n        Err(e) => {\n            eprintln!(\"{e}\"); // eprintln! writes to standard error\n            exit(1);          // exit with error code 1\n        }\n    };\n}\n```", "```rs\n#![allow(unused_imports)] use std::fs::File; use std::io::Read; use std::io::{BufRead, BufReader}; use std::process::exit; extern crate regex; // this is needed for the playground use regex::Regex;\n\nfn find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match regex.is_match(line) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn create_intervals(\n lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Vec<(usize, usize)> {\n lines .iter() .map(|line| { ( line.saturating_sub(before_context), line.saturating_add(after_context), ) }) .collect() }   fn merge_intervals(intervals: &mut Vec<(usize, usize)>) {\n // merge overlapping intervals intervals.dedup_by(|next, prev| { if prev.1 < next.0 { false } else { prev.1 = next.1; true } }) }   fn print_results(intervals: Vec<(usize, usize)>, lines: Vec<String>) {\n for (start, end) in intervals { for (line_no, line) in lines.iter().enumerate().take(end + 1).skip(start) { println!(\"{}: {}\", line_no + 1, line) } } }   fn read_file(file: impl Read) -> Vec<String> {\n BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {\n let poem = \"I have a little shadow that goes in and out with me, And what can be the use of him is more than I can see. He is very, very like me from the heels up to the head; And I see him jump before me, when I jump into my bed.   The funniest thing about him is the way he likes to grow - Not at all like proper children, which is always very slow; For he sometimes shoots up taller like an india-rubber ball, And he sometimes gets so little that there's none of him at all.\";   let mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern = \"(all)|(little)\"; let before_context = 1; let after_context = 1;   // attempt to open the file let lines = read_file(mock_file); //let lines = match File::open(filename) { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e) => { //        eprintln!(\"Error opening {filename}: {e}\"); //        exit(1); //    } //};      // compile the regular expression\n    let regex = match Regex::new(pattern) {\n        Ok(re) => re, // bind re to regex\n        Err(e) => {\n            eprintln!(\"{e}\"); // write to standard error\n            exit(1);\n        }\n    };\n\n    // store the 0-based line number for any matched line\n    let match_lines = find_matching_lines(&lines, regex);\n  // create intervals of the form [a,b] with the before/after context let mut intervals = create_intervals(match_lines, before_context, after_context);   // merge overlapping intervals merge_intervals(&mut intervals);   // print the lines print_results(intervals, lines); }\n```"]
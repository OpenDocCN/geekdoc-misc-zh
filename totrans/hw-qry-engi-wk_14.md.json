["```rs\nSELECT e.name, d.dept_name\nFROM employees e\nINNER JOIN departments d ON e.dept_id = d.id \n```", "```rs\nSELECT e.name, d.dept_name\nFROM employees e\nLEFT JOIN departments d ON e.dept_id = d.id \n```", "```rs\nSELECT e.name, d.dept_name\nFROM employees e\nRIGHT JOIN departments d ON e.dept_id = d.id \n```", "```rs\nSELECT e.name, d.dept_name\nFROM employees e\nFULL OUTER JOIN departments d ON e.dept_id = d.id \n```", "```rs\nSELECT e.name, d.dept_name\nFROM employees e\nCROSS JOIN departments d \n```", "```rs\nSELECT e.name\nFROM employees e\nWHERE EXISTS (SELECT 1 FROM departments d WHERE d.id = e.dept_id) \n```", "```rs\nSELECT e.name\nFROM employees e\nWHERE NOT EXISTS (SELECT 1 FROM departments d WHERE d.id = e.dept_id) \n```", "```rs\nON employees.dept_id = departments.id \n```", "```rs\nSELECT *\nFROM events e\nJOIN time_ranges t ON e.timestamp BETWEEN t.start_time AND t.end_time \n```", "```rs\nfor each row L in left_table:\n    for each row R in right_table:\n        if matches(L, R):\n            emit(L, R) \n```", "```rs\nsort left_table by join_key\nsort right_table by join_key\n\nwhile both tables have rows:\n    if left.key == right.key:\n        emit all matching combinations\n        advance both\n    else if left.key < right.key:\n        advance left\n    else:\n        advance right \n```", "```rs\n// Build phase\nhash_table = {}\nfor each row R in build_table:\n    key = R.join_column\n    hash_table[key].append(R)\n\n// Probe phase\nfor each row L in probe_table:\n    key = L.join_column\n    for each match in hash_table[key]:\n        emit(L, match) \n```", "```rs\nSELECT *\nFROM large_table l\nJOIN small_table s ON l.id = s.id\nWHERE s.category = 'active' \n```", "```rs\nval hashTable = HashMap<Any, MutableList<RecordBatch>>() \n```", "```rs\nfun probe(key: Any): List<Row> {\n    val bucket = hashTable[key.hashCode()]\n    return bucket.filter { it.joinKey == key }\n} \n```", "```rs\nclass HashJoinExec(\n    val left: PhysicalPlan,\n    val right: PhysicalPlan,\n    val joinType: JoinType,\n    val leftKeys: List<Int>,\n    val rightKeys: List<Int>,\n    val schema: Schema,\n    val rightColumnsToExclude: Set<Int>\n) : PhysicalPlan {\n\n    override fun execute(): Sequence<RecordBatch> {\n        // Build phase: load all right-side rows into a hash table\n        val hashTable = HashMap<List<Any?>, MutableList<List<Any?>>>()\n\n        right.execute().forEach { batch ->\n            for (rowIndex in 0 until batch.rowCount()) {\n                val key = rightKeys.map { keyIndex ->\n                    normalizeValue(batch.field(keyIndex).getValue(rowIndex))\n                }\n                val row = (0 until batch.columnCount()).map {\n                    batch.field(it).getValue(rowIndex)\n                }\n                hashTable.getOrPut(key) { mutableListOf() }.add(row)\n            }\n        }\n\n        // Probe phase: iterate through left side and find matches\n        return sequence {\n            left.execute().forEach { leftBatch ->\n                val outputRows = mutableListOf<List<Any?>>()\n\n                for (leftRowIndex in 0 until leftBatch.rowCount()) {\n                    val probeKey = leftKeys.map { keyIndex ->\n                        normalizeValue(leftBatch.field(keyIndex).getValue(leftRowIndex))\n                    }\n                    val leftRow = (0 until leftBatch.columnCount()).map {\n                        leftBatch.field(it).getValue(leftRowIndex)\n                    }\n                    val matchedRows = hashTable[probeKey]\n\n                    when (joinType) {\n                        JoinType.Inner -> {\n                            if (matchedRows != null) {\n                                for (rightRow in matchedRows) {\n                                    outputRows.add(combineRows(leftRow, rightRow))\n                                }\n                            }\n                        }\n                        JoinType.Left -> {\n                            if (matchedRows != null) {\n                                for (rightRow in matchedRows) {\n                                    outputRows.add(combineRows(leftRow, rightRow))\n                                }\n                            } else {\n                                // No match: include left row with nulls for right columns\n                                val nullRightRow = List(rightSchema.fields.size) { null }\n                                outputRows.add(combineRows(leftRow, nullRightRow))\n                            }\n                        }\n                        // Right join handled after probe phase...\n                    }\n                }\n\n                if (outputRows.isNotEmpty()) {\n                    yield(createBatch(outputRows))\n                }\n            }\n        }\n    }\n} \n```", "```rs\nSELECT *\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nJOIN products p ON o.product_id = p.id \n```"]
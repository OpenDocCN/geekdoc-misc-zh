<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Control Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Control Flow</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/control_flow.html">https://freddiehaddad.github.io/fast-track-to-rust/control_flow.html</a></blockquote>
                        
<p>Some of the common methods in Rust for controlling the flow of a program
include:</p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code></a> and <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code></a> expressions</li>
<li><a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html">Loop expressions</a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions/match-expr.html"><code>match</code> expressions</a></li>
</ul>
<p>These methods help you manage the execution flow and make your code more
efficient and readable.</p>
<p>We will use a <code>for</code> loop to iterate over all the lines in the poem, checking
each for the substring specified by <code>pattern</code>. Each line will be evaluated using
a <code>match</code> expression.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let pattern = "him";
    let poem = "I have a little shadow that goes in and out with me,
                And what can be the use of him is more than I can see.
                He is very, very like me from the heels up to the head;
                And I see him jump before me, when I jump into my bed.

                The funniest thing about him is the way he likes to grow -
                Not at all like proper children, which is always very slow;
                For he sometimes shoots up taller like an india-rubber ball,
                And he sometimes gets so little that there's none of him at all.";

    for line in poem.lines() {
        match line.contains(pattern) {
            true =&gt; println!("{line}"),
            false =&gt; (),
        }
    }
}</code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h2>
<p>The syntax of a <code>for</code> loop should look familiar. However, something interesting
is happening on that line. Notice the method call <code>poem.lines()</code>. You might have
thought poem was a string literal. How can it have methods? Well, as you guessed
and as was mentioned earlier, string slices are more than just string literals.
We'll explore them in more detail, so keep that in mind.</p>
<p>The purpose of the loop is quite clear: it iterates over each line in the poem.</p>
<h2 id="match-expressions"><a class="header" href="#match-expressions"><code>match</code> Expressions</a></h2>
<p>You might have already figured it out, but the <code>match</code> expression is similar to
an <code>if</code> expression in that it introduces a branch in the code execution.
However, it has a very powerful feature: when used, the compiler ensures that
all possible results of the <a href="https://doc.rust-lang.org/reference/glossary.html#scrutinee"><em>scrutinee</em></a> are covered. This aspect of
<a href="https://doc.rust-lang.org/reference/expressions/match-expr.html"><code>match</code> expressions</a> guarantees that all cases are handled.</p>
<p>Let's ensure we fully understand this. In the code snippet, comment out line 16
by prefixing it with <code>//</code>, and then run the code.</p>
<blockquote>
<p>Friendly compiler errors</p>
<p>Take a moment to appreciate just how helpful this compiler error is. The Rust
compiler is truly your friend!</p>
</blockquote>
<pre><code class="language-text">   Compiling playground v0.0.1 (/playground)
error[E0004]: non-exhaustive patterns: `false` not covered
  --&gt; src/main.rs:14:15
   |
14 |         match line.contains(pattern) {
   |               ^^^^^^^^^^^^^^^^^^^^^^ pattern `false` not covered
   |
   = note: the matched value is of type `bool`
help: ensure that all possible cases are being handled by adding a match arm with a
   |  wildcard pattern or an explicit pattern as shown
   |
15 ~             true =&gt; println!("{line}"),
16 ~             false =&gt; todo!(),
   |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>The compiler error message is informing you that:</p>
<ul>
<li>The <code>contains</code> method returns a boolean value.</li>
<li>The <code>false</code> case is not covered.</li>
<li>The Rust compiler can provide more information via <code>rustc --explain E0004</code>.</li>
</ul>
<p>Let's see what the Rust compiler has to say:</p>
<pre><code class="language-rust noplayground">$ rustc --explain E0004
This error indicates that the compiler cannot guarantee a matching pattern for
one or more possible inputs to a match expression. Guaranteed matches are
required in order to assign values to match expressions, or alternatively,
determine the flow of execution.

Erroneous code example:

enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand =&gt; {}
}

If you encounter this error you must alter your patterns so that every possible
value of the input type is matched. For types with a small number of variants
(like enums) you should probably cover all cases explicitly. Alternatively, the
underscore `_` wildcard pattern can be added after all other patterns to match
"anything else". Example:

enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x {
    Terminator::TalkToMyHand =&gt; {}
    Terminator::HastaLaVistaBaby =&gt; {}
}

// or:

match x {
    Terminator::TalkToMyHand =&gt; {}
    _ =&gt; {}
}</code></pre>
<p><code>match</code> arms have the following structure:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<h2 id="-unit-type"><a class="header" href="#-unit-type"><code>()</code> Unit Type</a></h2>
<p>In situations where we don't want to perform any action, such as in the <code>false</code>
arm, we can use the empty unit type <code>()</code>. We'll explore this more as we progress
through the course.</p>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>In this section, we:</p>
<ul>
<li>Explored <code>for</code> loop expressions.</li>
<li>Examined <code>match</code> expressions.</li>
<li>Learned how the Rust compiler provides helpful error messages.</li>
<li>Were introduced to the empty unit type <code>()</code>.</li>
</ul>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<ul>
<li>Replace the <code>match</code> expression with an <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code></a> expression.</li>
</ul>
<details>
<summary>Solution</summary>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let pattern = "him";
    let poem = "I have a little shadow that goes in and out with me,
                And what can be the use of him is more than I can see.
                He is very, very like me from the heels up to the head;
                And I see him jump before me, when I jump into my bed.

                The funniest thing about him is the way he likes to grow -
                Not at all like proper children, which is always very slow;
                For he sometimes shoots up taller like an india-rubber ball,
                And he sometimes gets so little that there's none of him at all.";

    for line in poem.lines() {
        if line.contains(pattern) {
            println!("{line}");
        }
    }
}</code></pre></pre>
</details>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>Take a break if you need, and then let's continue!</p>

                        
</body>
</html>
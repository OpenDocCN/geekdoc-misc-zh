["```rs\npub trait PartialEq<Rhs = Self>\nwhere\n    Rhs: ?Sized,\n{\n    // Required method\n    fn eq(&self, other: &Rhs) -> bool;\n\n    // Provided method\n    fn ne(&self, other: &Rhs) -> bool { ... }\n}\n```", "```rs\nuse interval::Interval;\n\npub mod interval {\n /// A list specifying general categories of Interval errors.    #[derive(Debug)]\n    pub enum IntervalError {\n /// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals to be merged do not overlap NonOverlappingInterval, } \n /// A closed-interval [`start`, `end`] type used for representing a range of /// values between `start` and `end` inclusively. /// /// # Examples /// /// You can create an `Interval` using `new`. /// /// ~~~rs /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ~~~    #[derive(Debug, PartialEq)]\n    pub struct Interval<T> {\n pub start: T, pub end: T, }   impl<T: Copy + PartialOrd> Interval<T> { /// Creates a new `Interval` set to `start` and `end`. /// /// # Examples /// /// ~~~rs /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ~~~ pub fn new(start: T, end: T) -> Result<Self, IntervalError> { if start <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid) } }   /// Checks if two intervals overlap. Overlapping intervals have at least /// one point in common. /// /// # Examples /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ~~~ /// /// ~~~rs /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2, 4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ~~~ /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4, 6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a), true); /// ~~~ pub fn overlaps(&self, other: &Interval<T>) -> bool { self.end >= other.start }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval` range includes the union of ranges from each /// `Interval`. /// /// # Examples /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); /// assert_eq!(c.end, 5); /// ~~~ pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> { if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) } else { Err(IntervalError::NonOverlappingInterval) } } } }\n\nfn main() {\n    let a = Interval::new(1, 5).unwrap(); // unwrap returns the Ok value or panics\n    let b = Interval::new(1, 5).unwrap();\n    let c = Interval::new(2, 4).unwrap();\n\n    // Comparing intervals with eq and ne.\n    println!(\"{:?} == {:?} => {}\", a, b, a.eq(&b));\n    println!(\"{:?} == {:?} => {}\", a, c, a.eq(&c));\n    println!(\"{:?} != {:?} => {}\", a, b, a.ne(&b));\n    println!(\"{:?} != {:?} => {}\", a, c, a.ne(&c));\n\n    // Rust supports operator overloading too!\n    println!(\"{:?} == {:?} => {}\", a, b, a == b);\n    println!(\"{:?} != {:?} => {}\", a, c, a != c);\n}\n```", "```rs\npub trait Display {\n    // Required method\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>;\n}\n```", "```rs\nuse interval::Interval;\n\npub mod interval {\n /// A list specifying general categories of Interval errors. #[derive(Debug)] pub enum IntervalError { /// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals to be merged do not overlap NonOverlappingInterval, }   /// A closed-interval [`start`, `end`] type used for representing a range of /// values between `start` and `end` inclusively. /// /// # Examples /// /// You can create an `Interval` using `new`. /// /// ~~~rs /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ~~~ #[derive(Debug, PartialEq)] pub struct Interval<T> { pub start: T, pub end: T, }      use std::fmt;\n    impl<T: fmt::Display> fmt::Display for Interval<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"[{}, {}]\", self.start, self.end)\n        }\n    }\n  impl<T: Copy + PartialOrd> Interval<T> { /// Creates a new `Interval` set to `start` and `end`. /// /// # Examples /// /// ~~~rs /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ~~~ pub fn new(start: T, end: T) -> Result<Self, IntervalError> { if start <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid) } }   /// Checks if two intervals overlap. Overlapping intervals have at least /// one point in common. /// /// # Examples /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ~~~ /// /// ~~~rs /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2, 4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ~~~ /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4, 6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a), true); /// ~~~ pub fn overlaps(&self, other: &Interval<T>) -> bool { self.end >= other.start }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval` range includes the union of ranges from each /// `Interval`. /// /// # Examples /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); /// assert_eq!(c.end, 5); /// ~~~ pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> { if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) } else { Err(IntervalError::NonOverlappingInterval) } } } }\n\nfn main() {\n    let a = Interval::new(1, 5).unwrap(); // unwrap returns the Ok value or panics\n    let b = Interval::new(1, 5).unwrap();\n    let b_str = b.to_string();\n    let c = Interval::new(2, 4).unwrap();\n\n    println!(\n        \"Comparisons between three intervals: {}, {}, {}...\",\n        a, b_str, c\n    );\n\n    // Comparing intervals with eq and ne.\n    println!(\"{} == {} => {}\", a, b, a.eq(&b));\n    println!(\"{} == {} => {}\", a, c, a.eq(&c));\n    println!(\"{} != {} => {}\", a, b, a.ne(&b));\n    println!(\"{} != {} => {}\", a, c, a.ne(&c));\n\n    // Rust supports operator overloading too!\n    println!(\"{} == {} => {}\", a, b, a == b);\n    println!(\"{} != {} => {}\", a, c, a != c);\n}\n```", "```rs\nuse interval::Interval;\n\npub mod interval {\n    /// A list specifying general categories of Interval errors.\n    #[derive(Debug)]\n    pub enum IntervalError {\n        /// Start is not less than or equal to end\n        StartEndRangeInvalid,\n        /// Two intervals to be merged do not overlap\n        NonOverlappingInterval,\n    }\n\n    /// A closed-interval [`start`, `end`] type used for representing a range of\n    /// values between `start` and `end` inclusively.\n    ///\n    /// # Examples\n    ///\n    /// You can create an `Interval` using `new`.\n    ///\n    /// ~~~rs\n    /// let interval = Interval::new(1, 10).unwrap();\n    /// assert_eq!(interval.start, 1);\n    /// assert_eq!(interval.end, 10);\n    /// ~~~\n    #[derive(Debug, PartialEq)]\n    pub struct Interval<T> {\n        pub start: T,\n        pub end: T,\n    }\n\n    use std::fmt;\n    impl<T: fmt::Display> fmt::Display for Interval<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"[{}, {}]\", self.start, self.end)\n        }\n    }\n\n    impl<T: Copy + PartialOrd> Interval<T> {\n        /// Creates a new `Interval` set to `start` and `end`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let interval = Interval::new(1, 10).unwrap();\n        /// assert_eq!(interval.start, 1);\n        /// assert_eq!(interval.end, 10);\n        /// ~~~\n        pub fn new(start: T, end: T) -> Result<Self, IntervalError> {\n            if start <= end {\n                Ok(Self { start, end })\n            } else {\n                Err(IntervalError::StartEndRangeInvalid)\n            }\n        }\n\n        /// Checks if two intervals overlap. Overlapping intervals have at least\n        /// one point in common.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 5).unwrap();\n        /// let b = Interval::new(2, 4).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(4, 6).unwrap();\n        /// assert_eq!(a.overlaps(&b), false);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        pub fn overlaps(&self, other: &Interval<T>) -> bool {\n            self.end >= other.start\n        }\n\n        /// Merges two intervals returning a new `Interval`.\n        ///\n        /// The merged `Interval` range includes the union of ranges from each\n        /// `Interval`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// let c = a.merge(&b).unwrap();\n        /// assert_eq!(c.start, 1);\n        /// assert_eq!(c.end, 5);\n        /// ~~~\n        pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n            if self.overlaps(other) {\n                Ok(Self {\n                    start: self.start,\n                    end: other.end,\n                })\n            } else {\n                Err(IntervalError::NonOverlappingInterval)\n            }\n        }\n    }\n}\n\nfn main() {\n    use std::cmp::Ordering::{Equal, Greater, Less};\n\n    let a = Interval::new(0, 1).unwrap();\n    let b = Interval::new(0, 1).unwrap();\n    assert_eq!(a.partial_cmp(&b), Some(Equal));\n    assert_eq!(b.partial_cmp(&a), Some(Equal));\n\n    let a = Interval::new(0, 1).unwrap();\n    let b = Interval::new(2, 3).unwrap();\n    assert_eq!(a.partial_cmp(&b), Some(Less));\n    assert_eq!(b.partial_cmp(&a), Some(Greater));\n\n    println!(\"Nice Work!\");\n}\n```", "```rs\nuse interval::Interval;   pub mod interval {\n /// A list specifying general categories of Interval errors. #[derive(Debug)] pub enum IntervalError { /// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals to be merged do not overlap NonOverlappingInterval, }   /// A closed-interval [`start`, `end`] type used for representing a range of /// values between `start` and `end` inclusively. /// /// # Examples /// /// You can create an `Interval` using `new`. /// /// ~~~rs /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ~~~ #[derive(Debug, PartialEq)] pub struct Interval<T> { pub start: T, pub end: T, }   use std::fmt; impl<T: fmt::Display> fmt::Display for Interval<T> { fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result { write!(f, \"[{}, {}]\", self.start, self.end) } }      use std::cmp::Ordering;\n    impl<T: PartialEq + PartialOrd> PartialOrd for Interval<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            if self == other {\n                Some(Ordering::Equal)\n            } else if self.end < other.start {\n                Some(Ordering::Less)\n            } else if self.start > other.end {\n                Some(Ordering::Greater)\n            } else {\n                None // Intervals overlap\n            }\n        }\n    }\n  impl<T: Copy + PartialOrd> Interval<T> { /// Creates a new `Interval` set to `start` and `end`. /// /// # Examples /// /// ~~~rs /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ~~~ pub fn new(start: T, end: T) -> Result<Self, IntervalError> { if start <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid) } }   /// Checks if two intervals overlap. Overlapping intervals have at least /// one point in common. /// /// # Examples /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ~~~ /// /// ~~~rs /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2, 4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ~~~ /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4, 6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a), true); /// ~~~ pub fn overlaps(&self, other: &Interval<T>) -> bool { self.end >= other.start }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval` range includes the union of ranges from each /// `Interval`. /// /// # Examples /// /// ~~~rs /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); /// assert_eq!(c.end, 5); /// ~~~ pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> { if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) } else { Err(IntervalError::NonOverlappingInterval) } } } }\n  fn main() {\n use std::cmp::Ordering::{Equal, Greater, Less};   let a = Interval::new(0, 1).unwrap(); let b = Interval::new(0, 1).unwrap(); assert_eq!(a.partial_cmp(&b), Some(Equal)); assert_eq!(b.partial_cmp(&a), Some(Equal));   let a = Interval::new(0, 1).unwrap(); let b = Interval::new(2, 3).unwrap(); assert_eq!(a.partial_cmp(&b), Some(Less)); assert_eq!(b.partial_cmp(&a), Some(Greater));   println!(\"Nice Work!\"); }\n```", "```rs\n#![allow(unused_imports)]\nextern crate regex; // this is needed for the playground\nuse interval::{Interval, IntervalError};\nuse itertools::Itertools;\nuse regex::Regex;\nuse std::fs::File;\nuse std::io::Read;\nuse std::io::{BufRead, BufReader};\nuse std::process::exit;\n\nfn find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match regex.is_match(line) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Result<Vec<Interval<usize>>, IntervalError> {\n    lines\n        .iter()\n        .map(|line| {\n            let start = line.saturating_sub(before_context);\n            let end = line.saturating_add(after_context);\n            Interval::new(start, end)\n        })\n        .collect()\n}\n\nfn merge_intervals(intervals: Vec<Interval<usize>>) -> Vec<Interval<usize>> {\n    // merge overlapping intervals\n    intervals\n        .into_iter()\n        .coalesce(|p, c| p.merge(&c).map_err(|_| (p, c)))\n        .collect()\n}\n\nfn print_results(intervals: Vec<Interval<usize>>, lines: Vec<String>) {\n    for interval in intervals {\n        for (line_no, line) in lines\n            .iter()\n            .enumerate()\n            .take(interval.end + 1)\n            .skip(interval.start)\n        {\n            println!(\"{}: {}\", line_no + 1, line)\n        }\n    }\n}\n\nfn read_file(file: impl Read) -> Vec<String> {\n    BufReader::new(file).lines().map_while(Result::ok).collect()\n}\n\nfn main() {\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    let mock_file = std::io::Cursor::new(poem);\n\n    // command line arguments\n    let pattern = \"(all)|(little)\";\n    let before_context = 1;\n    let after_context = 1;\n\n    // attempt to open the file\n    let lines = read_file(mock_file);\n    //let lines = match File::open(filename) {\n    //    // convert the poem into lines\n    //    Ok(file) => read_file(file),\n    //    Err(e) => {\n    //        eprintln!(\"Error opening {filename}: {e}\");\n    //        exit(1);\n    //    }\n    //};\n\n    // compile the regular expression\n    let regex = match Regex::new(pattern) {\n        Ok(re) => re, // bind re to regex\n        Err(e) => {\n            eprintln!(\"{e}\"); // write to standard error\n            exit(1);\n        }\n    };\n\n    // store the 0-based line number for any matched line\n    let match_lines = find_matching_lines(&lines, regex);\n\n    // create intervals of the form [a,b] with the before/after context\n    let intervals =\n        match create_intervals(match_lines, before_context, after_context) {\n            Ok(intervals) => intervals,\n            Err(_) => {\n                eprintln!(\"An error occurred while creating intervals\");\n                exit(1);\n            }\n        };\n\n    // merge overlapping intervals\n    let intervals = merge_intervals(intervals);\n\n    // print the lines\n    print_results(intervals, lines);\n}\n\npub mod interval {\n    /// A list specifying general categories of Interval errors.\n    #[derive(Debug)]\n    pub enum IntervalError {\n        /// Start is not less than or equal to end\n        StartEndRangeInvalid,\n        /// Two intervals to be merged do not overlap\n        NonOverlappingInterval,\n    }\n\n    /// A closed-interval [`start`, `end`] type used for representing a range of\n    /// values between `start` and `end` inclusively.\n    ///\n    /// # Examples\n    ///\n    /// You can create an `Interval` using `new`.\n    ///\n    /// ~~~rs\n    /// let interval = Interval::new(1, 10).unwrap();\n    /// assert_eq!(interval.start, 1);\n    /// assert_eq!(interval.end, 10);\n    /// ~~~\n    #[derive(Debug, PartialEq)]\n    pub struct Interval<T> {\n        pub start: T,\n        pub end: T,\n    }\n\n    impl<T: Copy + PartialOrd> Interval<T> {\n        /// Creates a new `Interval` set to `start` and `end`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let interval = Interval::new(1, 10).unwrap();\n        /// assert_eq!(interval.start, 1);\n        /// assert_eq!(interval.end, 10);\n        /// ~~~\n        pub fn new(start: T, end: T) -> Result<Self, IntervalError> {\n            if start <= end {\n                Ok(Self { start, end })\n            } else {\n                Err(IntervalError::StartEndRangeInvalid)\n            }\n        }\n\n        /// Checks if two intervals overlap. Overlapping intervals have at least\n        /// one point in common.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 5).unwrap();\n        /// let b = Interval::new(2, 4).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(4, 6).unwrap();\n        /// assert_eq!(a.overlaps(&b), false);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        pub fn overlaps(&self, other: &Interval<T>) -> bool {\n            self.end >= other.start\n        }\n\n        /// Merges two intervals returning a new `Interval`.\n        ///\n        /// The merged `Interval` range includes the union of ranges from each\n        /// `Interval`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// let c = a.merge(&b).unwrap();\n        /// assert_eq!(c.start, 1);\n        /// assert_eq!(c.end, 5);\n        /// ~~~\n        pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n            if self.overlaps(other) {\n                Ok(Self {\n                    start: self.start,\n                    end: other.end,\n                })\n            } else {\n                Err(IntervalError::NonOverlappingInterval)\n            }\n        }\n    }\n\n    use std::fmt;\n    impl<T: fmt::Display> fmt::Display for Interval<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"[{}, {}]\", self.start, self.end)\n        }\n    }\n\n    use std::cmp::Ordering;\n    impl<T: PartialEq + PartialOrd> PartialOrd for Interval<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            if self == other {\n                Some(Ordering::Equal)\n            } else if self.end < other.start {\n                Some(Ordering::Less)\n            } else if self.start > other.end {\n                Some(Ordering::Greater)\n            } else {\n                None // Intervals overlap\n            }\n        }\n    }\n}\n```"]
["```rs\nfn find_matching_lines(lines: Vec<&str>, pattern: &str) -> Vec<usize>\n```", "```rs\nuse std::iter::FromIterator; // this line addresses a rust playground bug   fn find_matching_lines(lines: &Vec<&str>, pattern: &str) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match line.contains(pattern) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn main() {\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    // command line arguments\n    let pattern = \"all\";\n    let before_context = 1;\n    let after_context = 1;\n\n    // convert the poem into lines\n    let lines = Vec::from_iter(poem.lines());\n\n    // store the 0-based line number for any matched line\n    let match_lines = find_matching_lines(&lines, pattern);\n\n    // create intervals of the form [a,b] with the before/after context\n    let mut intervals: Vec<_> = match_lines\n        .iter()\n        .map(|line| {\n            (\n                line.saturating_sub(before_context),\n                line.saturating_add(after_context),\n            )\n        })\n        .collect();\n\n    // merge overlapping intervals\n    intervals.dedup_by(|next, prev| {\n        if prev.1 < next.0 {\n            false\n        } else {\n            prev.1 = next.1;\n            true\n        }\n    });\n\n    // print the lines\n    for (start, end) in intervals {\n        for (line_no, line) in\n            lines.iter().enumerate().take(end + 1).skip(start)\n        {\n            println!(\"{}: {}\", line_no + 1, line)\n        }\n    }\n}\n```", "```rs\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Vec<(usize, usize)>\n```", "```rs\n// create intervals of the form [a,b] with the before/after context\nlet mut intervals: Vec<_> = match_lines\n    .iter()\n    .map(|line| {\n        (\n            line.saturating_sub(before_context),\n            line.saturating_add(after_context),\n        )\n    })\n    .collect();\n```", "```rs\nuse std::iter::FromIterator; // this line addresses a rust playground bug   fn find_matching_lines(lines: &Vec<&str>, pattern: &str) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match line.contains(pattern) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Vec<(usize, usize)> {\n    lines\n        .iter()\n        .map(|line| {\n            (\n                line.saturating_sub(before_context),\n                line.saturating_add(after_context),\n            )\n        })\n        .collect()\n}\n\nfn main() {\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    // command line arguments\n    let pattern = \"all\";\n    let before_context = 1;\n    let after_context = 1;\n\n    // convert the poem into lines\n    let lines = Vec::from_iter(poem.lines());\n\n    // store the 0-based line number for any matched line\n    let match_lines = find_matching_lines(&lines, pattern);\n\n    // create intervals of the form [a,b] with the before/after context\n    let mut intervals =\n        create_intervals(match_lines, before_context, after_context);\n\n    // merge overlapping intervals\n    intervals.dedup_by(|next, prev| {\n        if prev.1 < next.0 {\n            false\n        } else {\n            prev.1 = next.1;\n            true\n        }\n    });\n\n    // print the lines\n    for (start, end) in intervals {\n        for (line_no, line) in\n            lines.iter().enumerate().take(end + 1).skip(start)\n        {\n            println!(\"{}: {}\", line_no + 1, line)\n        }\n    }\n}\n```", "```rs\n    // merge overlapping intervals\n    intervals.dedup_by(|next, prev| {\n        if prev.1 < next.0 {\n            false\n        } else {\n            prev.1 = next.1;\n            true\n        }\n    });\n    ```", "```rs\n    // print the lines\n    for (start, end) in intervals {\n        for (line_no, line) in\n            lines.iter().enumerate().take(end + 1).skip(start)\n        {\n            println!(\"{}: {}\", line_no + 1, line)\n        }\n    }\n    ```", "```rs\nuse std::iter::FromIterator; // this line addresses a rust playground bug\n\nfn find_matching_lines(lines: &Vec<&str>, pattern: &str) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match line.contains(pattern) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Vec<(usize, usize)> {\n    lines\n        .iter()\n        .map(|line| {\n            (\n                line.saturating_sub(before_context),\n                line.saturating_add(after_context),\n            )\n        })\n        .collect()\n}\n\nfn merge_intervals(intervals: &mut Vec<(usize, usize)>) {\n    // merge overlapping intervals\n    intervals.dedup_by(|next, prev| {\n        if prev.1 < next.0 {\n            false\n        } else {\n            prev.1 = next.1;\n            true\n        }\n    })\n}\n\nfn print_results(intervals: Vec<(usize, usize)>, lines: Vec<&str>) {\n    for (start, end) in intervals {\n        for (line_no, line) in\n            lines.iter().enumerate().take(end + 1).skip(start)\n        {\n            println!(\"{}: {}\", line_no + 1, line)\n        }\n    }\n}\n\nfn main() {\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    // command line arguments\n    let pattern = \"all\";\n    let before_context = 1;\n    let after_context = 1;\n\n    // convert the poem into lines\n    let lines = Vec::from_iter(poem.lines());\n\n    // store the 0-based line number for any matched line\n    let match_lines = find_matching_lines(&lines, pattern);\n\n    // create intervals of the form [a,b] with the before/after context\n    let mut intervals =\n        create_intervals(match_lines, before_context, after_context);\n\n    // merge overlapping intervals\n    merge_intervals(&mut intervals);\n\n    // print the lines\n    print_results(intervals, lines);\n}\n```"]
["```rs\nfn find_matching_lines(lines: Vec<&str>, pattern: &str) -> Vec<usize>\n```", "```rs\n// store the 0-based line number for any matched line\nlet match_lines: Vec<_> = lines\n    .iter()\n    .enumerate()\n    .filter_map(|(i, line)| match line.contains(pattern) {\n        true => Some(i),\n        false => None,\n    })\n    .collect(); // turns anything iterable into a collection\n```", "```rs\nuse std::iter::FromIterator; // this line addresses a rust playground bug   fn find_matching_lines(lines: Vec<&str>, pattern: &str) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match line.contains(pattern) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n        // The return keyword is unnecessary when the returned value is the\n        // final expression in a function. In this scenario, the semicolon (;)\n        // is omitted.\n}\n\nfn main() {\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    // command line arguments\n    let pattern = \"all\";\n    let before_context = 1;\n    let after_context = 1;\n\n    // convert the poem into lines\n    let lines = Vec::from_iter(poem.lines());\n\n    // store the 0-based line number for any matched line\n    let match_lines = find_matching_lines(lines, pattern);\n\n    // create intervals of the form [a,b] with the before/after context\n    let mut intervals: Vec<_> = match_lines\n        .iter()\n        .map(|line| {\n            (\n                line.saturating_sub(before_context),\n                line.saturating_add(after_context),\n            )\n        })\n        .collect();\n\n    // merge overlapping intervals\n    intervals.dedup_by(|next, prev| {\n        if prev.1 < next.0 {\n            false\n        } else {\n            prev.1 = next.1;\n            true\n        }\n    });\n\n    // print the lines\n    for (start, end) in intervals {\n        for (line_no, line) in\n            lines.iter().enumerate().take(end + 1).skip(start)\n        {\n            println!(\"{}: {}\", line_no + 1, line)\n        }\n    }\n}\n```", "```rs\nerror[E0382]: borrow of moved value: `lines`\n    --> src/main.rs:63:13\n     |\n34   |     let lines = Vec::from_iter(poem.lines());\n     |         ----- move occurs because `lines` has type `Vec<&str>`, which\n     |               does not implement the `Copy` trait\n...\n37   |     let match_lines = find_matching_lines(lines, pattern);\n     |                                           ----- value moved here\n...\n63   |             lines.iter().enumerate().take(end + 1).skip(start)\n     |             ^^^^^^^^^^^^ value borrowed here after move\n     | \n```"]
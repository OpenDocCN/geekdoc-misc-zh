<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Traits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Traits</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/traits.html">https://freddiehaddad.github.io/fast-track-to-rust/traits.html</a></blockquote>
                        
<p>In the previous section, we specified trait bounds to restrict the types that
can be used with our <code>Interval</code>. Let's formalize what a trait is:</p>
<p>A trait is officially defined as a collection of methods for an unknown type:
<code>Self</code>.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<p>In simpler terms, a trait allows you to define shared behavior in an abstract
way. It specifies a set of methods that a type must implement, similar to
interfaces in other programming languages.</p>
<p>The <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a> book includes many examples of <a href="https://doc.rust-lang.org/rust-by-example/trait.html">traits</a> and explores their
usage in depth. Reviewing this material is highly recommended.</p>
<blockquote>
<p>The compiler can automatically provide basic implementations for certain
traits using the derive (<code>#[derive]</code>) <a href="https://doc.rust-lang.org/reference/attributes.html">attribute</a>. However, if more complex
behavior is needed, these traits can still be manually implemented. Here is a
list of derivable traits:</p>
</blockquote>
<ul>
<li>Comparison traits: <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, Ord, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>.</li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, to create <code>T</code> from <code>&amp;T</code> via a copy.</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>, to give a type <em>copy semantics</em> instead of <em>move semantics</em>.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>, to compute a hash from <code>&amp;T</code>.</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, to create an empty instance of a data type.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>, to format a value using the <code>{:?}</code> formatter.</li>
</ul>
<h2 id="deriving-a-trait"><a class="header" href="#deriving-a-trait">Deriving a Trait</a></h2>
<p>Someone using our <code>Interval</code> might find it helpful to have an easy way to
compare them. For instance, a user may want to check if two intervals are equal.
The <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> trait, part of the <a href="https://doc.rust-lang.org/std/cmp/index.html"><code>cmp</code></a> module, specifies two methods that
any type must define to implement the <code>PartialEq</code> trait.</p>
<pre><code class="language-rust noplayground">pub trait PartialEq&lt;Rhs = Self&gt;
where
    Rhs: ?Sized,
{
    // Required method
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;

    // Provided method
    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool { ... }
}</code></pre>
<blockquote>
<p>Notice the comment above the <code>ne</code> method that says "Provided method." This
indicates that if we manually implement this trait, we only need to provide an
implementation for <code>eq</code>.</p>
</blockquote>
<p>Here's our revised <code>Interval</code> with support for <code>PartialEq</code>, thanks to the derive
attribute and the Rust compiler. Give it a try!</p>
<blockquote>
<p>The <code>Debug</code> trait has also been derived, enabling intervals to be printed in a
programmer-facing context using the <code>:?</code> operator. This common pattern in Rust
provides more helpful output in the program below.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use interval::Interval;

pub mod interval {
<span class="boring">    /// A list specifying general categories of Interval errors.
</span>    #[derive(Debug)]
    pub enum IntervalError {
<span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span>
<span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span>    #[derive(Debug, PartialEq)]
    pub struct Interval&lt;T&gt; {
<span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span>}

fn main() {
    let a = Interval::new(1, 5).unwrap(); // unwrap returns the Ok value or panics
    let b = Interval::new(1, 5).unwrap();
    let c = Interval::new(2, 4).unwrap();

    // Comparing intervals with eq and ne.
    println!("{:?} == {:?} =&gt; {}", a, b, a.eq(&amp;b));
    println!("{:?} == {:?} =&gt; {}", a, c, a.eq(&amp;c));
    println!("{:?} != {:?} =&gt; {}", a, b, a.ne(&amp;b));
    println!("{:?} != {:?} =&gt; {}", a, c, a.ne(&amp;c));

    // Rust supports operator overloading too!
    println!("{:?} == {:?} =&gt; {}", a, b, a == b);
    println!("{:?} != {:?} =&gt; {}", a, c, a != c);
}</code></pre></pre>
<blockquote>
<p>The <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap()</code></a> method is implemented by <code>Result</code> and other types like
<code>Option</code>. For <code>Result</code>, it returns the <code>Ok</code> value or panics if the value is
<code>Err</code>. Its usage is generally discouraged and is only used here for brevity.</p>
</blockquote>
<blockquote>
<p>Operator Overloading</p>
<p>You might have noticed the comparison between intervals using <code>==</code> and <code>!=</code>.
This works because Rust includes support for operator overloading! You can
find all the detailed information in the <a href="https://doc.rust-lang.org/rust-by-example/trait/ops.html">Operator Overloading</a> section of the
<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a> book and in the <a href="https://doc.rust-lang.org/std/ops/index.html"><code>ops</code></a> module.</p>
</blockquote>
<h2 id="implementing-a-trait"><a class="header" href="#implementing-a-trait">Implementing a Trait</a></h2>
<p>Just as comparing traits for equality can be helpful, so can generating a
user-facing representation of an <code>Interval</code>. By implementing the <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a>
trait, we can achieve this quite efficiently. Additionally, implementing the
<code>Display</code> trait automatically implements the <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> trait, enabling the
use of the <code>to_string()</code> method. Let's enhance our <code>Interval</code> code to print an
interval in the form <code>[x, y]</code>.</p>
<p>Here's the trait definition for <code>Display</code>:</p>
<pre><code class="language-rust noplayground">pub trait Display {
    // Required method
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<blockquote>
<p>The <code>&lt;'_&gt;</code> suffix next to <code>Formatter</code> is known as <em>lifetime annotation
syntax</em>.<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup></p>
</blockquote>
<p>Here's our revised <code>Interval</code> with the <code>Display</code> trait implemented. Give it a
try!</p>
<pre><pre class="playground"><code class="language-rust edition2021">use interval::Interval;

pub mod interval {
<span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    #[derive(Debug)]
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    #[derive(Debug, PartialEq)]
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span>    use std::fmt;
    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "[{}, {}]", self.start, self.end)
        }
    }
<span class="boring">
</span><span class="boring">    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span>}

fn main() {
    let a = Interval::new(1, 5).unwrap(); // unwrap returns the Ok value or panics
    let b = Interval::new(1, 5).unwrap();
    let b_str = b.to_string();
    let c = Interval::new(2, 4).unwrap();

    println!(
        "Comparisons between three intervals: {}, {}, {}...",
        a, b_str, c
    );

    // Comparing intervals with eq and ne.
    println!("{} == {} =&gt; {}", a, b, a.eq(&amp;b));
    println!("{} == {} =&gt; {}", a, c, a.eq(&amp;c));
    println!("{} != {} =&gt; {}", a, b, a.ne(&amp;b));
    println!("{} != {} =&gt; {}", a, c, a.ne(&amp;c));

    // Rust supports operator overloading too!
    println!("{} == {} =&gt; {}", a, b, a == b);
    println!("{} != {} =&gt; {}", a, c, a != c);
}</code></pre></pre>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<ul>
<li>Our interval module has been enhanced to support several new capabilities.</li>
<li>We can print programmer-facing intervals using the <code>Debug</code> trait and
user-facing intervals using the <code>Display</code> trait.</li>
<li>We have limited support for comparing intervals through the <code>PartialEq</code> and
<code>PartialOrd</code> traits.</li>
<li>A trait defines shared behavior abstractly, specifying methods a type must
implement, similar to interfaces in other languages.</li>
<li>The compiler can automatically provide basic implementations for certain
traits using the <code>#[derive]</code> attribute.</li>
<li>Rust includes support for operator overloading.</li>
</ul>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<ul>
<li>Implement the <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> trait for <code>Interval</code>. To keep the code simple,
you can return <code>None</code> for overlapping intervals.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">use interval::Interval;

pub mod interval {
    /// A list specifying general categories of Interval errors.
    #[derive(Debug)]
    pub enum IntervalError {
        /// Start is not less than or equal to end
        StartEndRangeInvalid,
        /// Two intervals to be merged do not overlap
        NonOverlappingInterval,
    }

    /// A closed-interval [`start`, `end`] type used for representing a range of
    /// values between `start` and `end` inclusively.
    ///
    /// # Examples
    ///
    /// You can create an `Interval` using `new`.
    ///
    /// ```rust
    /// let interval = Interval::new(1, 10).unwrap();
    /// assert_eq!(interval.start, 1);
    /// assert_eq!(interval.end, 10);
    /// ```
    #[derive(Debug, PartialEq)]
    pub struct Interval&lt;T&gt; {
        pub start: T,
        pub end: T,
    }

    use std::fmt;
    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "[{}, {}]", self.start, self.end)
        }
    }

    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
        /// Creates a new `Interval` set to `start` and `end`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let interval = Interval::new(1, 10).unwrap();
        /// assert_eq!(interval.start, 1);
        /// assert_eq!(interval.end, 10);
        /// ```
        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
            if start &lt;= end {
                Ok(Self { start, end })
            } else {
                Err(IntervalError::StartEndRangeInvalid)
            }
        }

        /// Checks if two intervals overlap. Overlapping intervals have at least
        /// one point in common.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 5).unwrap();
        /// let b = Interval::new(2, 4).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(4, 6).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), false);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
            self.end &gt;= other.start
        }

        /// Merges two intervals returning a new `Interval`.
        ///
        /// The merged `Interval` range includes the union of ranges from each
        /// `Interval`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// let c = a.merge(&amp;b).unwrap();
        /// assert_eq!(c.start, 1);
        /// assert_eq!(c.end, 5);
        /// ```
        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
            if self.overlaps(other) {
                Ok(Self {
                    start: self.start,
                    end: other.end,
                })
            } else {
                Err(IntervalError::NonOverlappingInterval)
            }
        }
    }
}

fn main() {
    use std::cmp::Ordering::{Equal, Greater, Less};

    let a = Interval::new(0, 1).unwrap();
    let b = Interval::new(0, 1).unwrap();
    assert_eq!(a.partial_cmp(&amp;b), Some(Equal));
    assert_eq!(b.partial_cmp(&amp;a), Some(Equal));

    let a = Interval::new(0, 1).unwrap();
    let b = Interval::new(2, 3).unwrap();
    assert_eq!(a.partial_cmp(&amp;b), Some(Less));
    assert_eq!(b.partial_cmp(&amp;a), Some(Greater));

    println!("Nice Work!");
}</code></pre></pre>
<details>
<summary>Solution</summary>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use interval::Interval;
</span><span class="boring">
</span>pub mod interval {
<span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    #[derive(Debug)]
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    #[derive(Debug, PartialEq)]
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    use std::fmt;
</span><span class="boring">    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">            write!(f, "[{}, {}]", self.start, self.end)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    use std::cmp::Ordering;
    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
            if self == other {
                Some(Ordering::Equal)
            } else if self.end &lt; other.start {
                Some(Ordering::Less)
            } else if self.start &gt; other.end {
                Some(Ordering::Greater)
            } else {
                None // Intervals overlap
            }
        }
    }
<span class="boring">
</span><span class="boring">    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    use std::cmp::Ordering::{Equal, Greater, Less};
</span><span class="boring">
</span><span class="boring">    let a = Interval::new(0, 1).unwrap();
</span><span class="boring">    let b = Interval::new(0, 1).unwrap();
</span><span class="boring">    assert_eq!(a.partial_cmp(&amp;b), Some(Equal));
</span><span class="boring">    assert_eq!(b.partial_cmp(&amp;a), Some(Equal));
</span><span class="boring">
</span><span class="boring">    let a = Interval::new(0, 1).unwrap();
</span><span class="boring">    let b = Interval::new(2, 3).unwrap();
</span><span class="boring">    assert_eq!(a.partial_cmp(&amp;b), Some(Less));
</span><span class="boring">    assert_eq!(b.partial_cmp(&amp;a), Some(Greater));
</span><span class="boring">
</span><span class="boring">    println!("Nice Work!");
</span><span class="boring">}</span></code></pre></pre>
</details>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>Now that we've covered traits, let's ensure our projects are synchronized before
we proceed to exploring attributes.</p>
<p>Here's the completed code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![allow(unused_imports)]
extern crate regex; // this is needed for the playground
use interval::{Interval, IntervalError};
use itertools::Itertools;
use regex::Regex;
use std::fs::File;
use std::io::Read;
use std::io::{BufRead, BufReader};
use std::process::exit;

fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match regex.is_match(line) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
}

fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
        .collect()
}

fn print_results(intervals: Vec&lt;Interval&lt;usize&gt;&gt;, lines: Vec&lt;String&gt;) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            println!("{}: {}", line_no + 1, line)
        }
    }
}

fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

fn main() {
    let poem = "I have a little shadow that goes in and out with me,
                And what can be the use of him is more than I can see.
                He is very, very like me from the heels up to the head;
                And I see him jump before me, when I jump into my bed.

                The funniest thing about him is the way he likes to grow -
                Not at all like proper children, which is always very slow;
                For he sometimes shoots up taller like an india-rubber ball,
                And he sometimes gets so little that there's none of him at all.";

    let mock_file = std::io::Cursor::new(poem);

    // command line arguments
    let pattern = "(all)|(little)";
    let before_context = 1;
    let after_context = 1;

    // attempt to open the file
    let lines = read_file(mock_file);
    //let lines = match File::open(filename) {
    //    // convert the poem into lines
    //    Ok(file) =&gt; read_file(file),
    //    Err(e) =&gt; {
    //        eprintln!("Error opening {filename}: {e}");
    //        exit(1);
    //    }
    //};

    // compile the regular expression
    let regex = match Regex::new(pattern) {
        Ok(re) =&gt; re, // bind re to regex
        Err(e) =&gt; {
            eprintln!("{e}"); // write to standard error
            exit(1);
        }
    };

    // store the 0-based line number for any matched line
    let match_lines = find_matching_lines(&amp;lines, regex);

    // create intervals of the form [a,b] with the before/after context
    let intervals =
        match create_intervals(match_lines, before_context, after_context) {
            Ok(intervals) =&gt; intervals,
            Err(_) =&gt; {
                eprintln!("An error occurred while creating intervals");
                exit(1);
            }
        };

    // merge overlapping intervals
    let intervals = merge_intervals(intervals);

    // print the lines
    print_results(intervals, lines);
}

pub mod interval {
    /// A list specifying general categories of Interval errors.
    #[derive(Debug)]
    pub enum IntervalError {
        /// Start is not less than or equal to end
        StartEndRangeInvalid,
        /// Two intervals to be merged do not overlap
        NonOverlappingInterval,
    }

    /// A closed-interval [`start`, `end`] type used for representing a range of
    /// values between `start` and `end` inclusively.
    ///
    /// # Examples
    ///
    /// You can create an `Interval` using `new`.
    ///
    /// ```rust
    /// let interval = Interval::new(1, 10).unwrap();
    /// assert_eq!(interval.start, 1);
    /// assert_eq!(interval.end, 10);
    /// ```
    #[derive(Debug, PartialEq)]
    pub struct Interval&lt;T&gt; {
        pub start: T,
        pub end: T,
    }

    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
        /// Creates a new `Interval` set to `start` and `end`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let interval = Interval::new(1, 10).unwrap();
        /// assert_eq!(interval.start, 1);
        /// assert_eq!(interval.end, 10);
        /// ```
        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
            if start &lt;= end {
                Ok(Self { start, end })
            } else {
                Err(IntervalError::StartEndRangeInvalid)
            }
        }

        /// Checks if two intervals overlap. Overlapping intervals have at least
        /// one point in common.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 5).unwrap();
        /// let b = Interval::new(2, 4).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(4, 6).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), false);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
            self.end &gt;= other.start
        }

        /// Merges two intervals returning a new `Interval`.
        ///
        /// The merged `Interval` range includes the union of ranges from each
        /// `Interval`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// let c = a.merge(&amp;b).unwrap();
        /// assert_eq!(c.start, 1);
        /// assert_eq!(c.end, 5);
        /// ```
        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
            if self.overlaps(other) {
                Ok(Self {
                    start: self.start,
                    end: other.end,
                })
            } else {
                Err(IntervalError::NonOverlappingInterval)
            }
        }
    }

    use std::fmt;
    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "[{}, {}]", self.start, self.end)
        }
    }

    use std::cmp::Ordering;
    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
            if self == other {
                Some(Ordering::Equal)
            } else if self.end &lt; other.start {
                Some(Ordering::Less)
            } else if self.start &gt; other.end {
                Some(Ordering::Greater)
            } else {
                None // Intervals overlap
            }
        }
    }
}</code></pre></pre>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>https://doc.rust-lang.org/rust-by-example/trait.html <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>This is a separate topic that you can learn more about in the
<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Validating References with Lifetimes</a> section of the
<a href="https://doc.rust-lang.org/stable/book/">Rust Programming Language</a> and the <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">Lifetimes</a> section of
<a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>. <a href="#fr-2-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
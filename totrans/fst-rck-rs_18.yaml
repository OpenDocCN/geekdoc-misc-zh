- en: Vec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/vec.html](https://freddiehaddad.github.io/fast-track-to-rust/vec.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A `Vec`, short for vector, is a contiguous growable array type, written as `Vec<T>`.
    Although we haven't covered user-defined types yet, `Vec` is implemented using
    a `struct`.^([1](#footnote-1)) It supports many familiar operations like `push`,
    `pop`, and `len`, but also includes some operations you might not be familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: '[Storing our Lines in a Vector](#storing-our-lines-in-a-vector)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's populate a vector with the input we've been using so far in our rustle
    program. There are several ways to create a vector, and the [documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html)
    provides plenty of examples. We'll explore a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using `push`](#using-push)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Someone with a C++ background might be inclined to achieve this using a variant
    of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: Hidden code
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To make reading the code easier, only the new parts are visible. You can view
    previously seen code by clicking the *Show hidden lines* button when hovering
    over the code block.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there's none of him at all.";      let
    mut lines = Vec::new(); // each call to push mutates the vector
  prefs: []
  type: TYPE_NORMAL
- en: for line in poem.lines() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lines.push(line);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // format text for debugging purposes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{lines:?}");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We haven't discussed traits yet, so for now, just know that `:?` specifies formatting
    the output with the `Debug`^([2](#footnote-2)) trait. The vector type implements
    the `fmt::Debug` trait.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using an Iterator](#using-an-iterator)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While using `push` is functionally correct, it introduces a mutable variable
    unnecessarily. An idiomatic solution would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there's none of him at all.";      //
    convert poem into lines
  prefs: []
  type: TYPE_NORMAL
- en: let lines = Vec::from_iter(poem.lines());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // format text for debugging purposes println!("{lines:?}"); }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Favoring immutability
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The concept of being *immutable by default* is one of the many ways Rust encourages
    you to write code that leverages its safety features and supports easy concurrency.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Tracking all Matches](#tracking-all-matches)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a vector containing all the lines in our poem, let's create
    another vector to hold the line numbers where the pattern was found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there's none of him at all.";      let
    pattern = "all";
  prefs: []
  type: TYPE_NORMAL
- en: // convert the poem into lines let lines = Vec::from_iter(poem.lines());      //
    store the 0-based line number for any matched line
  prefs: []
  type: TYPE_NORMAL
- en: 'let match_lines: Vec<_> = lines // inferred type (_)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match line.contains(pattern) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect(); // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // format text for debugging purposes println!("{match_lines:?}"); }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using `from_iter`, you can also use `collect`.
  prefs: []
  type: TYPE_NORMAL
- en: The inferred type (`_`) in `Vec<_>` *asks* the compiler to infer the type if
    possible based on the surrounding context.^([2](#footnote-2))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Creating Intervals from Matched Lines](#creating-intervals-from-matched-lines)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `map` function invokes the `closure` once for each value in the vector,
    passing `line_no` (the line number) to the function. We use this to identify the
    lines before and after the match that we want to print. To handle potential out-of-bounds
    indexing, we use `saturating_add` and `saturating_sub`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there's none of him at all.";   let
    pattern = "all";    let before_context = 1;
  prefs: []
  type: TYPE_NORMAL
- en: let after_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// convert the poem into lines let lines = Vec::from_iter(poem.lines());   //
    store the 0-based line number for any matched line let match_lines: Vec<_> = lines
    .iter() .enumerate() .filter_map(|(i, line)| match line.contains(pattern) { true
    => Some(i), false => None, }) .collect(); // turns anything iterable into a collection      //
    create intervals of the form [a,b] with the before/after context'
  prefs: []
  type: TYPE_NORMAL
- en: 'let intervals: Vec<_> = match_lines'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line_no| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // prevent underflow
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line_no.saturating_sub(before_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // prevent overflow
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line_no.saturating_add(after_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // format text for debugging purposes println!("{intervals:?}"); }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Merging Intervals](#merging-intervals)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Merging overlapping intervals is straightforward because they are already sorted,
    and the ending value of the next interval must be greater than the current one.
    We could store the merged intervals in a new Vector, but that would be inefficient.
    Instead, we'll make our `intervals` vector mutable and take advantage of the `dedup_by`
    iterator adaptor to perform the merge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    pattern = "all"; let before_context = 1; let after_context = 1;   // convert the
    poem into lines let lines = Vec::from_iter(poem.lines());   // store the 0-based
    line number for any matched line let match_lines: Vec<_> = lines .iter() .enumerate()
    .filter_map(|(i, line)| match line.contains(pattern) { true => Some(i), false
    => None, }) .collect(); // turns anything iterable into a collection   // create
    intervals of the form [a,b] with the before/after context    let mut intervals:
    Vec<_> = match_lines'
  prefs: []
  type: TYPE_NORMAL
- en: .iter() .map(|line| { ( line.saturating_sub(before_context), line.saturating_add(after_context),
    ) }) .collect();      // merge overlapping intervals
  prefs: []
  type: TYPE_NORMAL
- en: intervals.dedup_by(|next, prev| {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if prev.1 < next.0 {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'false'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: prev.1 = next.1;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // format text for debugging purposes println!("{intervals:?}"); }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The [`dedup_by`](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.dedup_by)
    iterator adaptor removes consecutive identical elements based on a provided closure.
    It starts by calling the closure with the first (`prev`) and second (`next`) elements
    in the collection. If the closure returns `false`, `prev` becomes `next`, `next`
    is advanced, and the closure is called with the new elements. If the closure returns
    `true`, only `next` is advanced. This behavior allows us to update `prev` to be
    the merged interval, enabling efficient merging of overlapping intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple fields are accessed using a 0-based index, just like array elements.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Print the Results](#print-the-results)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our intervals merged, we can now print out the results correctly!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    pattern = "all"; let before_context = 1; let after_context = 1;   // convert the
    poem into lines let lines = Vec::from_iter(poem.lines());   // store the 0-based
    line number for any matched line let match_lines: Vec<_> = lines .iter() .enumerate()
    .filter_map(|(i, line)| match line.contains(pattern) { true => Some(i), false
    => None, }) .collect(); // turns anything iterable into a collection   // create
    intervals of the form [a,b] with the before/after context let mut intervals: Vec<_>
    = match_lines .iter() .map(|line| { ( line.saturating_sub(before_context), line.saturating_add(after_context),
    ) }) .collect();   // merge overlapping intervals intervals.dedup_by(|next, prev|
    { if prev.1 < next.0 { false } else { prev.1 = next.1; true } });      // print
    the lines'
  prefs: []
  type: TYPE_NORMAL
- en: for (start, end) in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in lines
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .take(end + 1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .skip(start) {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[We Did It!](#we-did-it)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a working rustle program! Take some time to review everything we've
    covered so far. The rest of the course is going to move quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered quite a bit in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`collect` converts any iterable into a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saturating_add` and `saturating_sub` prevent overflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip` creates an iterator that skips elements until `n` elements are skipped
    or the end of the iterator is reached, whichever comes first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take` creates an iterator that yields elements until `n` elements are yielded
    or the end of the iterator is reached, whichever comes first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `println!` macro supports the [`:?`](https://doc.rust-lang.org/std/fmt/index.html#fmtdisplay-vs-fmtdebug)
    format specifier, which is intended to help with debugging Rust code. All public
    types should implement the `fmt::Debug trait`.^([3](#footnote-3))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive into the concepts of ownership and borrowing.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the [`Vec` source code](https://doc.rust-lang.org/src/alloc/vec/mod.rs.html)
    see it's full implementation. The `struct` definition is on line [397](https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#397).
    [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [Inferred type](https://doc.rust-lang.org/reference/types/inferred.html?highlight=Vec%3C_%3E#inferred-type)
    is part of the type system in Rust. [↩](#fr-2-1) [↩2](#fr-2-2)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Details about the `Debug` trait can be found [here](https://doc.rust-lang.org/std/fmt/trait.Debug.html).
    [↩](#fr-3-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

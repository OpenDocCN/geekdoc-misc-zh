- en: An Evaluator for Local Binding
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地绑定的评估器
- en: Now that we’ve seen what behavior we want, we should implement it. That is,
    we’ll extend our calculator to handle local binding (a feature you may well have
    wished your calculator had). To reflect that our calculator is growing up, from
    now on we’ll call it an interpreter, abbreviated in code to `interp`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们想要的行为，我们应该实现它。也就是说，我们将扩展我们的计算器以处理本地绑定（你可能非常希望你的计算器拥有这个功能）。为了反映我们的计算器正在成长，从现在起我们将称它为解释器，在代码中简写为`interp`。
- en: 'Let’s start with the new AST. For simplicity, we’ll ignore conditionals, which
    are anyway orthogonal to our goal of handling local binding. Recall that we added
    two new branches to the BNF, so we’ll want two new corresponding branches to the
    AST:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从新的抽象语法树（AST）开始。为了简化，我们将忽略条件语句，因为它们无论如何都与我们的目标——处理本地绑定——正交。回想一下，我们在巴科斯-诺尔范式（BNF）中添加了两个新的分支，因此我们也将想要为抽象语法树添加两个新的对应分支：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also copy over our previous calculator, but we pretty quickly run into
    trouble:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以复制我们之前的计算器，但我们很快就会遇到麻烦：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What do we do when we encounter a `let1E`? For that matter, what do we do when
    we encounter a variable? In fact, these two should be intimately connected: the
    variable binding introduced by the former should substitute the variable use in
    the latter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到`let1E`时我们该怎么办？同样，当我们遇到变量时我们该怎么办？实际上，这两个应该是紧密相连的：前者引入的变量绑定应该替换后者中的变量使用。

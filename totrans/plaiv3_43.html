<html><head></head><body>
<h2 class="c27" id="h.n6eymaq2d8zz"><span class="c4">Extending the Representation</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Therefore, let’s think about what it takes to evaluate functions-as-values to SMoL. We don’t need functions to inherently have a name, because naming can be done by </span><code>let1</code><span class="c4">.  We’ll assume, for simplicity, that all functions take only one argument; extending this to multiple arguments is left as an exercise.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> What issues might we have to deal with when we extend functions from having one argument only to having multiple arguments?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">First, we need to extend our abstract syntax.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> How many new constructs do we need to add to the abstract syntax?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">When we added </span><code>let1</code><span class="calibre3">, you may recall that it didn’t suffice to add one construct; we needed two: one for variable </span><span class="c7">binding</span><span class="calibre3"> and one for variable </span><span class="c7">use</span><span class="calibre3">. You’ll often see this pattern when adding values to the language. For any new kind of value,  you can expect to see one or more ways to </span><span class="c7">make</span><span class="calibre3"> it and one or more ways to </span><span class="c7">use</span><span class="c4"> it. (Even arithmetic: numeric constants were a way to make them, arithmetic operations consumed them—but also made them.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Likewise with functions, we need a way to represent both</span></p><p class="c3"><span class="c4"/></p><pre>lam(x): x * x</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">for defining new functions, and</span></p><p class="c3"><span class="c4"/></p><pre>sq(3)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">to use them.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> In more advanced texts, you will sometimes see the (formally correct, but perhaps slightly confusing) terms </span><span class="c7">introduction</span><span class="calibre3"> and </span><span class="c7">elimination</span><span class="calibre3">: introduction brings the new concept in, elimination uses them. Thus, the </span><code>lam</code><span class="c4"> introduces new functions, and an application eliminates them.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We therefore add</span></p><p class="c3"><span class="c4"/></p><pre>  [lamE (var : Symbol) (body : Exp)]
  [appE (fun : Exp) (arg : Exp)]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">to our AST.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s assume we’ve already extended our parser, so that programs like the following are legal:</span></p><p class="c3"><span class="c4"/></p><pre>{let1 {f {lam x {+ x x}}}
      {f 3}}</pre><p class="c3"><span class="c41"/></p><pre>{let1 {x 3}
      {let1 {f {lam y {+ x y}}}
            {f 3}}}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">These parse, respectively, into</span></p><p class="c3"><span class="c4"/></p><pre>(let1E 'f (lamE 'x (plusE (varE 'x) (varE 'x))) 
       (appE (varE 'f) (numE 3)))</pre><p class="c3"><span class="c41"/></p><pre>(let1E 'x (numE 3) 
       (let1E 'f (lamE 'y (plusE (varE 'x) (varE 'y))) 
              (appE (varE 'f) (numE 3))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and should both evaluate to </span><code>6</code><span class="c4">.</span></p>

<h2 class="c27" id="h.9bu9gdibar49"><span class="c4">Evaluating Functions</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s think about the evaluator, which by now we can think of as turning into a full-blown interpreter.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s start with the (almost) simplest kind of new program:</span></p><p class="c3"><span class="c4"/></p><pre>{lam x {+ x x}}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">which is represented as</span></p><p class="c3"><span class="c41"/></p><pre>(lamE 'x (plusE (varE 'x) (varE 'x)))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> What do we want this program to evaluate to? Think in terms of types!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Remember that </span><code>calc</code><span class="calibre3"> produces numbers. What </span><span class="c7">number</span><span class="calibre3"> does the above expression evaluate to? What number do you </span><span class="c7">expect</span><span class="c4"> it to produce?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If we really want to stretch our credibility, we could either make up an encoding of it in a number, or use a number in memory. But neither of these is what we would </span><span class="c7">expect</span><span class="c4">! Let’s look at what some other languages do:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (lambda (x) (+ x x))
#&lt;procedure&gt;
&gt; (number? (lambda (x) (+ x x)))
#f</pre><p class="c3"><span class="c41"/></p><pre>&gt;&gt;&gt; lambda x: x + x
&lt;function &lt;lambda&gt; at 0x108fd16a8&gt;
&gt;&gt;&gt; isinstance(lambda x: x + x, numbers.Number)
False</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Both Racket and Python agree: the result of creating an anonymous function is a function-kind of value, not a number. What this says is that we have to broaden the kinds of values that </span><code>interp</code><span class="c4"> can produce.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology: </span><span class="calibre3">A </span><span class="c7">side-effect</span><span class="calibre3"> is a change to the system that is visible from outside the body of a function. Typical side-effects are modifications to variables that are defined outside the function, communication with a network, changes to files, and so on.</span></p><p class="c51"><span class="c49"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> A function is </span><span class="c7">pure</span><span class="calibre3"> if, for a given input, it always produces the same output, and has no side-effects. In reality, a computation always has </span><span class="c7">some</span><span class="c4"> side-effects, such as the consumption of energy and production of heat, but we usually overlook these because they are universal. In a few settings, however, they can matter: e.g., if a cryptographic key can be stolen by measuring these side-effects.</span></p><p class="c51"><span class="c49"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> Traditionally, some languages have used the terms </span><span class="c7">procedure</span><span class="calibre3"> and </span><span class="c7">function</span><span class="c4"> for similar but not identical concepts. Both are function-like entities that encapsulate a body of code and can be applied (or “called”). A procedure is an encapsulation that does not produce a value; therefore, it must have side-effects to be of any use. In contrast, a function always produces a value (and may be expected to not have any side-effects). This terminology has gotten completely scrambled over the years and people now use the terms interchangeably, but if someone seems to be making a distinction between the two, they probably mean something like the above.</span></p>

<h2 class="c27" id="h.ro21l25wy6zu"><span class="c4">Extending Values</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What happens when evaluating a function? Both Racket and Python seem to suggest that we return a function.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We could have no additional information about the function:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type Value
  [numV (the-number : Number)]
  [boolV (the-boolean : Boolean)]
  [funV])</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">(That syntax means </span><code>funV</code><span class="calibre3"> is a constructor of no parameters. It conveys no information at all other than the fact that it’s a </span><code>funV</code><span class="calibre3">; because we can’t mix types, it says, in particular, that a value is not numeric or a Boolean—and nothing more.) But now think about a program like this (assuming </span><code>x</code><span class="c4"> is bound):</span></p><p class="c3"><span class="c4"/></p><pre>{{if0 x
      {lam x {+ x 1}}
      {lam x {- x 2}}}
 5}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In both cases we’re going to get a </span><code>funV</code><span class="c4"> value with no additional information, so when we try to perform the application, we…can’t.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Instead, it’s clear that the function value needs to tell us about the function. We need to know the body, because that’s what we need to evaluate; but the body can (and very likely does) reference the name of the formal parameter, so we need that too. Therefore, what we really need is</span></p><p class="c3"><span class="c4"/></p><pre>(define-type Value
  [numV (the-number : Number)]
  [boolV (the-boolean : Boolean)]
  [funV (var : Symbol) (body : Exp)])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">At this point, it seems like we’ve gone to a lot of trouble for nothing. We take numeric and Boolean values and simply re-wrap them in new constructors, and now we’re doing the same thing for functions.  A certain Shakespeareian play’s title comes to mind.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Patience.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">With what we have, we can already have a functioning interpreter. The lam case is obviously very simple:</span></p><p class="c3"><span class="c4"/></p><pre>    [(lamE v b) (funV v b)]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The application case is a bit more detailed. We need to:</span></p><ol class="c68" start="1"><li class="c69 pcalibre10"><span class="c4">Evaluate the function position, to figure out what kind of value it is.</span></li><li class="c69 pcalibre10"><span class="c4">Evaluate the argument position, since we’ve agreed that’s what happens in SMoL.</span></li><li class="c69 pcalibre10"><span class="c4">Check that the function position really does evaluate to a function. If it does not, raise an error.</span></li><li class="c69 pcalibre10"><span class="c4">Evaluate the body of the function. But because the body can refer to the formal parameter…</span></li><li class="c69 pcalibre10"><span class="c4">…first make sure the formal is bound to the actual value of the argument.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Codifying this, in stages:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>    [(appE f a) </code><span class="c65">(let ([fv (interp f nv)]</span></p><p class="c5"><span class="c65">                      [av (interp a nv)])</span></p><p class="c5"><span class="c64">                  …)</span><code>]</code></p><p class="c3"><span class="c4"/></p><pre>    [(appE f a) (let ([fv (interp f nv)]
                      [av (interp a nv)])</pre><p class="c5"><code>                  </code><span class="c65">(type-case Value fv</span></p><p class="c5"><span class="c65">                    [(funV v b) …]</span></p><p class="c5"><span class="c64">                    [else (error 'app "didn't get a function")]</span><code>))]</code></p><p class="c3"><span class="c4"/></p><pre>    [(appE f a) (let ([fv (interp f nv)]
                      [av (interp a nv)])
                  (type-case Value fv
                    [(funV v b)</pre><p class="c5"><code>                     </code><span class="c64">(interp b …)</span><code>]</code></p><pre>                    [else (error 'app "didn't get a function")]))]</pre><p class="c3"><span class="c4"/></p><pre>    [(appE f a) (let ([fv (interp f nv)]
                      [av (interp a nv)])
                  (type-case Value fv
                    [(funV v b)</pre><p class="c5"><code>                     (interp b </code><span class="c64">(extend nv v av)</span><code>)]</code></p><pre>                    [else (error 'app "didn't get a function")]))]</pre>

<h2 class="c27" id="h.kt5kvrtrdq0p"><span class="c4">Stepping Back</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Putting it all together, we get the following interpreter:</span></p><p class="c3"><span class="c4"/></p><pre>(interp : (Exp Env -&gt; Value))</pre><p class="c3"><span class="c41"/></p><pre>(define (interp e nv)
  (type-case Exp e
    [(numE n) (numV n)]
    [(varE s) (lookup s nv)]
    [(plusE l r) (add (interp l nv) (interp r nv))]
    [(lamE v b) (funV v b)]
    [(appE f a) (let ([fv (interp f nv)]
                      [av (interp a nv)])
                  (type-case Value fv
                    [(funV v b)
                     (interp b (extend nv v av))]
                    [else (error 'app "didn't get a function")]))]
    [(let1E var val body)
     (let ([new-env (extend nv
                            var
                            (interp val nv))])
       (interp body new-env))]))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> We wrote down a particular ordering above, which we put into practice in the code. But is that the same ordering that actual languages use? In particular, are non-function errors reported after or before evaluating the argument? Experiment and find out!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Since we’ve taken several steps to get here, it’s easy to lose sight of what we’ve just done. In just 20 lines of code (with a few helper functions), we have described the implementation of a </span><span class="c7">full programming language</span><span class="calibre3">. Not only that, a language that can express </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Church%25E2%2580%2593Turing_thesis&amp;sa=D&amp;source=editors&amp;ust=1695232021212601&amp;usg=AOvVaw1o9iRZ1zIR7qNKrD6lFhCa">all computations</a></span><span class="calibre3">. When Turing Award winner </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Alan_Kay&amp;sa=D&amp;source=editors&amp;ust=1695232021213036&amp;usg=AOvVaw1mQ9COqfNQ40uhDQa8ed0D">Alan Kay</a></span><span class="calibre3"> first saw the equivalent program, </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://queue.acm.org/detail.cfm?id%3D1039523&amp;sa=D&amp;source=editors&amp;ust=1695232021213294&amp;usg=AOvVaw2Jqf_V8SktzbJT9CEIRj32">he says</a></span><span class="c4">,</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c4">Yes, that was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="c4">I realized that anytime I want to know what I’m doing, I can just write down the kernel of this thing in a half page and it’s not going to lose any power. In fact, it’s going to gain power by being able to reenter itself much more readily than most systems done the other way can possibly do.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We’ve just rediscovered this same beautiful, powerful idea! If you want to see the original, here’s </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://www.softwarepreservation.org/projects/LISP/book/LISP%25201.5%2520Programmers%2520Manual.pdf&amp;sa=D&amp;source=editors&amp;ust=1695232021214133&amp;usg=AOvVaw2NEGhAo0Lj5kqCqv5LySNb">that manual</a></span><span class="c4"> (by McCarthy, Abrahams, Edwards, Hart, Levin). Here it is, copied:</span></p><p class="c3"><span class="c4"/></p><p class="c8"><span class="calibre21"><img alt="" src="image3.png" title="" class="calibre22"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Alright, so we now have a working interpreter for a full-fledged language. But before we can feel sure of that, we should try a few more examples to confirm that we’re happy with what we have.</span></p>

<h2 class="c27" id="h.rh0h0wb4rhhu"><span class="c4">Extending Tests</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Well, actually, we shouldn’t be too happy. Consider the following examples:</span></p><p class="c3"><span class="c4"/></p><pre>(let1E 'x (numE 1)
       (let1E 'f (lamE 'y (varE 'x))
              (let1E 'x (numE 2)
                     (appE (varE 'f) (numE 10)))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What do we expect it to produce? If in doubt, we can write the same thing as a Racket program:</span></p><p class="c3"><span class="c4"/></p><pre>(let ([x 1])
  (let ([f (lambda (y) x)])
    (let ([x 2])
      (f 10))))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">What we see is that </span><span class="c7">in Racket</span><span class="calibre3">, the inner binding of </span><code>x</code><span class="calibre3"> does </span><span class="c7">not</span><span class="calibre3"> override the outer one, the one that was present at the time the function bound to </span><code>f</code><span class="calibre3"> was defined. Therefore, this produces </span><code>1</code><span class="c4"> in Racket.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We should want this! Otherwise, consider this program:</span></p><p class="c3"><span class="c4"/></p><pre>(let1E 'f (lamE 'y (varE 'x))
       (let1E 'x (numE 1)
              (appE (varE 'f) (numE 10))))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="c4">This corresponds to</span></p><p class="c3"><span class="c4"/></p><pre>(let ([f (lambda (y) x)])
  (let ([x 5])
    (f 3)))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">which has an unbound identifier (</span><code>x</code><span class="calibre3">) error. But our interpreter produces </span><code>1</code><span class="calibre3"> instead of halting with an error, which leads us right back to </span><span class="c70">☠️</span><span class="c40">dynamic scope </span><span class="c4">☠️!</span></p>

<h2 class="c27" id="h.xd5vu82nq8vr"><span class="c4">Return to Static Scope</span></h2><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="c4">Run the following programs in the Stacker.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">So how do we fix this? The examples above actually give us a clue, but there is another source of inspiration as well. Do you remember that we started with </span><span class="c7">substitution</span><span class="c4">? We’ll walk through these examples in Racket, so that you can run each of them directly and check that they produce the same answer. Consider again this program:</span></p><p class="c3"><span class="c4"/></p><pre>(let ([x 1])
  (let ([f (lambda (y) x)])
    (let ([x 2])
      (f 10))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Substituting </span><code>1</code><span class="calibre3"> for </span><code>x</code><span class="c4"> produces:</span></p><p class="c3"><span class="c4"/></p><pre>  (let ([f (lambda (y) 1)])
    (let ([x 2])
      (f 10)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Substituting </span><code>f</code><span class="c4"> produces:</span></p><p class="c3"><span class="c4"/></p><pre>    (let ([x 2])
      ((lambda (y) 1) 10))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Finally, substituting </span><code>x</code><span class="calibre3"> with </span><code>2</code><span class="calibre3"> produces (note that there are no </span><code>x</code><span class="c4">s left in the program!):</span></p><p class="c3"><span class="c4"/></p><pre>      ((lambda (y) 1) 10)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">When you see it this way, it’s clear </span><span class="c7">why</span><span class="calibre3"> the later binding of </span><code>x</code><span class="calibre3"> should have no impact: it’s a different </span><code>x</code><span class="calibre3">, and the earlier </span><code>x</code><span class="calibre3"> has effectively already been substituted. Since we have agreed that substitution is how we want our programs to work, our job now is to make sure that the environment actually implements that </span><span class="c7">correctly</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The way to do it is to recognize that the environment represents the substitutions waiting to happen, and just </span><span class="c7">remember</span><span class="c4"> them. That is, our representation of a function needs to also keep track of the environment at the moment of function creation:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type Value
  [numV (the-number : Number)]
  [boolV (the-boolean : Boolean)]</pre><p class="c5"><code>  [funV (var : Symbol) (body : Exp) </code><span class="c64">(nv : Env)</span><code>])</code></p><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">This new and richer kind of </span><code>funV</code><span class="calibre3"> value has a special name: it’s called a </span><span class="c7">closure</span><span class="c4">. That’s because the expression is “closed” over the environment in which it was defined.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> A </span><span class="c7">closed</span><span class="calibre3"> term is one that has no unbound variables. The body of a function may have unbound variables—like </span><code>x</code><span class="calibre3"> above—but the closure makes sure that they aren’t </span><span class="c7">really</span><span class="c4"> unbound, because they can get their values from the stored environment.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Quote:</span><span class="calibre3"> “Save the environment! Create a closure today!” —</span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://users.soe.ucsc.edu/~cormac/&amp;sa=D&amp;source=editors&amp;ust=1695232021221610&amp;usg=AOvVaw0ubwf31ENzplf9Txn7x4SS">Cormac Flanagan</a></span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="c40">Quote:</span><span class="calibre3"> “Lambdas are relegated to relative obscurity until Java makes them popular by not having them.” </span><span class="c40">—</span><span class="calibre3">James Iry, </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html&amp;sa=D&amp;source=editors&amp;ust=1695232021222322&amp;usg=AOvVaw15zUkk_RscjegRPA01Zrxb">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</a></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">That means, when we create a closure, we have to record the environment at the time of its creation:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>    [(lamE v b) (funV v b </code><span class="c64">nv</span><code>)]</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Finally, when we use a function (represented by a closure), we have to make sure we use the </span><span class="c7">stored</span><span class="calibre3"> environment, not the one present at the point of calling the function, which is the </span><span class="c7">dynamic</span><span class="c4"> one:</span></p><p class="c3"><span class="c4"/></p><pre>    [(appE f a) (let ([fv (interp f nv)]
                      [av (interp a nv)])
                  (type-case Value fv</pre><p class="c5"><code>                    [(funV v b </code><span class="c64">nv</span><code>)</code></p><pre>                     (interp b (extend nv v av))]
                    [else (error 'app "didn't get a function")]))]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Just to be clear: in the code above, the </span><code>nv</code><span class="calibre3"> in the </span><code>funV</code><span class="calibre3"> case </span><span class="c7">intentionally shadows</span><span class="calibre3"> the </span><code>nv</code><span class="calibre3"> bound at the top of the interpreter. Thus, the call to </span><code>extend</code><span class="calibre3"> extends the environment </span><span class="c7">from the closure</span><span class="c4">, rather than the one present at the point of the call.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Notice that the function and argument expressions (</span><code>f</code><span class="calibre3"> and </span><code>a</code><span class="c4">, respectively) are evaluated in the environment given to the interpreter, not the one inside the closure. Is this correct? Or should they be using the closure’s environment? </span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="calibre3">You can do two things: argue from first principles or argue with examples. In the latter case, you would modify the interpreter to make the other choice. You would then use a sample input that produces different answers depending on which environment is used, indicate which one is correct (showing what the equivalent Racket program would produce can be a good argument), and use that to justify the chosen environment. </span><span class="c40">Hint:</span><span class="c4"> One of these you will need to argue from first principles, the other you should be able to argue using a program.</span></p>

<h2 class="c27" id="h.tho13dunr1bq"><span class="c4">A Subtle Test</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In the examples above, we always use the closure in the scope in which it was defined. However, our language is actually more powerful than that: we can </span><span class="c7">return</span><span class="calibre3"> a closure and use it </span><span class="c7">outside</span><span class="c4"> the scope in which it was defined. Here’s a sample Racket program:</span></p><p class="c3"><span class="c4"/></p><pre>((let ([x 3])
   (lambda (y) (+ x y)))
 4)</pre><p class="c3"><span class="c41"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> Take a moment to read it carefully. What should it produce?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">First we bind the </span><code>x</code><span class="calibre3">, then we evaluate the lambda. This creates a closure that remembers the binding to </span><code>x</code><span class="c4">. This closure is the value returned by this expression:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(</code><span class="c65">(let ([x 3])</span></p><p class="c5"><span class="c65">   (lambda (y) (+ x y)))</span></p><pre> 4)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This value is now applied to </span><code>4</code><span class="calibre3">. It’s legal to do this, because the value returned is a function. When we apply it to </span><code>4</code><span class="calibre3">, that evaluates the sum of </span><code>4</code><span class="calibre3"> and </span><code>3</code><span class="calibre3">, producing </span><code>7</code><span class="calibre3">. Sure enough, translating this and sending it to our interpreter produces </span><code>7</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(test (interp (appE (let1E 'x (numE 3)
                           (lamE 'y (plusE (varE 'x) (varE 'y))))
                    (numE '4))
              mt-env)
      (numV 7))</pre><p class="c3"><span class="c41"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Here’s another test to try out, written as a Racket program:</span></p><p class="c51"><span class="c4"/></p><pre>((let ([y 3])
   (lambda (y) (+ y 1)))
 5)</pre><p class="c51"><span class="c41"/></p><p class="c31"><span class="c4">What does it produce in Racket? Translate it and try it in your interpreter.</span></p>

<h1 class="c14" id="h.jfd2cla8q374"><span class="c4">••••• Syntactic Sugar •••••</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">We have now seen the essence of a small core language. In practice, programming languages need to also be </span><span class="calibre3">usable</span><span class="c32">. To do this, they have to provide features that make programming convenient. We will see they can do this while minimizing their effort and pain.</span></p>

<h1 class="c22" id="h.kbecy5s6bhgh"><span class="c4">How SMoL Becomes Large</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We have already been introduced to the idea of SImPl, the Standard Implementation Plan. The core idea is that the program’s syntax is represented as abstract syntax using a (mutually) recursive algebraic datatype, and we then write a similar (mutually) recursive program to process it. What that program produces depends on the process we are trying to implement: an interpreter produces </span><span class="c7">values</span><span class="calibre3">, a compiler produces </span><span class="c7">programs</span><span class="calibre3"> (in another language), a type-checker produces </span><span class="c7">judgments about type-correctness</span><span class="c4"> (and more, as we’ll soon see), and so on. But they all have the same basic structure.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In practice, this means that a SImPl needs to have a case to handle each of the constructs in the language. This is not a problem in principle, but it can become onerous in practice. Suppose we have two constructs that have a lot of repetition. Not only does it mean we have to duplicate programming, it also means we have to duplicate </span><span class="c7">maintenance</span><span class="c4">: if we fix a bug in one, we have to remember to fix it in the other in the corresponding way.</span></p>

<h2 class="c27" id="h.45int957ufz8"><span class="c4">Redundancy in Languages</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Where might we find such redundancy? There are several examples in real languages. For instance, many languages have both </span><code>for</code><span class="calibre3"> and </span><code>while</code><span class="calibre3"> loops. Consider a typical </span><code>for</code><span class="c4"> loop in C:</span></p><p class="c3"><span class="c4"/></p><pre>for(x = 0; x &lt; 10; x++) {
  sum += x;
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This is </span><span class="c7">exactly</span><span class="c4"> the same as</span></p><p class="c3"><span class="c4"/></p><pre>x = 0;
while (x &lt; 10) {
  sum += x;
  x++;
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">There is, in fact, a general pattern:</span></p><p class="c3"><span class="c4"/></p><pre>for(INITIAL; CONDITIONAL; UPDATE) {
  sum += x;
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">is the same (with some syntactic liberties) as</span></p><p class="c3"><span class="c4"/></p><pre>INITIAL;
while (CONDITIONAL) {
  sum += x;
  UPDATE;
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now imagine you’re writing an interpreter for this. Clearly, the </span><code>while</code><span class="calibre3"> loop’s implementation has to make several recursive calls, iterate, check, and perhaps perform some other bookkeeping (and maybe even manage temporary scope extensions). </span><span class="c7">All</span><span class="calibre3"> of that work has to be </span><span class="c7">duplicated</span><span class="calibre3"> for </span><code>for</code><span class="calibre3">! Wouldn’t it be much simpler to instead implement it just once, and translate the </span><code>for</code><span class="calibre3"> body into a </span><code>while</code><span class="c4"> body?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Why have both constructs at all? Because each one is convenient for different purposes. In particular, there’s a certain stylistic use of </span><code>while</code><span class="calibre3"> that would be harder to spot from a mass of </span><code>while</code><span class="calibre3"> code that is automatically classified for us with </span><code>for</code><span class="c4">. It adds to our vocabulary as programmers. It just happens to also add to our pain as implementors. We’d like the convenience and richer vocabulary without the pain.</span></p>

<h2 class="c27" id="h.uxu8lpxakrfe"><span class="c4">Desugaring</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This introduces a distinction between a </span><span class="c7">core</span><span class="calibre3"> language and a </span><span class="c7">surface</span><span class="calibre3"> language. The surface language may have various conveniences, but these get translated into the core language, whose constructs are all handled directly. The extra constructs—those that make it “sweeter” to program—are called </span><span class="c7">syntactic sugar</span><span class="calibre3">. The program that translates surface programs down to the core is called a </span><span class="c7">desugarer</span><span class="calibre3">, because it removes sugar. (In principle, a desugarer is actually a </span><span class="c7">compiler</span><span class="calibre3"> from the surface language to the core language. However, since the core language is a </span><span class="c7">sub</span><span class="calibre3">-language of the surface, this is a very special case of compilation, and we find it useful to have a special term to distinguish it from general compilation. Just like we find it useful to have a special term to distinguish </span><code>for</code><span class="calibre3"> from the general </span><code>while</code><span class="c4">…)</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> In a real implementation, this compilation requires a little more care. Suppose you make an error using </span><code>for</code><span class="calibre3">, but the error was reported in terms of </span><code>while</code><span class="calibre3">: you’d be pretty confused, because you never did type the </span><code>while</code><span class="calibre3">. As a special case, you may be a student who doesn’t even know what </span><code>while</code><span class="calibre3"> </span><span class="c7">is</span><span class="c4">! Modern desguaring systems, such as that in Racket, have special support to take care of this in most of the common cases.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">There are actually many more desugarings in real languages. For instance, </span><code>and</code><span class="calibre3"> and </span><code>or</code><span class="calibre3"> can desugar into nested </span><code>if</code><span class="calibre3">s. In JavaScript, </span><code>o.x</code><span class="calibre3"> desugars into </span><code>o["x"]</code><span class="calibre3"> (which will be relevant in a while). In many languages, </span><code>x += y</code><span class="calibre3"> is sugar for </span><code>x = x + y</code><span class="calibre3">. In Python, </span><code>+</code><span class="calibre3"> desugars into the method </span><code>__add__</code><span class="calibre3">. In fact, Python has a whole bunch of these desugarings; these methods are called “dunder” methods (short for double-underscore), and a whole programming style of “</span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://twitter.com/gvanrossum/status/1307712322320785409&amp;sa=D&amp;source=editors&amp;ust=1695232021233535&amp;usg=AOvVaw2ERm9Pb0kR6LijXtV_K83D">protocols</a></span><span class="c4">” has evolved around it. Many languages (like Haskell and Python) have list comprehensions, which desugar into function and method calls. And so on. In short, desugaring is everywhere in programming. If you don’t notice it, that’s part of the point: it feels like you’re working with a larger surface syntax than the implementor has to manage.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">There are many ways in which desugaring can be implemented. One way is to parse the program normally, then rewrite the AST into a subset of the same AST. But in some languages, especially those with parenthetical syntax, there are two levels of parsing: the coarser parenthetical level and the finer level of ASTs. This means we can perform rewriting on the parenthetical terms, and the internal AST never needs to know about the sugars (i.e., it need cover only the core language). These are typically called </span><span class="c7">macro</span><span class="calibre3"> systems: systems in which program source (slightly abstracted) is rewritten into program source, before parsing takes place. It’s important to understand that </span><span class="c7">most</span><span class="calibre3"> languages have syntactic sugar, but </span><span class="c7">very few</span><span class="c4"> languages have macro systems, which provide program rewriting capabilities directly to the programmer (as opposed to hiding them inside the compiler).</span></p>

<h2 class="c27" id="h.5hv439o42m65"><span class="c4">Macros By Example</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Racket is one of the few languages to have a macro system, and in fact has a very powerful one. Its rarity means ideas we learn using macros will take some effort to port to other languages; but its power means we can write quite sophisticated systems by leveraging the full power of Racket, and we will do so. In essence, Racket macros compile an extended version of Racket—call it Racket++, if you like—down to Racket, where we can then exploit the full power of the existing Racket framework.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We will introduce the Racket macro system through a series of examples. In what follows, please switch to using</span></p><p class="c3"><span class="c4"/></p><pre>#lang racket</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">because the restrictions and types of </span><code>plait</code><span class="c4">, while very useful for writing interpreters, can get in the way of some of what we’ll write.</span></p>

<h2 class="c27" id="h.uwpyf6uoxhek"><span class="c4">A New Conditional</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Recall that Racket is a truthy/falsy language, where </span><code>if</code><span class="calibre3"> takes any non-false value to be true. Suppose we want a strict </span><code>if</code><span class="calibre3"> that takes only Booleans. That is, we want to extend Racket itself with a </span><code>strict-if</code><span class="c4">. Let’s try this:</span></p><p class="c3"><span class="c4"/></p><pre>(define (strict-if C T E)
  (if (boolean? C)
      (if C T E)
      (error 'strict-if "expected a boolean")))</pre><p class="c3"><span class="c49"/></p><p class="c5"><span class="c4">Try examples like:</span></p><p class="c3"><span class="c4"/></p><pre>(strict-if true 1 2)
(strict-if 0 1 2)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Seems to work as desired!</span></p><p class="c3"><span class="c49"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> Do you see what the problem is?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The problem is that we have an eager language (this is true of SMoL in general!), so </span><code>strict-if</code><span class="c4">s arguments are going to be evaluated before the body begins to execute. However, the whole point of a conditional is to avoid evaluating part of the evaluation: Try</span></p><p class="c3"><span class="c4"/></p><pre>(strict-if true 1 (/ 1 0))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Compare this to what happens with</span></p><p class="c3"><span class="c4"/></p><pre>(if true 1 (/ 1 0))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, so we can’t use functions for this purpose. We need some other definition mechanism that consumes the </span><span class="c7">syntax</span><span class="c4"> and rewrites that, instead of letting it evaluate right away. These are macros.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s dive into how the macro is written, because it’s not so different from the function:</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax strict-if
  (syntax-rules ()
    [(strict-if C T E)
     (if (boolean? C)
         (if C T E)
         (error 'strict-if "expected a boolean"))]))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">What are the pieces? </span><code>define-syntax</code><span class="calibre3"> says we’re defining a new piece of </span><span class="c7">syntax</span><span class="calibre3"> (as opposed to a function). </span><code>syntax-rules</code><span class="calibre3"> introduces a pattern-matcher (for now, ignore what the </span><code>()</code><span class="calibre3"> means: but you do need to include it). Each rule, in brackets, is a pattern and output: if the input matches the pattern, then the desugarer (here called a </span><span class="c7">macro expander</span><span class="calibre3">) produces the corresponding output, but with the </span><span class="c7">names</span><span class="calibre3"> in the pattern (here, </span><code>C</code><span class="calibre3">, </span><code>T</code><span class="calibre3">, and </span><code>E</code><span class="c4">) copied as program source into the output. Thus, given</span></p><p class="c3"><span class="c4"/></p><pre>(strict-if true 1 (/ 1 0))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">the above macro definition transforms it into</span></p><p class="c3"><span class="c4"/></p><pre>(if (boolean? true)
    (if true 1 (/ 1 0))
    (error 'strict-if "expected a boolean"))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">which then evaluates exactly as we’d expect.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">One nice feature of Racket is the Macro Stepper (</span><span class="calibre23"><img alt="" src="image25.png" title="" class="calibre24"/></span><span class="c4">). It shows the program expanding step-by-step, which is useful both for understanding macros and debugging them. If necessary, change the “Macro hiding” option at the bottom-left to read “Standard”.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Try it out with the above macro definition and use. See what you get. Observe how, at each step, it highlights the macro use about to be expanded followed by the result of that expansion.</span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="c40">Note:</span><span class="calibre3"> The Macro Stepper is not an </span><span class="c7">evaluator</span><span class="calibre3">. It does not show the steps of evaluation, only the steps of expansion! Thus, if you write a program that will produce an error at run-time, the Macro Stepper does not show that error. It only shows </span><span class="c7">syntax</span><span class="c4"> errors.</span></p>

<h2 class="c27" id="h.jq7c4mh1czs0"><span class="c4">Local Binding</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s look at the </span><code>let</code><span class="calibre3"> bindings we’ve been using until now. Imagine we want to extend Racket with a </span><code>let1</code><span class="c4"> construct: for example, we want</span></p><p class="c3"><span class="c4"/></p><pre>(let1 (x 3) (+ x x))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">to evaluate to 6.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="calibre3"> Can </span><code>let1</code><span class="c4"> be defined as a function? Why or why not?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>let1</code><span class="calibre3"> can’t be a function. If it were, we would first try to evaluate each of the sub-terms as arguments. There are two things here that look like argument expressions: </span><code>(x 3)</code><span class="calibre3"> and </span><code>(+ x x)</code><span class="calibre3">. Suppose we try to </span><span class="c7">evaluate</span><span class="calibre3"> </span><code>(x 3)</code><span class="calibre3">. First of all, it looks like an application. Second, </span><code>x</code><span class="calibre3"> isn’t even bound. Third, there is no meaningful “value” it could produce: its only job is instead to </span><span class="c7">bind</span><span class="calibre3"> </span><code>x</code><span class="calibre3">. No, </span><code>let1</code><span class="c4"> is also a new piece of syntax.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> We will often refer to these new pieces of syntax as </span><span class="c7">constructs</span><span class="calibre3"> (as in, “a new language construct”). In the Lisp/Scheme/Racket community, these are sometimes also called </span><span class="c7">special forms</span><span class="c4">, because they are syntactic forms with their own special rules for binding and evaluation.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">From now on we’ll use the prefix </span><code>my-</code><span class="c4"> on our macros, because we don’t want to clash with the names of macros already built into Racket.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">From what we’ve seen above, we can probably figure out half of the macro for </span><code>my-let1</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax my-let1
  (syntax-rules ()
    [(my-let1 (var val) body)
     …]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But what would it </span><code>expan</code><span class="calibre3">d into? We certainly </span><span class="c7">could</span><span class="calibre3"> just expand it into the existing </span><code>let</code><span class="c4"> construct in Racket, but there’s another interesting option.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Let’s think about what </span><code>my-let1</code><span class="calibre3"> does: it </span><span class="c7">binds</span><span class="calibre3"> a name to a value, and then immediately </span><span class="c7">evaluates</span><span class="calibre3"> its body in an environment extended by its name. Now, can we think of anything else that binds names to values? Yes, functions. And functions evaluate a body in an extended environment. When do functions evaluate their body? When they are applied to an argument. Therefore, we can express </span><code>my-let1</code><span class="c4"> in terms of an anonymous function that is applied immediately:</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax my-let1
  (syntax-rules ()
    [(my-let1 (var val) body)
     ((lambda (var) body) val)]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Sure enough,</span></p><p class="c3"><span class="c4"/></p><pre>(my-let1 (x 3) (+ x x))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">will produce </span><code>6</code><span class="c4">. Use the Macro Stepper to see how!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> This pattern, of an anonymous function that is used right away, is commonly called </span><span class="c7">left-left-lambda</span><span class="calibre3"> (where “left” stands for left-parenthesis). For a long time this remained an obscure term in the Lisp/Scheme community. But JavaScript made this pattern popular again under the name </span><span class="c7">Immediately Invoked Function Expression</span><span class="c4"> (IIFE), because of problems with the handling of scope in earlier versions of the language. If you think the parentheses look bad here, look up some examples of IIFE on the Web.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Suppose we make a mistake in the macro and swap two parts:</span></p><p class="c51"><span class="c4"/></p><pre>(define-syntax my-let1
  (syntax-rules ()
    [(my-let1 (var val) body)
     ((lambda (var) val) body)]))</pre><p class="c51"><span class="c4"/></p><p class="c31"><span class="c4">What happens when we try to evaluate</span></p><p class="c51"><span class="c4"/></p><pre>(my-let1 (x 3) (+ x x))</pre><p class="c51"><span class="c4"/></p><p class="c31"><span class="c4">? Use the Macro Stepper to see what happened.</span></p>

<h2 class="c27" id="h.92jdu3da8tjz"><span class="c4">Binding More Locals</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">As we have noticed in Racket, however, the </span><code>let</code><span class="c4"> can bind many names at once, not only one. It becomes clear how: the function takes formal arguments, and is applied to just as many actual arguments. There can be as many as we want! But how do we express this in macro syntax?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In mathematics, it’s common to use ellipses (…) to denote a sequence of arbitrary length. Therefore, it would be nice if we could write something like this:</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax my-let2
  (syntax-rules ()
    [(my-let2 ([var val] ...) body)
     ((lambda (var ...) body) val ...)]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This would say, </span><code>my-let2</code><span class="calibre3"> is followed by any number of </span><code>var</code><span class="calibre3">-</span><code>val</code><span class="calibre3"> pairs, followed by a body. Turn that into a </span><code>lambda</code><span class="calibre3"> with all the </span><code>var</code><span class="calibre3">s as formal arguments, whose body is </span><code>body</code><span class="calibre3">, applied to all the same </span><code>val</code><span class="c4">s as the actual argument expressions. We would use it like so (the extra parens are to help us group the bindings):</span></p><p class="c3"><span class="c4"/></p><pre>(my-let2 ([x 3] [y 4]) (+ x y))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">In fact, that is </span><span class="c7">exactly</span><span class="c4"> the syntax supported by Racket! Try out the above program: run it, and also examine it in the Macro Stepper!</span></p>

<h2 class="c27" id="h.vntesywk0bpk"><span class="c4">Multi-Armed Conditionals</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here’s one last example that clarifies what … means: it means “zero or more instances of the preceding pattern”. Using it, we can define our own multi-armed conditional. Suppose we want to define a function called </span><code>sign</code><span class="c4"> that produces a string based on the sign of a number:</span></p><p class="c3"><span class="c4"/></p><pre>(define (sign n)
  (my-cond
   [(&lt; n 0) "negative"]
   [(= n 0) "zero"]
   [(&gt; n 0) "positive"]))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">Again, it’s clear that </span><code>my-cond</code><span class="c4"> can’t be a function; we need to extend the language with a new construct, using a macro.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">How many arms should our multi-armed conditional have? As many as the programmer wants, of course. We’ll further stipulate that if we have exhausted all the questions and none has yielded a true value, the “falling through” produces an error.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Thus, we want to peel off the first question-answer pair and evaluate the question. If it succeeds, we evaluate the answer. Otherwise, we want to recur on the remaining questions…which is essentially a smaller instance of </span><code>my-cond</code><span class="calibre3">. (That’s right, we’re recurring on </span><span class="c7">syntax</span><span class="c4"> now!)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Since </span><code>…</code><span class="calibre3"> means “zero or more”, we end up with a pattern where we repeat a pattern: the first copy peels off the first instance, while the second, followed by a </span><code>…</code><span class="c4">, captures all the remaining instances:</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax my-cond
  (syntax-rules ()
    [(my-cond) (error 'my-cond "should not get here")]
    [(my-cond [q0 a0] [q1 a1] ...)
     (if q0
         a0
         (my-cond [q1 a1] ...))]))</pre><p class="c3"><span class="c41"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Examine this code in detail. Try out the example above. It’s </span><span class="c7">essential</span><span class="c4"> that you run this through the Macro Stepper: you’ll learn a lot about macros from this example!</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c29" id="h.j3al6cmtfmmc"><span class="c4"/></h1><h1 class="c30" id="h.9yyfge80lw9s"><span class="c4">More on Macros</span></h1><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Note:</span><span class="calibre3"> All the examples from this chapter you can find in a video on YouTube, so if you prefer, you can watch that instead: </span><span class="c71"><a class="c11" href="https://www.google.com/url?q=https://youtu.be/2FK6jpAcX9Q&amp;sa=D&amp;source=editors&amp;ust=1695232021251280&amp;usg=AOvVaw2wCzzJcOXLR7zXUAetXhxF">More on Macros</a></span><span class="c4">. Be sure to stop and reflect after each example, and try each of them out for yourself!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s start to look at various idiomatic aspects of using Racket macros. We’ll want this understanding under our belt because we’ll make use of several of these features. Here are five concrete things we’ll see:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre3"><span class="c4">A convenience in definitions</span></li><li class="c25 pcalibre3"><span class="c4">A major and critical macro feature</span></li><li class="c25 pcalibre3"><span class="c4">An important idiom in truthy/falsy languages</span></li><li class="c25 pcalibre3"><span class="c4">A peril in macro definitions</span></li><li class="c25 pcalibre3"><span class="c4">A push to generalize definitions</span></li></ul>

<h2 class="c27" id="h.vlhe78g1luap"><span class="c4">A Definitional Convenience</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Supposing we want to define a “one-armed </span><code>if</code><span class="calibre3">” (e.g., useful for checking erroneous conditions and proceeding only if the coast is clear): this is commonly called </span><code>unless</code><span class="calibre3">. We can write it this way:</span></p><p class="c3"><span class="c72"/></p><pre>(define-syntax unless
  (syntax-rules ()
    [(_ cond body ...)
     (if (not cond)
         (begin
           body
           ...)
         (void))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">For instance, we can use it this way:</span></p><p class="c3"><span class="c4"/></p><pre>(unless false
  (println 1)
  (println 2))</pre><p class="c3"><span class="c72"/></p><p class="c5"><span class="c4">Notice that in the pattern, we don’t have to repeat the `unless`; we can just use an `_` instead.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> The full truth is, this isn’t just a </span><span class="c7">convenience</span><span class="calibre3">. They actually do slightly different things that you can detect in subtle situations. You can safely, and should, just use </span><code>_</code><span class="c4"> instead of repeating the name of the macro.</span></p>

<h2 class="c27" id="h.e0xxnn77cgxc"><span class="c4">Name Capture</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But now, what if we use the above code in this kind of context:</span></p><p class="c3"><span class="c72"/></p><pre>(let ([not (λ (v) v)])
  (unless false
    (println 1)
    (println 2)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This seems problematic: it seems to expand into</span></p><p class="c3"><span class="c4"/></p><pre>(let ([not (λ (v) v)])
  (if (not false)
      (begin
        (println 1)
        (println 2))
      (void)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">which is pretty much the opposite of what we want. That’s because the </span><code>not</code><span class="calibre3"> outside the macro seems to have captured the </span><code>not</code><span class="c4"> inside the macro. This is roughly analogous to dynamic scope: any use context can modify what happens inside the abstraction. If this were true, it would be terrifying to be a macro writer!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> Run both versions. Do they produce the same answer?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But running the macro version makes clear that the name </span><code>not</code><span class="calibre3"> is </span><span class="c7">not</span><span class="calibre3"> being captured. Most of all, use the Macro Stepper to see how the expansion works. The important thing is that variables are more than just </span><span class="c7">names</span><span class="c4">; they record binding information, which keeps names introduced in different settings separate. They may print the same way, but internally Racket keeps them separate (and shows this separation in the Macro Stepper using colors). That is, it’s as if we start with this program:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c73">(let ([not (λ (v) v)])</span></p><p class="c5"><span class="c73">  (unless false</span></p><p class="c5"><span class="c73">    (println 1)</span></p><p class="c5"><span class="c74">    (println 2)))</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">which, after expansion, turns into this program:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c73">(let ([not (λ (v) v)])</span></p><p class="c5"><code>  </code><span class="c75">(if (not false)</span></p><p class="c5"><span class="c75">      (begin</span></p><p class="c5"><span class="c75">        (println 1)</span></p><p class="c5"><span class="c75">        (println 2))</span></p><p class="c5"><span class="c76">      (void))</span><span class="c73">)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">So now we can easily keep the identifiers apart: the red </span><span class="c74">not</span><span class="calibre3"> is different from the blue </span><span class="c76">not</span><span class="calibre3">. The actual internal representation is an efficient analog to colors. If necessary, the macro expander can also use distinct </span><span class="c7">fresh</span><span class="calibre3"> (i.e., previously unused) names—</span><code>not1</code><span class="calibre3">, </span><code>not2</code><span class="c4">, etc.—to represent the different variables of the same name.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This property, which recovers an analog of static scoping for macros, and is called </span><span class="c7">hygiene</span><span class="calibre3">. Hygiene is a critical feature for macros (and, notably, is one </span><span class="c7">not</span><span class="c4"> given by the C pre-processor). It lets programmers use whatever name they want in the macro definition without worrying about what names will be bound in the use context; and similarly, lets users use whatever variable names they want without worrying about the macro’s code.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That said, you may wonder whether hygiene is just for built-in functions like </span><code>not</code><span class="c4">. We’ll see that it’s not. But to get there, we’ll work through some other idiomatic examples.</span></p>

<h2 class="c27" id="h.sfk1bknlljs8"><span class="c4">A Truthy/Falsy Idiom</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Unrelated to macros, here’s something we often see in truthy/falsy languages. Consider a two-arm </span><code>or</code><span class="calibre3">, which we can define as a macro:</span></p><p class="c3"><span class="c72"/></p><pre>(define-syntax or-2
  (syntax-rules ()
    [(_ e1 e2)
     (if e1
         true
         e2)]))</pre><p class="c3"><span class="c72"/></p><p class="c5"><span class="c4">This works well enough for</span></p><p class="c3"><span class="c72"/></p><pre>(or-2 true false)
(or-2 false false)
(or-2 false true)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">However, consider a function like </span><code>member</code><span class="c4">:</span></p><p class="c3"><span class="c72"/></p><pre>(member 'y '(x y z))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">When it succeeds, it doesn’t just return </span><code>true</code><span class="calibre3">, it returns the entire rest of the list (which is a truthy value). But if we combine this with </span><code>or-2</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(or-2 (member 'y '(x y z)) "not found")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This is clearly not the result we want: we’ve lost the useful return value. Instead, here’s a different macro that returns rather than suppressing that result:</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax or-2
  (syntax-rules ()
    [(_ e1 e2)
     (if e1
         e1
         e2)]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This makes</span></p><p class="c3"><span class="c4"/></p><pre>(or-2 (member 'y '(x y z)) "not found")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">work as expected. </span></p>

<h2 class="c27" id="h.g95sgdh0td7p"><span class="c4">A Macro Definition Peril</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">However, this macro contains a subtle (almost hidden), important peril. Consider this example:</span></p><p class="c3"><span class="c4"/></p><pre>(or-2 (print "hello") "not found")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That also returns a truthy value, but now we see the print </span><span class="c7">twice</span><span class="c4">. So we need</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax or-2
  (syntax-rules ()
    [(_ e1 e2)
     (let ([v e1])
       (if v v e2))]))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Confirm that this produces the correct answer.</span></p>

<h2 class="c27" id="h.7hw3astg7q9x"><span class="c4">Back to Hygiene</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This now works fine for the printing example. But now we have to worry about</span></p><p class="c3"><span class="c4"/></p><pre>(let ([v 1])
  (or-2 false v))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Using fresh names, there are two things this could expand into:</span></p><p class="c3"><span class="c4"/></p><pre>(let ([v 1])
  (let ([v false])
    (if v
        v
        v)))</pre><p class="c3"><span class="c4"/></p><pre>(let ([v0 1])
  (let ([v1 false])
    (if v1
        v1
        v0)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Which does the macro version produce? That’s right, the latter: the one corresponding to</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c73">(let ([v 1])</span></p><p class="c5"><code>  </code><span class="c75">(let ([v false])</span></p><p class="c5"><span class="c75">    (if v</span></p><p class="c5"><span class="c75">        v</span></p><p class="c5"><span class="c76">        </span><span class="c74">v</span><span class="c76">))</span><span class="c73">)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In other words, hygiene works just as well for local variables, not just for built-in functions! In other words, we have spent a whole bunch of time on something you </span><span class="c7">don’t</span><span class="c4"> need to worry about. In return, it means you can use names with impunity in your macro programs, just as you do inside functions and methods because of static scoping.</span></p>

<h2 class="c27" id="h.vji0kba4jcxk"><span class="c4">Generalizing Macros</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Finally, unlike the poor programmers stuck with their infix syntaxes and binary operators, parenthetical syntax programmers can generalize constructs to arbitrary arity. We’ve seen </span><code>…</code><span class="calibre3"> already; let’s put it to work here to create an </span><span class="c7">n</span><span class="calibre3">-ary </span><code>or</code><span class="c4">. A natural first definition is</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax orN
  (syntax-rules ()
    [(_ e1 e2 ...)
     (let ([v e1])
       (if v v (orN e2 ...)))]))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> However,  see what happens when we try:</span></p><p class="c51"><span class="c4"/></p><pre>(let ([v true])
  (orN false v))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, so that doesn’t work. It’s important to pay attention to the error message:</span></p><p class="c3"><span class="c72"/></p><p class="c5"><span class="c78">orN: bad syntax in: (orN)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This highlights the need for a base case. The problem is our definition above requires one or more sub-expressions: </span><code>e1</code><span class="calibre3"> is the first, and </span><code>e2 …</code><span class="calibre3"> means </span><span class="c7">zero or more</span><span class="c4"> from the second position onward. But nothing covers the case of no sub-terms. So we need</span></p><p class="c3"><span class="c4"/></p><pre>(define-syntax orN
  (syntax-rules ()
    [(_) false]
    [(_ e1 e2 ...)
     (let ([v e1])
       (if v v (orN e2 ...)))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and of course this works fine.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c40">Exercise: </span><span class="calibre3">The problem above appears to have been self-inflicted: why did we start with the pattern </span><code>(_ e1 e2 ...)</code><span class="calibre3">, which requires one-or-more (</span><code>e1</code><span class="calibre3"> is the first, </span><code>e2 …</code><span class="calibre3"> is zero or more)? We should have just written </span><code>(_ e...)</code><span class="calibre3"> instead, which would be zero-or-more! Rewrite the </span><code>orN</code><span class="c4"> macro using this pattern: can you make it work?</span></p>

<h1 class="c29" id="h.pfey3y2bcobm"><span class="c4"/></h1><h1 class="c35" id="h.25npr165inek"><span class="c4">••••• Objects •••••</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c32">Objects—the bundling of data with operations over them—are a generalization of closures. Many languages have objects, but in a variety of different forms.</span></p>

<h1 class="c22" id="h.d119ko5rrsdg"><span class="c4">A Standard Model of Objects</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now we’re ready to start looking at our first major language feature that goes beyond SMoL: objects. Not all SMoL languages have objects; though many do, they have them in very different ways. Nevertheless, what we will see is that there is a fairly uniform way to think about objects across all these languages, and furthermore this way of thinking really builds on our understanding of SMoL.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">When building the essence of objects, though, we now have a choice: we can do it either in the core or through syntactic sugar. The former is frustrating in several ways:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">We have to do more low-level bookkeeping (e.g., with environments) that may not necessarily be </span><span class="c7">instructive</span><span class="c4">.</span></li><li class="c25 pcalibre"><span class="c4">The interpreter gets larger and more unwieldy, because all the new constructs go in the same place rather than each being independent definitions.</span></li><li class="c25 pcalibre"><span class="c4">Most of all: it becomes a lot harder to write illustrative programs and tests, because the core language may not have all the features we need to make this convenient.</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In contrast, all these problems go away if we use syntactic sugar instead. Therefore, even though a real implementation may well have at least parts of objects (especially the parts needed for efficiency) in the core language, we are going to build objects entirely through desugaring, using macros. In fact, in this book, we will do something even simpler: we will give </span><span class="c7">concrete examples </span><span class="calibre3">of what programs desugar </span><span class="c7">to</span><span class="c4">. Figuring out the general desugaring will be left as an exercise for you. To aid in that process, we will write code in as stylized a form as possible, not using any short-cuts that might obscure the macro rules.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Note:</span><span class="calibre3"> The programs in this section cannot be written in the language </span><code>plait</code><span class="calibre3">. Instead, we will use  </span><code>#lang racket</code><span class="c4">, which does not perform static type-checking. Add the line</span></p><p class="c51"><span class="c4"/></p><pre>(require [only-in plait test print-only-errors])</pre><p class="c51"><span class="c4"/></p><p class="c31"><span class="calibre3">at the top to access the testing operator and printing control parameter from </span><code>plait</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Spot the point at which the type-checker would become problematic. </span><span class="c40">Hint:</span><span class="calibre3"> The easiest way is, of course, to keep using </span><code>#lang plait</code><span class="c4"> until you run into a problem. Make sure you understand what the problem is!</span></p>

<h2 class="c27" id="h.k8d10uqtunn0"><span class="c4">What is an Object?</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The central question we must answer, before we start thinking about implementations, is what an object is. There is a lot of variation between languages, but they all seem to agree that an object is</span></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">a value, that</span></li><li class="c25 pcalibre"><span class="c4">maps names to </span></li><li class="c25 pcalibre"><span class="c4">stuff: either other values or “methods”.</span></li></ul><p class="c5"><span class="c4">From a minimalist perspective, methods seem to be just functions, and since we already have those in the language, we can put aside this distinction.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> We will use the term </span><span class="c7">member</span><span class="c4"> to refer to a generic entry in an object, when we don’t want to make a distinction between fields and methods.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">How can we capture this? An object is just a value that dispatches on a given name. For simplicity, we’ll use </span><code>lambda</code><span class="calibre3"> to represent the object and Racket’s </span><code>case</code><span class="c4"> construct to implement the dispatching. Here’s an object that responds to either add1 or sub1, and in each case returns a function that either increments or decrements:</span></p><p class="c3"><span class="c4"/></p><pre>(define o
  (lambda (m)
    (case m
      [(add1) (lambda (x) (+ x 1))]
      [(sub1) (lambda (x) (- x 1))])))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We would use this as follows:</span></p><p class="c3"><span class="c4"/></p><pre>(test ((o 'add1) 5) 6)</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Observe that basic objects are a generalization of </span><code>lambda</code><span class="calibre3"> to have multiple “entry-points”. Conversely, a </span><code>lambda</code><span class="calibre3"> is an object with only </span><span class="c7">one</span><span class="c4"> entry-point; therefore, it doesn’t need a “method name” to disambiguate.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Of course, writing method invocations with these nested function calls is unwieldy (and is about to become even more so), so we’d be best off equipping ourselves with a convenient syntax for invoking methods:</span></p><p class="c3"><span class="c4"/></p><pre>(define (msg o m . a)
  (apply (o m) a))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This enables us to rewrite our test:</span></p><p class="c3"><span class="c4"/></p><pre>(test (msg o 'add1 5) 6)</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> We’ve taken advantage of Racket’s variable-arity syntax: </span><code>. a</code><span class="calibre3"> says “bind all the remaining—zero or more—arguments to a list named </span><code>a</code><span class="calibre3">”. The </span><code>apply</code><span class="c4"> function “splices” in such lists of arguments to call functions.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe something very subtle about our language: nothing precludes us from writing an arbitrary expression in the second position of a call to </span><code>msg</code><span class="calibre3">. That is, we can </span><span class="c7">compute</span><span class="c4"> which member we want to access. For instance:</span></p><p class="c3"><span class="c4"/></p><pre>(test (msg o (first '(add1)) 5) 6)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This is unlike many languages with objects, which force you to write the literal </span><span class="c7">name</span><span class="c4"> of the member (e.g., in Java, in most cases). We’ll return to this later!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This is a general problem with desugaring: the target language may allow expressions that have no counterpart in the source, and hence cannot be mapped back to it. Fortunately we don’t often need to perform this inverse mapping, though it does arise in some debugging and program comprehension tools. More subtly, however, we must ensure that the target language does not produce </span><span class="c7">values</span><span class="c4"> that have no corresponding equivalent in the source.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now that we have basic objects, let’s start adding the kinds of features we’ve come to expect from most object systems.</span></p>

<h2 class="c27" id="h.zeynmcaiww0s"><span class="c4">The “Object” Pattern</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can consolidate what we have written above as the “object” pattern: code that looks like</span></p><p class="c3"><span class="c4"/></p><pre>  (lambda (m)
    (case m
      … dispatch on each of the members …))</pre>

<h2 class="c27" id="h.cyirf2k5pbmi"><span class="c4">Constructors</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">A constructor is simply a function that is invoked at object construction time. We currently lack such a feature, but by turning an object from a literal into a function that takes constructor parameters, we achieve this effect:</span></p><p class="c3"><span class="c4"/></p><pre>(define (o-constr x)
  (lambda (m)
    (case m
      [(addX) (lambda (y) (+ x y))])))
 
(test (msg (o-constr 5) 'addX 3) 8)
(test (msg (o-constr 2) 'addX 3) 5)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In the first example, we pass 5 as the constructor’s argument, so adding 3 yields 8. The second is similar, and shows that the two invocations of the constructors don’t interfere with one another (just as we would expect from static scope).</span></p>

<h2 class="c27" id="h.cto9sgoo2s2n"><span class="c4">The “Class” Pattern</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We’ve actually made quite a momentous change with this small addition: we’ve gone from objects to functions-that-make-objects (notice the object pattern inside the function). But traditionally, what makes objects? Classes! And classes typically have constructors. So in the process of introducing constructors, we have actually also shifted from objects to classes. The “class” pattern, at its simplest, is:</span></p><p class="c3"><span class="c4"/></p><pre>(define (class constructor-params)
  … the object pattern …)</pre>

<h2 class="c27" id="h.3jmxv1l9d9nw"><span class="c4">State</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Many people believe that objects primarily exist to encapsulate state.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Curiously, Alan Kay, who won a Turing Award for inventing Smalltalk and modern object technology, disagrees. In </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://worrydream.com/EarlyHistoryOfSmalltalk/&amp;sa=D&amp;source=editors&amp;ust=1695232021277736&amp;usg=AOvVaw2Jq9XZtuuo6438N_xh50ZK">The Early History of Smalltalk</a></span><span class="c4">, he says, “[t]he small scale [motivation for OOP] was to find a more flexible version of assignment, and then to try to eliminate it altogether”. He adds, “It is unfortunate that much of what is called ‘object-oriented programming’ today is simply old style programming with fancier constructs. Many programs are loaded with ‘assignment-style’ operations now done by more expensive attached procedures.”</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We certainly haven’t lost that ability. If we desugar to a language with variables, we can easily have multiple methods mutate common state, such as a constructor argument:</span></p><p class="c3"><span class="c4"/></p><pre>(define (mk-o-state count)
  (lambda (m)
    (case m
      [(inc) (lambda () (set! count (+ count 1)))]
      [(dec) (lambda () (set! count (- count 1)))]
      [(get) (lambda () count)])))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We have changed the name to </span><code>mk-o-…</code><span class="calibre3"> to reflect the fact that this is an object-</span><span class="c7">maker</span><span class="c4">, i.e., analogous to a class. For instance, we can test a sequence of operations:</span></p><p class="c3"><span class="c4"/></p><pre>(test (let ([o (mk-o-state 5)])
        (begin (msg o 'inc)
                   (msg o 'inc)
               (msg o 'dec)
               (msg o 'get)))
      6)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and also notice that mutating one object doesn’t affect another:</span></p><p class="c3"><span class="c4"/></p><pre>(test (let ([o1 (mk-o-state 3)]
            [o2 (mk-o-state 3)])
        (begin (msg o1 'inc)
               (msg o1 'inc)
               (+ (msg o1 'get)
                  (msg o2 'get))))
      (+ 5 3))</pre>

<h2 class="c27" id="h.lylyl0eajnve"><span class="c4">Private Members</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Another common object language feature is private members: ones that are visible only inside the object, not outside it.  </span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> Except that, in Java, instances of other classes of the same type are privy to “private” members. Otherwise, you would simply never be able to implement an Abstract Data Type. Note that classes are not Abstract Data Types!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">These may seem like an additional feature we need to implement, but we already have the necessary mechanism in the form of locally-scoped, lexically-bound variables:</span></p><p class="c3"><span class="c4"/></p><pre>(define (mk-o-state/priv init)
  (let ([count init])
    (lambda (m)
      (case m
        [(inc) (lambda () (set! count (+ count 1)))]
        [(dec) (lambda () (set! count (- count 1)))]
        [(get) (lambda () count)]))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The code above uses lexical scoping to ensure that </span><code>count</code><span class="calibre3"> remains hidden to the world. Trying to access </span><code>count</code><span class="c4"> directly from the outside will fail.</span></p>

<h2 class="c27" id="h.a0ymvc6n5zri"><span class="c4">A Refined “Class” Pattern</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">With this change, we can now refine our pattern for classes:</span></p><p class="c3"><span class="c4"/></p><pre>(define (class-w/-private constructor-params)
  (let ([private-vars …] …)
    … the object pattern …))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">which we can also write as:</span></p><p class="c3"><span class="c4"/></p><pre>(define class-w/-private
  (lambda (constructor-params)
    (let ([private-vars …] …)
      … the object pattern …)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We’ll see in a moment why we might want to do this.</span></p>

<h2 class="c27" id="h.hg5aqh9ojfl1"><span class="c4">Static Members</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Another feature often valuable to users of objects is static members: those that are common to all instances of the same type of object. This, however, is merely a lexically-scoped identifier (making it private) that lives outside the constructor (making it common to all uses of the constructor).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Suppose we want to keep a count of how many instances of a kind of object are created. This count cannot be inside any one of those objects, because they would not “know” about each other; rather, the constructor needs to keep track of this. This is the role of static members, and the variable </span><code>counter</code><span class="c4"> plays this role in the following example:</span></p><p class="c3"><span class="c4"/></p><pre>(define mk-o-static
  (let ([counter 0])
    (lambda (amount)
      (begin
        (set! counter (+ 1 counter))
        (lambda (m)
          (case m
            [(inc) (lambda (n) (set! amount (+ amount n)))]
            [(dec) (lambda (n) (set! amount (- amount n)))]
            [(get) (lambda () amount)]
            [(count) (lambda () counter)]))))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We’ve written the counter increment where the “constructor” for this object would go, though it could just as well be manipulated inside the methods.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To test it, we should make multiple objects and ensure they each affect the global count:</span></p><p class="c3"><span class="c4"/></p><pre>(test (let ([o (mk-o-static 1000)])
        (msg o 'count))
      1)
 
(test (let ([o (mk-o-static 0)])
        (msg o 'count))
      2)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">It is productive to see how this program runs through the Stacker. For simplicity, we can ignore most of the details and focus just on the core static pattern. Here is a Stacker-friendly translation:</span></p><p class="c3"><span class="c4"/></p><pre>#lang stacker/smol/hof</pre><p class="c3"><span class="c41"/></p><pre>(defvar mk-o-static
  (let ([counter 0])
    (lambda (amount)
      (begin
        (set! counter (+ 1 counter))
        (lambda (m)
          (if (equal? m "get")
              (lambda () amount)
              (if (equal? m "count")
                  counter
                  (error "no such member"))))))))</pre><p class="c3"><span class="c41"/></p><pre>(defvar o1 (mk-o-static 1000))
(defvar o2 (mk-o-static 0))
(o1 "count")
(o2 "count")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Run this and see how the static member works!</span></p>

<h2 class="c27" id="h.547ckr5uiev8"><span class="c4">A Re-Refined “Class” Pattern</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now we can refine our pattern for classes even further:</span></p><p class="c3"><span class="c4"/></p><pre>(define class-w/-private&amp;static
  (let ([static-vars …] …)
    (lambda (constructor-params)
      (let ([private-vars …] …)
        … the object pattern …))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Put differently:</span></p><p class="c3"><span class="c4"/></p><pre>(define class-w/-private&amp;static
  (let ([static-vars …] …)
    … the class-w/-private pattern …))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="calibre3">Statics, as defined here, are accessed through </span><span class="c7">objects</span><span class="calibre3">. However, statics by definition belong to a </span><span class="c7">class</span><span class="calibre3">, not to objects, and hence should be accessible through the class itself—for instance, even if no instances of the class have ever been created. (In the working example above, one should be able to access the count when it is still </span><code>0</code><span class="calibre3">.) Modify the pattern above to respect this by making static members be accessible directly through the </span><span class="c7">class</span><span class="c4"> rather than through objects.</span></p>

<h2 class="c27" id="h.5e60w47v68ti"><span class="c4">Objects with Self Reference</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Until now, our objects have simply been packages of named functions: functions with multiple named entry-points, if you will. We’ve seen that many of the features considered important in object systems are actually simple patterns over functions and scope, and have indeed been used—without names assigned to them—for decades by programmers armed with lambdas.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What this means is that the different members are actually independent of each other: they can’t, for instance, directly reference one another. This is too limiting for a true object system, where a method has a way of referencing the object it is part of so that it can use other members of that object. To enable this, many object systems automatically equip each object with a reference to itself, often called </span><code>self</code><span class="calibre3"> or </span><code>this</code><span class="c4">. Can we implement this?</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside</span><span class="c4">: I prefer this slightly dry way of putting it to the anthropomorphic “knows about itself” terminology often adopted by object advocates. Indeed, note that we have gotten this far into object system properties without ever needing to resort to anthropomorphism. </span></p><h3 class="c79" id="h.weagppgxo8s8"><span class="c80">Self-Reference Using Mutation</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Yes, we can! This relies on a pattern that sets up the name for the recursive reference, then uses that to create the body that will employ the recursion, and finally uses mutation to make the name refer to the defined body. For simplicity, we will go back to the</span><span class="c7"> object</span><span class="c4"> pattern, ignoring the class-related features:</span></p><p class="c3"><span class="c4"/></p><pre>(define o-self!
  (let ([self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(first) (lambda (x) (msg self 'second (+ x 1)))]
                [(second) (lambda (x) (+ x 1))])))
      self)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We can test it by having </span><code>first</code><span class="calibre3"> invoke </span><code>second</code><span class="c4">. Sure enough, this produces the expected answer:</span></p><p class="c3"><span class="c4"/></p><pre>(test (msg o-self! 'first 5) 7)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Here is the above program translated into the simpler smol/fun language. Once translated, we can run it in the Stacker:</span></p><p class="c3"><span class="c4"/></p><pre>#lang stacker/smol/hof</pre><p class="c3"><span class="c41"/></p><pre>(defvar o-self!
  (let ([self 0])
    (begin
      (set! self
            (lambda (m)
              (if (equal? m "first")
                  (lambda (x) ((self "second") (+ x 1)))
                  (if (equal? m "second")
                      (lambda (x) (+ x 1))
                      (error "no such member")))))
      self)))</pre><p class="c3"><span class="c41"/></p><pre>((o-self! "first") 5)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Run it for yourself! What do you learn from it? Do you see how </span><code>self</code><span class="c4"> works?</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> This change to the object pattern is essentially </span><span class="c7">independent</span><span class="c4"> of the class pattern. Extend the class pattern to include self-reference.</span></p><h3 class="c79" id="h.uh01s2uf032m"><span class="c80">Self-Reference Without Mutation</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">There’s another pattern we can use that avoids mutation, which is to send the object itself as a parameter:</span></p><p class="c3"><span class="c4"/></p><pre>(define o-self-no!
  (lambda (m)
    (case m
      [(first) (lambda (self x) (msg/self self 'second (+ x 1)))]
      [(second) (lambda (self x) (+ x 1))])))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Each method now takes </span><code>self</code><span class="c4"> as an argument. That means method invocation must be modified to follow this new pattern:</span></p><p class="c3"><span class="c4"/></p><pre>(define (msg/self o m . a)
  (apply (o m) o a))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, when invoking a method on </span><code>o</code><span class="calibre3">, we must pass </span><code>o</code><span class="c4"> as a parameter to the method. Notice that we did not do any such thing when invoking a function! This distinguishes functions and methods.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Obviously, this approach is dangerous because we can potentially pass a different object as the “self”. Exposing this to the developer is therefore probably a bad idea; if this implementation technique is used, it should only be done in desugaring. (Unfortunately, Python exposes exactly this in its surface syntax.) Sure enough:</span></p><p class="c3"><span class="c4"/></p><pre>(test (msg/self o-self-no! 'first 5) 7)</pre>

<h2 class="c27" id="h.bs96alxhw7on"><span class="c4">Dynamic Dispatch</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Finally, we should make sure our objects can handle a characteristic attribute of object systems, which is the ability to invoke a method without the caller having to know or decide which object will handle the invocation.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Suppose we have a binary tree data structure, where a tree consists of either empty nodes or leaves that hold a value. In traditional functions, we are forced to implement some form of conditional—such as a </span><code>type-case</code><span class="c4">—that exhaustively lists and selects between the different kinds of trees. If the definition of a tree grows to include new kinds of trees, each of these code fragments must be modified.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Dynamic dispatch solves this problem by making that conditional branch disappear from the user’s program and instead be handled by the method selection code built into the language. The key feature that this provides is an extensible conditional. This is one dimension of the extensibility that objects provide.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s first define our two kinds of tree objects:</span></p><p class="c3"><span class="c4"/></p><pre>(define (mt)
  (let ([self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(sum) (lambda () 0)])))
      self)))</pre><p class="c5"><span class="c4"> </span></p><pre>(define (node v l r)
  (let ([self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(sum) (lambda () (+ v
                                     (msg l 'sum)
                                     (msg r 'sum)))])))
      self)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">With these, we can make a concrete tree:</span></p><p class="c3"><span class="c4"/></p><pre>(define a-tree
  (node 10
        (node 5 (mt) (mt))
        (node 15 (node 6 (mt) (mt)) (mt))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">And finally, test it:</span></p><p class="c3"><span class="c4"/></p><pre>(test (msg a-tree 'sum) (+ 10 5 15 6))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that both in the test case and in the </span><code>sum</code><span class="calibre3"> method of </span><code>node</code><span class="calibre3">, there is a reference to </span><code>’sum</code><span class="calibre3"> without checking whether the recipient is a </span><code>mt</code><span class="calibre3"> or </span><code>node</code><span class="calibre3">. Instead, the </span><span class="c7">language’s run-time system</span><span class="calibre3"> extracts the recipient’s </span><code>sum</code><span class="c4"> method and invokes it. This conditional missing from the user’s program, and handled automatically by the language,  is the essence of dynamic dispatch.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">It’s worth noting that we didn’t have to change our pattern to add dynamic dispatch; </span><span class="c7">it simply followed as a result of the rest of the design</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This property—which appears to make systems more black-box extensible because one part of the system can grow without the other part needing to be modified to accommodate those changes—is often hailed as a key benefit of object-orientation. While this is indeed an advantage objects have over functions, there is a dual advantage that functions have over objects, and indeed many object programmers end up contorting their code—using the Visitor pattern—to make it look more like a function-based organization. Read </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&amp;sa=D&amp;source=editors&amp;ust=1695232021299288&amp;usg=AOvVaw3CC6NAYK9gN3UxWzQtILYg">Synthesizing Object-Oriented and Functional Design to Promote Re-Use</a></span><span class="calibre3"> for a running example that will lay out the problem in its full glory. Try to solve it in your favorite language, and see the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml&amp;sa=D&amp;source=editors&amp;ust=1695232021299768&amp;usg=AOvVaw1BZuSy7k1EJ8XRqphKUm57">Racket solution</a></span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.wvj66g8ci12r"><span class="c4">What Else do Objects Have?</span></h1><h2 class="c23" id="h.kymatxsbb8uu"><span class="c4">Member Name Design Space</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now we will focus on the names of members (a term we use to not distinguish between fields and methods). Also, let’s set aside the distinction between classes and objects for a moment: whether through classes or not, we eventually end up with objects, which programs use. So the two questions are:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">Is the set of member names statically fixed, or can it be changed dynamically?</span></li><li class="c25 pcalibre"><span class="c4">Is the member being accessed at a point statically fixed, or can it be computed dynamically?</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This gives us a 2x2 table, and it’s worthwhile to ask whether each cell makes sense (and whether we’ve seen it in any real languages). We get:</span></p><p class="c3"><span class="c4"/></p><a id="t.81bfe1e2dcf82c19ef12e895561aea23413e5af0"/><a id="t.2"/><table class="c45"><tbody class="calibre14"><tr class="c46"><td class="c81" colspan="1" rowspan="1"><p class="c52"><span class="c4"/></p></td><td class="c81" colspan="1" rowspan="1"><p class="c8"><span class="c49">Name is Static</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c8"><span class="c49">Name is Computed</span></p></td></tr><tr class="c46"><td class="c81" colspan="1" rowspan="1"><p class="c82"><span class="c49">Fixed Set of Members</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c5"><span class="c4">As in base Java.</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c5"><span class="c4">As in Java with reflection to compute the name.</span></p></td></tr><tr class="c46"><td class="c81" colspan="1" rowspan="1"><p class="c82"><span class="c49">Variable Set of Members</span></p><p class="c83"><span class="c49"/></p></td><td class="c81" colspan="1" rowspan="1"><p class="c5"><span class="c4">Difficult to envision (what use would it be?).</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c5"><span class="c4">Most “scripting” languages.</span></p></td></tr></tbody></table><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Only one case does not quite make sense: if the member being accessed must be fixed in the source program, then the set of names is pre-decided, so it doesn’t seem to make sense to be able to dynamically change the set of members (new members would not be accessible, while deleted members would cause some existing accesses might fail). All other points in this design space have, however, been explored by languages.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The lower-right quadrant corresponds closely with languages that use hash-tables to represent objects. Then the name is simply the index into the hash-table. Some languages carry this to an extreme and use the same representation even for numeric indices, thereby (for instance) conflating objects with dictionaries and even arrays. Even when the object only handles “member names”, this style of object creates significant difficulty for type-checking and is hence not automatically desirable.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Therefore, in the rest of this section, we will stick with “traditional” objects that have a fixed set of names and even static member name references (the top-left quadrant). Even then, we will find there is much, much more to study.</span></p><p class="c3"><span class="c4"/></p>

<h2 class="c27" id="h.1d8viljk9g71"><span class="c4">What (Goes In) Else?</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Until now, our case statements have not had an </span><code>else</code><span class="calibre3"> clause. One reason to do so would be if we had a variable set of members in an object, though that is probably better handled through a different representation than a conditional: a hash-table, for instance, as we’ve discussed above. In contrast, if an object’s set of members is fixed, desugaring to a conditional works well for the purpose of illustration (because it </span><span class="c7">emphasizes</span><span class="calibre3"> the fixed nature of the set of member names, which a hash table leaves open to interpretation—and also error). There is, however, another reason for an </span><code>else</code><span class="calibre3"> clause, which is to “chain” control to another, parent, object. This is called </span><span class="c7">inheritance</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s return to our model of desugared objects. To implement inheritance, the object must be given “something” to which it can delegate method invocations that it does not recognize. A great deal will depend on what that “something” is.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">One answer could be that it is simply another object:</span></p><p class="c3"><span class="c4"/></p><pre>(case m
  ...
  [else (parent-object m)])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Due to our representation of objects, this application effectively searches for the member in the parent object (and, presumably, recursively in its parents). If a member matching the name is found, it returns through this chain to the original call in </span><code>msg</code><span class="c4"> that sought the member. If none is found, the final object presumably signals a “message not found” error.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> If you know what an l-value is, then you might notice that the application </span><code>(parent-object m)</code><span class="calibre3"> is like “half a </span><code>msg</code><span class="c4">”, just like an l-value was “half a value lookup”. Is there any connection?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Let’s try this by extending our trees to implement another method, </span><code>size</code><span class="calibre3">. We’ll write an “extension” (you may be tempted to say “sub-class”, but hold off for now!) for each </span><code>node</code><span class="calibre3"> and </span><code>mt</code><span class="calibre3"> to implement the </span><code>size</code><span class="calibre3"> method. We intend these to extend the existing definitions of </span><code>node</code><span class="calibre3"> and </span><code>mt</code><span class="c4">, so we’ll use the extension pattern described above. In other words, if we previously had the rough equivalent of this Java code:</span></p><p class="c3"><span class="c4"/></p><pre>class Mt   { … Mt()          { … } sum() { … } }
class Node { … Node(v, l, r) { … } sum() { … } }</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">now we want to extend it:</span></p><p class="c3"><span class="c4"/></p><pre>class MtSize   extends Mt   { … size() { … } … }
class NodeSize extends Node { … size() { … } … }</pre><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> We’re not editing the existing definitions because that is supposed to be the whole point of object inheritance: to reuse code in a black-box fashion. This also means different parties, who do not know one another, can each extend the same base code. If they had to edit the base, first they have to find out about each other, and in addition, one might dislike the edits of the other. Inheritance is meant to sidestep these issues entirely.</span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">Relatedly, read about the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Fragile_base_class&amp;sa=D&amp;source=editors&amp;ust=1695232021308845&amp;usg=AOvVaw0jUQoyWZ_AaVZEFstRRSte">fragile base class problem</a></span><span class="c4">.</span></p>

<h2 class="c27" id="h.iaguafowwwxv"><span class="c4">A Java Excursion</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s first understand what’s going on in Java. For simplicity, let’s use a canonical “2d point” and “3d point” example. We’ll start with this class:</span></p><p class="c3"><span class="c4"/></p><pre>class Pt2 {
    Pt2(int x, int y) {
        System.out.println("Pt2 with " + x + " and " + y);
    }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can make instances of it easily enough:</span></p><p class="c3"><span class="c4"/></p><pre>class Main {
    public static void main(String[] args) {
        Pt2 p2 = new Pt2(1, 2);
    }
}</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="c4">and this prints the expected output. Now suppose we extend this class:</span></p><p class="c3"><span class="c4"/></p><pre>class Pt3 extends Pt2 {
    Pt3(int x, int y, int z) {
        System.out.println("Pt3 with " + z);
    }
}</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="c7">This won’t even compile</span><span class="calibre3">. We will get a somewhat strange-looking error. The error is because Java is expecting to make an instance of </span><code>Pt2</code><span class="calibre3"> as well, but we have not told it how to. In the absence of anything else, it invokes a “default constructor”, which takes </span><span class="c7">no</span><span class="calibre3"> parameters (because Java has no way of knowing which parameters to pass). If we modify </span><code>Pt2</code><span class="c4"> to instead be</span></p><p class="c3"><span class="c4"/></p><pre>class Pt2 {
   Pt2() {
       System.out.println("default constructor");
   }
    Pt2(int x, int y) {
        System.out.println("Pt2 with " + x + " and " + y);
    }
}</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">then we find that the program compiles and, if we change </span><code>Main</code><span class="c4"> suitably,</span></p><p class="c3"><span class="c4"/></p><pre>class Main {
  public static void main(String[] args) {
    Pt3 p3 = new Pt3(1, 2, 3);
  }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">it runs, but perhaps without the effect we were expecting. The solution, in Java terms, is to explicitly invoke the constructor of the super-class:</span></p><p class="c3"><span class="c4"/></p><pre>class Pt3 extends Pt2 {
    Pt3(int x, int y, int z) {
        System.out.println("Pt3 with " + z);
        super(x, y);
    }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">but this won’t work either: Java expects the </span><code>super</code><span class="calibre3"> invocation to be the </span><span class="c7">first</span><span class="c4"> thing in the sub-class’s constructor.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">As the error message above reveals, hidden in the constructor of the extended class is lurking something important: it tries to </span><span class="c7">create an instance</span><span class="calibre3"> of the super-class, just as if we had written </span><code>new Pt2</code><span class="calibre3">. This is entirely masked by the syntactic sugar of </span><code>super</code><span class="calibre3">. The actual </span><code>Pt2</code><span class="c4"> instance is hidden out of sight, and it takes a little effort to coax it into view.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To see it, let’s first add some instance variables:</span></p><p class="c3"><span class="c4"/></p><pre>class Pt2 {
    public int x;
    Pt2(int x, int y) {
        this.x = x - 3;
        System.out.println("Pt2 with " + x + " and " + y);
    }
}</pre><p class="c3"><span class="c41"/></p><pre>class Pt3 extends Pt2 {
    public int x;
    Pt3(int x, int y, int z) {
        super(x, y);
        this.x = x + 7;
        System.out.println("Pt3 with " + z);
    }
}</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="c4">We’ve purposely made the instance variables have values that look different from those of the parameters, so that when we try to examine them, we can tell them apart. Now let’s modify the constructor to make two objects:</span></p><p class="c3"><span class="c4"/></p><pre>class Main {
    public static void main(String[] args) {
        Pt3 p3345 = new Pt3(3, 4, 5);
        Pt3 p3678 = new Pt3(6, 7, 8);
    }
}</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="c7">Two</span><span class="calibre3"> objects…how many objects did we really make? Well, we made </span><span class="c7">at least</span><span class="c4"> two, because adding</span></p><p class="c3"><span class="c4"/></p><pre>        System.out.println(p3345.x);
        System.out.println(p3678.x);</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">to the constructor shows that there are two different objects with two different values for </span><code>x</code><span class="c4">. So far, so unsurprising.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">However, I’ve claimed that there are two more objects, of type </span><code>Pt2</code><span class="calibre3">. Can we </span><span class="c7">see</span><span class="calibre3"> them? Yes, in fact, we can. The problem is that they’re of type </span><code>Pt2</code><span class="calibre3">, and what we have are </span><code>Pt3</code><span class="calibre3"> objects. We can’t just make a </span><code>Pt2</code><span class="calibre3">, because that doesn’t reveal the </span><span class="c7">hidden</span><span class="calibre3"> </span><code>Pt2</code><span class="calibre3">. But in fact the Java type system lets us get to the </span><code>Pt2</code><span class="calibre3"> by </span><span class="c7">casting</span><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>        System.out.println(((Pt2)p3345).x);
        System.out.println(((Pt2)p3678).x);</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">And that’s how we can see that there are actually two </span><code>Pt2</code><span class="c4"> objects lurking as well!</span></p>

<h2 class="c27" id="h.r3nhok3x9moc"><span class="c4">Extending Classes</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now we have to port all this code over to our world of desugaring. Is this the constructor pattern?</span></p><p class="c3"><span class="c4"/></p><pre>(define (node/size parent-object v l r)
  ...)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">That suggests that the parent is at the “same level” as the object’s constructor fields. That seems reasonable, in that once all these parameters are given, the object is “fully defined”. However, we also still have</span></p><p class="c3"><span class="c4"/></p><pre>(define (node v l r)
  ...)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The crucial issue here is that we need to make </span><span class="c7">two</span><span class="calibre3"> objects: one of </span><code>node/size</code><span class="calibre3"> and one more of </span><code>node</code><span class="calibre3">. We could imagine a protocol where the user of </span><code>node/size</code><span class="calibre3"> constructs a </span><code>node</code><span class="calibre3"> object and passes it to </span><code>node/size</code><span class="calibre3">, but in doing so, they could make any number of mistakes. Alternatively, we can leave it to </span><code>node/size</code><span class="calibre3"> to invoke node, and keep track of the object constructed through this process. That is, </span><code>node/size</code><span class="calibre3">’s parent parameter should not be the parent </span><span class="c7">object</span><span class="calibre3"> but rather the parent object’s </span><span class="c7">maker</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><pre>(define (node/size parent-maker v l r)
  (let ([parent-object (parent-maker v l r)]
        [self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(size) (lambda () (+ 1
                                     (msg l 'size)
                                     (msg r 'size)))]
                [else (parent-object m)])))
      self)))
 
(define (mt/size parent-maker)
  (let ([parent-object (parent-maker)]
        [self 'dummy])
    (begin
      (set! self
            (lambda (m)
              (case m
                [(size) (lambda () 0)]
                [else (parent-object m)])))
      self)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Then the object constructor must remember to pass the parent-object maker on every invocation:</span></p><p class="c3"><span class="c4"/></p><pre>(define a-tree/size
  (node/size node
             10
             (node/size node 5 (mt/size mt) (mt/size mt))
             (node/size node 15
                        (node/size node 6 (mt/size mt) (mt/size mt))
                        (mt/size mt))))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Note the repeated pattern of invoking the “super” class: e.g., </span><code>(mt/size mt)</code><span class="calibre3">. We would instead want to do this just once. Essentially, this binding of </span><code>mt/size</code><span class="calibre3"> to </span><code>mt</code><span class="calibre3"> is precisely what the </span><code>extends</code><span class="c4"> clause of Java does. We could simulate that here, but later in this chapter we’ll see a much more elegant way of achieving this end while also making programming with classes much more flexible.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can confirm that both the old and new tests still work:</span></p><p class="c3"><span class="c4"/></p><pre>(test (msg a-tree/size 'sum) (+ 10 5 15 6))
(test (msg a-tree/size 'size) 4)</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Rewrite this block of code using self-application instead of mutation.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What we have done is capture the essence of a class. Each function parameterized over a parent is...well, it’s a bit tricky, really. Let’s call it a </span><span class="c7">class extension</span><span class="c4">—we’ll soon see why. A class extension corresponds to what a Java programmer defines when they write:</span></p><p class="c3"><span class="c4"/></p><pre>class NodeSize extends Node { ... }</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> So why are we going out of the way to not call it a “class”?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">When a developer invokes a Java class’s constructor, it in effect constructs objects all the way up the inheritance chain (in practice, a compiler might optimize this to require only one constructor invocation and one object allocation). These are effectively “personal” copies of the objects corresponding to the parent classes (personal, that is, up to the presence of static members). There is, however, a question of how much of these objects is visible. Java chooses that—unlike in our implementation above—only one method of a given name (and signature) remains, no matter how many there might have been on the inheritance chain, whereas every field remains in the result, and can be accessed by casting. The latter makes some sense because each field presumably has invariants governing it, so keeping them separate (and hence all present) is wise. In contrast, it is easy to imagine an implementation that also makes all the methods available, not only the ones lowest (i.e., most refined) in the inheritance hierarchy. Many scripting languages take the latter approach.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> The code above is not what we would </span><span class="c7">really</span><span class="calibre3"> want as programmers. The self-reference is to the same syntactic object, whereas it needs to refer to the most-refined object: this is known as open recursion. Modify the object representations so that self always refers to the most refined version of the object. </span><span class="c40">Hint:</span><span class="c4"> You will find the self-application method (Self-Reference Without Mutation) of recursion handy.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This demonstrates the other form of extensibility we get from traditional objects: </span><span class="c7">extensible recursion</span><span class="c4">.</span></p>

<h2 class="c27" id="h.tf6f06neiiub"><span class="c4">Extending Prototypes</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In our description above, we’ve supplied each class with a description of its parent </span><span class="c7">class</span><span class="calibre3">. Object construction then makes instances of each as it goes up the inheritance chain. There is another way to think of the parent: not as a class to be instantiated but, instead, directly as an object itself. Then all children with the same parent would observe the very same object, which means changes to it from one child object would be visible to another child. The shared parent object is known as a </span><span class="c7">prototype</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> The archetypal prototype-based language is </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=http://selflanguage.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021325680&amp;usg=AOvVaw34T7y09URpNkHh7uTLFlXk">Self</a></span><span class="c4">. Though you may have read that languages like JavaScript are “based on” Self, there is value to studying the idea from its source, especially because Self presents these ideas in their purest form.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Some language designers have argued that prototypes are more primitive than classes in that, with other basic mechanisms such as functions, one can recover classes from prototypes—but not the other way around. That is essentially what we have done above: each “class” function contains inside it an object description, so a class is an object-returning-function. Had we exposed these as two different operations and chosen to inherit directly an object, we would have something akin to prototypes.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Modify the inheritance pattern above to implement a Self-like, prototype-based language, instead of a class-based language. Because classes provide each object with distinct copies of their parent objects, a prototype-language might provide a “clone” operation to simplify creation of the operation that simulates classes atop prototypes.</span></p>

<h2 class="c27" id="h.lt01fe27ngsi"><span class="c4">Multiple Inheritance</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now you might ask, why is there only one fall-through option? It’s easy to generalize this to there being many, which leads naturally to </span><span class="c7">multiple inheritance</span><span class="c4">. In effect, we have multiple objects to which we can chain the lookup, which of course raises the question of what order in which we should do so.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">It would be bad enough if the ascendants were arranged in a tree, because even a tree does not have a canonical order of traversal: take just breadth-first and depth-first traversal, for instance (each of which has compelling uses). Worse, suppose a blob A extends B and C; but now suppose B and C each extend D. Now we have to confront this question: will there be one or two D objects in the instance of A? Having only one saves space and might interact better with our expectations, but then, will we visit this object once or twice? Visiting it twice should not make any difference, so it seems unnecessary. But visiting it once means the behavior of one of B or C might change. And so on. As a result, virtually every multiple-inheritance language is accompanied by a subtle algorithm merely to define the lookup order.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This infamous situation is called the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Multiple_inheritance&amp;sa=D&amp;source=editors&amp;ust=1695232021327121&amp;usg=AOvVaw33E5ifiPPmd1ChrRegan9z">“diamond problem”</a></span><span class="c4"> (or even, “the Deadly Diamond of Death”!). If you choose to include multiple inheritance in your language you can lose yourself for days in design decisions on this. Because it is highly unlikely you will find a canonical answer, your pain will have only begun. Multiple inheritance is only attractive until you’ve thought it through.</span></p>

<h2 class="c27" id="h.db719pow9mrl"><span class="c4">Class Extensions: Mixins and Traits</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">When we write </span><code>class</code><span class="calibre3"> in Java, what are we really defining between the opening and closing braces? It is not the entire class: that depends on the parent that it extends, and so on recursively. Rather, what we define inside the braces is a class </span><span class="c7">extension</span><span class="c4">. It only becomes a full-blown class because we also identify the parent class in the same place.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Naturally, we should ask: Why? Why not separate the act of </span><span class="c7">defining</span><span class="calibre3"> an extension from </span><span class="c7">applying</span><span class="c4"> the extension to a base class? That is, suppose instead of</span></p><p class="c3"><span class="c4"/></p><pre>class C extends B { ... }</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">we instead write:</span></p><p class="c3"><span class="c4"/></p><pre>classext E { ... }</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and separately</span></p><p class="c3"><span class="c4"/></p><pre>class C = E(B)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where </span><code>B</code><span class="c4"> is some already-defined class?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Thus far, it looks like we’ve just gone to great lengths to obtain what we had before. However, the function-application-like syntax is meant to be suggestive: we can “apply” this extension to several different base classes. Thus:</span></p><p class="c3"><span class="c4"/></p><pre>class C1 = E(B1);
class C2 = E(B2);</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and so on. What we have done by separating the definition of </span><code>E</code><span class="calibre3"> from that of the class it extends is to liberate class extensions from the tyranny of the fixed base class. We have a name for these extensions: they’re called </span><span class="c7">mixins</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Mixins make class definition more compositional. They provide many of the benefits of multiple-inheritance (reusing multiple fragments of functionality) but within the aegis of a single-inheritance language (i.e., no complicated rules about lookup order). Observe that when desugaring, it’s actually quite easy to add mixins to the language. A mixin is just a “function over classes”. Because we have already determined how to desugar classes, and our target language for desugaring also has functions, and classes desugar to expressions that can be nested inside functions, it becomes almost trivial to implement a simple model of mixins.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This is a case where the greater generality of the target language of desugaring can lead us to a </span><span class="c7">better</span><span class="c4"> construct, if we reflect it back into the source language.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In a typed language, a good design for mixins can actually improve object-oriented programming practice. Suppose we’re defining a mixin-based version of Java. If a mixin is effectively a class-to-class function, what is the “type” of this “function”? Clearly, mixins ought to use </span><span class="c7">interfaces</span><span class="calibre3"> to describe what they expect and what they provide. Java already enables (but does not require) the latter, namely classes can say what interfaces they provide. However, it does not enable the former, namely specifying its parent as an </span><span class="c7">interface</span><span class="calibre3">: a class (extension) in Java extends its parent class—with all the parent’s members visible to the extension—rather than an interface that </span><span class="c7">stands for</span><span class="calibre3"> the parent (or any </span><span class="c7">other</span><span class="c4"> class that matches that same interface). That means it obtains all of the parent’s behavior, not a specification thereof. In turn, if the parent changes, the class might break. Mixins help break this asymmetry between extension and provision.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In a mixin language, we can instead write</span></p><p class="c3"><span class="c4"/></p><pre>mixin M extends I1 implements I2 { ... }</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where </span><code>I1</code><span class="calibre3"> and </span><code>I2 </code><span class="calibre3">are interfaces. Then </span><code>M</code><span class="calibre3"> can only be applied to a class that satisfies the interface </span><code>I1</code><span class="calibre3">, and in turn the language can ensure that only members specified in</span><code> I1</code><span class="calibre3"> are visible in </span><code>M</code><span class="calibre3">. This becomes directly analogous to how a client of </span><code>M</code><span class="calibre3"> can only see what is provided by </span><code>I2</code><span class="c4">, and follows one of the important principles of good software design:</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Quote:</span><span class="calibre3"> “Program to an interface, not an implementation.” —</span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Design_Patterns&amp;sa=D&amp;source=editors&amp;ust=1695232021331399&amp;usg=AOvVaw0oLqFKll63oSL1E3kTxWev">Design Patterns</a></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In short, a mixin is a class that has been turned into a function over parent classes:</span></p><p class="c3"><span class="c4"/></p><pre>M :: I1 -&gt; I2</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">A good design for mixins can go even further. A class can only be used once in an inheritance chain, by definition (if a class eventually referred back to itself, there would be a cycle in the inheritance chain, causing potential infinite loops). In contrast, when we compose functions, we have no qualms about using the same function twice (e.g.: </span><code>(map ... (filter ... (map ...))))</code><span class="c4">. Is there value to using a mixin twice?</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> There certainly is! See sections 3 and 4 of </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/&amp;sa=D&amp;source=editors&amp;ust=1695232021332340&amp;usg=AOvVaw2wOohANSHEwTtdW3WtYZHP">Classes and Mixins</a></span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Mixins solve an important problem that arises in the design of libraries. Suppose we have a dozen different features which can be combined in different ways. How many classes should we provide? Furthermore, not all of these can be combined with each other. It is obviously impractical to generate the entire combinatorial explosion of classes. It would be better if the developer could pick and choose the features they care about, with some mechanism to prevent unreasonable combinations. This is precisely the problem that mixins solve: they provide the class extensions, which the developers can combine, in an interface-preserving way, to create just the classes they need.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Mixins are used extensively in the Racket GUI library. For instance, </span><code>color:text-mixin</code><span class="c4"> consumes basic text editor interfaces and implements the colored text editor interface. The latter is itself a basic text editor interface, so additional basic text mixins can be applied to the result.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> How does the analogous library in your favorite object-oriented language solve this same problem?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Mixins do have one limitation: they enforce a linearity of composition. This strictness is sometimes misplaced, because it puts a burden on programmers that may not be necessary. A generalization of mixins called </span><span class="c7">traits</span><span class="c4"> says that instead of extending a single mixin, we can extend a set of them. Of course, the moment we extend more than one, we must again contend with potential name-clashes. Thus traits must be equipped with mechanisms for resolving name clashes, often in the form of some name-combination algebra. Traits thus offer a nice complement to mixins, enabling programmers to choose the mechanism that best fits their needs. As a result, Racket provides both mixins and traits.</span></p><p class="c3"><span class="c4"/></p>

<h1 class="c14" id="h.7rb3ecnk20em"><span class="c4">••••• Types •••••</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c32">Types that are checked before program execution—what are known as static types—are a vital part of programming, and a growing number of languages either have them from the start or, realizing their importance, are adding them in various forms. Types are a common first step towards proving properties about programs. If you use a typed language, you write small proofs about your programs every day, whether you realize it or not.</span></p><p class="c3"><span class="c4"/></p>

<div id="h.y2j16udukz8p" style="height:0pt"/><h1 class="c29" id="h.saihi466lr2u"><span class="c4"/></h1><h1 class="c30" id="h.py7ulxhe0tpd"><span class="c4">Introduction to Types</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We’re done with objects. Why weren’t objects in SMoL?</span></p><ol class="c84" start="1"><li class="pcalibre11 c85"><span class="c4">Not all languages have them.</span></li><li class="pcalibre11 c85"><span class="c4">The ones that do have them can’t seem to agree on the details (classes versus prototypes, single- versus multiple-inheritance, classes versus traits and mixins, etc.). There’s very little “standard” there.</span></li><li class="pcalibre11 c85"><span class="c4">We can add most notions through desugaring!</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we move on to types. We will always use the term </span><span class="c7">type</span><span class="calibre3"> to refer to a </span><span class="c7">static</span><span class="c4"> check, i.e., one that can be done purely with the program source. This means types cannot refer to dynamic conditions, and may suffer from either false-positive or false-negative errors (e.g., something that is in the code but can never run in practice may still cause a type error); in return, they give us guarantees without ever having to run the program. This is important when the program is expensive to run, impossible (e.g., it depends on conditions that can’t be reproduced by the developer), or dangerous.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Types aren’t really a part of SMoL either, but not because we can add them through desugaring (which we can’t); rather, it’s for the first two reasons: many languages don’t have them, and those that do don’t often agree on their form (in large part because of their disagreement over the nature of objects). However, there are parts they </span><span class="c7">do</span><span class="c4"> (largely) agree on, which we will begin with.</span></p>

<h2 class="c27" id="h.om6g3zw9o2c"><span class="c4">A Standard Model of Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Types can be thought of as abstractions of run-time values. That is, whereas at run-time we can have a very large number of numbers and strings and images (and two Booleans), we will collapse the distinctions </span><span class="c7">within</span><span class="calibre3"> these and preserve only the distinctions </span><span class="c7">between</span><span class="c4"> them. Therefore, it is instructive to start with a basic interpreter and try to build a type checker from there:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type BinOp
  [plus])</pre><p class="c3"><span class="c41"/></p><pre>(define-type Expr
  [binE (operator : BinOp)
        (left  : Exp)
        (right : Exp)]
  [numE (value : Number)])</pre><p class="c3"><span class="c41"/></p><pre>(calc : (Exp -&gt; Number))</pre><p class="c3"><span class="c41"/></p><pre>(define (calc e)
  (type-case Exp e
    [(binE o l r)
     (type-case BinOp o
       [(plus) (+ (calc l) (calc r))])]
    [(numE v) v]))</pre><p class="c3"><span class="c41"/></p><pre>(test (calc (binE (plus) (numE 5) (numE 6))) 11)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s see what needs to happen with a type-checker. The label on the tin says “checker”: that is, the job of a type-checker is to </span><span class="c7">pass judgment</span><span class="c4"> on programs, i.e., to determine whether or not they are type-correct. Thus, a natural type (for the type checker) would be</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(tc : (Exp -&gt; </code><span class="c64">Boolean</span><code>))</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">(In practice, of course, we would want more information in case the program is not type-correct, i.e., we’d like an error diagnostic. But we’re ignoring human factors considerations here.) With this type, we can now rewrite the relevant parts of the interpreter above:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(define (</code><span class="c64">tc</span><code> e)</code></p><pre>  (type-case Exp e
    [(binE o l r)
     (type-case BinOp o</pre><p class="c5"><code>       [(plus) (</code><span class="c64">and</span><code> (</code><span class="c64">tc</span><code> l) (</code><span class="c64">tc</span><code> r))])]</code></p><p class="c5"><code>    [(numE v) </code><span class="c64">#true</span><code>]))</code></p><p class="c3"><span class="c41"/></p><p class="c5"><code>(test (</code><span class="c64">tc</span><code> (binE (plus) (numE 5) (numE 6))) </code><span class="c64">#true</span><code>)</code></p><p class="c3"><span class="c72"/></p><p class="c5"><span class="calibre3">Actually, let’s peer at this for a moment. Given a number, the type-checker returns </span><code>#true</code><span class="calibre3">. In the recursive cases, it computes the </span><code>and</code><span class="calibre3"> of type-checking the pieces. And that’s it. Since there is no way to return </span><code>#false</code><span class="calibre3">, the entire type-checker must always only return </span><code>#true</code><span class="c4">. That is, every program is type-correct.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The problem is because we have only one type, numbers, and only one operation, also on numbers, so what could possibly go wrong? We need to extend the types and operations so that there are meaningful possibilities for errors. Therefore, suppose we add a </span><code>++</code><span class="c4"> operation that concatenates strings.</span></p><p class="c3"><span class="c4"/></p><pre>(define-type BinOp</pre><p class="c5"><code>  [plus] </code><span class="c64">[++]</span><code>)</code></p><p class="c3"><span class="c41"/></p><pre>(define-type Expr
  [binE (operator : BinOp)
        (left  : Exp)
        (right : Exp)]
  [numE (value : Number)]</pre><p class="c5"><code>  </code><span class="c64">[strE (value : String)]</span><code>)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Various things break, and need to be fixed. How about this?</span></p><p class="c3"><span class="c4"/></p><pre>(define (tc e)
  (type-case Exp e
    [(binE o l r)
     (type-case BinOp o
       [(plus) (and (tc l) (tc r))]</pre><p class="c5"><code>       </code><span class="c64">[(++)   (and (tc l) (tc r))]</span><code>)]</code></p><pre>    [(numE v) #true]</pre><p class="c5"><code>    </code><span class="c64">[(strE v) #true]</span><code>))</code></p><p class="c3"><span class="c41"/></p><p class="c5"><span class="c65">(test (tc (binE (++) (strE "hello") (strE "world"))) #true)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So this looks pretty good, right?</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> This is not at all what we want! Write a test case that demonstrates that.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here are two tests that demonstrate </span><span class="c7">desirable</span><span class="c4"> behavior:</span></p><p class="c3"><span class="c4"/></p><pre>(test (tc (binE (++) (numE 5) (numE 6))) #false)
(test (tc (binE (plus) (strE "hello") (strE "world"))) #false)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The first string-concatenates two numbers, the second adds two strings. Therefore, both should be rejected by the type-checker. Yet both of them pass (i.e., the tests above fail).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What is the core problem here? It’s that, given an expression, we only know </span><span class="c7">whether</span><span class="calibre3"> its sub-expressions typed correctly, but not </span><span class="c7">what</span><span class="calibre3"> their types are.  That is insufficient to determine whether the current expression is type-correct. For instance, the </span><code>++</code><span class="c4"> operator needs to check not only whether its two sub-expressions are well-typed, but also whether they produced strings; if they did not, then the concatenation is erroneous.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What this shows is that we need the type-checker to have a richer type: it must instead be</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(tc : (Exp -&gt; </code><span class="c64">Type</span><code>))</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, the type “checker” must actually be a type </span><span class="c7">calculator</span><span class="calibre3">, i.e., it even more closely parallels the evaluator, just over the universe of abstracted values (types) rather than concrete ones. Following convention, however, we’ll continue to call it a checker, because it </span><span class="c7">also</span><span class="c4"> checks in the process of calculating types.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In the type declaration above, </span><code>Type</code><span class="calibre3"> is a new (</span><code>plait</code><span class="c4"> type) definition that records the possible types:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type Type [numT] [strT])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">With this, we can rewrite our type-“checker”:</span></p><p class="c3"><span class="c4"/></p><pre>(define (tc e)
  (type-case Exp e
    [(binE o l r)
     (type-case BinOp o
       [(plus) (if (and (numT? (tc l)) (numT? (tc r)))
                   (numT)
                   (error 'tc "not both numbers"))]
       [(++)   (if (and (strT? (tc l)) (strT? (tc r)))
                   (strT)
                   (error 'tc "not both strings"))])]
    [(numE v) (numT)]
    [(strE v) (strT)]))</pre><p class="c3"><span class="c41"/></p><pre>(test (tc (binE (plus) (numE 5) (numE 6))) (numT))
(test (tc (binE (++) (strE "hello") (strE "world"))) (strT))</pre><p class="c3"><span class="c41"/></p><pre>(test/exn (tc (binE (++) (numE 5) (numE 6))) "strings")
(test/exn (tc (binE (plus) (strE "hello") (strE "world"))) "numbers")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">There are three take-aways from this:</span></p><p class="c3"><span class="c4"/></p><ol class="c86" start="1"><li class="c87 pcalibre12"><span class="c4">The type-checker follows the same implementation schema as the interpreter: an algebraic datatype to represent the AST, and structural recursion to process it. This is the schema we’re calling SImPl.</span></li><li class="c87 pcalibre12"><span class="calibre3">A type-checker, unlike an interpreter, operates with “weak” values: note, for instance, how the </span><code>numE</code><span class="c4"> case ignores the actual numeric values. Both the strengths and weaknesses of traditional type-checking arise from this ignorance.</span></li><li class="c87 pcalibre12"><span class="calibre3">In mathematical terms, the upgrade we performed in going from a type-checker to a type-calculator was a process of strengthening the inductive hypothesis: instead of returning only a </span><code>Boolean</code><span class="calibre3">, we had to return the actual type of each expression. This may not seem like a literal strengthening; but it is inasmuch as the former </span><code>#true</code><span class="calibre3"> has been replaced by a </span><code>Type</code><span class="calibre3"> and the </span><code>#false</code><span class="c4"> by an error.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Add division to the language and type-check it.</span></p>

<h2 class="c27" id="h.bd3i224rr6yk"><span class="c4">A Concise Notation</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">As we extend our type system, it is increasingly unwieldy to write everything out as code. Instead, we will adopt a notation commonly used in the world of types (though it can also be used for interpreters and other SImPl programs). We will write terms of the form</span></p><p class="c3"><span class="c4"/></p><pre>|- e : T</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where the </span><code>e</code><span class="calibre3"> are expressions, </span><code>T</code><span class="calibre3"> are types, and </span><code>:</code><span class="calibre3"> is pronounced as “has type”: i.e., the notation above says “</span><code>e</code><span class="calibre3"> has type </span><code>T</code><span class="calibre3">”. For now we won’t pronounce </span><code>|-</code><span class="c4"> as anything at all; later, we will see that it should be read as “proves”.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">First, we can very concisely say that all numeric expressions have numeric type and all string expressions have string type:</span></p><p class="c3"><span class="c4"/></p><pre>|- n : Num
|- s : Str</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where </span><code>n</code><span class="calibre3"> stands for all the syntactic terms with the syntax of numbers, and </span><code>s</code><span class="c4"> likewise for strings. (We can think of this as an infinite number of rules, one for each number and each string. We’re in the realm of mathematics, so what’s an infinite number of rules between friends?) The former is exactly equivalent to writing</span></p><p class="c3"><span class="c4"/></p><pre>    [(numC n) (numT)]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">but much more concisely.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">When we get to Booleans, we have a choice: we can either write</span></p><p class="c3"><span class="c4"/></p><pre>|- b : Bool</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where </span><code>b</code><span class="c4"> stands for all the syntactic terms with the syntax of Booleans, or—because there are only two of them—just enumerate them explicitly:</span></p><p class="c3"><span class="c4"/></p><pre>|- true : Bool
|- false : Bool</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, so these correspond to the base cases of the type-checker. These are called </span><span class="c7">axioms</span><span class="calibre3">. Now let’s get to the </span><span class="c7">conditional</span><span class="calibre3"> cases, which are called </span><span class="c7">(typing) rules</span><span class="c4">. Remember our code for typing addition:</span></p><p class="c3"><span class="c4"/></p><pre>       [(plus) (if (and (numT? (tc l)) (numT? (tc r)))
                   (numT)
                   (error 'tc "not both numbers"))]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can write it in this notation very concisely as follows:</span></p><p class="c3"><span class="c4"/></p><pre>|- e1 : Num    |- e2 : Num
--------------------------
|- (+ e1 e2) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We read the line as “if (what’s above) then (what’s below)”, and the space as “and”. So this says: “if </span><code>e1</code><span class="calibre3"> has type </span><code>Num</code><span class="calibre3"> and </span><code>e2</code><span class="calibre3"> has type </span><code>Num</code><span class="calibre3">, then </span><code>(+ e1 e2)</code><span class="calibre3"> has type </span><code>Num</code><span class="c4">”. This is of course the exact same thing the code says, but with rather less noise.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology:</span><span class="calibre3"> The part above is called the </span><span class="c7">antecedent</span><span class="calibre3"> (that which goes before) and the part below is called the </span><span class="c7">consequent</span><span class="c4"> (that which comes after). Don’t call these the numerator and denominator!</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c29" id="h.759kfdvfe109"><span class="c4"/></h1><h1 class="c30" id="h.j0kt5t35bpug"><span class="c4">Growing Types: Division, Conditionals</span></h1><h2 class="c23" id="h.5z2pgu9d57y5"><span class="c4">Handling Division</span></h2><p class="c5"><span class="calibre3">Addition, multiplication, and subtraction are </span><span class="c7">total</span><span class="calibre3"> functions over numbers: they consume two numbers and produce one. In contrast, division is a </span><span class="c7">partial</span><span class="c4"> function: it isn’t defined when the denominator is zero. Therefore, we need a strategy for handling it. There are several available strategies:</span></p><p class="c3"><span class="c4"/></p><ol class="c88" start="1"><li class="c89 pcalibre13"><span class="calibre3">We can declare that division doesn’t </span><span class="c7">return</span><span class="calibre3"> a number but instead something else that captures its partiality, such as </span><code>(Optionof Number)</code><span class="c4">. This can work just fine. However, it means every single use of division will need to check whether it obtained a proper number or not. This can get quite onerous.</span></li><li class="c89 pcalibre13"><span class="calibre3">We can declare that division only </span><span class="c7">consumes</span><span class="calibre3"> non-zero numbers in its second argument. This is a major change to our type system, because until now we had lumped all numbers together into a single numeric type. This now affects all callers of division, who must now prove that they are not calling it on zero as the second argument. This is onerous in a different way. Observe that the type checker cannot automatically prove that a value is non-zero without error, because this is not decidable (see </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&amp;sa=D&amp;source=editors&amp;ust=1695232021350115&amp;usg=AOvVaw1sfdnpfOgVLtiDbnXxEjlG">Rice’s Theorem</a></span><span class="c4">).</span></li><li class="c89 pcalibre13"><span class="c4">We give it the same type as other binary numeric operations, and declare that the exceptional case will be handled by an exception or error. This implicitly puts the burden on the rest of the program, which must be aware of this possibility and handle it.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">For more about general strategies for handling partial functions, see</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&amp;sa=D&amp;source=editors&amp;ust=1695232021350790&amp;usg=AOvVaw1xa-O5dafyrpg45paMpzmj">https://dcic-world.org/2022-08-28/partial-domains.html</a></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Most programming languages have taken the third option above, which seems the most pragmatic. However, a growing number of languages are exploring the first two options. They get around Rice’s Theorem in the second case by trying to prove non-zero-ness and, when they cannot, putting the burden on the programmer. While this creates more effort for the programmer, it increases the program’s robustness.</span></p>

<h2 class="c27" id="h.brtolkc9ldd4"><span class="c4">Another Perspective on Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We have already seen how we can think of types as abstractions of values, and type-checking as running a program over these abstract values. As we’ll soon see, the analogy will break down a bit.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Another perspective is to think of types as a </span><span class="c7">static discipline</span><span class="calibre3">: a way of statically making judgments about programs. In a way, we have already been doing just this: it’s called </span><span class="c7">parsing</span><span class="c4">. A parser statically (i.e., before the program runs) passes judgment (i.e., decides that some programs are good and others are bad). Types can be viewed as an extension of this idea.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> In computability theory terms, parsers are usually </span><span class="c7">context-free</span><span class="calibre3">, whereas types usually reflect </span><span class="c7">context-sensitive</span><span class="calibre3"> constraints. Computability theory then helps us understand why we might separate these checks into two separate phases, and in particular why we might do one before the other. Essentially, the type-checker only needs to deal with programs that have already passed the parsing, i.e., context-free check, so it has much less complexity than if it had to do everything. We already saw this: our previous checker only consumed </span><code>Expr</code><span class="c4">s, which are produced by the parser.</span></p>

<h2 class="c27" id="h.i9owwcfqedn3"><span class="c4">From Axioms and Rules to Judgments</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">When we need to apply type rules to a program, we compose them recursively, just as the type-checker runs. Consider this program:</span></p><p class="c3"><span class="c4"/></p><pre>(+ 5 (+ 6 7))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">To decide its type, we will use our current rules [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_091.html#h.bd3i224rr6yk">👉</a></span><span class="calibre3">]. Observe that it does not fit any axiom, because the program does not match the syntax of a single number or string. Therefore, we have to use a conditional rule. We have seen only one so far, and fortunately this term does match the consequent: it requires two terms, and we have two terms, so </span><code>e1</code><span class="calibre3"> is </span><code>5</code><span class="calibre3"> and </span><code>e2</code><span class="calibre3"> is </span><code>(+ 6 7)</code><span class="c4">. Therefore, applying this conditional rule, we get:</span></p><p class="c3"><span class="c4"/></p><pre>|- 5 : Num    |- (+ 6 7) : Num
----------------------
|- (+ 5 (+ 6 7)) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So far, so good. Now let’s look at the two terms in the antecedent. The first one now actually matches to an axiom; therefore, we’ll mark that in green and can stop with that:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- 5 : Num</span><code>    |- (+ 6 7) : Num</code></p><pre>----------------------
|- (+ 5 (+ 6 7)) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4"> For the other, we have to apply the same conditional rule again:</span></p><p class="c3"><span class="c4"/></p><pre>              |- 6 : Num    |- 7 : Num
              ------------------------</pre><p class="c5"><span class="c90">|- 5 : Num</span><code>    |- (+ 6 7) : Num</code></p><pre>----------------------
|- (+ 5 (+ 6 7)) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">These new terms also match the axiom for numbers, so we can mark them also in green:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>              </code><span class="c90">|- 6 : Num</span><code>    </code><span class="c91">|- 7 : Num</span></p><pre>              ------------------------</pre><p class="c5"><span class="c90">|- 5 : Num</span><code>    |- (+ 6 7) : Num</code></p><pre>----------------------
|- (+ 5 (+ 6 7)) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Every part of the tree now terminates in an axiom. We therefore consider this program to have successfully type-checked. This tree is called a </span><span class="c7">judgment</span><span class="calibre3">, because it passes judgment on the initial term: in this case, judging it to have type-checked and to produce a value of type </span><code>Num</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Observe closely that this is the same pattern of execution we had with the type-checker! The difference is that we were able to skip the tedious details of passing and returning things, and instead simply used pattern-matching. This will save us a fair bit of work as we go forward.</span></p>

<h2 class="c27" id="h.t2g8ynrf9fu3"><span class="c4">Judgments and Errors</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s see another example, which will illustrate an important principle:</span></p><p class="c3"><span class="c4"/></p><pre>(+ 5 (+ 6 "hi"))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This proceeds analogously to the previous example. This leaves us with the following attempted judgment:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>              </code><span class="c90">|- 6 : Num</span><code>    |- "hi" : Num</code></p><pre>              ---------------------------</pre><p class="c5"><span class="c90">|- 5 : Num</span><code>    |- (+ 6 "hi") : Num</code></p><pre>-------------------------
|- (+ 5 (+ 6 "hi")) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But now we have a problem: we need to type-check</span></p><p class="c3"><span class="c4"/></p><pre>|- "hi" : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">but </span><span class="c7">we don’t have a rule that matches</span><span class="calibre3">. Therefore, we </span><span class="c7">cannot</span><span class="c4"> construct a successful tree:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>              </code><span class="c90">|- 6 : Num</span><code>    </code><span class="c92">|- "hi" : Num</span></p><pre>              ---------------------------</pre><p class="c5"><span class="c90">|- 5 : Num</span><code>    |- (+ 6 "hi") : </code></p><pre>-------------------------
|- (+ 5 (+ 6 "hi")) : </pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Remember the “if … and … then” interpretation. Because we cannot satisfy all the antecedents, we cannot prove anything about the consequents, leaving the tree incomplete.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">A type error is simply a failure to construct a judgment.</span><span class="c4"> It may not be the most satisfying user feedback, but our concern here is with a concise way of expressing ideas; going from this to an implementation is not too hard, and the user interface details can be added to the latter.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This requires some clarification. We only call it a judgment if the tree is “checked off” completely: i.e., every antecedent is generated using given rules, and all the leaves are actual axioms. In this example, we are unable to check off the tree: there is no available rule </span><span class="c7">or</span><span class="calibre3"> axiom that lets us conclude that </span><code>"hi"</code><span class="calibre3"> is a </span><code>Num</code><span class="calibre3">. Therefore, we cannot “judge” the initial expression. This is a technical meaning of the word </span><span class="c7">judgment</span><span class="c4">, not to be confused with potentially colloquial interpretations of the term.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Similarly, imagine that we started with this program:</span></p><p class="c3"><span class="c4"/></p><pre>(+ 5 (- 6 7))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We would get this far:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- 5 : Num</span><code>    </code><span class="c92">|- (- 6 7) : Num</span></p><pre>----------------------
|- (+ 5 (- 6 7)) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Again we would fail, this time because we haven’t provided a (conditional) rule for </span><code>(- e1 e2)</code><span class="c4">. Obviously it’s not difficult to define one; we just haven’t done so yet, so our pattern-matcher would fail.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Construct the conditional rule for </span><code>++</code><span class="c4"> (string concatenation). Compare it to the code in the type-checker.</span></p>

<h2 class="c27" id="h.d70s6cjh8dnk"><span class="c4">Typing Conditionals</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we’re ready to add a rule for </span><code>if</code><span class="c4">. As we have seen, different languages have different rules for what can go in the conditional clause. Since the goal of a type-checker is to catch type errors, it is common for languages with type-checkers to demand that the conditional be a Boolean (without a truthy/falsy set of Boolean values). Our goal here is not to make a value judgment but rather to illustrate how we would add a type rule for it.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">By now, we can see that we will need a conditional rule (because we want to type-check more than just constants); following SImPl, and we will need the antecedent to say something about the sub-expressions. Clearly, we need at least:</span></p><p class="c3"><span class="c4"/></p><pre>|- C : Bool    …
------------------
|- (if C T E) : …</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, what now? What is the type of the entire conditional expression? Technically, it should be whatever type is returned by the branch that was executed. However, a type-checker can’t know which branch will be executed; over time, both might. So we have to somehow capture the </span><span class="c7">uncertainty</span><span class="c4"> in this situation. There are two common solutions:</span></p><p class="c3"><span class="c4"/></p><ol class="c93" start="1"><li class="c94 pcalibre14"><span class="calibre3">Introduce a new kind of type that stands for “this type </span><span class="c7">or</span><span class="calibre3"> that type” (a </span><span class="c7">union</span><span class="c4">). This is easy to introduce but creates a burden for every piece of code that will consume such a value.</span></li><li class="c94 pcalibre14"><span class="c4">Just rule that both branches should have the same type.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The latter is a very elegant solution, because it eliminates the uncertainty entirely.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Okay, so we need to do the following things:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">Compute the type of T.</span></li><li class="c25 pcalibre"><span class="c4">Compute the type of E.</span></li><li class="c25 pcalibre"><span class="c4">Make sure T and E have the same type.</span></li><li class="c25 pcalibre"><span class="c4">Make this (same) type the result of the conditional.</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">That seems like a lot: how will we express all that? Very easily, actually:</span></p><p class="c3"><span class="c4"/></p><pre>|- C : Bool    |- T : U    |- E : U
-----------------------------------
|- (if C T E) : U</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here, </span><code>U</code><span class="calibre3"> is a placeholder: it isn’t a concrete type but rather </span><span class="c7">stands for</span><span class="calibre3"> whatever type might go in that place. The repeated use of </span><code>U</code><span class="calibre3"> accomplishes all of our goals above. Read this as: “if </span><code>C </code><span class="calibre3">has type </span><code>Bool</code><span class="calibre3"> and </span><code>T</code><span class="calibre3"> has type </span><code>U</code><span class="calibre3"> and </span><code>E</code><span class="calibre3"> has [</span><span class="c7">the </span><span class="c95">same</span><span class="calibre3">] type </span><code>U</code><span class="calibre3">, then </span><code>(if C T E)</code><span class="calibre3"> has [the same] type </span><code>U</code><span class="c4">”.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s see this in action on the following program:</span></p><p class="c3"><span class="c4"/></p><pre>(if true 1 2)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We get:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- true : Bool</span><code>    |- 1 : U    |- 2 : U</code></p><pre>--------------------------------------
|- (if true 1 2) : U</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Either of the axioms for the other two antecedents tells us what U must be, which lets us fill in the result of U everywhere:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- true : Bool</span><code>    |- 1 : Num    |- 2 : Num</code></p><pre>------------------------------------------
|- (if true 1 2) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Fortunately, the other two antecedents are also axioms:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- true : Bool</span><code>    </code><span class="c90">|- 1 : Num</span><code>    </code><span class="c91">|- 2 : Num</span></p><pre>------------------------------------------
|- (if true 1 2) : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This lets us conclude that the overall term is well-typed, and that it has type </span><code>Num</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s look at:</span></p><p class="c3"><span class="c4"/></p><pre>(if 4 1 2)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Applying the conditional rule gives us:</span></p><p class="c3"><span class="c4"/></p><pre>|- 4 : Bool    |- 1 : U    |- 2 : U
-----------------------------------
|- (if 4 1 2) : U</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">However, we do not have any axiom or conditional rule that lets us conclude that </span><code>4</code><span class="calibre3"> has type </span><code>Bool</code><span class="c4"> (because, in fact, it does not). Therefore, we cannot complete the judgment:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c96">|- 4 : Bool</span><code>    |- 1 : U    |- 2 : U</code></p><pre>-----------------------------------
|- (if 4 1 2) : U</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and the program is (rightly) judged to have a type error.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">One last example:</span></p><p class="c3"><span class="c4"/></p><pre>(if true 1 "hi")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Again, applying the conditional rule and checking off the first antecedent:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- true : Bool</span><code>    |- 1 : U    |- "hi" : U</code></p><pre>-----------------------------------------
|- (if true 1 "hi") : U</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But now we have a problem. If we apply the axiom for numbers, we replace all instances of </span><code>U</code><span class="calibre3"> with </span><code>Num</code><span class="c4"> to get:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- true : Bool</span><code>    </code><span class="c90">|- 1 : Num</span><code>    </code><span class="c92">|- "hi" : Num</span></p><pre>---------------------------------------------
|- (if true 1 "hi") : Num</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Maybe we just tried the wrong axiom? We do have one more option! However, it ends up with the same net effect:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c90">|- true : Bool</span><code>    </code><span class="c96">|- 1 : Str</span><code>    </code><span class="c91">|- "hi" : Str</span></p><pre>---------------------------------------------
|- (if true 1 "hi") : Str</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Because there is </span><span class="c7">no</span><span class="c4"> way to construct a judgment for this program, it too has a type error.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Let’s now add functions. We need two new constructs: one to introduce them (</span><code>lambda</code><span class="calibre3">) and one to use them (function application). Write down judgments for each. </span><span class="c40">Hint:</span><span class="c4"> You may need to revisit the set of types, too.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that because </span><code>let</code><span class="calibre3"> desugars into </span><code>lambda</code><span class="calibre3">, once we have this, in principle we also have a conditional rule for </span><code>let</code><span class="calibre3">. (For more sophisticated language constructs this is not so straightforward; </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pk-resuarging-types/&amp;sa=D&amp;source=editors&amp;ust=1695232021368048&amp;usg=AOvVaw3PHiJldDLQfYPUNuwxOBi_">this paper</a></span><span class="c4"> works out some of the details.)</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Add desugaring to the type-checker.</span></p>

<h2 class="c27" id="h.9ailyuprz16v"><span class="c4">Where Types Diverge from Evaluation</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Something very important, and subtle, happened above. Compare the </span><span class="c7">type rule</span><span class="calibre3"> for a conditional with the </span><span class="c7">evaluation</span><span class="calibre3"> process [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936">👉</a></span><span class="calibre3">]. If the rule is too abstract, just look at the example judgments (or failed judgments) above. The evaluator evaluates only </span><span class="c7">one</span><span class="calibre3"> branch out of </span><code>T</code><span class="calibre3"> and </span><code>E</code><span class="calibre3">; indeed, that is the </span><span class="c7">entire point</span><span class="calibre3"> of a conditional. The type-checker, in contrast, traverses </span><span class="c7">both</span><span class="calibre3"> branches! In other words, it looks at code that </span><span class="c7">might</span><span class="calibre3"> evaluate, not only code that absolutely </span><span class="c7">does</span><span class="c4"> evaluate.<br class="calibre"/></span></p><p class="c5"><span class="calibre3">In other words, the idea that a type-checker is like an “evaluator that runs over simple values” is a convenient starting analogy, but it is in fact false. An evaluator and type-checker follow different traversal strategies. That is why a program like </span><code>(if true 1 "hi")</code><span class="c4"> might run without any difficulty but is rejected by a type-checker. While this particular example may make the type-checker look overly pedantic, what if the same program were</span></p><p class="c3"><span class="c4"/></p><pre>(if (is-full-moon) 1 "hi")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What now? Should the type-checker pass the program every month? Should it consider the moon’s phase at the time of type-checking or at execution? Unfortunately, the type-checker doesn’t know when the program will run; indeed, the program is type-checked once but may run an arbitrary number of times. Therefore, a type-checker must necessarily be </span><span class="c7">conservative</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This also lets us relate type-checking to </span><span class="c40">testing</span><span class="calibre3">. In software testing, making sure that all branches are visited is called </span><span class="c7">branch coverage</span><span class="calibre3">, and making sure all branches have coverage is both important and very difficult (because each branch may have additional branches which in turn may have even more branches which…). In contrast, a type-checker effortlessly covers both branches. The trade-off is that it does so only at the </span><span class="c7">type</span><span class="c4"> level (and indeed, the abstraction of values to types is precisely what enables it to do this).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Thus, testing and type-checking are complementary. Type-checking provides code coverage at a lightweight level; testing typically provides only partial coverage but at the deep level of specific values. In recent years, people have invented a notion of </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Concolic_testing&amp;sa=D&amp;source=editors&amp;ust=1695232021370424&amp;usg=AOvVaw1QJrbACLLfoZOf01gPppBi">concolic</a></span><span class="c4">—i.e., “concrete” + “symbolic”—testing to try to create the best of both worlds.</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c29" id="h.koavnladb9kb"><span class="c4"/></h1><h1 class="c30" id="h.1hrl1xnfptjg"><span class="c4">Growing Types: Typing Functions</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we’re ready to grow our language further, to include functions. As we’ve noted before, concepts like functions come in pairs: a way to introduce them and a way to use (“eliminate”) them. As in our interpreter, we’ll use a </span><code>lambda</code><span class="calibre3"> form to represent the former and application for the latter. We’ve already seen that once we have </span><code>lambda</code><span class="calibre3">, we use syntactic sugar to obtain other forms like </span><code>let</code><span class="c4">, so this suffices for our core language. (Mostly, as we’ll see…)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">So we have to come up with typing rules for application and </span><code>lambda</code><span class="c4">. Let’s do them in that order.</span></p>

<h2 class="c27" id="h.y05m31xxm5lb"><span class="c4">Typing Function Applications</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">A function application expression has two parts: the function and the arguments. For simplicity, we’re going to assume that we’re working with single-argument functions.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Extend the rules below to deal with functions of arbitrary number of parameters (formally called </span><span class="c7">arity</span><span class="c4">).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Because functions are first-class values, the function position is itself an expression. We have to check each sub-expression before we can type the whole expression. Therefore, function applications are conditional rules with two terms in the antecedent:</span></p><p class="c3"><span class="c4"/></p><pre>|- F : ???    |- A : ???
------------------------
|- (F A) : ???</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">First, let’s notice that functions are different kinds of values than other values: a function is not itself a number, or string, or Boolean—it may </span><span class="c7">produce</span><span class="calibre3"> one of those, but it is not </span><span class="c7">itself</span><span class="calibre3"> one of those (an important distinction). Therefore, we need a different type for functions, which reflects what functions consume and what they produce. A natural idea is to assume functions have some “function” type, here called </span><code>Fun</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>|- F : Fun    |- A : ???
------------------------
|- (F A) : ???</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What do we know about the argument expression (the actual parameter)? It had better match the type demanded by the formal parameter. But how do we check that here? We’ve collapsed </span><span class="c7">all</span><span class="calibre3"> functions in the world into a single type, </span><code>Fun</code><span class="c4">. That’s far too coarse.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Instead, following convention, we’ll use the “arrow” syntax for functions:</span></p><p class="c3"><span class="c4"/></p><pre>|- F : (??? -&gt; ???)    |- A : ???
---------------------------------
|- (F A) : ???</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(Technically, the arrow is a </span><span class="c7">constructor</span><span class="c4"> of function types. It’s a two-place constructor, for reasons we will see below.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">With this, we can now say that the function’s formal parameter’s type had better match up with the type of the actual argument. Which type, exactly? Functions could consume numbers, strings, even other functions…all we know is that these should be </span><span class="c7">consistent</span><span class="c4">. Notice that this is very similar to the consistency we expected of the branches of a conditional. We can again encode this by using the same placeholder in both places:</span></p><p class="c3"><span class="c4"/></p><pre>|- F : (T -&gt; ???)    |- A : T
-----------------------------
|- (F A) : ???</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now, what about what the function returns? Again, it could return values of any type. Whatever that type is, that is what the entire application produces. Again, we use a common placeholder to reflect this:</span></p><p class="c3"><span class="c4"/></p><pre>|- F : (T -&gt; U)    |- A : T
---------------------------
|- (F A) : U</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So here’s how we read this:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">Type-check the </span><code>F</code><span class="calibre3"> position. Make sure it’s a function type (</span><code>-&gt;</code><span class="calibre3">). Assuming it is, call the formal parameter’s type </span><code>T</code><span class="calibre3"> and the return type </span><code>U</code><span class="c4">.</span></li><li class="c25 pcalibre"><span class="c4">Type-check the actual parameter (the argument). Make sure it has the same type as what the function is expecting in its formal parameter.</span></li><li class="c25 pcalibre"><span class="c4">If both of those hold, then the function’s return type is the type of the entire application.</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This list of steps is what a conventional type-checker would implement. Observe that again, a type error is the result of a failure to construct a judgment. If, for instance, the actual argument’s type doesn’t match that of the formal parameter, then </span><span class="c7">the conditional rule above doesn’t apply</span><span class="calibre3"> (it applies only when we can write the same type for the </span><code>T</code><span class="c4"> placeholder), which is how we learn that the program has a type error.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Construct an example to illustrate the above type-error case.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> We intentionally don’t use a </span><span class="c7">numbered</span><span class="calibre3"> list because formally, the semantics of judgments doesn’t say that these steps have to occur in this order! For instance, the argument can be type-checked before the function; if so, that determines what the placeholder </span><code>T</code><span class="calibre3"> stands for, and the checking of </span><code>F</code><span class="calibre3"> confirms that </span><code>F</code><span class="c4">’s type matches that.</span></p><p class="c31"><span class="calibre3">Even more perversely, you can imagine checking the application, determining—from the context—what its type </span><span class="c7">needs</span><span class="calibre3"> to be (e.g., if it’s in an addition, it had better produce a number), and using that to drive the checking of </span><code>F</code><span class="calibre3">. In fact, all of these things can happen if instead of a </span><span class="c7">checker</span><span class="calibre3">, we implement type-</span><span class="c7">inference</span><span class="c4">—as we will soon see.</span></p>

<h2 class="c27" id="h.63hbomho6j8r"><span class="c4">Typing Function Definitions</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we’re ready to type </span><code>lambda</code><span class="calibre3">. Here, we have to be careful about how many sub-expressions there are. Given </span><code>(lambda V B)</code><span class="calibre3">, it is tempting to think that there are two: </span><code>V</code><span class="calibre3"> (the formal parameter) and </span><code>B</code><span class="calibre3"> (the body). This is wrong! The formal parameter is a literal name, </span><span class="c7">not</span><span class="calibre3"> an expression: we can’t replace that name with some larger expression, which is what it would mean for it to be an expression. Furthermore, we can’t evaluate it: it would (most likely) produce an unbound variable error, because its whole job is to </span><span class="c7">bind</span><span class="calibre3"> that variable, so it can’t assume it has already been bound. Therefore, there is only </span><span class="c7">one</span><span class="c4"> sub-expression, the body.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Therefore, we expect to end up with a conditional rule that looks like this:</span></p><p class="c3"><span class="c4"/></p><pre>|- B : ???
---------------------
|- (lambda V B) : ???</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If we think about this for a moment, we can see that there’s going to be a problem.  We just said that the </span><code>lambda</code><span class="calibre3"> introduces a binding for the variable in the </span><code>V</code><span class="calibre3"> position. This is precisely so that the body, </span><code>B</code><span class="c4">, can make use of that variable. So let’s imagine the simplest function:</span></p><p class="c3"><span class="c4"/></p><pre>|- x : ???
---------------------
|- (lambda x x) : ???</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But we don’t have any typing rule that covers variables! Furthermore, we have no way of knowing what the type of any old variable will be. So we have a problem.</span></p>

<h2 class="c27" id="h.q8diyyvoghis"><span class="c4">Typing Variables</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Remember how we addressed this problem in our interpreter: we had an </span><span class="c7">environment</span><span class="calibre3"> for recording the value bound to each variable. We will use this same idea again: we’ll have a </span><span class="c7">type environment</span><span class="calibre3"> for recording the </span><span class="c7">type</span><span class="c4"> of each variable. That is, just as our interpreter had the type</span></p><p class="c3"><span class="c4"/></p><pre>(interp : (Exp Env -&gt; Value))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">our type-checker will have the type</span></p><p class="c3"><span class="c4"/></p><pre>(tc : (Exp TEnv -&gt; Type))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In our type-checker notation, we will use a slightly different way of writing it, which will finally make make </span><code>|-</code><span class="c4"> stop being silent and take it proper pronounciation, “proves”: all type rules will have the form</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- e : T</code></p><p class="c3"><span class="c98"/></p><p class="c5"><span class="calibre3">where </span><span class="c97">Γ</span><span class="calibre3">, the capital Greek letter gamma, is conventionally used for the environment. We read this as “the environment </span><span class="c97">Γ</span><span class="calibre3"> proves that </span><code>e</code><span class="calibre3"> has type </span><code>T</code><span class="c4">”. So in fact there’s been an environment hiding in all our judgments, but we didn’t have to worry about it when we didn’t have variables; but now we do, so from now on we have to make it explicit. Fortunately, in most cases the environment is unchanged, and just passes recursively to the sub-terms, as you would expect from writing the interpreter.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">With this, we can write a type for variables. What is the type of a variable? It’s whatever the environment says it is! We’ll treat the environment as a function, so we can just write the following axiom (where </span><code>v</code><span class="c4"> stands for all the syntactically valid variable names):</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- v : </code><span class="c97">Γ</span><code>(v)</code></p>

<h2 class="c27" id="h.2b5j3vv7uch0"><span class="c4">Back to Typing Function Definitions</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we’re in a position to fill in the holes. When we check the body of the function, we should do it in an </span><span class="c7">extended</span><span class="c4"> environment:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ</span><span class="c99">[V &lt;- ???]</span><span class="c97"> </span><code>|- B : ???</code></p><pre>-----------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (lambda V B) : ???</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where </span><span class="c97">Γ[V &lt;- _] </span><span class="calibre3">is how we write “</span><span class="c97">Γ</span><span class="calibre3"> is extended with </span><code>V</code><span class="c4"> bound to _”: this is the same environment-extension function that we’ve written before, for type environments instead of value environments, but operationally the same.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, but two questions: extend </span><span class="c7">which</span><span class="calibre3"> environment, and extend it with </span><span class="c7">what</span><span class="c4">?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Which is easy: it’s the environment of the function definition (static scope!). The repetition of </span><span class="c97">Γ</span><span class="c4"> in both the consequent and antecedent accomplishes that.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In terms of what:  We need to provide a type for the variable so that, when we try to look up its type, the environment can return something. But we don’t know what to extend it with! The type-checker needs the </span><span class="c7">programmer to tell it</span><span class="c4"> what type the function is expecting. This is one of the reasons why programming languages expect annotations in function and method definitions. (Another—equally good—reason is because it better documents the function for people who have to use it and maintain it.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Therefore, we have to extend the syntax of functions to include a type annotation:</span></p><p class="c3"><span class="c4"/></p><pre>(lambda V : T B)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">which says that </span><code>V</code><span class="calibre3"> is expecting to be bound to a value of type </span><code>T</code><span class="calibre3"> in body </span><code>B</code><span class="c4">. Once we accept this modification, we can make progress on the conditional rule:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ[V &lt;- </span><span class="c99">T</span><span class="c97">] </span><code>|- B : ???</code></p><pre>---------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (lambda V : </code><span class="c64">T</span><code> B) : ???</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What type are we expecting for the function definition? Clearly it must be a function type:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><code>|- B : ???</code></p><pre>------------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (lambda V : T B) : </code><span class="c64">(??? -&gt; ???)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Furthermore, we know that the type expected by the function must be </span><code>T</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><code>|- B : ???</code></p><pre>----------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (lambda V : T B) : (</code><span class="c64">T</span><code> -&gt; ???)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Given a value of type </span><code>T</code><span class="c4">, the function will return whatever the body produces:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><code>|- B : </code><span class="c65">U</span></p><pre>--------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (lambda V : T B) : (T -&gt; </code><span class="c64">U</span><code>)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">And that gives us our final rule for function definitions.</span></p>

<h2 class="c27" id="h.4k3a0d9bmmp0"><span class="c4">More Divergence Between Types and Evaluation</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">It is interesting to contrast the above pair of typing rules with the corresponding evaluation rules. In the evaluator, we visit the body of the function on every </span><span class="c7">application</span><span class="calibre3">—which could be as many as an infinite number of times in a program. In contrast, we visit the body of the function on </span><span class="c7">definition</span><span class="c4">, which happens only once. Therefore, even if the program runs forever, the type-checker is guaranteed to terminate!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Why can we get away with this? The evaluator has to run the body with the </span><span class="c7">specific</span><span class="c4"> value it was given. The type-checker, however, has abstracted the concrete values away. Therefore, it only needs to make one pass through the body with the “abstract value”, the type.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">Earlier, when we proposed the type </span><code>Fun</code><span class="calibre3">, we said that it collapsed all functions in the world into one type. This was too coarse, and we had to refine the type of a function. However, we are </span><span class="c7">still</span><span class="calibre3"> collapsing an infinite number of functions into each of those function types—just as we collapse an infinite number of strings into </span><code>Str</code><span class="c4">, and so on. Both the strength and weakness of type-checking lies in this collapsing.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">For the same reason, observe that a function application rule only cares about the </span><span class="c7">type</span><span class="calibre3"> of the function, not </span><span class="c7">which</span><span class="calibre3"> specific function is being applied. Therefore, any function that has that type can be used. For that same reason, the type-checker </span><span class="c7">cannot</span><span class="c4"> traverse the function’s body at application time—it doesn’t even know which function might be used! All communication between the function body and application must happen entirely through the type boundary.</span></p>

<h2 class="c27" id="h.yg4pidy7mny2"><span class="c4">Assume-Guarantee Reasoning</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">There is a delicate dance going on between these typing rules for application and definition (now updated to have the environment). We’ll use colors to highlight this:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- F : </code><span class="c100">(T -&gt; U)</span><code>    Γ |- A : </code><span class="c101">T</span></p><pre>-------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (F A) : U</code></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ[V &lt;- </span><span class="c102">T</span><span class="c97">] </span><code>|- B : U</code></p><pre>--------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (lambda V : T B) : </code><span class="c100">(T -&gt; U)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The rule for </span><code>lambda</code><span class="calibre3"> </span><span class="c7">assumes</span><span class="calibre3"> the parameter will be given a value of type </span><span class="c103">T</span><span class="calibre3">; the application rule </span><span class="c7">guarantees</span><span class="calibre3"> that that the actual parameter will indeed have the expected type. The application rule </span><span class="c7">assumes</span><span class="calibre3"> that the function, if given a </span><code>T</code><span class="calibre3">, will produce a </span><code>U</code><span class="calibre3"> (because the type is </span><span class="c100">(T -&gt; U)</span><span class="calibre3">); the </span><code>lambda</code><span class="calibre3"> rule </span><span class="c7">guarantees</span><span class="c4"> that the function will indeed perform that way.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> The notation </span><code>(T -&gt; U)</code><span class="calibre3"> is not chosen at random. The </span><code>-&gt;</code><span class="calibre3"> may remind you of the notation for implication in mathematics. That’s intentional. We can read the type as “giving the function a </span><code>T</code><span class="calibre3"> implies that it will produce a </span><code>U</code><span class="calibre3">” (not giving it a </span><code>T</code><span class="calibre3"> implies nothing about what it will do…). It is that </span><span class="c7">implication</span><span class="c4"> that is assumed in the application rule, and that is guaranteed by the rule for lambda.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This assume-guarantee reasoning shows up in many places, so look out for this pattern in other places as well.</span></p>

<h2 class="c27" id="h.3x1o016rduha"><span class="c4">Recursion and Infinite Loops</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We alluded, earlier, to how we can desugar more interesting features into functions and application. Let’s take a look at a very specific feature: an infinite loop. Let’s first confirm that we can write an infinite loop. Here’s a program that does it:</span></p><p class="c3"><span class="c4"/></p><pre>fun f():
  f()</pre><p class="c3"><span class="c41"/></p><pre>f()</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But this assumes we already have recursion. Can we write it without recursion? Actually we can! We’ll use historical names (</span><span class="c104">ω</span><span class="c4"> is the lower-case Greek omega):</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(let ([</code><span class="c104">ω</span><code> (lambda (x) (x x))])</code></p><p class="c5"><code>  (</code><span class="c104">ω</span><code> </code><span class="c104">ω</span><code>))</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Run this in Racket and confirm that it runs forever!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="calibre3"> Write a conditional type rule for </span><code>let</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s see what happens when we try to type this. We have to provide a type annotation:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(let ([</code><span class="c104">ω</span><code> (lambda (x : ???) (x x))])</code></p><p class="c5"><code>  (</code><span class="c104">ω</span><code> </code><span class="c104">ω</span><code>))</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Historically, the overall term is called </span><span class="c104">Ω</span><span class="c4"> (the capital Greek omega).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, so what is the annotation? To determine a type for </span><code>x</code><span class="calibre3">, we have to see how it’s used. It’s used twice. One use is in a function application position, so we know that the type must be of the form </span><code>(T -&gt; U)</code><span class="calibre3">; now we have to determine what </span><code>T</code><span class="calibre3"> and </span><code>U</code><span class="calibre3"> are. Let’s focus on the parameter type, </span><code>T</code><span class="calibre3">. But what are we passing in? We’re passing in </span><code>x</code><span class="calibre3">, whose type is </span><code>(T -&gt; U)</code><span class="c4">. So we need a solution to the equation</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>T</code><span class="calibre3"> = </span><code>(T -&gt; U)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">with one coming from the application position and the other from the argument position. Of course, there is no finite type that can fit this equation! Therefore, it appears that this program cannot be typed!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Of course, this is not a proof. However, there is a formal property associated with this programming language, which is called the Simply Typed Lambda Calculus (STLC): the property is called </span><span class="c7">strong normalization</span><span class="calibre3">, and it means that </span><span class="c7">all programs in this language terminate</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> If you have heard about the Halting Problem, how does that square with what you just read?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">It may seem rather useless to have a language in which all programs terminate—you can’t write an operating system, or Web server, or many other programs in such a language. However, that misses two things.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">First, there are many cases where we </span><span class="c7">want</span><span class="calibre3"> programs to always terminate. You don’t want a network packet filter or a device driver or a compiler or a type-checker or … to run forever. Of course we also want them to run quickly, but it would be nice if we had a guarantee that no matter what we did, we </span><span class="c7">cannot</span><span class="c4"> create an infinite loop. The STLC is very useful in some of these settings. Another example of a place where we want guaranteed termination is in program linking, and the module language of Standard ML is therefore built atop the STLC: it lets you even write higher-order programs, but the type language guarantees that all module compositions (linkages) will terminate.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Second, many long-running programs are actually a composition of an infinite loop and a short-running program. Think about an operating system with device drivers, a Web server with a Web application, a GUI with callbacks, etc. In each case, there is a “spine” of an infinite loop that simply keeps the program reactive, and “ribs” of short computations that do a little specific work and terminate. In fact, on the Web these programs </span><span class="c7">must</span><span class="calibre3"> terminate quickly, otherwise the Web browser thinks the server has hung and offers to kill the window! These kinds of </span><span class="c7">reactive systems</span><span class="c4"> are therefore a composition of a very generic infinite loop calling out to specific programs for which a termination guarantee will often be very useful.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Finally, observe that we’ve learned something profound. Until now, we have probably thought of types as just a convenience or as a way of eliminating basic errors. However, we have just now seen that adding a type system can </span><span class="c7">change the expressive power of a language</span><span class="c4">. That is, these types are “semantic”.</span></p>

<h2 class="c27" id="h.ls7b0qafb55w"><span class="c4">Typing Recursion</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What went wrong above? The problem is that each application “uses up an arrow” in a function type; because a program text must be finite, it can contain at most a finite number of “arrows”, so eventually the program must terminate. To get around this, we need a way to effectively have an “infinite quiver”.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We typically do this by adding a recursive function construct to the language, and create a custom type for it. Let’s start with a type rule for the analogous, but simpler, </span><code>let</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- E : T    </code><span class="c97">Γ[V &lt;- T] </span><code>|- B : U</code></p><pre>--------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (let V : T E B) : U</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Note that we’re going to expect an annotation in </span><code>let</code><span class="calibre3"> for the same reason we do for function definitions. So this says that we’ll check that </span><code>E</code><span class="calibre3"> actually does have the type promised in the declaration, </span><code>T</code><span class="calibre3">; when we extend the type environment with the </span><code>V</code><span class="calibre3"> having type </span><code>T</code><span class="calibre3">, if the body </span><code>B</code><span class="calibre3"> produces type </span><code>U</code><span class="c4">, then that’s the type of the whole expression.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> Notice that there’s an assume-guarantee pair in the antecedent: the first term is guaranteeing the annotation, which the second term is assuming.</span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Technically, the type of </span><code>E</code><span class="calibre3"> could be </span><span class="c7">calculated</span><span class="calibre3">. Therefore, the </span><code>T</code><span class="c4"> annotation is not strictly necessary.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that this is basically the type rule we would get from expanding the syntactic sugar for </span><code>let</code><span class="calibre3">. Therefore, this still doesn’t let us write a recursive definition. We need something more. Let’s introduce a new construct, </span><code>rec</code><span class="calibre3">, for recursive definitions. An example of a </span><code>rec</code><span class="c4"> (in an untyped setting) might be</span></p><p class="c3"><span class="c4"/></p><pre>(rec ([inf-loop (lambda (n) (inf-loop n))])
  (inf-loop 0))</pre><p class="c3"><span class="c41"/></p><pre>(rec ([fact (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))])
  (fact 10))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In the typed world, we’ll want rec to have the form</span></p><p class="c3"><span class="c4"/></p><pre>(rec V : T E B)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">so we’d instead have to write</span></p><p class="c3"><span class="c4"/></p><pre>(rec inf-loop : (Number -&gt; Number)
     (lambda (n) (inf-loop n))
  (inf-loop 0))</pre><p class="c3"><span class="c41"/></p><pre>(rec fact : (Number -&gt; Number)
     (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))
  (fact 10))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where </span><code>V</code><span class="calibre3"> is </span><code>fact</code><span class="calibre3">, </span><code>T</code><span class="calibre3"> is </span><code>(Number -&gt; Number)</code><span class="calibre3">, </span><code>E</code><span class="calibre3"> is the big </span><code>lambda</code><span class="calibre3"> term, and </span><code>B</code><span class="calibre3"> is </span><code>(fact 10)</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So this introduces a recursive definition, and then uses it. How might we type this?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">???</span></p><pre>------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (rec V : T E B) : U</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Well, clearly one part of it must be the same: we have to type the body in the extended environment, and the environment must be extended with the annotated type:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">???    Γ[V &lt;- T] </span><code>|- B : U</code></p><pre>-------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (rec V : T E B) : U</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We also know that we need to confirm that the annotation is correct:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">??? </span><code>|- E : T</code><span class="c97">    Γ[V &lt;- T] </span><code>|- B : U</code></p><pre>----------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (rec V : T E B) : U</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But clearly, </span><span class="c7">something</span><span class="calibre3"> needs to be different, otherwise we’ve just reproduced </span><code>let</code><span class="calibre3">. Look at the example use of </span><code>rec</code><span class="calibre3">: the </span><code>E</code><span class="calibre3"> term also needs to have </span><code>V</code><span class="calibre3"> bound in it! In other words, both </span><code>E</code><span class="calibre3"> and </span><code>B</code><span class="c4"> are typed in the same environment:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ[V &lt;- T] </span><code>|- E : T</code><span class="c97">    Γ[V &lt;- T] </span><code>|- B : U</code></p><pre>----------------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (rec V : T E B) : U</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">From the type, we can read off how the recursion happens: the extended environment for </span><code>B</code><span class="calibre3"> </span><span class="c7">initiates</span><span class="calibre3"> the recursion, while that for </span><code>E</code><span class="calibre3"> </span><span class="c7">sustains</span><span class="calibre3"> it. Essentially, the environment of </span><code>E</code><span class="c4"> enables arbitrary recursive depth.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In short, to obtain arbitrary recursion—and hence infinite loops—we have to add a special construct to the language and its type-checker; we cannot obtain it just through desugaring. Once we add </span><code>rec</code><span class="c4"> to the STLC, however, we obtain a conventional programming language again.</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c29" id="h.iypss2moo9rt"><span class="c4"/></h1><h1 class="c30" id="h.ugmt6kgqztq6"><span class="c4">Safety and Soundness</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">A critical component of SMoL is the concept of </span><span class="c7">safety</span><span class="calibre3">: that some operations are </span><span class="c7">partial</span><span class="calibre3"> over the set of all values, and that a SMoL language enforces this by reporting violations. Typical examples of partiality may include </span><code>+</code><span class="calibre3"> applying only to certain types of values. However, I intentionally write “operations” rather than, say, “functions”, because these could be primitive operations like application (expecting the first position to be a function or method) as well. In fact, in some languages like JavaScript, there are very few violations, as the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://www.destroyallsoftware.com/talks/wat&amp;sa=D&amp;source=editors&amp;ust=1695232021400146&amp;usg=AOvVaw1NOpkYKNjpy6IwTp-vrqEQ">Wat talk</a></span><span class="c4"> shows.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">How must these be enforced? It can be either statically or dynamically. In Python and JavaScript, for instance, all safety violations are reported dynamically. In Java or OCaml, most of them are reported statically. Either way, safety means that </span><span class="c7">data have integrity</span><span class="calibre3">: there is some notion of “what they are”, and that identity is respected by operations. Put differently, data are not </span><span class="c7">misinterpreted</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">These are all very abstract statements, which we will soon concretize.</span></p>

<h2 class="c27" id="h.qgdclmmudlfd"><span class="c4">Revisiting the Basic Calculator</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We will start with a very basic calculator that has two types, numbers and strings, and an operation (addition and concatenation, respectively) on them. Note that it helps to have more than one type if we want to talk about safety. We will skip most of the boilerplate code and focus on the core of the calculator:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type Exp
  [num (n : Number)]
  [str (s : String)]
  [plus (l : Exp) (r : Exp)]
  [cat (l : Exp) (r : Exp)])</pre><p class="c3"><span class="c41"/></p><pre>(define-type Value
  (numV (n : Number))
  (strV (s : String)))</pre><p class="c3"><span class="c41"/></p><pre>(calc : (Exp -&gt; Value))</pre><p class="c3"><span class="c41"/></p><pre>(define (calc e)
  (type-case Exp e
    [(num n) (numV n)]
    [(str s) (strV s)]
    [(plus l r) (num+ (calc l) (calc r))]
    [(cat l r) (str++ (calc l) (calc r))]))</pre><p class="c3"><span class="c41"/></p><pre>(define (num+ lv rv)
  (type-case Value lv
    ((numV ln)
     (type-case Value rv
       ((numV rn) (numV (+ ln rn)))
       (else (error '+ "right not a number"))))
    (else (error '+ "left not a number"))))</pre><p class="c3"><span class="c41"/></p><pre>(define (str++ lv rv)
  (type-case Value lv
    ((strV ls)
     (type-case Value rv
       ((strV rs) (strV (string-append ls rs)))
       (else (error '++ "right not a string"))))
    (else (error '++ "left not a string"))))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="c4">You might have imagined the latter two functions to be merely convenient helpers, and hence wonder why they are part of the “core”. You will soon see why!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">With a suitable parser, we can run tests such as the following:</span></p><p class="c3"><span class="c4"/></p><pre>(test (calc (plus (num 1) (num 2))) (numV 3))
(test (calc (plus (num 1) (plus (num 2) (num 3)))) (numV 6))
(test (calc (cat (str "hel") (str "lo"))) (strV "hello"))
(test (calc (cat (cat (str "hel") (str "l")) (str "o"))) (strV "hello"))
(test/exn (calc (cat (num 1) (str "hello"))) "left")
(test/exn (calc (plus (num 1) (str "hello"))) "right")</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">The last two, in particular, show that the language is safe. The checks inside the primitives—in </span><code>num+</code><span class="calibre3">, for instance—are called </span><span class="c7">safety checks</span><span class="c4">.</span></p>

<h2 class="c27" id="h.r9b5rx2ualtj"><span class="c4">Making Memory Explicit (Unsafely)</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now we’re going to do something fun: we’re going to make the memory allocation of values explicit. As we go through this, remember what we’ve said before: a value in SMoL is just a memory address.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s do this in stages. First, we’ll use a vector to represent memory:</span></p><p class="c3"><span class="c4"/></p><pre>(define MEMORY (make-vector 100 -1))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The value </span><code>-1</code><span class="calibre3"> is useful for identifying parts of memory that have not yet been touched (assuming, of course, we don’t write a program that produces </span><code>-1</code><span class="c4">—which we can avoid doing easily enough in this illustration).</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> To run the code below, you will need to import some Racket primitives into plait:</span></p><p class="c51"><span class="c4"/></p><pre>(require (typed-in racket/base
                   [char-&gt;integer : (Char -&gt; Number)]
                   [integer-&gt;char : (Number -&gt; Char)]
                   [number-&gt;string : (Number -&gt; String)]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">It will be useful to have a helper to use the next available bit of memory:</span></p><p class="c3"><span class="c4"/></p><pre>(define next-addr 0)
(define (write-and-bump v)
  (let ([n next-addr])
    (begin
      (vector-set! MEMORY n v)
      (set! next-addr (add1 next-addr))
      n)))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">Now let’s say we want to store a number in memory. We put it in the next available memory place, and return the </span><span class="c7">address</span><span class="calibre3"> of the place where the number was stored. Be careful here: the number we return is a memory address (which, here, is represented as an array index), which is not at all necessarily the same as the </span><span class="c7">numeric value</span><span class="c4"> being stored.</span></p><p class="c3"><span class="c4"/></p><pre>(define (store-num n)
  (write-and-bump n))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Correspondingly, when we want to read a number, we simply return what is at the address corresponding to the number.</span></p><p class="c3"><span class="c4"/></p><pre>(define (read-num a)
  (vector-ref MEMORY a))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We want the property that when we </span><code>read-num</code><span class="calibre3"> from the address where we </span><code>store-num</code><span class="calibre3"> a number, we get back that same number: for all </span><code>N</code><span class="c4">,</span></p><p class="c3"><span class="c4"/></p><p class="c8"><code>(read-num (store-num N))</code><span class="calibre3"> is </span><code>N</code></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This is not quite exactly how numbers are stored in most languages. As we will see when we update the calculator below, this means every time we produce a particular number—</span><code>1730</code><span class="calibre3">, say—we store it afresh in memory. That would be extremely wasteful. Rather, language implementations use representation tricks to make sure there is only one copy of numbers and that they don’t need to take up space on the heap at all, as we describe below [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_114.html#h.dirpjggvkz7z">👉</a></span><span class="calibre3">]. However, we will continue to work with this simple model because this optimization is not the focus of this chapter. In addition, </span><span class="c7">some</span><span class="calibre3"> numbers—that don’t fit in a small amount of space—</span><span class="c7">do</span><span class="c4"> need to be stored on the heap.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s look at strings. We are going to convert the string into a sequence of character codes, and store those codes explicitly:</span></p><p class="c3"><span class="c4"/></p><pre>(define (store-str s)
  (let ([a0 (write-and-bump (string-length s))])
    (begin
      (map write-and-bump
           (map char-&gt;integer (string-&gt;list s)))
      a0)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In particular, the value stored at the address representing the string is the </span><span class="c7">length</span><span class="c4"> of the string, followed by the individual characters. (Endless blood has been spent over whether strings should store their lengths at the front, or whether they should only be delimited by a special value, or both. The question is uninteresting here.) Thus, suppose with a fresh memory we run</span></p><p class="c3"><span class="c4"/></p><pre>(store-str "hello")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">this would return the address </span><code>0</code><span class="c4">. The resulting value of MEMORY would be</span></p><p class="c3"><span class="c4"/></p><pre>'#(5
   104
   101
   108
   108
   111
   -1
   -1
   -1
   …)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, at address </span><code>0</code><span class="calibre3"> we have the length of the string, followed by five character codes; these six memory entries together constitute the five-character string </span><code>"hello"</code><span class="c4">. The rest of the memory remains untouched. To read a string we have to reassemble it:</span></p><p class="c3"><span class="c4"/></p><pre>(define (read-str a)
  (letrec ([loop
            (lambda (count a)
              (if (zero? count)
                  empty
                  (cons (vector-ref MEMORY a)
                        (loop (sub1 count) (add1 a)))))])
    (list-&gt;string
     (map integer-&gt;char
          (loop (vector-ref MEMORY a) (add1 a))))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Once again, we want the result of reading a written string to give us the same string.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s update the calculator. First, we’re in for a surprise: we no longer need (or </span><span class="c7">want</span><span class="c4">) a fancy Racket datatype to track values, because values are just addresses (i.e., array indices)! So:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type-alias Value Number)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The </span><span class="c7">type</span><span class="calibre3"> of the calculator doesn’t change; it still produces values. It’s just that the representation of values has changed…dramatically. (Recall, again, that these </span><code>Number</code><span class="calibre3">s are addresses, not numeric values </span><span class="c7">in</span><span class="c4"> the interpreted language.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The calculator remains the same. What has changed is in the helper functions. In the primitive value cases, we have to explicitly allocate them—which is what we were doing when we called the previous definitions of </span><code>numV</code><span class="calibre3"> and </span><code>strV</code><span class="c4"> (which store data on the heap), except it may not have been so evident. We will make it explicit as follows:</span></p><p class="c3"><span class="c4"/></p><pre>(define numV store-num)
(define strV store-str)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, now to update the helper functions. Let’s focus on </span><code>num+</code><span class="c4">. The core logic is currently</span></p><p class="c3"><span class="c4"/></p><pre>       [(numV rn) (numV (+ ln rn))]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that now we’re calling it on the result of calling </span><code>calc</code><span class="calibre3">, i.e., on </span><code>Value</code><span class="calibre3">s. That means </span><code>num+</code><span class="c4"> is going to get two addresses as arguments, and it needs to look up the corresponding numbers in memory, and then produce the resulting number:</span></p><p class="c3"><span class="c4"/></p><pre>(define (num+ la ra)
  (numV (+ (read-num la) (read-num ra))))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside: </span><span class="c4">In case you’re wondering: yes, we’re cheating a tiny bit. We’re using Racket numbers rather than dealing with even lower-level representations. We’ll give ourselves this little bit of leeway since this is not the point we’re trying to illustrate.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Analogously, we can define concatenation as well:</span></p><p class="c3"><span class="c4"/></p><pre>(define (str++ la ra)
  (strV (string-append (read-str la) (read-str ra))))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">Yes, we’re cheating again, and quite a bit. If we were less lazy, we’d write a big loop over </span><code>MEMORY</code><span class="c4"> that copies all the values from the first and second strings into a new, third string, explicitly. But we’re lazy.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Finally, we have to update our tests as well. Because </span><code>calc</code><span class="calibre3"> now returns </span><span class="c7">addresses</span><span class="calibre3">, all our answers appear to be incorrect. Instead, we have to obtain the corresponding numbers or strings at those addresses. Once we do so, </span><code>calc</code><span class="c4"> passes the tests:</span></p><p class="c3"><span class="c4"/></p><pre>(test (read-num (calc (plus (num 1) (num 2)))) 3)
(test (read-num (calc (plus (num 1) (plus (num 2) (num 3))))) 6)
(test (read-str (calc (cat (str "hel") (str "lo")))) "hello")
(test (read-str (calc (cat (cat (str "hel") (str "l")) (str "o")))) "hello")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Except…does it? These two tests do not pass:</span></p><p class="c3"><span class="c4"/></p><pre>(test/exn (calc (cat (num 1) (str "hello"))) "left")
(test/exn (calc (plus (num 1) (str "hello"))) "right")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In fact, how </span><span class="c7">can</span><span class="c4"> they? In all the above code, there are no errors left! Rather, when we run</span></p><p class="c3"><span class="c4"/></p><pre>(calc (cat (num 1) (str "hello")))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">we get an address back (maybe </span><code>69</code><span class="calibre3">; it depends on what you ran earlier and hence what is in </span><code>MEMORY</code><span class="c4">). In fact, we can decide how we want to treat this: as a number?</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (read-num 69)
- Number
6
&gt; (read-str 69)
- String
"\u0005hello"</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">How can something be both a number and a string? Well, actually, the situation is a bit more confusing than that: </span><code>69</code><span class="calibre3"> above is just an address in memory from which we can read off whatever we want </span><span class="c7">however we want it</span><span class="calibre3"> (i.e., the content of that address is </span><span class="c7">interpreted</span><span class="c4"> by the function that reads from it), which can result in garbage. It can get even worse:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (read-num (calc (plus (num 1) (str "hello"))))
- Number
6
&gt; (read-str (calc (plus (num 1) (str "hello"))))
- String</pre><p class="c5"><span class="c73">. . integer-&gt;char: contract violation</span></p><p class="c5"><span class="c73">  expected: valid-unicode-scalar-value?</span></p><p class="c5"><span class="c73">  given: -1</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, we’ve tried to read “off the end of memory”. It was dumb luck that we had a </span><code>-1</code><span class="calibre3"> as the initial value; the </span><code>-1</code><span class="calibre3"> triggered an error when we tried to convert it to a character </span><span class="c7">because Racket’s primitives are safe</span><span class="calibre3">, which halted the program. If </span><code>integer-&gt;char</code><span class="c4"> did not have a safety check, we would have gotten some garbled string instead.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In short, what we have created is an </span><span class="c7">unsafe</span><span class="c4"> language. Data have no integrity. Any value can be treated as any kind of datum. This, in short, is the memory model of C, and it’s largely proven to be a disaster for modern programming, which is why SMoL languages evolved.</span></p>

<h2 class="c27" id="h.52l6s2rjm6u3"><span class="c4">Recovering Safety</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Fortunately, it does not take too much work to make the language safe again. What we’ve just written holds the key: every value needs to record what kind of value it is. And any use of that value needs to check that it’s the right kind of value. This information is called a </span><span class="c7">tag</span><span class="calibre3">; it takes a fixed amount of space, and represents </span><span class="c7">metadata</span><span class="c4"> about the subsequent datum. All subsequent values are interpreted in accordance with the tag.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We need two tags for the two kinds of values. Let’s use</span></p><p class="c3"><span class="c4"/></p><pre>(define NUMBER-TAG 1337)
(define STRING-TAG 5712)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">It’s important that the two tags be different, so they are unambiguous. However, we don’t need to worry about the tags themselves being confused with other data (e.g., numbers), because the tags will never be processed directly as program data (unless, of course, there is a bug in our implementation that accidentally does so…which is why language implementations need to be tested extensively).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now, when we allocate a number, we write its </span><span class="c7">tag</span><span class="c4"> into the first address, followed by the actual numeric value:</span></p><p class="c3"><span class="c4"/></p><pre>(define (store-num n)</pre><p class="c5"><code>  </code><span class="c65">(let ([a0 (write-and-bump NUMBER-TAG)])</span></p><p class="c5"><span class="c65">    (begin</span></p><pre>      (write-and-bump n)</pre><p class="c5"><code>      </code><span class="c64">a0))</span><code>)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">And when we try to read a number, we </span><span class="c7">first</span><span class="calibre3"> check that it really </span><span class="c7">is</span><span class="c4"> a number, and only then obtain the actual numeric value:</span></p><p class="c3"><span class="c4"/></p><pre>(define (safe-read-num a)</pre><p class="c5"><code>  </code><span class="c65">(if (= (vector-ref MEMORY a) NUMBER-TAG)</span></p><p class="c5"><code>      (vector-ref MEMORY </code><span class="c64">(add1 </span><code>a</code><span class="c64">)</span><code>)</code></p><p class="c5"><code>      </code><span class="c64">(error 'number (number-&gt;string a)))</span><code>)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Strings are analogous:</span></p><p class="c3"><span class="c4"/></p><pre>(define (store-str s)</pre><p class="c5"><code>  (let ([a0 (write-and-bump </code><span class="c64">STRING-TAG</span><code>)])</code></p><pre>    (begin</pre><p class="c5"><code>      </code><span class="c65">(write-and-bump (string-length s))</span></p><pre>      (map write-and-bump
           (map char-&gt;integer (string-&gt;list s)))
      a0)))</pre><p class="c3"><span class="c41"/></p><pre>(define (safe-read-str a)</pre><p class="c5"><code>  </code><span class="c65">(if (= (vector-ref MEMORY a) STRING-TAG)</span></p><pre>      (letrec ([loop
                (lambda (count a)
                  (if (zero? count)
                      empty
                      (cons (vector-ref MEMORY a)
                            (loop (sub1 count) (add1 a)))))])
        (list-&gt;string
         (map integer-&gt;char</pre><p class="c5"><code>              (loop (vector-ref MEMORY </code><span class="c64">(add1 </span><code>a</code><span class="c64">)</span><code>) (+ a </code><span class="c64">2</span><code>)))))</code></p><p class="c5"><code>      </code><span class="c64">(error 'string (number-&gt;string a)))</span><code>)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So now, starting from a fresh memory, running</span></p><p class="c3"><span class="c4"/></p><pre>(store-str "hello")</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">still produces </span><code>0</code><span class="calibre3">, but the content of </span><code>MEMORY</code><span class="c4"> looks a bit different:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>'#(</code><span class="c65">5712</span></p><pre>   5
   104
   101
   108
   108
   111
   -1
   -1
   -1
   …)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, at address </span><code>0</code><span class="calibre3"> we first encounter the tag for strings. Only then do we get the string’s length, followed by its contents. Observe that now, storing the length up front makes even more sense: the first two locations contain the tag and the length, both of which are metadata that help us interpret what comes later, with the second (the length) </span><span class="c7">refining</span><span class="c4"> the first (the tag).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">With this change, the interpreter stays unchanged, and effectively so do the helpers, other than using the new names we’ve chosen:</span></p><p class="c3"><span class="c4"/></p><pre>(define (num+ la ra)</pre><p class="c5"><code>  (store-num (+ (</code><span class="c64">safe-</span><code>read-num la) (</code><span class="c64">safe-</span><code>read-num ra))))</code></p><p class="c3"><span class="c41"/></p><pre>(define (str++ la ra)</pre><p class="c5"><code>  (store-str (string-append (</code><span class="c64">safe-</span><code>read-str la) (</code><span class="c64">safe-</span><code>read-str ra))))</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">All our “good” tests still pass, but interestingly, our “bad” tests now fail:</span></p><p class="c3"><span class="c4"/></p><pre>(test/exn (calc (cat (num 1) (str "hello"))) "string")
(test/exn (calc (plus (num 1) (str "hello"))) "number")</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="c4">You may notice the error message strings above have changed slightly. Why?</span></p>

<h2 class="c27" id="h.w5idwmpm1ep3"><span class="c4">What Price Safety?</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Our safe evaluator has, however, come at a price relative to the unsafe evaluator. In terms of running </span><span class="c40">time</span><span class="calibre3">, we are now clearly paying for the overhead of safety checks. In terms of </span><span class="c40">space</span><span class="calibre3">, we are paying for the tags. Thus, we have had to get worse space </span><span class="c7">and</span><span class="c4"> time.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Nevertheless, the price of unsafe languages is so high—e.g., in the form of security problems—and the cost of safety is often so low, that programmers gladly pay this price (or do so without even particularly noticing it).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Still, it would be nice if we didn’t have to pay the price at all. And there is a way to accomplish that: </span><span class="c7">types</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Look at our “bad” programs. These are programs that can </span><span class="c7">statically</span><span class="calibre3"> be rejected by a type-checker. If we could reject all such programs, then—since no “bad” programs would be left—we can then run the program on the </span><span class="c7">unsafe</span><span class="c4"> evaluator without worrying about negative consequences. This, in effect, is what most typed languages, like Java and OCaml, do. Thus we find another use for types: to improve program performance. But this requires care.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Usually, in computer science, we talk about a space-time </span><span class="c7">tradeoff</span><span class="calibre3">. Yet here we seem to have a situation where we’ve improved (i.e., reduced the use of) both the space </span><span class="c7">and</span><span class="c4"> the time! How is that possible?</span></p>

<h2 class="c27" id="h.o6z8cl4dhyfk"><span class="c4">Soundness</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Running on an unsafe evaluator is, as the name suggests, dangerous. Therefore, we should only do it if we can be sure that nothing can go wrong. That means that our type system needs to come with a </span><span class="c7">guarantee</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The way this guarantee is usually formulated is as follows. Suppose we have</span></p><p class="c3"><span class="c4"/></p><pre>e : t</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and suppose we evaluate it and find that</span></p><p class="c3"><span class="c4"/></p><pre>e -&gt; v</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The latter—its value—is the ground truth. The type checker’s job is to make sure it matches what the evaluator produces. That is, we would ideally like that</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>e : t</code><span class="calibre3"> if and only if </span><code>e -&gt; v</code><span class="calibre3"> and </span><code>v : t</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This says that the type checker's job is to perfectly mirror the evaluator: whatever type the program’s result value has is the same type the type-checker says it has.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Unfortunately, for a Turing-complete language, this full guarantee is impossible to obtain, because of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&amp;sa=D&amp;source=editors&amp;ust=1695232021427399&amp;usg=AOvVaw1_99VdJEVQ2qFHhOKxeYso">Rice’s Theorem</a></span><span class="c4">. Instead, we have to compromise and see if we can get at least one of the two directions. When we think about it, we realize that, in a typed language, we’re only really interested in programs that pass the type-checker (i.e., have a type). Therefore, we expect that</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If </span><code>e : t</code><span class="c4"> then</span></p><p class="c5"><span class="calibre3">        if </span><code>e -&gt; v</code><span class="calibre3">, then </span><code>v : t</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This says that whatever type the type-checker predicted is exactly the type that the program has. That means we can rely on the type-checker’s prediction. Which in turn means that we can be sure there are no type violations. Which tells us we can safely run the program atop an unsafe evaluator! This property is called </span><span class="c7">type soundness</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Note that soundness is not a given: it’s a property that must be formally, mathematically </span><span class="c7">proven</span><span class="calibre3"> of a given type-checker and evaluator. The proof can be quite complex. This is because the “shape” of program evaluation and that of type-checking can be very different, as we have seen before for conditionals [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk">👉</a></span><span class="calibre3">] and functions [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg">👉</a></span><span class="c4">]. And failure to prove it correctly—i.e., claiming it holds when in fact it doesn’t—means we’ve allowed a vulnerability to slip through. This can manifest as uncaught exceptions, crashes, segmentation faults, etc. In addition, a clever attacker can construct a program that exploits the vulnerability, and our system can be subjected to a security or other attack. Thus, any soundness violations are emergencies and result in panic.</span></p>

<h2 class="c27" id="h.stnwipd5np0c"><span class="c4">Generic Printing</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">One of the consequences of our tagged representation is that when extracting a value from memory, we don’t </span><span class="c7">have</span><span class="calibre3"> to know whether to use </span><code>safe-read-num</code><span class="calibre3"> or </span><code>safe-read-str</code><span class="c4">; the tag at the address can tell us which to use. That is, we can define</span></p><p class="c3"><span class="c4"/></p><pre>(define (generic-read a)
  (let ([tag (vector-ref MEMORY a)])
    (cond
      [(= tag NUMBER-TAG) (safe-read-num a)]
      [(= tag STRING-TAG) (safe-read-str a)]
      [else (error 'generic-print "invalid tag")])))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Unfortunately, this code can’t be typed by plait because the two branches return different types. We can solve this in two ways:</span></p><p class="c3"><span class="c4"/></p><ol class="c105" start="1"><li class="c106 pcalibre15"><span class="calibre3">We can use a hack: use </span><code>#lang plait #:untyped</code><span class="calibre3">, which provides the same syntactic language, features, and run-time behavior, but turns off the type-checker. (Curiously, we were using the type-checker to keep us disciplined: so that the only values we could store in </span><code>MEMORY</code><span class="c4"> would be numbers! Therefore, it’s good to not use the untyped version often.)</span></li><li class="c106 pcalibre15"><span class="calibre3">Notice that in the end, what printers do is essentially print a string. Therefore, we just need to return a string in all cases:<br class="calibre"/><br class="calibre"/></span><code>(define (generic-read a)</code></li></ol><pre>  (let ([tag (vector-ref MEMORY a)])
    (cond
      [(= tag NUMBER-TAG) (number-&gt;string (safe-read-num a))]
      [(= tag STRING-TAG) (safe-read-str a)]
      [else (error 'generic-print "invalid tag")])))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">A consequence of having this function is that we can rewrite our tests to be more proper:</span></p><p class="c3"><span class="c4"/></p><pre>(test (generic-read (calc (plus (num 1) (num 2)))) "3")
(test (generic-read (calc (plus (num 1) (plus (num 2) (num 3))))) "6")
(test (generic-read (calc (cat (str "hel") (str "lo")))) "hello")
(test (generic-read (calc (cat (cat (str "hel") (str "l")) (str "o")))) "hello")</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">This is much closer to how we would write the test in the original interpreter; the only difference here is that the evaluator produces an address as the value, but we would like to inspect the value in a human-readable and -writable form, so we use </span><code>generic-read</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Alert:</span><span class="calibre3"> If you run these tests in addition to the preceding ones, you may need to enlarge </span><code>MEMORY</code><span class="c4">.</span></p><a id="kix.3i7vvizaw4m8"/>

<h2 class="c27" id="h.dirpjggvkz7z"><span class="c4">The Representation of Numbers</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Examining the content of </span><code>MEMORY</code><span class="calibre3"> gives the impression that every single number we compute is stored afresh on the heap, and furthermore, if we compute a certain number (say </span><code>3</code><span class="c4">) twice, each instance will be stored and hence take up space. However, this is not the space consumption model of real implementations.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">On most modern architectures, values are stored at </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Data_structure_alignment&amp;sa=D&amp;source=editors&amp;ust=1695232021431461&amp;usg=AOvVaw1zfmzCHLp7ziOLweunTDXZ">“word” boundaries</a></span><span class="c4">: depending on the machine, starting at addresses that are multiples of 4 or 8. For the purposes of illustration, let’s say we have a 32-bit machine, with 4-byte alignment. (The reasons for this are due to details of computer architecture that are outside the scope of this book.) That means every legal memory address, when viewed in binary, ends in …00. However, there are four legal values for those two bits, only one of which is being used. This creates an opportunity.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">A common technique is to therefore use a pattern like …01 to be the tag for numbers. The actual number itself is stored in the remaining (say 30) bits of the “address”. That means, “addresses” that end in 01 are not true addresses, and must not be looked up; they are actually just numbers.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Thus, in principle, the first thing to do with a value (that is, an address) is to test its 0’th bit. If this is 1, then shift the value right by 2 places. This drops the 01 tag, </span><span class="c7">leaving the number in place</span><span class="c4">. Similarly, when a number is constructed, provided it fits in 30 bits, it is shifted left by two places, and the last bit is made 1 (resulting in the 01 tag).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">As a consequence, every number has a tag; but every number is also stored in registers and on the stack, not on the heap. All numbers with the same value have the same bit-pattern representation (the 30-bit numeric value followed by 01). Thus, there will be </span><span class="c7">zero</span><span class="c4"> instances of them on the heap, and they can be accurately compared for equality in constant time.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> Notice that the above technique only works for numbers that can fit in 30 bits (or about 60 bits in a 64-bit machine). Larger numbers have to still be stored on the heap.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">As you might imagine, we have further room to play: we still have the patterns …10 and …11. Another good candidate for fitting entirely in the address is a Boolean, so the pattern …10 could be used for that. Very short strings might fit in a word. And so on. There are many architectural, instruction-set, and program considerations in designing these tags at the low level.</span></p>

<h1 class="c22" id="h.bheym24u3ntv"><span class="c4">Type Inference</span></h1><h2 class="c23" id="h.bq0i6plsiwy6"><span class="c4">Unannotated Programs and Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Consider the following plait program:</span></p><p class="c3"><span class="c4"/></p><pre>(lambda (x y)
  (if x
      (+ y 1)
      (+ y 2)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">If we enter this program into plait, e.g., as follows, something remarkable happens:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (lambda (x y)
    (if x
        (+ y 1)
        (+ y 2)))
- (Boolean Number -&gt; Number)
#&lt;procedure&gt;</pre><p class="c5"><span class="c4"> </span></p><p class="c5"><span class="calibre3">In response, plait </span><span class="c7">figures out</span><span class="calibre3"> the type of this function </span><span class="c7">without</span><span class="calibre3"> our having to provide any annotations. This is in contrast to the type-checker we just wrote [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg">👉</a></span><span class="calibre3">], </span><span class="c4">which required us to extend the syntax just to provide (required) type annotations. That tells us that something different—and more—must be happening under plait. In contrast, consider another example:</span></p><p class="c3"><span class="c4"/></p><pre>(lambda (x)
    (if x
        (+ x 1)
        (+ x 2)))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">This produces an error, observing that we are using </span><code>x</code><span class="calibre3"> both in a position that requires it to be a Boolean (in </span><code>if</code><span class="c4">) and a number (in the two additions). Again, plait has figured this out without our having to write any annotations at all!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The algorithm that sits underneath plait is essentially the same algorithm under OCaml, Haskell, and several other programming languages. These languages provide </span><span class="c7">type inference</span><span class="c4">: figuring out (inferring) types automatically from the program source. Now we’re going to see how this works.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The key idea is to break this seemingly very complex problem into two rather simple parts. In the first, we recursively visit each sub-expression of the program (following SImPl) and generate a set of </span><span class="c7">constraints</span><span class="calibre3"> that formally do what we’ve been doing informally above. The second phase </span><span class="c7">solves</span><span class="calibre3"> this set of constraints, using a process that is a generalization of the process you used for solving “systems of simultaneous equations” in school. The solution is a </span><span class="c7">type</span><span class="c4"> for each variable. That lets us fill in the annotations that the programmer left blank. </span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The process of generation will also have applied the type constraints, so there will be no further need to type-check the program; but we can use the annotations, for instance, in an IDE for tool-tips, in a compiler for optimization, etc. That is, with inference, we can program as if we’re in a “scripty” language without annotations, yet achieve most of the benefits of types. (I say “most” because one of the benefits is documentation; leaving off all annotations makes programs harder to read and understand. For that reason, inference should be used sparingly.)</span></p>

<h2 class="c27" id="h.f2auvndzp4jo"><span class="c4">Imagining a Solution</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Until now, our type checker has required us to annotate the parameter of every function. But let’s imagine someone handed us a piece of code without annotations; can we figure out the type anyway? For instance, consider:</span></p><p class="c3"><span class="c4"/></p><pre>(+ 1 2)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We clearly know the type of this; even our type-checker can calculate it for us without any annotations. But of course that’s not surprising: there are no variables to annotate. So now consider this expression:</span></p><p class="c3"><span class="c4"/></p><pre>(lambda (x : ___) (+ x 1))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">With a moment’s inspection, we can tell that the function has type </span><code>(Num -&gt; Num)</code><span class="calibre3">. But our type-checker couldn’t have calculated that, because it would have tripped on the empty annotation. So how can </span><span class="c7">we</span><span class="c4"> figure it out?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Well, let’s see. First we have to figure out the type of </span><code>x</code><span class="calibre3">. To determine its type, we should look for </span><span class="c7">uses</span><span class="calibre3"> of </span><code>x</code><span class="c4">. There is only one, and it’s used in an addition. But the rule for addition</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- e1 : Num    </code><span class="c97">Γ </span><code>|- e2 : Num</code></p><pre>------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (+ e1 e2) : Num</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">tells us that the term in that position must have type </span><code>Num</code><span class="calibre3">. There is no additional information we have about </span><code>x</code><span class="calibre3"> (this remark will become clearer in a moment). Therefore, we can determine that its type must be </span><code>Num</code><span class="calibre3">. Furthermore, we know that the result of an addition is also a </span><code>Num</code><span class="calibre3">. From that, we can conclude that the function has type </span><code>(Num -&gt; Num)</code><span class="c4">.</span></p>

<h2 class="c27" id="h.qq2x3uxalskl"><span class="c4">Unique Variable Names</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In what follows, we will assume that all variable names in the program are unique. That is, a given variable name is bound in at most one place in a program. This greatly simplifies the presentation below, because we can speak of the type of a variable and know </span><span class="c7">which</span><span class="c4"> variable it refers to, instead of having to constantly qualify which variable of that name we mean.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This restriction does not actually preclude any programs in a language with static scope. Consider this program, which produces </span><code>7</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(let ([x 3])
  (+ (let ([x 4])
       x)
     x))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We can just as well </span><span class="c7">consistently rename</span><span class="calibre3"> one of the </span><code>x</code><span class="c4">s to something else (heck, we can even use the DrRacket interface to have Racket do the renaming for us), and leave the program meaning exactly the same:</span></p><p class="c3"><span class="c4"/></p><pre>(let ([x 3])
  (+ (let ([y 4])
       y)
     x))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This renaming process is called </span><span class="c7">alpha conversion</span><span class="calibre3"> or </span><span class="c7">alpha renaming</span><span class="c4">.</span></p>

<h2 class="c27" id="h.nyfouco82zsf"><span class="c4">More Informal Examples</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">With that important detail out of the way, let’s return to our process of </span><span class="c7">inferring</span><span class="calibre3"> or </span><span class="c7">reconstructing</span><span class="c4"> the types of variables from the way they’re used in a program. Here’s another example with a two-parameter function:</span></p><p class="c3"><span class="c4"/></p><pre>(lambda ((x : ___) (y : ___))
  (if x
      (+ y 1)
      (+ y 2)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Once again, we can’t just calculate its type with our type-checker; instead, we must reconstruct the type from the function body. Let’s do that. What can we tell? Let’s again refer to the conditional rule:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- C : Bool    </code><span class="c97">Γ </span><code>|- T : U    </code><span class="c97">Γ </span><code>|- E : U</code></p><pre>-----------------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (if C T E) : U</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This tells us that what’s in the </span><code>C</code><span class="calibre3"> position—here, </span><code>x</code><span class="calibre3">—must be a </span><code>Bool</code><span class="calibre3">. Furthermore, both branches </span><code>(+ y 1)</code><span class="calibre3"> and </span><code>(+ y 2)</code><span class="calibre3"> must have the same type. That’s all we can learn from the rule for </span><code>if</code><span class="calibre3">! But now we can (and must) recur into the sub-expressions. Each one is an addition, and the addition rule tells us that both arguments must be </span><code>Num</code><span class="calibre3">s. Both of these indicate that the type of </span><code>y</code><span class="calibre3"> must be </span><code>Num</code><span class="calibre3">. Furthermore, both indicate that the overall addition returns a </span><code>Num</code><span class="c4">. From that we can tell that the entire expression must have the type</span></p><p class="c3"><span class="c4"/></p><pre>(Bool Num -&gt; Num)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">By this process, we can figure out what types to put in the missing annotations. More subtly, notice that by running through this process, we have effectively applied all the typing rules; therefore, if we have successfully reconstructed the type annotations, we need not bother type-checking the program with those annotations: it will have to type-check.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s consider a slight variation on the above program:</span></p><p class="c3"><span class="c4"/></p><pre>(lambda (x : ___)
  (if x
      (+ x 1)
      (+ x 2)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s figure out everything we can learn about </span><code>x</code><span class="c4"> from the function’s body:</span></p><ul class="c24"><li class="c25 pcalibre"><code>x</code><span class="calibre3"> is used in the conditional position of an </span><code>if</code><span class="calibre3">. Therefore, it must have type </span><code>Bool</code><span class="c4">.</span></li><li class="c25 pcalibre"><code>x</code><span class="calibre3"> is used as a parameter to </span><code>+</code><span class="calibre3">. Therefore, it must have type </span><code>Num</code><span class="c4">.</span></li><li class="c25 pcalibre"><code>x</code><span class="calibre3"> is again used as a parameter to </span><code>+</code><span class="calibre3">. Therefore, it must have type </span><code>Num</code><span class="c4">.</span></li></ul><p class="c5"><span class="calibre3">Notice that each of these conclusions is perfectly fine on its own. However, when we </span><span class="c7">put them together</span><span class="calibre3"> (which is what we meant by “additional information” above), there’s a problem: </span><code>x</code><span class="calibre3"> cannot be both of those. That is, we are unable to find a single type for </span><code>x</code><span class="calibre3">. This inability to find a type for </span><code>x</code><span class="calibre3"> means that the program has a </span><span class="c7">type error</span><span class="calibre3">. And indeed, there </span><span class="c7">is</span><span class="c4"> no type we could have given that would have enabled this program to execute safely.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe something subtle. While we can report that the program clearly has a type error, our error message must necessarily be much more ambiguous. Previously, when we had a type annotation on </span><code>x</code><span class="calibre3">, we could pinpoint where the error occurred. Now, all we can say is that the program is not type-</span><span class="c7">consistent</span><span class="calibre3">, but cannot blame one spot or the other without potentially misleading the programmer. Instead, we must report all these locations and let the programmer decide where the error is based on their </span><span class="c7">unstated intent</span><span class="c4"> (in the form of a type annotation).</span></p>

<h2 class="c27" id="h.ds1q1ge60mtd"><span class="c4">Algorithmic Details</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The details of this algorithm—called </span><span class="c7">Hindley-Milner inference</span><span class="calibre3">—are fascinating, and worked out in detail in both the first and second editions of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://www.plai.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021443495&amp;usg=AOvVaw1Jv2eQapvZVGeMGKdx7dFB">this book, PLAI</a></span><span class="c4"> (Chapter 30 in the first edition and Chapter 15.3.2 in the second edition). For several worked examples of both constraint generation and constraint solving, refer to the first edition. The first edition has a more algorithmic presentation, while the second provides code (it may be useful to compare the two). The prose in the second is different from that in the first, so different readers may prefer one over the other.</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.e43aokkp4uwk"><span class="c4">Algebraic Datatypes</span></h1><p class="c5"><span class="calibre3">We have written numerous </span><code>define-type</code><span class="c4"> definitions so far, e.g., for expressions. Now we will study this mechanism, which is increasingly found in many new programming languages, in more detail.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To simplify things, consider a simple plait data definition of a binary tree of numbers:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type BT
  [mt]
  [node (v : Number) (l : BT) (r : BT)])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The </span><code>define-type</code><span class="c4"> construct here is doing three different things, and it’s worth teasing them apart:</span></p><p class="c3"><span class="c4"/></p><ol class="c107" start="1"><li class="pcalibre16 c108"><span class="calibre3">Giving a </span><span class="c7">name</span><span class="calibre3"> to a new type, </span><code>BT</code><span class="c4">.</span></li><li class="pcalibre16 c108"><span class="calibre3">Allowing the type to be defined by multiple cases or </span><span class="c7">variants</span><span class="calibre3"> (</span><code>mt</code><span class="calibre3"> and </span><code>node</code><span class="c4">).</span></li><li class="pcalibre16 c108"><span class="calibre3">Permitting a </span><span class="c7">recursive</span><span class="calibre3"> definition (</span><code>BT</code><span class="calibre3"> references </span><code>BT</code><span class="c4">).</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">It’s worth asking whether all these pieces of functionality really have to be bundled together, or whether they can be handled separately. While they can indeed be separated, they often end up working in concert, especially when it comes to recursive definitions, which are quite common. A recursive definition needs a name for creating the recursion; therefore, the third feature requires the first. Furthermore, a recursive definition often needs a non-recursive case to “bottom out”; this requires there to be more than one variant, using the second feature. Putting the three together, therefore, makes a lot of sense.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This construct is called an </span><span class="c7">algebraic datatype</span><span class="calibre3">, sometimes also known as a “sum of products”. That is because the variants are read as an “or”: a </span><code>BT</code><span class="calibre3"> is an </span><code>mt</code><span class="calibre3"> </span><span class="c7">or</span><span class="calibre3"> a </span><code>node</code><span class="calibre3">. Each variant is an “and” of its fields: a node has a </span><code>v</code><span class="calibre3"> </span><span class="c7">and</span><span class="calibre3"> an </span><code>l</code><span class="calibre3"> </span><span class="c7">and</span><span class="calibre3"> an </span><code>r</code><span class="c4">. In Boolean algebra, “or” is analogous to a sum and “and” is analogous to a product.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Sometimes, you will also see this referred to as a </span><span class="c7">tagged union</span><span class="calibre3">. The word “union” is because we can conceptually think of a </span><code>BT</code><span class="calibre3"> as a union of </span><code>mt</code><span class="calibre3">s and </span><code>node</code><span class="calibre3">s. The tag is the constructor. This term makes more sense once we compare it against “untagged” union types [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt">👉</a></span><span class="c4">].</span></p>

<h2 class="c27" id="h.72j0j01cvgav"><span class="c4">Generated Bindings</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now the question is, how do we type code that uses such a definition? First, let’s take an inventory of all the definitions that this might create. It at least creates two </span><span class="c7">constructors</span><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(mt : ( -&gt; BT))
(node : (Number BT BT -&gt; BT))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We have been starting our interpretation and type-checking with the empty environment, but there is no reason we need to, nor do we do so in practice: the primordial environment can contain all kinds of pre-defined values and their types. Thus, we can imagine the </span><code>define-type</code><span class="calibre3"> above adding the above two definitions to the initial type environment, enabling uses of </span><code>mt</code><span class="calibre3"> and </span><code>node</code><span class="c4"> to be type-checked.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This much is standard across various languages. But less commonly, in plait you get two more families of functions: </span><span class="c7">predicates</span><span class="c4"> for distinguishing between the variants:</span></p><p class="c3"><span class="c4"/></p><pre>(mt? : (BT -&gt; Boolean))
(node? : (BT -&gt; Boolean))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and </span><span class="c7">accessors</span><span class="c4"> for getting the values out of fields:</span></p><p class="c3"><span class="c4"/></p><pre>(node-v : (BT -&gt; Number))
(node-l : (BT -&gt; BT))
(node-r : (BT -&gt; BT))</pre>

<h2 class="c27" id="h.b9fuu6pixv2g"><span class="c4">Static Type Safety</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We should be troubled by the types of these accessors. They seem to indiscriminately try to pull out field values, </span><span class="c7">whether the variant has them or not</span><span class="c4">. For instance, we can write and type-check this program, which is appealing:</span></p><p class="c3"><span class="c4"/></p><pre>(size-correct : (BT -&gt; Number))</pre><p class="c3"><span class="c41"/></p><pre>(define (size-correct (t : BT))
  (if (mt? t)
      0
      (+ 1 (+ (size-correct (node-l t)) (size-correct (node-r t))))))</pre><p class="c3"><span class="c41"/></p><pre>(test (size-correct (mt)) 0)</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">However, we can just as well type-check </span><span class="c7">this</span><span class="c4"> program:</span></p><p class="c3"><span class="c4"/></p><pre>(define (size-wrong (t : BT))
  (+ 1 (+ (size-wrong (node-l t)) (size-wrong (node-r t)))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This should not type-check because it has a clear type-error. The type of </span><code>size-wrong</code><span class="c4"> is</span></p><p class="c3"><span class="c4"/></p><pre>(size-wrong : (BT -&gt; Number))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">so it is perfectly type-correct to write:</span></p><p class="c3"><span class="c4"/></p><pre>(size-wrong (mt))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But running this, of course, results in a run-time error, the very kind of error we might have hoped the type-checker would catch.</span></p>

<h2 class="c27" id="h.whl38kyxs86p"><span class="c4">Pattern-Matching and Type-Checking</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This kind of error cannot occur naturally in languages like OCaml and Haskell. Instead of exposing all these predicates and accessors, instances of an algebraic datatype are deconstructed using pattern-matching. Thus, the size computation would be written as (</span><code>-pm</code><span class="c4"> stands for “pattern matching”):</span></p><p class="c3"><span class="c4"/></p><pre>(size-pm : (BT -&gt; Number))</pre><p class="c3"><span class="c4"/></p><pre>(define (size-pm t)
  (type-case BT t
    [(mt) 0]
    [(node v l r) (+ 1 (+ (size-pm l) (size-pm r)))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This might seem like a convenience—it certainly makes the code much more compact and perhaps also much more readable—but it’s also doing something more. The pattern-matcher is effectively baked into the way programs are type-checked. That is, the above algebraic datatype definition effectively adds the following typing rule to the type checker:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- e : </code><span class="c91">BT</span></p><p class="c5"><span class="c109">Γ</span><span class="c97"> </span><code>|- e1 : </code><span class="c110">T</span></p><p class="c5"><span class="c97">Γ</span><span class="c111">[V &lt;- Number, L &lt;- BT, R &lt;- BT]</span><span class="c97"> </span><code>|- e2 : </code><span class="c110">T</span></p><pre>-----------------------------------------</pre><p class="c5"><span class="c109">Γ</span><span class="c97"> </span><code>|- (type-case BT e</code></p><pre>       [(mt) e1]
       [(node V L R) e2]) : T</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The first antecedent is clear: we have to confirm that the expression </span><code>e</code><span class="calibre3"> evaluates to a </span><span class="c90">BT</span><span class="calibre3"> before we pattern-match </span><code>BT</code><span class="calibre3"> patterns against it. The second type-checks </span><code>e1</code><span class="calibre3"> in the </span><span class="c112">same</span><span class="calibre3"> environment as in the consequent because the </span><code>mt</code><span class="calibre3"> variant does not add any local bindings. The type of this expression needs to be the </span><span class="c113">same</span><span class="calibre3"> as the type from the other branch, due to how we’re handling conditionals. Finally, to type-check </span><code>e2</code><span class="calibre3">, we have to </span><span class="c114">extend</span><span class="calibre3"> the consequent’s type environment with the bound variables; their types we can read off directly from the data </span><span class="c7">definition</span><span class="c4">. In short, the above typing rule can be defined automatically by desugaring.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> Notice that there is also an assume-guarantee here: we type-check </span><code>e2</code><span class="calibre3"> in an environment that </span><span class="c7">assumes</span><span class="calibre3"> the annotated types; this is </span><span class="c7">guaranteed</span><span class="calibre3"> by the </span><code>node</code><span class="c4"> constructor.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In particular, observe what we </span><span class="c7">couldn’t</span><span class="calibre3"> do! We didn’t have awkward selectors, like </span><code>node-v</code><span class="calibre3">, for which we had to come up with some type. By saying they consumed a </span><code>BT</code><span class="calibre3">, we had to let them statically consume any kind of </span><code>BT</code><span class="calibre3">, which caused a problem at run-time. Here, there is </span><span class="c7">no selector</span><span class="calibre3">: pattern-matching means we can only write pattern-variables in variants where the algebraic datatype definition permits it, and the variables automatically gets the right type. Thus, pattern-matching plays a crucial role in the </span><span class="c7">statically safe</span><span class="c4"> handling of types.</span></p>

<h2 class="c27" id="h.zf7hekvcesl"><span class="c4">Algebraic Datatypes and Space</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Earlier, we’ve seen that types can save us both time and space. We have to be a little more nuanced when it comes to algebraic datatypes.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The new type introduced by an algebraic datatype still enjoys the space saving. Because the type checker can tell a </span><code>BT</code><span class="calibre3"> apart from every other type, at run-time we don’t need to record that a value is a </span><code>BT</code><span class="calibre3">: it doesn’t need a type-tag. However, we still need to tell apart the different </span><span class="c7">variants</span><span class="calibre3">: the function </span><code>size-pm</code><span class="calibre3"> effectively desugars into (</span><code>-ds</code><span class="c4"> stands for “desugared”):</span></p><p class="c3"><span class="c4"/></p><pre>(define (size-pm-ds (t : BT))
  (cond
    [(mt? t) 0]
    [(node? t)
     (let ([v (node-v t)]
           [l (node-l t)]
           [r (node-r t)])
       (+ 1 (+ (size-pm-ds l) (size-pm-ds r))))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(We’ve introduced the </span><code>let</code><span class="calibre3"> to bind the names introduced by the pattern.) What this shows is that at run-time, there are conditional checks that need to know what kind of </span><code>BT</code><span class="calibre3"> is bound to </span><code>t</code><span class="c4"> on this iteration. Therefore, we need just enough tagging to tell the variants apart. In practice, this means we need as many bits as the logarithm of the number of variants; since this number is usually small, this information can often be squeezed into other parts of the data representation.</span></p><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.tg4ohkq8ngzt"><span class="c4">Union Types and Retrofitted Types</span></h1><p class="c5"><span class="calibre3">Typed Racket is an instance of a </span><span class="c7">retrofitted</span><span class="calibre3"> type system: adding a type system to a language that did not previously have types. The original language, which does not have a static type system, is usually called </span><span class="c7">dynamic</span><span class="c4">. There are now numerous retrofitted type systems: e.g., TypeScript for JavaScript and Static Python for Python. There are even multiple retrofitted type systems for some languages: e.g., both TypeScript and Flow add types to JavaScript.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The goal of a retrofitted type system is to turn run-time errors into static type errors. Due to the Halting Problem, we cannot precisely turn every single run-time error into a static one, so the designer of the type system must make some decisions about which errors matter more than others. In addition, programmers have already written considerable code in many dynamic languages, so changes that require programmers to rewrite code significantly would not be adopted. Instead, as much as possible, type system designers need to accommodate </span><span class="c7">idiomatic type-safe programs</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Algebraic datatypes present a good example. Typically, they have tended to not be found in dynamic languages. Instead, these languages have some kind of structure definition mechanism (such as classes, or lightweight variants thereof, like Python’s </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.python.org/3/library/dataclasses.html&amp;sa=D&amp;source=editors&amp;ust=1695232021455665&amp;usg=AOvVaw2l-qHVAvQWW6klXtg2zXhU">dataclasses</a></span><span class="c4">). Therefore, the elegant typing that goes with algebraic datatypes and their pattern-matching does not apply. Because it is not practical to force dynamic language programmers to wholesale change to this “new” (to that dynamic language) style of programming, type system designers must find the idioms they use (that happen to be type-safe) and try to bless them. We will look at some examples of this.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">A good working example of a retrofitted typed language is Typed Racket, which adds types to Racket while trying to preserve idiomatic Racket programs. (This is in contrast to plait, which is also a typed form of Racket but does </span><span class="c7">not</span><span class="calibre3"> try very hard to preserve Racket idioms. The accessors we saw earlier, for algebraic datatypes [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">👉</a></span><span class="c4">], are forgiving in what they accept, at the cost of static safety.)</span></p>

<h2 class="c27" id="h.hmq96sdr2bi"><span class="c4">You Get a Type! And You Get a Type! And You Get a Type!</span></h2><p class="c5"><span class="calibre3">Let’s return [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">👉</a></span><span class="c4">] to our non-statically-type-safe accessors in plait: e.g.,</span></p><p class="c3"><span class="c4"/></p><pre>(node-v : (BT -&gt; Number))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In a way, it’s not fair to blame the accessor: the fault is really with the constructor, because</span></p><p class="c3"><span class="c4"/></p><pre>(node : (Number BT BT -&gt; BT))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Once the </span><code>node</code><span class="calibre3"> constructor creates a </span><code>BT</code><span class="calibre3">, the information about </span><code>node</code><span class="calibre3">-ness is lost, and there’s not much that the accessors can do. So perhaps the alternative is to </span><span class="c7">not</span><span class="calibre3"> create a </span><code>BT</code><span class="calibre3">, but instead create a value of the </span><code>node</code><span class="c4"> type.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So let’s start over. This time, we’ll use a different typed language, Typed Racket:</span></p><p class="c3"><span class="c4"/></p><pre>#lang typed/racket</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In Typed Racket, we can create products, called structures, which define a new type:</span></p><p class="c3"><span class="c4"/></p><pre>(struct mt ())</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This creates a constructor with the type we’d expect:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; mt
- : (-&gt; mt)
#&lt;procedure:mt&gt;</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">It also creates a predicate, whose type is a bit different; previously we had a function that could only take a </span><code>BT</code><span class="calibre3">, because it didn’t make sense to apply </span><code>mt?</code><span class="calibre3"> to any other type. Now, however, there isn’t even a concept of a </span><code>BT</code><span class="calibre3"> (yet), so </span><code>mt?</code><span class="c4"> will take values of any type:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; mt?
- : (-&gt; Any Boolean : mt)
#&lt;procedure:mt?&gt;</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(The additional text, </span><code>: mt</code><span class="c4">, is telling us when the Boolean is true; ignore this for now.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s try to define nodes. Here we run into a problem:</span></p><p class="c3"><span class="c4"/></p><pre>(struct node ([v : Number] [l : </pre>

<h2 class="c27" id="h.i5byz3jrh4uv"><span class="c4">Union Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Oops—what do we write here?!? We have to also introduce a notion of a binary tree. But we already have two existing types, </span><code>mt</code><span class="calibre3"> and (in progress) </span><code>node</code><span class="calibre3">. Therefore, we need a way to define a binary tree that has a sum that combines these two existing types. This suggests that we have a way of describing a new type as a </span><span class="c7">union</span><span class="c4"> of existing types:</span></p><p class="c3"><span class="c4"/></p><pre>(define-type-alias BT (U mt node))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that in this case, there are no special constructors to distinguish between the two kinds of BT. Therefore, this is called an </span><span class="c7">untagged union</span><span class="calibre3">, in contrast to tagged unions [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">👉</a></span><span class="c4">].</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we can go back and complete our definition of </span><code>node</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(struct node ([v : Number] [l : BT] [r : BT]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s look at what Typed Racket tells us are the types of </span><code>node</code><span class="c4">’s constructor, predicate, and selectors:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; node
- : (-&gt; Number BT BT node)
&gt; node-v
- : (-&gt; node Number)
&gt; node-l
- : (-&gt; node BT)
&gt; node-r
- : (-&gt; node BT)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Using these definitions we can create trees: e.g.,</span></p><p class="c3"><span class="c4"/></p><pre>(define t1
  (node 5
        (node 3
              (node 1 (mt) (mt))
              (mt))
        (node 7
              (mt)
              (node 9 (mt) (mt)))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But now let’s try to write a program to compute its size:</span></p><p class="c3"><span class="c4"/></p><pre>(define (size-tr [t : BT]) : Number
  (cond
    [(mt? t) 0]
    [(node? t) (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">It is not clear at all that this program should type-check. Consider the expression </span><code>(node-l t)</code><span class="calibre3">. The type of </span><code>node-l</code><span class="calibre3"> expects its argument to be of type </span><code>node</code><span class="calibre3">. However, all we know is that </span><code>t</code><span class="calibre3"> is of type </span><code>BT</code><span class="c4">. Yet this program type-checks!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The fact that this does type-check, however, should not fill us with too much joy. We saw how </span><code>size-wrong</code><span class="c4"> type-checked, only to halt with an undesired run-time error. So what if we instead write its analog, which is this?</span></p><p class="c3"><span class="c4"/></p><pre>(define (size-tr-wrong [t : BT]) : Number
  (+ 1 (size (node-l t)) (size (node-r t))))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">This program does </span><span class="c40">not</span><span class="calibre3"> type-check! Instead, it gives us a type error of exactly the sort we would have expected: </span><code>node-l</code><span class="calibre3"> and </span><code>node-r</code><span class="calibre3"> both complain that they were expecting an </span><code>node</code><span class="calibre3"> and were given a </span><code>BT</code><span class="calibre3">. So the wonder is not that </span><code>size-tr-wrong</code><span class="calibre3"> has a type-error, but rather that </span><code>size-tr</code><span class="c4"> does not!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To understand why it type-checks, we have to go back to the types of the predicates:</span></p><p class="c3"><span class="c41"/></p><pre>&gt; mt?
- : (-&gt; Any Boolean : mt)
&gt; node?
- : (-&gt; Any Boolean : node)</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">Critically, the </span><code>: mt</code><span class="calibre3"> and </span><code>: node</code><span class="calibre3"> are Typed Racket’s way of saying that the Boolean will be true only when the input is an </span><code>mt</code><span class="calibre3"> or </span><code>node</code><span class="calibre3">, respectively. This crucial </span><span class="c7">refinement</span><span class="calibre3"> information is picked up by the type-checker. In the right-hand-side of the </span><code>cond</code><span class="calibre3"> clauses, it </span><span class="c7">narrows</span><span class="calibre3"> the type of </span><code>t</code><span class="calibre3"> to be </span><code>mt</code><span class="calibre3"> and </span><code>node</code><span class="calibre3">, respectively. Thus, </span><code>(node-l t)</code><span class="calibre3"> is type-checked in a type environment where the type of </span><code>t</code><span class="calibre3"> is </span><code>node</code><span class="calibre3"> and not </span><code>BT</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To test this theory, we can try another wrong program:</span></p><p class="c3"><span class="c4"/></p><pre>(define (size-tr-w2 [t : BT]) : Number
  (cond
    [(node? t) 0]
    [(mt? t) (+ 1 (size-tr-w2 (node-l t)) (size-tr-w2 (node-r t)))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here, we have swapped the predicates. It is not only important that this version produces a type error, it is also instructive to understand why, by reading the type error. This explicitly says that the program expected an </span><code>node</code><span class="calibre3"> (for instance, in </span><code>node-l</code><span class="calibre3">) and was given an </span><code>mt</code><span class="calibre3"> (based on the </span><code>mt?</code><span class="c4">). This confirms that Typed Racket is refining the types in branches based on predicates.</span></p>

<h2 class="c27" id="h.jo5pzefb48p1"><span class="c4">If-Splitting</span></h2><p class="c5"><span class="calibre3">To summarize, </span><code>size-tr</code><span class="c4"> type-checks is because the type-checker is doing something special when it sees the pattern</span></p><p class="c3"><span class="c4"/></p><pre>(define (size-tr [t : BT]) : Number
  (cond
    [(mt? t) …]
    [(node? t) …]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">It knows that every </span><code>BT</code><span class="calibre3"> is related to </span><code>mt</code><span class="calibre3"> and </span><code>node</code><span class="calibre3"> through the union. When it sees the predicate, it </span><span class="c7">narrows</span><span class="calibre3"> the type from the full union to the branch of the union that the predicate has checked. Thus, in the </span><code>mt?</code><span class="calibre3"> branch, it narrows the type of </span><code>t</code><span class="calibre3"> from </span><code>BT</code><span class="calibre3"> to </span><code>mt</code><span class="calibre3">; in the </span><code>node?</code><span class="calibre3"> branch, similarly, it narrows the type of </span><code>t</code><span class="calibre3"> to just </span><code>node</code><span class="calibre3">. Now, </span><code>node-l</code><span class="calibre3">, say, gets confirmation that it is indeed processing a </span><code>node</code><span class="calibre3"> value, and the program is statically type-safe. In the absence of those predicates, in </span><code>size-tr-wrong</code><span class="calibre3">, the type of </span><code>t</code><span class="calibre3"> does not get narrowed, resulting in the error. In </span><code>size-tr-w2</code><span class="c4">, swapping the predicates also gives an error. Here is one more version:</span></p><p class="c3"><span class="c4"/></p><pre>(define (size-tr-else [t : BT]) : Number
  (cond
    [(mt? t) 0]
    [else (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This program could go either way! It just so happens that it does type-check in typed/racket, because typed/racket is “smart” enough to determine that there are only two kinds of </span><code>BT</code><span class="calibre3"> and one has been excluded, so in the </span><code>else</code><span class="calibre3"> case, it must be the other kind. But one could also imagine a less clever checker that expects to see an explicit test of </span><code>node?</code><span class="c4"> to be able to bless the second clause.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In short, both the algebraic datatype and union type approaches need some special treatment of syntax by the type-checker to handle variants. In the former case it’s through pattern-matching. The narrowing technique above is sometimes called </span><span class="c7">if-splitting</span><span class="calibre3">, because an </span><code>if</code><span class="calibre3"> (which </span><code>cond</code><span class="calibre3"> and other conditional constructs desugar to) “splits” the union. You will sometimes also see the terms </span><span class="c7">occurrence typing</span><span class="calibre3"> and </span><span class="c7">flow typing</span><span class="c4"> to describe variants of the ideas in this chapter.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> This idea was invented by </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.racket-lang.org/ts-guide/occurrence-typing.html&amp;sa=D&amp;source=editors&amp;ust=1695232021469775&amp;usg=AOvVaw0FOrR34cG9UC9PeiZoFxr8">Typed Racket</a></span><span class="c4"> by studying how programmers write code in Scheme and Racket programs. It has later proved to be relevant to many real-world retrofitted type systems.</span></p>

<h2 class="c27" id="h.bq382as7rh4u"><span class="c4">Introducing Union Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">As we discussed when evaluating conditionals [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936">👉</a></span><span class="c4">], union types can be useful to represent partial functions. There are several ways of handling them:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&amp;sa=D&amp;source=editors&amp;ust=1695232021470794&amp;usg=AOvVaw0tfeqewvVEB-EA9H442jKE">https://dcic-world.org/2022-08-28/partial-domains.html</a></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Using an option type avoids the need for ad-hoc type unions. If we have unions anyway, however, then we can give types to partial functions: e.g., </span><code>(V U Boolean)</code><span class="calibre3"> in Racket or </span><code>(V U None)</code><span class="calibre3"> in Python, respectively, where </span><code>V</code><span class="calibre3"> is the normal return type. Thus, Racket’s </span><code>string-&gt;number</code><span class="calibre3"> can be given the type </span><code>(Number U Boolean)</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What we’ve just seen is that with if-splitting, we can eliminate union types. That then raises the possibility that we can also introduce union types! One way is of course by giving union types to built-in functions, as above. But what about in user programs? Previously we had rejected such a solution: if we introduced a union, we had no way to deal with it. Now we can safely introduce them in languages that have solutions for deconstructing them.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">How do we introduce union types? Curiously, using the same construct that eliminates them! Observe that we no longer need both branches of a conditional to return the same type:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- C : Bool    </code><span class="c97">Γ </span><code>|- T : V    </code><span class="c97">Γ </span><code>|- E : W</code></p><pre>-----------------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (if C T E) : (U V W)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where our notation means “the union of the types represented by </span><code>V</code><span class="calibre3"> and </span><code>W</code><span class="c4">”.</span></p>

<h2 class="c27" id="h.n8627oz7x8jd"><span class="c4">How Many Unions?</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">When we wrote an algebraic datatype, the variants “belonged” to the new type. We had no mechanism for mixing-and-matching variants.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In contrast, with union types, a new type is a collection of existing types. There’s nothing that prevents those existing types from engaging in several different unions. For instance, we had</span></p><p class="c3"><span class="c4"/></p><pre>(define-type-alias BT (U mt node))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But we could also write, say,</span></p><p class="c3"><span class="c4"/></p><pre>(struct link ((v : Number) (r : LinkedList)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and reusing mt to define</span></p><p class="c3"><span class="c4"/></p><pre>(define-type-alias LinkedList (U mt link))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Therefore, given an mt, what “is” it? Is it a </span><code>BT</code><span class="calibre3">? A </span><code>LinkedList</code><span class="calibre3">? It’s all those, but it’s also just an </span><code>mt</code><span class="calibre3">, which can participate in any number of unions. This provides a degree of flexibility that we don’t get with algebraic datatypes—since we can create ad-hoc unions of existing types—but that also means it becomes harder to tell all the ways a value might be used, and also complicates inferring types (if we see an </span><code>mt</code><span class="calibre3"> constructed, are we also constructing a </span><code>BT</code><span class="calibre3">? a </span><code>LinkedList</code><span class="calibre3">?). The Hindley-Milner inference algorithm [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_115.html#h.bheym24u3ntv">👉</a></span><span class="c4">] doesn’t cover these cases, though it can be extended to do so.</span></p>

<h2 class="c27" id="h.71ezdj4s2c3z"><span class="c4">Union Types and Space</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Therefore, union types combined with if-splitting gives us an alternate approach of obtaining something akin to algebraic datatypes in our programming language. However, we don’t obtain the space benefits of the algebraic datatype definition. We created two distinct types; in principle, that’s not a problem. However, to write programs, we needed to have predicates (</span><code>mt?</code><span class="calibre3"> and </span><code>node?</code><span class="calibre3">) that took </span><span class="c7">any</span><span class="calibre3"> value. Therefore, those predicates need type-tags on the values to be able to tell what kind of value they are looking at. Observe that these are </span><span class="c7">type</span><span class="calibre3"> tags, not </span><span class="c7">variant</span><span class="c4"> tags, so the amount of space they need is proportional to the number of types in the whole program, not just the number of variants in that particular algebraic datatype definition.</span></p>

<h2 class="c27" id="h.go4qznyl2cip"><span class="c4">If-Splitting with Control Flow</span></h2><p class="c5"><span class="c4">This pattern, of dispatching based on type-tests and values, is quite common in dynamic (or “scripting”) languages. These languages do not have a static type system, but they do have safe run-times, which attach type tags to values and provide predicates that can check them. Programmers then adopt programming patterns that take advantage of this.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> The term </span><span class="c7">dynamic</span><span class="calibre3"> language seems to have no clear fixed definition. It means, at least, that the language doesn't have static types. Sometimes it's implicit that the language is nevertheless safe. But some people use it to mean that the language has features that let you do things like inspect or even modify the program as it's running (features like </span><code>eval</code><span class="c4">). In this book I use it in the second sense: not-statically typed, but still safe.</span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> What, then, is a “scripting” language? I use the term to mean a dynamic language that is also very liberal with its types: e.g., many operations are either overloaded and/or very forgiving of what a statically-typed language would consider an error. Scripting languages tend to be dynamic in all three senses: they do not have a static type-system, they are safe, and they tend to have rich features for introspection and even modification. They are designed to maximize expressiveness and thus minimize just about any useful static analysis.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">For instance, here’s an example from JavaScript, of a serialization function. A serializer takes a value of (almost) </span><span class="c7">any</span><span class="c4"> type and converts it into a string to be stored or transmitted. (This version is adapted from version 1.6.1 of Prototype.js.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3"/><code>function serialize(val) {</code></p><pre>  switch (typeof val) {
    case "undefined":
    case "function": 
      return false;
    case "boolean":
      return val ? "true" :
                   "false";
    case "number":
      return "" + val;
    case "string":
      return val;
  }
  if (val === null)
    { return "null"; } 
  
  var fields = [ ];
  for (var p in val) {
    var v = serialize(val[p]);
    if (typeof v === "string") {
      fields.push(p + ": " + v);
    }
  }
  return "{ " + 
         fields.join(", ") + 
         " }";
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now suppose we’re trying to retrofit a type system onto JavaScript. We would need to type-check such programs. But before we even ask </span><span class="c7">how</span><span class="c4"> to do it, we should know what answer to expect: i.e., is this program even type-safe?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The answer is quite subtle. It uses JavaScript’s </span><code>typeof</code><span class="calibre3"> operator to check the tags. For two kinds of values, it returns </span><code>false</code><span class="calibre3"> (that is, the type of this function is not </span><code>Any -&gt; String</code><span class="calibre3">, it’s actually </span><code>Any -&gt; (String U Boolean)</code><span class="calibre3">, where the </span><code>false</code><span class="calibre3"> value is used to signal that the value can’t be serialized—observe that an actual </span><code>false</code><span class="calibre3"> value is serialized to </span><code>"false"</code><span class="calibre3">). For Booleans, numbers, and strings, it translates them appropriately into strings. In all these cases, execution returns. (Note, however, that the code also exploits JavaScript’s “fall-through” behavior in </span><code>switch</code><span class="calibre3">, so that </span><code>"undefined"</code><span class="calibre3"> and </span><code>"function"</code><span class="c4"> are treated the same without having to repeat code. The type-checker needs to understand this part of JavaScript semantics.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If none of these cases apply, then execution falls through; we need to know enough JavaScript to know that this corresponds to the one other return from </span><code>typeof</code><span class="calibre3">, namely objects. Now the code splits between objects that are and aren’t </span><code>null</code><span class="calibre3">. In the non-</span><code>null</code><span class="c4"> case, it iterates through each field, serializing it in turn. Therefore, this program is actually type-safe…but for very complicated reasons!</span></p>

<h2 class="c27" id="h.69zcn56ptd5w"><span class="c4">If-Splitting with Control Flow and State</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Here’s another program, taken from the Python 2.5.2 standard library:</span></p><p class="c3"><span class="c41"/></p><pre>def insort_right(a, x, lo=0, hi=None):
    if hi is None:
        hi = len(a)
    while lo &lt; hi:
        mid = (lo+hi)//2
        if x &lt; a[mid]: hi = mid
        else: lo = mid+1
    a.insert(lo, x)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This function inserts an element (</span><code>x</code><span class="calibre3">) into an already-sorted list (</span><code>a</code><span class="calibre3">). It also takes a low search interval index (</span><code>lo</code><span class="calibre3">), which defaults to </span><code>0</code><span class="calibre3">, and a high interval (</span><code>hi</code><span class="calibre3">), which defaults to </span><code>None</code><span class="c4">. It inserts the element into the right place in the array.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s ask whether this is actually type-correct. Observe that </span><code>lo</code><span class="calibre3"> and </span><code>hi</code><span class="c4"> are used in several arithmetic operations. These are the ones we’re most interested in.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If it helps, here’s the code with type annotations in </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://github.com/facebookincubator/cinder&amp;sa=D&amp;source=editors&amp;ust=1695232021481698&amp;usg=AOvVaw2pIqSg2CpkTCGrPRBDemlf">Static Python</a></span><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>from typing import Optional</pre><p class="c3"><span class="c41"/></p><pre>def insort_right(a, x, lo: int = 0, hi: Optional[int] = None):
    if hi is None:
        hi = len(a)
    while lo &lt; hi:
        mid = (lo+hi)//2
        if x &lt; a[mid]:
            hi = mid
        else:
            lo = mid+1
    a.insert(lo, x)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(In Static Python, </span><code>Optional[T]</code><span class="calibre3"> is an abbreviation for </span><code>(T U None)</code><span class="calibre3">. So the annotation on </span><code>hi</code><span class="calibre3"> above allows the user to pass in either an </span><code>int</code><span class="calibre3"> or </span><code>None</code><span class="calibre3">. What makes the last two arguments optional is (perhaps confusingly) not the type </span><code>Optional</code><span class="c4"> but rather the fact that they have default values in the function header.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">It’s easier to see what’s happening with </span><code>lo</code><span class="calibre3">: it’s allowed to be optional; if the optional argument is provided, it must be an </span><code>int</code><span class="calibre3">; and if it’s not provided, it has value </span><code>0</code><span class="calibre3">, which also has type </span><code>int</code><span class="calibre3">. So its type is effectively </span><code>(int U int)</code><span class="calibre3">, which is just </span><code>int</code><span class="calibre3">, so all uses of </span><code>lo</code><span class="calibre3"> as an </span><code>int</code><span class="c4"> are fine.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But now consider the type of </span><code>hi</code><span class="calibre3">. It is also optional. If it is provided, it has to be an </span><code>int</code><span class="calibre3">, which would be fine. But if it’s </span><span class="c7">not</span><span class="calibre3"> provided, its value is </span><code>None</code><span class="calibre3">, which cannot be used in arithmetic. However, right at the top, the function checks whether it is </span><code>None</code><span class="calibre3"> and, if so, </span><span class="c7">changes</span><span class="calibre3"> it to the result of </span><code>len(a)</code><span class="calibre3">—which is an </span><code>int</code><span class="calibre3">. Therefore, once the if is done, no matter which path the program takes, </span><code>hi</code><span class="calibre3"> is an </span><code>int</code><span class="c4">. Thus, the program is actually type-safe.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">That’s all well and good for us to reason about by hand. However, our job is to build a type-checker that will neither reject programs needlessly nor approve type-incorrect programs. This balance is very hard to maintain.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This represents the challenge retrofitted type system designers face: they must either reject idiomatic programs or add complexity to the type system to handle them. If we reject the program, we reject many other programs like it, which are idiomatically found in many “scripting” languages. The result would be very safe, but also very useless—indeed, safe </span><span class="c7">because</span><span class="c4"> it would be very useless—type-checker (a type-checker that rejects every program would be extremely safe…). Instead, we need an even more complicated solution than what we have seen until now.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> See </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/people/sk/Publications/Papers/Published/gsk-flow-typing-theory/&amp;sa=D&amp;source=editors&amp;ust=1695232021485488&amp;usg=AOvVaw2-6nKeOUE7cQ6F3KqzAJ7z">this paper</a></span><span class="calibre3"> for how to type such programs.</span></p>

<h2 class="c27" id="h.bwvc7krwcbb9"><span class="c4">The Price of Retrofitting</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Retrofitting a type-system onto an existing untyped language clearly puts a heavy burden on the creator of the type system. But it also puts a burden on developers. If the type system is to not reject a bunch of existing code, then it must be based on some heuristics about program structure. The more complex these heuristics grow (as we’ve seen hints of in this chapter), the stranger it will be when a program falls outside what they can handle.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">You might argue that it was ever thus: when type-checking algebraic datatypes, too, we had to use pattern-matching to help the type-checker. The difference there is that the type-checker was around at program </span><span class="c7">construction</span><span class="c4"> time, so we adhered to its rules from the very start; we didn’t try to add types after the fact. The problem arises when programmers are allowed to write code however they like, and the type-checker must retroactively try to bless them.</span></p>

<h2 class="c27" id="h.97wxiumnq341"><span class="c4">Types and Tags</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Finally, we should clarify something important about the </span><code>typeof</code><span class="calibre3"> operator in JavaScript, which is analogous to the </span><code>type</code><span class="calibre3"> function in Python. When we impose a type system on JavaScript, we expect, say, the type </span><code>(Number -&gt; String)</code><span class="calibre3"> to be different from the type </span><code>(String -&gt; Boolean)</code><span class="calibre3">. Similarly, an object that contains only the fields </span><code>x</code><span class="calibre3"> and </span><code>y</code><span class="calibre3"> is very different from the object that contains only the method </span><code>draw</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">However, these nuances are lost on </span><code>typeof</code><span class="calibre3">, which is innocent to even the existence of any such type systems. Therefore, all those functions are lumped under one tag, </span><code>"function"</code><span class="calibre3">, and all those objects are similarly treated uniformly as one tag, </span><code>"object"</code><span class="calibre3"> (and analogously in Python). This is because their names are misleading: what they are reporting are not the </span><span class="c7">types</span><span class="calibre3"> but rather the run-time </span><span class="c7">tags</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The difference between types and tags can grow arbitrarily big. After all, the number of types in a program can grow without bound, and so can their size (e.g., you can have a list of lists of arrays of functions from …). But the set of tags is fixed in many languages, though in those that allow you to define new (data)classes, this set might grow. Nevertheless, tags are meant to take up a fixed amount of space and be checked in a small constant amount of time.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Of course, this difference is not inherently problematic. After all, even in statically-typed languages with algebraic datatypes, we still need space to track variants, which requires a kind of (intra-type) tag. The issue is rather with the choice of </span><span class="c7">name</span><span class="calibre3">: that </span><code>typeof</code><span class="calibre3"> and </span><code>type</code><span class="calibre3"> do not, actually, return “types”. A more accurate name for them would be something like </span><code>tagof</code><span class="c4">, leaving the term “type” free for actual static type systems.</span></p>

<h1 class="c22" id="h.x5r0sn73vjq0"><span class="c4">Nominal Types, Structural Types, and Subtyping</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s go back to</span></p><p class="c3"><span class="c4"/></p><pre>(define-type BT
  [mt]
  [node (v : Number) (l : BT) (r : BT)])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and ask how we could have represented this in Java.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now:</span><span class="c4"> Represent this in Java!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">How did you do it? Did you create a single class with </span><code>null</code><span class="c4"> for the empty case?</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> Why is that solution not object-oriented?</span></p>

<h2 class="c27" id="h.w7cavichendz"><span class="c4">Algebraic Datatypes Encoded With Nominal Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We’ll take a different approach. Observe from the datatype definition that we have two constructors, and one type that represents their union. We can encode this in Java as:</span></p><p class="c3"><span class="c4"/></p><pre>abstract class BT {
  abstract public int size();
}</pre><p class="c3"><span class="c41"/></p><pre>class mt extends BT {
  public int size() {
    return 0;
  }
}</pre><p class="c3"><span class="c41"/></p><pre>class node extends BT {
  int v;
  BT l, r;
  node(int v, BT l, BT r) {
    this.v = v;
    this.l = l;
    this.r = r;
  }
  public int size() {
    return 1 + this.l.size() + this.r.size();
  }
}</pre><p class="c3"><span class="c41"/></p><pre>class Main {
  public static void main(String[] args) {
    BT t = new node(5, new node(3, new mt(), new mt()), new mt());
    System.out.println(t.size());
  }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">How is the “if-splitting” addressed here? It’s done in a hidden way, through dynamic dispatch. When we invoke a method, Java makes sure we run the right method: there are actually two concrete </span><code>size</code><span class="calibre3"> methods, and the run-time picks the right one. Once that choice is made, the class in which the method resides automatically determines what is bound. Thus, the </span><code>size</code><span class="calibre3"> in </span><code>node</code><span class="calibre3"> can safely use </span><code>this.l</code><span class="calibre3"> and </span><code>this.r</code><span class="c4">, and the type-checker knows that those fields exist.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This is, then, similar to, yet different from, our two prior solutions: using algebraic datatypes and union types. The solutions are structurally different, but they are all similar in that some </span><span class="c7">syntactic</span><span class="c4"> pattern must be used to make the program statically type-able. With algebraic datatypes, it was pattern-matching; with union types, it was if-splitting; in Java, it’s the splitting of the code into separate methods.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The algebraic datatype and Java solutions are even more connected than we might imagine. With algebraic datatypes, we fixed the set of variants; but we were free to add new functions </span><span class="c7">without having to edit existing code</span><span class="calibre3">. In Java, we fix the set of behaviors (above, one method), but can add new variants without having to edit existing code. Therefore, neither has an inherent advantage over the other, and one’s strengths are the other’s weakness. How to do </span><span class="c7">both</span><span class="calibre3"> at once is the essence of the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Expression_problem&amp;sa=D&amp;source=editors&amp;ust=1695232021492211&amp;usg=AOvVaw3l4_wQP5pOCFZHndfQMdbX">Expression Problem</a></span><span class="calibre3">. See also the concrete examples and approaches given in these two papers, one focusing on a </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&amp;sa=D&amp;source=editors&amp;ust=1695232021492633&amp;usg=AOvVaw2Xm1yq3fY2pVUVr5sWjXEr">Java-based approach</a></span><span class="calibre3"> and another </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kf-ext-sw-def/&amp;sa=D&amp;source=editors&amp;ust=1695232021492914&amp;usg=AOvVaw0SbXWoMkkqB5ySEJa9jMG3">function-centric</a></span><span class="c4">.</span></p>

<h2 class="c27" id="h.gsr5owruw55z"><span class="c4">Nominal Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The type system in Java is representative of an entire class of languages. These have </span><span class="c7">nominal</span><span class="calibre3"> types, which means the </span><span class="c7">name</span><span class="calibre3"> of a class matters. (“Nominal” comes from the Latin </span><span class="c7">nomen</span><span class="c4">, or name.) It’s easiest to explain with an example.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Above we have the following class:</span></p><p class="c3"><span class="c4"/></p><pre>class mt extends BT {
  public int size() {
    return 0;
  }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s now suppose we create another class that is identical in every respect but its name:</span></p><p class="c3"><span class="c4"/></p><pre>class empty extends BT {
  public int size() {
    return 0;
  }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Let’s say we have a method that takes </span><code>mt</code><span class="c4"> objects:</span></p><p class="c3"><span class="c4"/></p><pre>class Main {
  static int m(mt o) {
    return o.size();
  }
  public static void main(String[] args) {
    System.out.println(m(new mt()));
  }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But observe that </span><code>empty</code><span class="calibre3"> is a perfectly good substitute for </span><code>mt</code><span class="calibre3">: it too has a </span><code>size</code><span class="calibre3"> method, which too takes no arguments, and it too returns an </span><code>int</code><span class="c4"> (in fact, the very same value). Therefore, we try:</span></p><p class="c3"><span class="c4"/></p><pre>class Main {
  static int m(mt o) {
    return o.size();
  }
  public static void main(String[] args) {</pre><p class="c5"><code>    System.out.println(m(new </code><span class="c64">empty</span><code>()));</code></p><pre>  }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But Java rejects this. That’s because it expects an object that was constructed by the actual class </span><code>mt</code><span class="calibre3">, not just one that “looks like” it. That is, what matters is which actual (named) class, not what </span><span class="c7">structure</span><span class="c4"> of class, created the value.</span></p>

<h2 class="c27" id="h.vd0ufwwlpdb0"><span class="c4">Structural Types</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In contrast, we can imagine a different type system: one where the type of each of the above classes is not its name but rather a description of what fields and methods it has: i.e., it’s structure, or its “services”. For instance, we might have:</span></p><p class="c3"><span class="c4"/></p><pre>mt : {size : ( -&gt; int)}
node : {size : ( -&gt; int)}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, each of these is a collection of names (one name, to be precise), which is a method that takes no parameters and returns an </span><code>int</code><span class="c4">. Whenever two types are the same, objects of one can be used where objects of the other kind are expected. Indeed, it is unsurprising that both kinds of trees have the same type, because programs that process one will invariably also need to process the other because trees are a union of these two types. Similarly, we also have</span></p><p class="c3"><span class="c4"/></p><pre>empty : {size : ( -&gt; int)}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The above m method might be written as:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>static int m(o </code><span class="c64">: {size : (-&gt; int)}</span><code>) {</code></p><pre>  return o.size();
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, it only indicates what shape of object it expects, and doesn’t indicate which constructor should have made it. This is called </span><span class="c7">structural</span><span class="calibre3"> typing, though the Internet appears to have decided to call this “duck” typing (though it’s hard to be clear: there is no actual theory of duck typing to compare against well-defined theories of structural typing: </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://www.springer.com/gp/book/9780387947754&amp;sa=D&amp;source=editors&amp;ust=1695232021498288&amp;usg=AOvVaw3AweVzQ_7nSMI7klfzt2li">Abadi and Cardelli</a></span><span class="calibre3"> represent a classical viewpoint, and here’s an </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/&amp;sa=D&amp;source=editors&amp;ust=1695232021498703&amp;usg=AOvVaw2EFVs5AkPquJx2jsIUl9pQ">extension</a></span><span class="c4"> for modern “scripting” languages).</span></p>

<h2 class="c27" id="h.9ovtdfd2w9ci"><span class="c4">Nominal Subtyping</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We’ve been writing a bit gingerly about Java above: because we know that the </span><code>m</code><span class="calibre3"> method will accept not only </span><code>mt</code><span class="calibre3">’s but also anything that is a sub-class of </span><code>mt</code><span class="c4">. Let’s explore this further.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To simplify things, let’s make some basic classes:</span></p><p class="c3"><span class="c4"/></p><pre>class A { String who = "A"; }
class B extends A { String who = "B"; }
class C extends A { String who = "C"; }
class D { String who = "D"; }</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We’ll also create a shell “runner”:</span></p><p class="c3"><span class="c4"/></p><pre>class Main {
 public static void main(String[] args) {
   System.out.println((true ? _____ : _____).who);
 }
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and try filling in different values for the blanks and seeing what output we get:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>System.out.println((true ? </code><span class="c64">new B()</span><code> : </code><span class="c64">new B()</span><code>).who);</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Unsurprisingly, this prints </span><code>"B"</code><span class="c4">. What about:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>System.out.println((true ? </code><span class="c64">new B()</span><code> : </code><span class="c64">new A()</span><code>).who);</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">You might expect this to also print </span><code>"B"</code><span class="calibre3">, because that’s the value that we created. However, it actually prints </span><code>"A"</code><span class="c4">! Let’s see a few more examples:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>System.out.println((true ? </code><span class="c64">new B()</span><code> : </code><span class="c64">new C()</span><code>).who);</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Will this print </span><code>"B"</code><span class="calibre3">? No, in fact, this also prints </span><code>"A"</code><span class="c4">! How about:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>System.out.println((true ? </code><span class="c64">new B()</span><code> : </code><span class="c64">new D()</span><code>).who)</code></p><p class="c5"><code>System.out.println((true ? </code><span class="c64">new B()</span><code> : </code><span class="c64">3</span><code>).who)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Both of these produce a static error. It’s instructive to read the error message: in both cases they reference </span><code>Object</code><span class="calibre3">. In the former case, it’s because there is nothing else common to B and D. But in the latter case, the primitive value 3 was effectively converted into an object—</span><code>new Integer(3)</code><span class="c4">—and those two object types were compared.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What is happening in the type system that causes this error? The cause is documented here:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html%23jls-15.25.3&amp;sa=D&amp;source=editors&amp;ust=1695232021502810&amp;usg=AOvVaw13Y12I72q4_WhlbdEUkvSr">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3</a></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Specifically, the document says:</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c4">The type of the conditional expression is the result of applying capture conversion (§5.1.10) to lub(T1, T2).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where “lub” stands for “least upper bound”: the “lowest” class “above” all the given ones. This type is determined </span><span class="c7">statically</span><span class="c4">. That is, the type rule is essentially:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c97">Γ </span><code>|- C : Bool    </code><span class="c97">Γ </span><code>|- T : V    </code><span class="c97">Γ </span><code>|- E : W    X = lub(V, W)</code></p><pre>----------------------------------------------------------</pre><p class="c5"><span class="c97">Γ </span><code>|- (if C T E) : X</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Contrast this to the other rules we’ve seen for conditionals! The first type rule we saw was the most rigid, but produced the most usable values (because there was no ambiguity). The second type rule, for union types, was less rigid, but as a result the output type could have a union that needed to be split. This type rule is even less rigid (in terms of what the two branches produce), but the result could be as general as </span><code>Object</code><span class="c4">, with which we can do almost nothing.</span></p>

<h2 class="c27" id="h.a3b9h8vhxlfm"><span class="c4">Subtyping</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The general principle here is called </span><span class="c7">subtyping</span><span class="calibre3">: we say that type </span><code>X</code><span class="calibre3"> is a subtype of </span><code>Y</code><span class="calibre3">, written </span><code>X &lt;: Y</code><span class="calibre3"> (read the </span><code>&lt;:</code><span class="calibre3"> like a “less than” or “contained”), whenever </span><code>X</code><span class="calibre3"> can be used wherever a </span><code>Y</code><span class="calibre3"> was expected: i.e., </span><code>X</code><span class="calibre3"> can </span><span class="c7">safely</span><span class="calibre3"> be </span><span class="c7">substituted</span><span class="calibre3"> for </span><code>Y</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Java chose to make sub-</span><span class="c7">classes</span><span class="calibre3"> into sub-</span><span class="c7">types</span><span class="calibre3">. Not all object-oriented languages do this, and indeed many consider it to be a mistake, but that’s the design Java has. Therefore, a sub-class is expected to offer at least as many services as its super-class; and hence, it can be substituted where a super-class is expected. The lub computation above finds the </span><span class="c7">most specific</span><span class="c4"> common super-type.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This is an account of how subtyping works for </span><span class="c7">nominal</span><span class="calibre3"> systems. This has the virtue of being fairly easy to understand. We can also define subtyping for </span><span class="c7">structural</span><span class="calibre3"> systems, but that is rather more complex: some parts are easy to follow, other parts are a bit more tricky (but essential to obtain a sound type system). For a detailed explanation, with an illustrative example, see </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://papl.cs.brown.edu/2020/objects.html%23%2528part._subtyping%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021505625&amp;usg=AOvVaw25ykJjwpXl83jpgPY6xeR9">section 33.6.1 of PAPL</a></span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.za7ad4a0uuz"><span class="c4">Gradual Typing</span></h1><h2 class="c23" id="h.n57g5t4oxu2c"><span class="c4">From Scripts to Programs</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">As dynamic language programs grow, they become increasingly hard to maintain. Programmers use types to define interfaces, communicate expectations of behavior, document, and so on, and in their absence, we need several ad hoc tools. Put differently, we want “scripts” to grow up and become “programs”.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Thus, one of the most visible trends in programming languages over the past ten years is dynamic languages adding a static counterpart. In principle, this is as simple as adding a type-system to an existing language. As we’ve already seen when discussing retrofitted types [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt">👉</a></span><span class="c4">], however, such a type system needs to take into account the idiomatic style of programming in the language; otherwise it would report as erroneous too many programs that are actually type-correct, and this high false-positive rate would make people not use the type system at all. Therefore, we discussed some patterns of code that need to be supported.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Another major obstacle to adoption is that people often have a large amount of code lying around, and it is simply impractical to convert all of it to a typed language in one go. In fact, some of it may not even be typeable by most reasonable type systems: e.g., the </span><code>eval</code><span class="calibre3"> construct, which takes a </span><span class="c7">dynamic</span><span class="c4"> string (e.g., one that may be constructed on-the-fly during program execution) and runs it. By definition, we statically do not know what this string is; without knowing it, we can’t possibly type it statically.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In short, there are two reasons why we cannot expect the whole program to make an instant transition from untyped to typed:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">The program is too large, and programmers have other things to do with their time.</span></li><li class="c25 pcalibre"><span class="c4">Some parts of the program may not even be typeable.</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(You don’t need </span><code>eval</code><span class="c4"> to make things hard to type. Many dynamic constructs that look at program behavior and modify it have the same flavor. They enter the language because it’s dynamic and doesn’t have to worry about a static type discipline, and then create an obstacle for later typing.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Despite this, type systems have been built for many real-world dynamic languages. These type systems exhibit a property called </span><span class="c7">gradual typing</span><span class="calibre3">: as the name suggests, you add types “gradually” to the program, hopefully making it more-and-more typed. What started out as an academic idea in the Scheme community (two papers in 2006 introduced gradual typing for Scheme) is now </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Gradual_typing&amp;sa=D&amp;source=editors&amp;ust=1695232021507601&amp;usg=AOvVaw0ZgqxCx2wfimBQuPFFxnVE">widely used in industry</a></span><span class="c4">.</span></p>

<h2 class="c27" id="h.wtk3zpm1lfas"><span class="c4">Micro Versus Macro</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In gradual typing, we are going to add annotations to programs and then type-check the program. Within this broad principle, there are two schools of thought.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In “micro” gradual typing we can add annotations to any subset of the variables of the language. We saw this earlier in the Static Python example:</span></p><p class="c3"><span class="c4"/></p><pre>def insort_right(a, x, lo: int = 0, hi: Optional[int] = None):</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here, we have annotations on </span><code>lo</code><span class="calibre3"> and </span><code>hi</code><span class="calibre3">, but not on </span><code>a</code><span class="calibre3"> and </span><code>x</code><span class="calibre3">. Ergonomically, this is very convenient for the programmer: use annotations for the parts you care about, and not for the parts you don’t. Unfortunately, this comes at a cost: there is now a much more complex language where any parts of a program can be static and any other parts dynamic, and they can freely commingle in the same body of code, even in a single expression or line (e.g., from the same example: </span><code>hi = len(a)</code><span class="calibre3">). The type system needs to somehow deal with constructs it cannot meaningfully type (like </span><code>eval</code><span class="c4">). Also, previously we had a clean and simple soundness result for the typed program; now it is rather unclear what soundness means. In turn, that means that programmers may put a lot of effort into annotations, but without a clear guarantee of what they are getting in return. (A large body of literature now tries to make sense of this.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In contrast, there is another approach, often called “macro” gradual typing. In the macro approach, there are </span><span class="c7">two languages</span><span class="calibre3">: the typed and the dynamic one. They are expected to be very similar—so similar that they have the same run-time system and can freely share values—so we’ll refer to them as “sibling” languages. However, they may not have the same constructs (e.g., the typed language would not contain </span><code>eval</code><span class="calibre3">). Instead of freely mixing code between typed and untyped, we only have to figure out what happens when values travel </span><span class="c7">between</span><span class="c4"> the languages, not within each one. The expectation is that the programmer will gradually migrate part of their codebase from the dynamic to the typed language, typically a function at a time. Each language can import code from the other, but when importing into typed code, the programmer must specify a type for the imported code.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">A canonical example of this approach is Typed Racket. Because Typed Racket is one of the oldest and most developed gradually typed languages (technically, it’s the </span><span class="c7">combination</span><span class="c4"> of Racket and Typed Racket that is gradually typed—Typed Racket itself is fully typed), and also offers some of the most interesting perspective on what happens when values travel between languages, we will use that as our exemplar for study.</span></p>

<h2 class="c27" id="h.a3ij6ys6ziqq"><span class="c4">Typed Racket at Work</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In what follows, it’s critical to pay attention to the exact details of error messages!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">First, let’s write the following function in </span><code>#lang racket</code><span class="c4"> and test it out:</span></p><p class="c3"><span class="c4"/></p><pre>(define (g s)
  (+ 1 (or (string-&gt;number s) 0)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">As we would expect,</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (g "5")
6</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">because the string represents a valid number,</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (g "hi")
1</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">because the string doesn’t represent a valid number, and</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (g 5)</pre><p class="c5"><span class="c73">string-&gt;number: contract violation</span></p><p class="c5"><span class="c73">  expected: string?</span></p><p class="c5"><span class="c73">  given: 5</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">because </span><code>5</code><span class="c4"> isn’t a string at all.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s define it in Typed Racket:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3"/><code>#lang typed/racket</code></p><p class="c3"><span class="c41"/></p><pre>(define (f [s : String]) : Number
  (+ 1 (or (string-&gt;number s) 0)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The type-checker confirms that this program is well-typed.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="c4"> As a test, try</span></p><p class="c51"><span class="c4"/></p><pre>(define (f [s : String]) : Number
  (+ 1 (string-&gt;number s)))</pre><p class="c51"><span class="c4"/></p><p class="c31"><span class="c4">and see what happens.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now suppose we export this function from Typed Racket:</span></p><p class="c3"><span class="c4"/></p><pre>(provide f)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and import it into the Racket module:</span></p><p class="c3"><span class="c4"/></p><pre>(require "typed.rkt") ;; or whatever filename you’ve chosen</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s try the same three tests. Predictably, two of them work the same:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (f "5")
6
&gt; (f "hi")
1</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The third still produces an error, but a rather different kind of error:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (f 5)</pre><p class="c5"><span class="c73">f: contract violation</span></p><p class="c5"><span class="c73">  expected: string?</span></p><p class="c5"><span class="c73">  given: 5</span></p><p class="c5"><span class="c73">  in: the 1st argument of</span></p><p class="c5"><span class="c73">      (-&gt; string? any)</span></p><p class="c5"><span class="c73">  contract from: typed.rkt</span></p><p class="c5"><span class="c73">  blaming: untyped.rkt</span></p><p class="c5"><span class="c73">   (assuming the contract is correct)</span></p><p class="c5"><span class="c73">  at: typed.rkt:5:9</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here’s what is happening. When we export f from Typed Racket, we don’t just export the function in its raw form. Rather, Typed Racket wraps the function in </span><span class="c7">contracts</span><span class="c4"> that “protect” it in a dynamic setting. Thus, it is as if the function that was exported was</span></p><p class="c3"><span class="c4"/></p><pre>(define (wrapped-f s)
  (if (string? s)
      (let ([b (+ 1 (or (string-&gt;number s) 0))])
        (if (number? b)
            b
            (error 'contract "returned value was not a Number")))
      (error 'contract "provided value was not a String")))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(with suitably different error messages). Notice that </span><code>wrapped-f</code><span class="calibre3"> behaves exactly like our imported </span><code>f</code><span class="calibre3"> does: the error when given </span><code>5</code><span class="c4"> is from a contract check, rather than from an internal operation. Observe also that this wrapped version is quite easy to produce in a completely mechanical way, i.e., through desugaring:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(define (f [</code><span class="c115">s</span><code> : </code><span class="c116">String</span><code>]) : </code><span class="c101">Number</span></p><p class="c5"><code>  </code><span class="c115">(+ 1 (or (string-&gt;number s) 0))</span><code>)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">became</span></p><p class="c3"><span class="c4"/></p><p class="c5"><code>(define (wrapped-f </code><span class="c115">s</span><code>)</code></p><p class="c5"><code>  (if (</code><span class="c116">string?</span><code> </code><span class="c115">s</span><code>)</code></p><p class="c5"><code>      (let ([b </code><span class="c115">(+ 1 (or (string-&gt;number s) 0))</span><code>])</code></p><p class="c5"><code>        (if (</code><span class="c103">number?</span><code> b)</code></p><pre>            b</pre><p class="c5"><code>            (error 'contract "returned value was not a </code><span class="c103">Number</span><code>")))</code></p><p class="c5"><code>      (error 'contract "provided value was not a </code><span class="c116">String</span><code>")))</code></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Why do we bind </span><code>b</code><span class="c4"> to the result of the body? Why not use the body expression directly?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The point of this wrapping is to put the type annotations to work in a dynamic setting. Essentially, the programmer who has put the effort to add annotations and get the program through the type-checker gets assurance that their function will not be abused through checks that are early and more informative than an internal error (that may not even occur, depending on the inputs, leaving the error to lurk!).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Here is a more interesting example. We define the following typed function:</span></p><p class="c3"><span class="c4"/></p><pre>(define (h [i : (-&gt; String Number)]) : Number
  (+ (i "5") 1))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Here is its Racket counterpart:</span></p><p class="c3"><span class="c4"/></p><pre>(define (j i)
  (+ (i "5") 1))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s assume we are trying to use both of these from Racket. We first define a function that produces strings from strings, i.e., one that does </span><span class="c7">not</span><span class="calibre3"> match the function expected by either </span><code>h</code><span class="calibre3"> or </span><code>j</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(define (str-dbl s) (string-append s s))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now watch what happens when we run </span><code>(j str-dbl)</code><span class="calibre3"> and </span><code>(h str-dbl)</code><span class="calibre3">. Both produce a run-time error, but very different ones. The former (which is entirely in Racket) gives an error at </span><code>+</code><span class="calibre3">: the “doubled” string is produced and makes it as far as </span><code>+</code><span class="calibre3">, which reports a violation. In contrast, in the latter case, the doubled string is produced but, when it tries to return from </span><code>(i "5")</code><span class="calibre3">, the type </span><code>(-&gt; String Number)</code><span class="calibre3"> has been turned into a contract, which halts execution saying that there is a </span><span class="c7">contract</span><span class="c4"> violation!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> To get a sense of Racket’s contract system, see </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://docs.racket-lang.org/guide/contracts.html&amp;sa=D&amp;source=editors&amp;ust=1695232021518320&amp;usg=AOvVaw3cHKDevH_K7R7ne4KDUsP7">Contracts</a></span><span class="c4"> in the Racket Guide.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="calibre3">Another interesting static-dynamic language combination is Racket with plait. plait does not try very much to accommodate Racket idioms, though it does to some extent: recall the predicates and accessors in algebraic dataytypes [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk">👉</a></span><span class="c4">], though at the cost of static type safety. Largely, however, plait is trying to implement the Standard ML type language. Nevertheless, because plait lives in the context of Racket, its values can be exported and used from Racket. Try the above examples in plait!</span></p>

<h1 class="c14" id="h.70owrbm6k2ld"><span class="c4">••••• Non-Standard Models •••••</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c32">We have already seen some non-standard features, but they are in widespread use. Here we look at some that are less widely used (though some are growing in prominence, and others are enjoying a renaissance) but provide fascinating views of what programming languages can do.</span></p>

<h1 class="c22" id="h.19zaqlbd627k"><span class="c4">Relations</span></h1><h2 class="c23" id="h.q48qr189ipzq"><span class="c4">A Language Genealogy</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Suppose we want to record a genealogy of programming languages and determine which languages obtained ideas from which ones. We start by recording which languages directly borrowed ideas from which ones: e.g., Java directly borrowed from C++, and C++ directly borrowed from C. From that, we can also trace the descendants down a chain of borrowing.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We will write some of these in the following, maybe peculiar, syntax:</span></p><p class="c3"><span class="c4"/></p><pre>borrows(A, B)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">means that the language </span><code>A</code><span class="calibre3"> borrows from the language </span><code>B</code><span class="calibre3"> (i.e., </span><code>A</code><span class="calibre3"> is newer, </span><code>B</code><span class="calibre3"> is older). For another peculiar reason, we will write constants not as quotes but as alphanumeric strings with a </span><span class="c7">lower-case initial</span><span class="calibre3">. Given that, here are some facts (with </span><code>cpp</code><span class="c4"> standing for C++):</span></p><p class="c3"><span class="c4"/></p><pre>borrows(java, cpp).
borrows(cpp, c).
borrows(c, bcpl).
borrows(pascal, algol).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we can express the notion of being a descendant: there are two ways that </span><code>A</code><span class="calibre3"> can be a descendant of </span><code>B</code><span class="calibre3">. One is if </span><code>A</code><span class="calibre3"> borrows directly from </span><code>B</code><span class="calibre3">. The other is if it borrows from some language </span><code>Z</code><span class="calibre3"> that is itself a descendant of </span><code>B</code><span class="c4">. We express these two rules using this syntax:</span></p><p class="c3"><span class="c4"/></p><pre>descends(A, B) :- borrows(A, B).
descends(A, B) :- borrows(A, Z), descends(Z, B).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Congratulations, you’ve just written your first </span><span class="c40">Prolog</span><span class="calibre3"> program. To see this run, you can use </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://swish.swi-prolog.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021521364&amp;usg=AOvVaw3htfQEX93FhT5bpRmnE6re">SWI Prolog online</a></span><span class="c4">. But what does it mean to “run” this? Prolog answers questions: we can ask several questions like:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">Does </span><code>cpp</code><span class="c7"> borrow from </span><code>c</code><span class="c7">?</span></p><pre>borrows(cpp, c).</pre><p class="c5"><span class="c4">→ true</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">Does </span><code>cpp</code><span class="c7"> borrow from </span><code>bcpl</code><span class="c32">?</span></p><pre>borrows(cpp, bcpl).</pre><p class="c5"><span class="c4">→ false</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">That is, we can see that Prolog is acting like a basic database. But we can do more:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">Does </span><code>cpp</code><span class="c7"> descend from </span><code>bcpl</code><span class="c32">?</span></p><pre>descends(cpp, bcpl).</pre><p class="c5"><span class="c4">→ true</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">Does </span><code>bcpl</code><span class="c7"> descend from </span><code>cpp</code><span class="c32">?</span></p><pre>descends(bcpl, cpp).</pre><p class="c5"><span class="c4">→ false</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Aha: so Prolog will not only query basic facts, it will also process queries through rules.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But we can actually ask Prolog more sophisticated questions that look more like function applications. Consider:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">What does </span><code>cpp</code><span class="c7"> borrow from?</span></p><p class="c5"><span class="c4">borrows(cpp, X).</span></p><p class="c5"><span class="c4">→ </span></p><p class="c5"><span class="c117">X</span><span class="c118"> = </span><span class="c119">c</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This seems to treat borrows like a rather funny function, calling it with a </span><span class="c7">variable</span><span class="c4"> (a name that begins with a capital letter) and letting Prolog fill in the variable. Does that work only for basic definitions, or also for rules?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">What does </span><code>cpp</code><span class="c7"> descend from?</span></p><p class="c5"><span class="c4">descends(cpp, X).</span></p><p class="c5"><span class="c4">→ </span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">c</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">bcpl</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Oh, this is interesting! Prolog didn’t return just one answer; it returned </span><span class="c7">all</span><span class="calibre3"> the answers. And this was done by using a </span><span class="c7">variable</span><span class="calibre3"> (a name that begins with a </span><span class="c7">capital letter</span><span class="c4">). This naturally suggests the question, what if we did it the other way around?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c7">What descends from </span><code>cpp</code><span class="c4">?</span></p><p class="c5"><span class="c4">descends(X, cpp).</span></p><p class="c5"><span class="c4">→ </span></p><p class="c5"><span class="c117">X</span><span class="c118"> = </span><span class="c119">java</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This is even stranger: it’s like passing a variable as an argument and asking what inputs will produce a particular result from the function!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In fact, a function is just the wrong way to think about any of this. What is happening in Prolog is that we’re defining </span><span class="c7">relations</span><span class="c4">. So borrows and descends are actually relations, where one (borrows) is defined by concrete examples and the other (descends) by abstract rules.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Once we understand these are relations, we no longer need to limit ourselves to just one source of borrowing, to better reflect reality. That is, let’s say this is our set of facts:</span></p><p class="c3"><span class="c4"/></p><pre>borrows(java, cpp).
borrows(cpp, c).
borrows(cpp, simula).
borrows(smalltalk, simula).
borrows(self, smalltalk).
borrows(c, bcpl).
borrows(pascal, algol).
borrows(scheme, algol).
borrows(scheme, lisp).
borrows(javascript, self).
borrows(javascript, scheme).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now we can ask what all languages contributed to JavaScript:</span></p><p class="c3"><span class="c4"/></p><pre>descends(javascript, X).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">From this set of facts, we learn:</span></p><p class="c3"><span class="c4"/></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">self</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">scheme</span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">smalltalk</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">simula</span></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">algol</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">lisp</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Similarly, we can ask how widely Lisp’s influence spread:</span></p><p class="c3"><span class="c4"/></p><pre>descends(X, lisp).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">And we learn that for this very limited set of languages:</span></p><p class="c3"><span class="c4"/></p><p class="c120"><span class="c117">X</span><span class="c121"> = </span><span class="c122">scheme</span></p><p class="c123"><span class="c117">X</span><span class="c121"> = </span><span class="c122">javascript</span></p><p class="c3"><span class="c4"/></p>

<h2 class="c27" id="h.v6fayh5pylk0"><span class="c4">Encoding Type Rules</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">You may have noticed that we’re writing rules that are quite similar to the typing rules we’ve written. Let’s see whether we can encode them directly.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">First, we need to encode the rules for syntactic constants:</span></p><p class="c3"><span class="c4"/></p><pre>tc(numE, numT).
tc(strE, strT).
tc(boolE, boolT).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We will use the Prolog constant </span><code>numE</code><span class="c4"> to stand for a syntactic numeric expression, and so on.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now, using just what we already know, we can encode the conditional rules:</span></p><p class="c3"><span class="c4"/></p><pre>tc(plusE(L, R), numT) :-
    tc(L, numT),
    tc(R, numT).</pre><p class="c3"><span class="c41"/></p><pre>tc(catE(L, R), strT) :-
    tc(L, strT),
    tc(R, strT).</pre><p class="c3"><span class="c41"/></p><pre>tc(ifE(C, T, E), Ty) :-
    tc(C, boolT),
    tc(T, Ty),
    tc(E, Ty).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Note that this is literally just a syntactic transformation of the rules we wrote before!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">With this, we can now use Prolog as a </span><span class="c7">checker</span><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>tc(ifE(boolE, plusE(numE, numE), numE), numT).</pre><p class="c5"><span class="c4">→ true</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and as a </span><span class="c7">calculator</span><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>tc(ifE(boolE, plusE(numE, numE), numE), Y).</pre><p class="c5"><span class="c4">→ </span></p><p class="c5"><span class="c117">Y</span><span class="c118"> = </span><span class="c119">numT</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But we can do something much more intriguing: what if we leave variables in the </span><span class="c7">program</span><span class="c4">?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">tc(ifE(boolE, plusE(numE, Y), numE), numT).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This is asking Prolog to </span><span class="c7">come up with programs</span><span class="c4"> that will make this program have numeric type. Prolog responds with:</span></p><p class="c3"><span class="c4"/></p><p class="c120"><span class="c117">Y</span><span class="c124"> = </span><span class="c125">numE</span></p><p class="c123"><span class="c117">Y</span><span class="c124"> = </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c127">numE</span><span class="c128">)</span></p><p class="c120"><span class="c117">Y</span><span class="c124"> = </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c127">numE</span><span class="c128">))</span></p><p class="c123"><span class="c117">Y</span><span class="c124"> = </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c126">plusE</span><span class="c124">(</span><span class="c127">numE</span><span class="c124">, </span><span class="c127">numE</span><span class="c124">)))</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(and many more; the structure of terms reveals something about how Prolog works). That is, Prolog is acting as a </span><span class="c7">program synthesizer</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s see how to extend this to include the type environment. For that, we have to enlarge our typing rules to include an environment as well. Recall that the environment doesn’t matter for the axioms, while the other rules just pass the environment through:</span></p><p class="c3"><span class="c4"/></p><pre>tc(numE, _, numT).
tc(strE, _, strT).
tc(boolE, _, boolT).</pre><p class="c3"><span class="c41"/></p><pre>tc(plusE(L, R), Env, numT) :-
    tc(L, Env, numT),
    tc(R, Env, numT).</pre><p class="c3"><span class="c41"/></p><pre>tc(catE(L, R), Env, strT) :-
    tc(L, Env, strT),
    tc(R, Env, strT).</pre><p class="c3"><span class="c41"/></p><pre>tc(ifE(C, T, E), Env, Ty) :-
    tc(C, Env, boolT),
    tc(T, Env, Ty),
    tc(E, Env, Ty).</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">Now let’s add the three variable-oriented rules. We will use a list of </span><code>bind</code><span class="c4"> relations to capture the environment. To look up a variable, we pattern-match on whether the variable is the first binding; if it is we can respond with the relevant type, otherwise we must search in the remaining bindings:</span></p><p class="c3"><span class="c4"/></p><pre>tc(varE(V), [bind(V, T) | _], T).</pre><p class="c3"><span class="c41"/></p><pre>tc(varE(V), [bind(_, _) | RestTEnv], T) :-
   tc(varE(V), RestTEnv, T).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The Prolog notation </span><code>[ … | … ]</code><span class="calibre3"> means to decompose a list into a first, or head, element to the left of the </span><code>|</code><span class="calibre3"> and the rest, or tail, to the right of the </span><code>|</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The other two rules look much more like the type rules we wrote earlier:</span></p><p class="c3"><span class="c4"/></p><pre>tc(lamE(V, B), TEnv, funT(A, R)) :-
    tc(B, [bind(V, A) | TEnv], R).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that in the above rule, we have done away with the type annotation! This rule looks more like what we would write with type </span><span class="c7">inference</span><span class="calibre3"> than with type </span><span class="c7">checking</span><span class="c4">. Finally:</span></p><p class="c3"><span class="c4"/></p><pre>tc(appE(F, A), TEnv, U) :-
    tc(F, TEnv, funT(T, U)),
    tc(A, TEnv, T).</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We can now use these definitions with the example we used for type </span><span class="c7">inference</span><span class="c4">. Let’s translate this program (we have only single-argument functions) from before:</span></p><p class="c3"><span class="c4"/></p><pre>(lambda (v)
  (lambda (w)
    (if v
        (+ w 1)
        (+ w 2))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We pass this to the </span><code>tc</code><span class="c4"> relation, encoded as follows, with the type environment and result type left variable:</span></p><p class="c3"><span class="c4"/></p><pre>tc(lamE(v, 
     lamE(w, 
       ifE(varE(v), 
           plusE(varE(w), numE),
           plusE(varE(w), numE)))), TEnv, T)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Prolog produces the following output:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c117">T</span><span class="c118"> = </span><span class="c129">funT</span><span class="c121">(</span><span class="c119">boolT</span><span class="c121">, </span><span class="c129">funT</span><span class="c121">(</span><span class="c119">numT</span><span class="c121">, </span><span class="c119">numT</span><span class="c121">))</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In other words, it has effectively inferred the type of the function: </span><code>v</code><span class="calibre3"> has Boolean type, </span><code>w</code><span class="c4"> has numeric type, and the result of the whole expression is a number.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In other words, it has </span><span class="c7">inferred</span><span class="c4"> the types of the parameters. Now let’s consider some type-erroneous programs:</span></p><p class="c3"><span class="c4"/></p><pre>tc(lamE(v, ifE(boolE, strE, numE)), _, _)</pre><p class="c5"><span class="c4">→ false</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Here, Prolog tells us it can’t find any variable name that would satisfy this shape of program. But if instead we give it a program with holes to fill in for expressions:</span></p><p class="c3"><span class="c4"/></p><pre>tc(lamE(w, ifE(A, strE, numE)), _, _)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Prolog tries to build bigger and bigger terms that might work, and goes into an infinite loop trying to find a program that is typeable! In general, this is a problem for synthesis systems: if the problem they are given has a solution they can often find one quickly, but if it does not have a solution, they have to spend a long time trying to find one—either very long, if it’s a large but finite space to search, or infinitely long, if the space is infinite. Often, synthesizers will use heuristics to truncate this search.</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.kus22glln4xa"><span class="c4">Generators</span></h1><h2 class="c23" id="h.lj5w51p6s1j8"><span class="c4">A Canonical Example</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Consider the following canonical Python program that uses generators:</span></p><p class="c3"><span class="c4"/></p><pre>def nats():
  n = 0
  while True:
    yield n
    n += 1</pre><p class="c3"><span class="c41"/></p><pre>g = nats()</pre><p class="c3"><span class="c41"/></p><pre>next(g) + next(g) + next(g)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">produces </span><code>0 + 1 + 2</code><span class="calibre3"> = </span><code>3</code><span class="c4">. But how does it work?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">At a textual level, we can understand it as follows. </span><code>nats</code><span class="calibre3"> looks like a function, but it has the keyword </span><code>yield</code><span class="calibre3"> in it. This makes it not a function but a </span><span class="c7">generator</span><span class="calibre3">. Its body initializes </span><code>n</code><span class="calibre3"> to </span><code>0</code><span class="calibre3">, then goes into an infinite loop. Each time through the loop, it </span><span class="c7">yields</span><span class="calibre3"> the current value of </span><code>n</code><span class="c4">, then increments it, before continuing the loop.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Outside the definition of </span><code>nats</code><span class="calibre3">, we define </span><code>g</code><span class="calibre3"> to be an </span><span class="c7">instance</span><span class="calibre3"> of the generator, and each call to </span><code>next</code><span class="calibre3"> gets the next yielded value. This explains the result. What we need to do is understand what is going on inside </span><code>nats</code><span class="c4">, and hence what happens with generators in general.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">It is clear that we </span><span class="c7">cannot</span><span class="calibre3"> think of </span><code>nats</code><span class="calibre3"> (or of the generator returned by it) as a function. If we do, then clearly it goes into an infinite loop. That means the very first </span><code>next</code><span class="calibre3"> call would run forever; it would never produce a value, which enables the next </span><code>next</code><span class="c4"> call, and then the third, producing the sum. To see this, imagine we had the following version instead:</span></p><p class="c3"><span class="c4"/></p><pre>def natsr():
  n = 0
  while True:
    return n
    n += 1</pre><p class="c3"><span class="c41"/></p><pre>natsr() + natsr() + natsr()</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here, even though natsr (“</span><code>nats</code><span class="calibre3"> with </span><code>return</code><span class="calibre3">”) has an infinite loop, every time Python runs the </span><code>return</code><span class="calibre3">, it halts the function and returns. Furthermore, on the next call, we start again from the beginning of </span><code>natsr</code><span class="calibre3">. As a result, each call produces </span><code>0</code><span class="calibre3"> so the sum is also </span><code>0</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In contrast, that is clearly not what is happening in (the generator created by) </span><code>nats</code><span class="calibre3">. Rather, it’s clear that—as the name </span><code>yield</code><span class="calibre3"> suggests—the computation is </span><span class="c7">halting</span><span class="calibre3"> when the </span><code>yield</code><span class="calibre3"> occurs. When we call </span><code>next</code><span class="calibre3">, computation does not start at the top of </span><code>nats</code><span class="calibre3">; if it did, </span><code>n</code><span class="calibre3"> would be </span><code>0</code><span class="calibre3">. Instead, it </span><span class="c7">resumes</span><span class="calibre3"> from where it left off, so that the value of </span><code>n</code><span class="calibre3"> is incremented and the next iteration of the </span><code>while</code><span class="c4"> loop occurs.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If all of this sounds suspiciously like variables in a scope being held on to by a closure, you’re on the right track. To understand this more, though, we need to peer a bit more closely at the evaluation. While we could run this in the </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://pythontutor.com/python-debugger.html%23mode%3Dedit&amp;sa=D&amp;source=editors&amp;ust=1695232021543587&amp;usg=AOvVaw1V3VjgOrP0CFbXmfhLsC-A">Python Tutor</a></span><span class="c4">, that tool does not really have the support necessary for us to understand what is happening in this program. Instead, we will turn to our Stacker.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">In Python, generators are merely syntactic sugar over the more general notion of </span><span class="c7">iterators</span><span class="calibre3">. Iterators respond to the </span><code>next</code><span class="calibre3"> protocol. To learn how a generator desugars into an iterator, see </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators&amp;sa=D&amp;source=editors&amp;ust=1695232021544241&amp;usg=AOvVaw2tKB37Q1fKdFcreD_ejsF-">this StackOverflow post</a></span><span class="calibre3">. To understand Python generators in more depth, see sections 4.1 and 4.3 of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&amp;sa=D&amp;source=editors&amp;ust=1695232021544525&amp;usg=AOvVaw1G24Y80eCAnFcayzoealQX">this paper</a></span><span class="c4">.</span></p>

<h2 class="c27" id="h.bdskqll060u1"><span class="c4">Translating to SMoL</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The following program is a rough simulation of the above Python program </span><span class="c7">if</span><span class="calibre3"> SMoL had a notion of </span><code>yield</code><span class="calibre3">, which it does not. To avoid unbound identifier errors, we will use the following simple definition of </span><code>yield</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(deffun (yield n)
  n)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can then translate the above code as follows:</span></p><p class="c3"><span class="c4"/></p><pre>(deffun (gen)
  (defvar n 0)
  (deffun (loop)
    (yield n)
    (set! n (+ n 1))
    (loop))
  (loop))</pre><p class="c3"><span class="c41"/></p><pre>(+ (gen) (gen) (gen))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">For simplicity, we’re ignoring the step where we </span><span class="c7">instantiate</span><span class="c4"> the generator: i.e., we can have only one copy of the generator in this version, whereas the Python version lets us instantiate multiple. We will return to this later.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that running the above program goes into an infinite loop, because </span><code>yield</code><span class="c4"> does not “yield”. However, because the Stacker shows us intermediate steps in the computation, it still provides something very useful.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now that we have this program, let’s run it through the Stacker. We will see a few preliminary states, and then one that looks like this:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre25"><img alt="" src="image10.png" title="" class="calibre26"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">At this point, the oldest frame represents the top-level expression, which is waiting for the first call to </span><code>gen</code><span class="calibre3"> to compute. Inside </span><code>gen</code><span class="calibre3">, we have initialized </span><code>n</code><span class="calibre3"> to </span><code>0</code><span class="c4">. Now we are about to start computing the (potentially) infinite loop.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">A little bit later, we see the following:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre27"><img alt="" src="image20.png" title="" class="calibre28"/></span></p><p class="c3"><span class="c4"/></p><p class="c8"><span class="c7">This picture is the essence of generators. Understanding it is critical.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Here is what is happening here. The top-level computation is waiting for the call to </span><code>gen</code><span class="calibre3"> to finish and produce an answer. </span><span class="c7">Within</span><span class="calibre3"> the generator, the computation has initialized n and is about to yield its current value. What is critical is the </span><span class="c7">context</span><span class="c4"> of this operation:</span></p><p class="c3"><span class="c4"/></p><pre>(begin
  •
  (set! n (+ n 1))
  (loop))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">in @1678, which has no bindings and hence defers to @1909. This binds </span><code>n</code><span class="calibre3"> to </span><code>0</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now, suppose we could break up this stack into two parts (with the environment and store shared as needed):</span></p><p class="c3"><span class="c4"/></p><pre>(+ • (gen) (gen))</pre><p class="c5"><span class="c4">in @1233</span></p><p class="c3"><span class="c4"/></p><pre>(begin
  •
  (set! n (+ n 1))
  (loop))</pre><p class="c5"><span class="c4">in @1678</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that each part looks like a full-fledged stack in its own right! The environment @1233 refers to names that the top-level uses (such as </span><code>gen</code><span class="calibre3">), while the environment @1678 (and hence @1909) refers to ones that the generator uses (such as </span><code>n</code><span class="c4">).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Until now, however, we have acted as if a program has only one stack. The simplest conceptual model for a generator is:</span></p><p class="c3"><span class="c4"/></p><p class="c8"><span class="c4">Each generator has its own local stack.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, the generator’s stack does not know about the computation in the main program or in any other generators. It only knows about the computation that it is performing. A </span><code>yield</code><span class="c4"> does two things:</span></p><p class="c3"><span class="c4"/></p><ol class="c130" start="1"><li class="c131 pcalibre17"><span class="calibre3">It transparently (i.e., without the programmer’s knowledge) stores the </span><span class="c7">local</span><span class="c4"> stack with the generator data structure.</span></li><li class="c131 pcalibre17"><span class="c4">It returns the yielded value to the stack that invoked the generator.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Everything else—variables, aliasing, closures, growth and decline of the stack with functions calls and returns, etc.—stays exactly the same. The only difference is that calling a generator causes computation to start, or resume the context, in a separate, disconnected stack.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Thus, in the above model, after the first </span><code>yield</code><span class="c4"> succeeds, the top-level stack frame would be</span></p><p class="c3"><span class="c4"/></p><pre>(+ 0 • (gen))</pre><p class="c5"><span class="c4">in @1233</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">invoking the generator. This would resume the previous stack, so </span><code>n</code><span class="c4"> would be set to 1, and the next iteration of the loop would run, which would</span></p><p class="c3"><span class="c4"/></p><ol class="c132" start="1"><li class="c133 pcalibre18"><span class="calibre3">Store the generator’s stack (which, conceptually, is exactly the same—only the value of </span><code>n</code><span class="c4"> has changed, but that is in the environment), and</span></li><li class="c133 pcalibre18"><span class="calibre3">return the new value of </span><code>n</code><span class="calibre3"> (i.e., </span><code>1</code><span class="c4">) to the top-level stack.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This would result in </span></p><p class="c3"><span class="c4"/></p><pre>(+ 0 1 •)</pre><p class="c5"><span class="c4">in @1233</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">repeating the above process, and hence producing </span><code>3</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p>

<h2 class="c27" id="h.ywpuswfihawr"><span class="c4">A Richer Example</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Using what we have learned, let us consider another Python example:</span></p><p class="c3"><span class="c4"/></p><pre>def nats():
  n = 0
  while True:
    yield n
    n += 1</pre><p class="c3"><span class="c41"/></p><pre>def odds():
  ns = nats()
  while True:
    n = next(ns)
    if n % 2:
      yield n</pre><p class="c3"><span class="c41"/></p><pre>g = odds()</pre><p class="c3"><span class="c41"/></p><pre>next(g) + next(g) + next(g)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This program has two distinct generator creators: the one we’ve already seen for natural numbers, and one more that filters the natural numbers to produce only odd numbers.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We can now think of control proceeding as follows. First, we make an instance of </span><code>odds</code><span class="calibre3"> and bind it to </span><code>g</code><span class="calibre3">. This immediately creates an instance of </span><code>nats</code><span class="calibre3"> and binds it (within the instance of </span><code>odds</code><span class="calibre3">) to </span><code>ns</code><span class="c4">. Now all our generators are set up and ready to compute.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We now begin the infinite loop in </span><code>odds</code><span class="c4">. This calls the natural number generator. At this point, the odd number generator’s local stack looks like</span></p><p class="c3"><span class="c4"/></p><pre>while True:
  n = •
  if n % 2:
    yield n</pre><p class="c5"><span class="calibre3">in an environment where </span><code>ns</code><span class="calibre3"> is bound to a generator and </span><code>n</code><span class="c4"> is uninitialized</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Because we have called a generator, not a function, computation now runs in that generator’s own stack. This is the natural number generator, which we have already studied. It binds </span><code>n</code><span class="calibre3"> to </span><code>0</code><span class="calibre3"> and then </span><code>yield</code><span class="c4">s, storing its local stack—</span></p><p class="c3"><span class="c4"/></p><pre>while True:
  •
  n += 1</pre><p class="c5"><span class="calibre3">in an environment where </span><code>n</code><span class="calibre3"> is bound to </span><code>0</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">—and returning </span><code>0</code><span class="c4"> to the odd number generator.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This resumes the odd generator’s stack. This binds n to 0 and performs the comparison. It fails, continuing the loop body:</span></p><p class="c3"><span class="c4"/></p><pre>    n = next(ns)
    if n % 2:
      yield n</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we are again ready to invoke the natural number generator. The odd number generator’s </span><span class="c7">local</span><span class="calibre3"> stack is unchanged from before (same context, same environment, except this time the environment does have a binding for </span><code>n</code><span class="calibre3">, to </span><code>0</code><span class="c4">). Meanwhile, the natural’s generator resumes from</span></p><p class="c3"><span class="c4"/></p><pre>while True:
  •
  n += 1</pre><p class="c5"><span class="calibre3">in an environment where </span><code>n</code><span class="calibre3"> is bound to </span><code>0</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This increments </span><code>n</code><span class="c4"> and resumes the loop body:</span></p><p class="c3"><span class="c4"/></p><pre>    yield n
    n += 1</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This immediately causes it to yield </span><code>1</code><span class="c4">, leaving the stack</span></p><p class="c3"><span class="c4"/></p><pre>while True:
  •
  n += 1</pre><p class="c5"><span class="calibre3">in an environment where </span><code>n</code><span class="calibre3"> is bound to </span><code>1</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This resumes the odd generator’s stack. This binds </span><code>n</code><span class="calibre3"> to </span><code>1</code><span class="c4">, so the conditional succeeds. Therefore, the stack at the point of yielding becomes</span></p><p class="c3"><span class="c4"/></p><pre>  while True:
    n = next(ns)
    if n % 2:
      •</pre><p class="c5"><span class="calibre3">in an environment where </span><code>ns</code><span class="calibre3"> is bound to a generator and </span><code>n</code><span class="calibre3"> is bound to </span><code>1</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This completes the first call to </span><code>next(g)</code><span class="c4">, enabling the top-level stack frame to have the context</span></p><p class="c3"><span class="c4"/></p><pre>1 + • + next(g)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">From this, we can see the next two computations will produce </span><code>3</code><span class="calibre3"> and </span><code>5</code><span class="calibre3">, and hence the total of </span><code>9</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.9cpi3w9pvb34"><span class="c4">Laziness</span></h1><h2 class="c23" id="h.cwfokkjeidig"><span class="c4">Evaluation Strategies</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Back when we began to study evaluation [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_015.html#h.nin2n4sergiw">👉</a></span><span class="calibre3">], we saw that we had a choice when performing evaluation. During function application, we could substitute the actual parameter as an </span><span class="c7">expression</span><span class="calibre3"> or as a </span><span class="c7">value</span><span class="c4">. At that time, we indicated that SMoL is eager. Now we will investigate the other option, laziness.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Consider the following program:</span></p><p class="c3"><span class="c4"/></p><pre>(deffun (f x)
  (g (+ x x)))</pre><p class="c3"><span class="c41"/></p><pre>(deffun (g y)
  (h (* y 2)))</pre><p class="c3"><span class="c41"/></p><pre>(deffun (h x)
  (+ x 5))</pre><p class="c3"><span class="c41"/></p><pre>(f (+ 2 3))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">When run eagerly in the Stacker, we see calls like</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre29"><img alt="" src="image4.png" title="" class="calibre30"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and the environment contents look like</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre31"><img alt="" src="image9.png" title="" class="calibre32"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Both the call and the environment reinforce that parameters are evaluated </span><span class="c7">before</span><span class="calibre3"> the function body begins to execute, so names are bound to </span><span class="c7">values</span><span class="c4">.</span></p>

<h2 class="c27" id="h.98lrgqdhs8f4"><span class="c4">Why Lazy Evaluation</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Suppose, instead, we evaluate this lazily. The evaluation would look like this:</span></p><p class="c3"><span class="c4"/></p><pre>  (f (+ 2 3))
→ (g (+ (+ 2 3) (+ 2 3)))
→ (h (* (+ (+ 2 3) (+ 2 3))) 2))
→ (+ (* (+ (+ 2 3) (+ 2 3))) 2) 5)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">A natural question might be, why bother doing this? </span></p><p class="c3"><span class="c4"/></p><ol class="c134" start="1"><li class="c135 pcalibre19"><span class="calibre3">A reason people often cite is that it can save time, in that we don’t need to evaluate parameters we don’t need. For instance, suppose we have<br class="calibre"/><br class="calibre"/></span><code>(deffun (f x y z)<br class="calibre"/>  (if (zero? x)<br class="calibre"/>      y<br class="calibre"/>      z))<br class="calibre"/><br class="calibre"/></code><span class="c4">and we call f with two expensive-to-compute parameters in the last two positions. In an eager language, we have evaluated both whether we want to or not. In a lazy language, we only evaluate the one we need. As we will see below, this is actually not a very compelling argument.<br class="calibre"/></span></li><li class="c135 pcalibre19"><span class="calibre3">A second reason is that it enables us to add new, non-eager constructs to the language through functions. Consider </span><code>if</code><span class="calibre3">: in an eager language it can’t be a function because the whole point of </span><code>if</code><span class="c4"> is to not evaluate one of the branches (which would become parameters that are evaluated). Again, this argument has somewhat limited merit: we have seen how we can add such constructs using macros, which can do a great deal more as well.<br class="calibre"/></span></li><li class="c135 pcalibre19"><span class="calibre3">The most interesting reason is probably that </span><span class="c7">the set of equations that govern the language changes</span><span class="calibre3">. Consider the following. Suppose we have the expressions </span><code>E</code><span class="calibre3"> and </span><code>(lambda (x) (E x))</code><span class="calibre3">. Are they the “same”? It would seem, intuitively, that they are. Suppose </span><code>E</code><span class="calibre3"> is a function. In any setting where we apply </span><code>E</code><span class="calibre3"> to a parameter, the second expression does exactly the same: it takes that parameter, binds it to </span><code>x</code><span class="calibre3">, and then applies </span><code>E</code><span class="calibre3"> to </span><code>x</code><span class="calibre3">, which has the same effect.<br class="calibre"/><br class="calibre"/>However, note that </span><code>E</code><span class="calibre3"> may not be a function! It could be a </span><code>print</code><span class="calibre3"> statement,</span><code> (/ 1 0)</code><span class="calibre3">, and so on. In those cases, </span><code>E</code><span class="calibre3"> evaluates right away and has some observable effect, but the version “hidden under the </span><code>lambda</code><span class="c4">” will not until it is used.<br class="calibre"/><br class="calibre"/>Why does this matter? It matters because many parts of programming implementations and tools want to replace some terms with other terms. An optimizing compiler does this (replacing a term with an equivalent one that is better by whatever optimizing criterion is in use), as do program refactoring engines, and more. Thus, the more terms that can be replaced, or the fewer conditions under which terms can be replaced, the better. Lazy languages allow more terms to be replaced.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology: </span><span class="c4">This equivalence is called “rule eta” (η).</span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="c40">Terminology: </span><span class="calibre3">You may see some people say that lazy languages have “referential transparency”. If you ask them to define it, they may say something like “you can replace equals with equals”. Think about that for a moment: you can </span><span class="c7">always</span><span class="calibre3"> replace equals with equals. That is (by some definitions) literally what equality </span><span class="c7">means</span><span class="c4">: two things are equal exactly when you can replace one with the other. So that phrase tells us nothing. In fact, every language has some degree of “referential transparency”: you can always replace some things with other equivalent things. In lazy languages, the set of things you can replace is usually bigger: the referential transparency relation is larger. That’s all.<br class="calibre"/></span></p><ol class="c24" start="4"><li class="c135 pcalibre19"><span class="c4">One very important, practical reason is to create potentially-infinite data structures. See the example on streams below.<br class="calibre"/></span></li><li class="c135 pcalibre19"><span class="calibre3">More fundamentally, the famous paper </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://www.cse.chalmers.se/~rjmh/Papers/whyfp.html&amp;sa=D&amp;source=editors&amp;ust=1695232021569949&amp;usg=AOvVaw13ypvMWgaZXeEPuILJzYCX">Why Functional Programming Matters</a></span><span class="calibre3"> argues that laziness is a </span><span class="c7">modularity</span><span class="c4"> concept, and develops this argument through several beautiful examples.</span></li></ol>

<h2 class="c27" id="h.low2y8msmm0b"><span class="c4">Strictness Points</span></h2><p class="c5"><span class="c4">Coming back to our example from earlier: when we run such a program in a language with lazy evaluation, when, if ever, does all this arithmetic resolve and print a value?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Before we answer that question, let us also observe that sometimes programs can’t really defer decisions indefinitely. For instance, consider this program:</span></p><p class="c3"><span class="c4"/></p><pre>(deffun (f x)
  (if (even? x)
      7
      11))</pre><p class="c3"><span class="c41"/></p><pre>(f (+ 2 3))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What happens when we try to evaluate it? Presumably substitution reduces this to</span></p><p class="c3"><span class="c4"/></p><pre>(if (even? (+ 2 3))
    7
    11)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and now what? Presumably that could be considered “the answer”, but that doesn’t seem very useful; and in real programs, these terms would just grow larger and larger. Furthermore, suppose the program were</span></p><p class="c3"><span class="c4"/></p><pre>(deffun (fact n)
  (if (zero? n)
      1
      (* n (fact (- n 1)))))</pre><p class="c3"><span class="c41"/></p><pre>(fact 5)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can certainly produce as an answer</span></p><p class="c3"><span class="c4"/></p><pre>  (if (zero? 5)
      1
      (* 5 (fact (- 5 1)))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">but…then what? And for that matter, what is </span><code>fact</code><span class="c4"> in this response? This does not seem like a very useful programming language.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Instead, lazy programming languages define certain points in the language as </span><span class="c7">strictness</span><span class="calibre3"> points, which are points where expressions are forced to compute and produce an answer. Different choices of strictness points will result in languages that behave slightly differently. Conventionally, the following are considered </span><span class="c7">useful</span><span class="c4"> strictness points:</span></p><p class="c3"><span class="c4"/></p><ol class="c136" start="1"><li class="c137 pcalibre20"><span class="c4">The conditional portion of a conditional expression. This enables the language to determine which branch to take and which branch to ignore.</span></li><li class="c137 pcalibre20"><span class="c4">Arithmetic. This avoids long chains of computations building up.</span></li><li class="c137 pcalibre20"><span class="c4">The printer in an interactive environment. This makes the environment useful.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">All three of these are </span><span class="c7">pragmatic</span><span class="c4"> choices. Notice that our first example above concerned the top-level printer, while the second example has to do with conditionals.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Because of these strictness points, a typical lazy language will in fact compute the programs we have seen above very similarly to an eager language. To get to something that really differentiates eagerness from laziness, we need to get to richer programs.</span></p>

<h2 class="c27" id="h.yil5odt1xmy7"><span class="c4">Evaluating Without Substitution</span></h2><p class="c5"><span class="c4">Above, we saw how we can think of lazy evaluation using substitution. While this is a useful mental model, as we have seen in earlier interpreters, we don’t really want to use substitution as our implementation strategy. That involves repeatedly rewriting program source, which is not how our interpreter worked.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So let’s say we don’t pass the value but instead “the expression”. Does it mean the above sequence becomes this?</span></p><p class="c3"><span class="c4"/></p><pre>  (f (+ 2 3))</pre><p class="c5"><code>→ (g (+ x x))</code><span class="calibre3"> where </span><code>x</code><span class="calibre3"> is bound to </span><code>(+ 2 3)</code></p><p class="c5"><code>→ (h (* y 2))</code><span class="calibre3"> where </span><code>y</code><span class="calibre3"> is bound to </span><code>(+ (+ 2 3) (+ 2 3)))</code></p><p class="c5"><code>→ (+ x 5)</code><span class="calibre3"> where </span><code>x</code><span class="calibre3"> is bound to </span><code>(* (+ (+ 2 3) (+ 2 3)) 2)</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In fact, even this isn’t quite right. It should rather be</span></p><p class="c3"><span class="c4"/></p><pre>  (f (+ 2 3))</pre><p class="c5"><code>→ (g (+ x x))</code><span class="calibre3"> where </span><code>x</code><span class="calibre3"> is bound to </span><code>(+ 2 3)</code></p><p class="c5"><code>→ (h (* y 2))</code><span class="calibre3"> where </span><code>y</code><span class="calibre3"> is bound to </span><code>(+ x x))</code><span class="calibre3"> whose </span><code>x</code><span class="calibre3"> is </span><code>(+ 2 3)</code></p><p class="c5"><code>→ (+ x 5)</code><span class="calibre3"> where </span><code>x</code><span class="calibre3"> is bound to </span><code>(* y 2)</code><span class="calibre3"> whose </span><code>y</code><span class="calibre3"> is </span><code>(+ x x))</code><span class="calibre3"> whose </span><code>x</code><span class="calibre3"> is </span><code>(+ 2 3)</code></p><p class="c3"><span class="c41"/></p><p class="c5"><span class="c4">In other words, we want to pass the unevaluated expression…but you can probably see where this is going! If we’re not careful, we will end up with dynamic scope. Even setting that aside, we can’t just pass the expression on its own, because when we eventually get a strictness point, we simply will have no idea what value a variable resolves to.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">However, the solution also presents itself very naturally. We don’t just pass an expression, we pass along its corresponding environment. An expression and environment combine to form a…closure! Of course, this closure does not take any parameters; its only job is to </span><span class="c7">suspend the evaluation of the expression</span><span class="calibre3"> until we reach a strictness point, and at that point, </span><span class="c7">evaluate it in the right environment</span><span class="c4">. Fortunately, we don’t need to do any new work here; closure application already does it for us.</span></p>

<h2 class="c27" id="h.87bogdfxe1hf"><span class="c4">Laziness Via Closures: Beyond Numbers</span></h2><p class="c5"><span class="calibre3">Laziness becomes more interesting when we consider data structures. Conventionally, data constructors are </span><span class="c7">not</span><span class="calibre3"> strict, so their arguments are not evaluated eagerly. We can illustrate this using lists, though technically we will be constructing </span><span class="c7">streams</span><span class="c4"> (which are infinite, as opposed to lists, which are finite).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">First, read about streams represented using closures:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/func-as-data.html%23%2528part._streams-from-funs%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021577933&amp;usg=AOvVaw3xFcgFEVIzH5OuDVgtWddP">https://dcic-world.org/2022-08-28/func-as-data.html#%28part._streams-from-funs%29</a></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What would the same code look like in a language that was already lazy?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To experiment with that, we’ll now use the Racket language</span></p><p class="c3"><span class="c4"/></p><pre>#lang lazy</pre><p class="c3"><span class="c4"/></p><pre>(define ones (cons 1 ones))</pre><p class="c3"><span class="c41"/></p><pre>(define (nats-from n)
  (cons n (nats-from (add1 n))))</pre><p class="c3"><span class="c41"/></p><pre>(define nats (nats-from 0))</pre><p class="c3"><span class="c41"/></p><pre>(define (take n s)
  (if (zero? n)
      empty
      (cons (first s) (take (sub1 n) (rest s)))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Observe how some of these values print:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; ones
#&lt;promise:ones&gt;
&gt; nats
#&lt;promise:nats&gt;</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The word “promise” means these are </span><span class="c7">thunks</span><span class="calibre3"> that represent the stream. To view the thunk’s content, we need to “force” the “promise”, which we do using the </span><code>!</code><span class="c4"> operator:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (! ones)
#0='(1 . #&lt;promise!#0#&gt;)
&gt; (! nats)
'(0 . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In the case of </span><code>ones</code><span class="calibre3">, Racket is telling us that the rest of the stream is the </span><span class="c7">same</span><span class="calibre3"> stream as the one we are viewing: i.e., it’s a cyclic stream. For </span><code>nats</code><span class="calibre3">, it tells us that the first element is </span><code>0</code><span class="c4">, followed by another promise. We can explore these streams a bit further:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (! (rest ones))
#0='(1 . #&lt;promise!#0#&gt;)
&gt; (! (rest (rest (rest ones))))
#0='(1 . #&lt;promise!#0#&gt;)
&gt; (! (rest nats))
'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)
&gt; (! (rest (rest (rest nats))))
'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Unsurprisingly, </span><code>ones</code><span class="calibre3"> does not change. But with </span><code>nats</code><span class="calibre3">, as we explore more of the stream, we run into more thunks. This is where </span><code>take</code><span class="calibre3"> is useful: it gives us a finite prefix of the potentially infinite stream. Unfortunately, that also seems to just produce more thunks, and it seems like we would need to laboriously apply </span><code>!</code><span class="c4"> to each part:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (take 10 ones)
'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)
&gt; (take 10 nats)
'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">For situations like this, where we </span><span class="c7">know</span><span class="calibre3"> the output is going to be finite, we might want to resolve all the thunks. For this, Lazy Racket provides </span><code>!!</code><span class="c4">, which recursively applies strictness to all contained thunks:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (!! (take 10 ones))
'(1 1 1 1 1 1 1 1 1 1)
&gt; (!! (take 10 nats))
'(0 1 2 3 4 5 6 7 8 9)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Sure enough, we get the expected answer.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> What happens if we apply </span><code>!!</code><span class="calibre3"> to </span><code>ones</code><span class="calibre3"> and to </span><code>nats</code><span class="c4">? Try it out, and explain what you see.</span></p>

<h2 class="c27" id="h.6x2nx4ia71fv"><span class="c4">Tracing Laziness</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Another way to understand laziness is to study the encoding of streams in the Stacker. Here is the code:</span></p><p class="c3"><span class="c4"/></p><pre>#lang stacker/smol/hof</pre><p class="c3"><span class="c41"/></p><pre>(deffun (lz-first s) (left s))
(deffun (lz-rest s) ((right s)))
(deffun (take n s)
  (if (equal? n 0)
      empty
      (cons (lz-first s) (take (- n 1) (lz-rest s)))))</pre><p class="c3"><span class="c41"/></p><pre>(defvar ones (mpair 1 (λ () ones)))</pre><p class="c3"><span class="c41"/></p><pre>(deffun (nats-from n)
  (mpair n (λ () (nats-from (+ n 1)))))
(defvar nats (nats-from 0))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now run each of</span></p><p class="c3"><span class="c4"/></p><pre>(take 3 ones)
(take 3 nats)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and study </span><span class="c7">when</span><span class="calibre3"> evaluation happens and </span><span class="c7">what is being held on to by the closures</span><span class="calibre3">. (You may find it helpful to view just one of these at a time: the definition and use of </span><code>ones</code><span class="calibre3">, and separately of </span><code>nats</code><span class="calibre3"> and </span><code>nats-from</code><span class="c4">.)</span></p>

<h2 class="c27" id="h.7faoga2ntna1"><span class="c4">Laziness and Side-Effects</span></h2><p class="c5"><span class="c4">Given the (potential) benefits of lazy evaluation, why is laziness not more widely used?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The problem is that laziness makes it much harder to predict what will happen in programs that use state. Therefore, popular lazy languages do not have state, or have it in very controlled forms. (This is not a bad thing! State </span><span class="c7">should</span><span class="c4"> only be used in very controlled ways, and Haskell, for instance, has very interesting designs that help with that. But programmers have traditionally expected to have unfettered access to state.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Consider, for instance, the following pair of functions:</span></p><p class="c3"><span class="c4"/></p><pre>(define (f x y)
  (g x y))</pre><p class="c3"><span class="c41"/></p><pre>(define (g x y)
  (if (zero? (random 2)) x y))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">On their own, they seem harmless. However, now consider this call:</span></p><p class="c3"><span class="c4"/></p><pre>(f (print "X") (print "Y"))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In an eager language, we know both strings would be printed right away. However, in a lazy language, only one will, and we cannot tell which one. To understand which, we can no longer treat </span><code>f</code><span class="calibre3"> as an abstraction but instead have to peer into its implementation, which in turn forces us to examine the source of </span><code>g</code><span class="c4"> as well. We would have to examine every call, and track all the strictness points along the way, to determine which effects will occur and when. Here is another example:</span></p><p class="c3"><span class="c4"/></p><pre>(define n 0)
(f (set! n (add1 n)) (set! n (sub1 n)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Again, if we ran this eagerly, we know </span><code>n</code><span class="calibre3"> would be set back to </span><code>0</code><span class="calibre3"> before the body of </span><code>f</code><span class="calibre3"> even begins to evaluate. In lazy evaluation, we cannot be sure what value </span><code>n</code><span class="calibre3"> will have: it could be </span><code>-1</code><span class="calibre3"> or </span><code>1</code><span class="calibre3">. Furthermore if, tomorrow, </span><code>g</code><span class="c4"> were altered to be</span></p><p class="c3"><span class="c4"/></p><pre>(define (g x y)
  (if (zero? (random 2)) "X" "Y"))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">then </span><code>n</code><span class="calibre3"> remains </span><code>0</code><span class="c4">—but we can’t know without examining its code!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">A natural reaction to reading these programs might be, “Don’t do that!” That is in fact an entirely legitimate reaction. The problem is not laziness: it’s the interaction between laziness and state. As we deprecate the use of unfettered state in programming, that increases the potential for laziness. Still, there are other situations—like errors—that we cannot avoid, and that can stay latent under lazy evaluation.</span></p>

<h2 class="c27" id="h.ymhwsz33pki9"><span class="c4">Caching Results</span></h2><p class="c5"><span class="calibre3">If we use lazy programming without side effects, we get a nice benefit: each expression always produces the same result. In that case, we don’t ever have to recompute an expression; we can just store its result and reuse it on subsequent accesses. That is, we can </span><span class="c7">cache</span><span class="c4"> the result, enabling us to trade space for time.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside: </span><span class="calibre3">If you are not familiar with trading space for time in computation—as found in techniques such as memoization and dynamic programming—see DCIC:<br class="calibre"/></span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/part_advtopics.html%23%2528part._avoid-recomp%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021588822&amp;usg=AOvVaw1pcTCRspVLqsEkkFNFbtyj">https://dcic-world.org/2022-08-28/part_advtopics.html#%28part._avoid-recomp%29</a></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">There are, however, two kinds of result caching one can perform.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">One is what happens in Lazy Racket, where each expression’s result is cached locally. This means that if the same source </span><span class="c7">location</span><span class="c4"> is evaluated multiple times, the cached value can be reused. Other implementation strategies can look for the same expression even in a dynamic setting (as happens, for instance, in a Fibonacci function, which dynamically generates sub-problems). This requires a rather different implementation approach, but can yield even bigger time-space trade-offs.</span></p>

<h2 class="c27" id="h.n0mbf5n0cyae"><span class="c4">Space Consumption</span></h2><p class="c5"><span class="c4">The ability to automatically memoize computation seems to show even more benefit to making lazy evaluation a default. Why not do it?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">One problem is that lazy evaluation can often take up significant amounts of space, </span><span class="c7">beyond</span><span class="c4"> the space consumed by memoization. To understand this, consider this squaring function:</span></p><p class="c3"><span class="c4"/></p><pre>(define (sq x)
  (* x x))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">Because we are evaluating lazily, </span><code>x</code><span class="calibre3"> is bound to an </span><span class="c7">expression</span><span class="c4"> represented as a closure. Now suppose our program looks like</span></p><p class="c3"><span class="c4"/></p><pre>(define v (make-vector 1000 0))
(sq (vector-ref v 2))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and beyond this we make no further reference to </span><code>v</code><span class="calibre3">. In an eager language, we would extract the second element of </span><code>v</code><span class="calibre3"> and can reclaim all the remaining storage. But in a lazy language, the </span><span class="c7">entire vector</span><span class="c4"> needs to stay alive until the last use of the closure that refers to it. Seemingly straightforward programs that have an intuitive space model in an eager language can have much more subtle and complicated space models in lazy programming. Observe that the issue above has nothing to do with memoization; it’s inherent in laziness.</span></p>

<h2 class="c27" id="h.hefjzztulaby"><span class="c4">Laziness in Eagerness</span></h2><p class="c5"><span class="calibre3">As a result of these issues, laziness has not gained popularity as a default option. At the same time, it is very useful in some settings. As we have seen above, we can always </span><span class="c7">simulate</span><span class="calibre3"> laziness by using thunks. This can, however, be syntactically unwieldy, so some languages provide syntactic support for it. In languages like Racket, for instance, </span><code>delay</code><span class="calibre3"> is a syntactic form that thunks its expression, and </span><code>force</code><span class="c4"> is a function that evaluates it (caching the result).</span></p><p class="c3"><span class="c4"/></p><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.pywusgfikk5t"><span class="c4">Control on the Web</span></h1><h2 class="c23" id="h.sunhzwthclo6"><span class="c4">Server-Side Programming</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Consider a program like this:</span></p><p class="c3"><span class="c138"/></p><p class="c5"><span class="c138">print(read("First number") + read("Second number")) </span></p><p class="c3"><span class="c138"/></p><p class="c5"><span class="calibre3">Imagine we were to run this program on a traditional command-line operating system. What happens when we call </span><code>read</code><span class="calibre3">? The operating system’s </span><span class="c7">synchronous</span><span class="calibre3"> input-reading commands are invoked: synchronous meaning that the program suspends its execution—that is, the stack stays intact—waiting for the user to respond (if ever they do), and when they do, the program’s stack resumes, with the value typed in by the user becoming the value returned by </span><code>read</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This seems so straightforward that we might never think twice about how remarkable this ability is. To understand that, we should try to run this program on the Web. When we do, we run headlong into a central problem on the Web: that there is no such thing as a “</span><span class="c139">read</span><span class="c4">” operation. Why not?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">On the Web, a hypothetical </span><code>read</code><span class="calibre3"> function can certainly send the prompt to the client. In principle, it should then wait for the client to respond with a value, which it returns. However, the </span><span class="c7">stateless</span><span class="calibre3"> nature of the Web means that this can’t happen: the program has to terminate. This is an </span><span class="c7">asynchronous</span><span class="c4"> operation. When the user responds (if they ever do), there is no computation waiting to go back to.</span></p><h3 class="c79" id="h.9i3mwy68n5ed"><span class="c80">Recording Contexts</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Therefore, a Web computation has to be arranged in a very different way. The programmer must manually remember the rest of the computation, and store it somewhere. For instance, we would break up the above program in the following way: what is going to be done next:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c138">read("First number")</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and what is waiting for the result:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c138">print(• + read("Second number")) </span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">(This is, of course, our old friend, a context.) But whereas the context is implicit on the program’s stack, because the program must terminate, the context needs to be written out explicitly. Of course, • is not a program operation; rather, we can think of the context as a function of one argument:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c139">lam(•</span><span class="c140">1</span><span class="c139">): print(•</span><span class="c140">1</span><span class="c139"> + read("Second number")) </span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and this is the function that is stored in a way associated with the outgoing prompt. Then, when (if) the user responds, their response value is bound to </span><span class="c139">•</span><span class="c140">1</span><span class="calibre3">, allowing the program to resume. Suppose, for instance, the user types </span><code>5</code><span class="c4">. Then this program effectively becomes</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c139">print(5 + read("Second number"))</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This needs to also perform a Web interaction, so we again split it into what must happen now</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c139">read("Second number")</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and what is waiting for the result:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c139">print(5 + •)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">which we can represent as a function:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c139">lam(•</span><span class="c140">2</span><span class="c139">): print(5 + •</span><span class="c140">2</span><span class="c139">)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">If and when the user resumes, this function is applied to the value they supply, and the result prints as we would expect.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This explanation glosses over some important details. Real program evaluation, as we have seen, does not proceed by rewriting programs, so the second function is not really</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c139">lam(•</span><span class="c140">2</span><span class="c139">): print(5 + •</span><span class="c140">2</span><span class="c139">)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">but rather a </span><span class="c7">closure</span><span class="c4"> with the body</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c139">lam(•</span><span class="c140">2</span><span class="c139">): print(•</span><span class="c140">1</span><span class="c139"> + •</span><span class="c140">2</span><span class="c139">)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">closed over an environment where </span><span class="c139">•</span><span class="c140">1</span><span class="calibre3"> is bound to </span><span class="c139">5</span><span class="calibre3">. Getting into these details is interesting from a Web architecture perspective, but for us, all we care about is that </span><span class="c7">contexts must be saved and restored</span><span class="c4">.</span></p><h3 class="c79" id="h.t2bpf83zez8o"><span class="c80">Simulating in the Stacker</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can simulate the above using the Stacker, provided we forego the input operation and pretend it always returns some constant:</span></p><p class="c3"><span class="c4"/></p><pre>#lang stacker/smol/hof</pre><p class="c3"><span class="c41"/></p><pre>(deffun (get-number s)
  5)</pre><p class="c3"><span class="c41"/></p><pre>(+ (get-number "first") (get-number "second"))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">At the point of the second call, we see that the state looks like this:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre33"><img alt="" src="image23.png" title="" class="calibre34"/></span></p>

<h2 class="c27" id="h.3ltfdc90y0i5"><span class="c4">Client-Side Termination</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">On the client-side Web, in JavaScript, we see the same phenomenon, but for a completely different reason. Imagine we write a factorial computation in JavaScript:</span></p><p class="c3"><span class="c4"/></p><pre>function fact(n) {
  ans = 1;
  while (n != 0) {
    ans = ans * n;
    n = n - 1;
  }
  return ans;
}</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Notice that the loop checks for </span><code>n != 0</code><span class="calibre3"> and not </span><code>n &gt; 0</code><span class="c4">, so if we put this in a Web page and run it, the program will in principle run forever:</span></p><p class="c3"><span class="c4"/></p><pre>&lt;script type="application/javascript"&gt;
function fact(n) {
  ans = 1;
  while (n != 0) {
    ans = ans * n;
    n = n - 1;
  }
  return ans;
}
function show() {
  window.alert('here');
  ans = fact(-1);
  window.alert(ans);
  document.getElementById('answer').innerHTML = ans;
  
}
&lt;/script&gt;
&lt;/head&gt;</pre><p class="c3"><span class="c41"/></p><pre>&lt;body&gt;
&lt;button onclick="show()"&gt;Click me&lt;/button&gt;
&lt;div id="answer"&gt;&lt;/div&gt;</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">However, this creates a problem: the JavaScript virtual machine runs only one computation at a time, and the same JavaScript virtual machine also manages the page and the browser’s components. Therefore, if the program inside a page goes into an infinite loop, the entire page stops being responsive. For this reason, after a little while, the browser will pop up a window offering to kill the computation.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">There is a solution to this in JavaScript, but it is hardly elegant. The programmer creates a closure—called a </span><span class="c7">callback</span><span class="c4">—that represents the rest of the computation. The programmer then calls</span></p><p class="c3"><span class="c4"/></p><pre>setTimeout(C, 0)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">or, in more modern programs,</span></p><p class="c3"><span class="c4"/></p><pre>requestAnimationFrame(C)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">(though the former version perhaps makes a bit clearer what is happening), where </span><code>C</code><span class="calibre3"> is the callback. This creates an event to run </span><code>C</code><span class="calibre3"> as soon as possible (after </span><code>0</code><span class="calibre3"> units of time). The programmer then—does this sound familiar?—</span><span class="c7">terminates the program</span><span class="calibre3">. This returns control to the JavaScript virtual machine. It runs any other pending events, then arrives at this event, which it runs immediately—i.e., it “calls back” into the computation using </span><code>C</code><span class="calibre3">. If </span><code>C</code><span class="c4"> was constructed correctly, then this properly resumes the computation, as if it had never halted. Phew!</span></p>

<h2 class="c27" id="h.tbnq99ytq7iw"><span class="c4">Abstracting the Problem</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Thus, we have the same problem on both the server and client sides of the Web. The reasons are very different, but the net effect is the same: the programmer has to manually keep track of information that needs to persist, store it somewhere, halt the computation to return control to whatever called it and, when resumed, fetch information back from storage; all this code must run exactly as if an interruption had never occurred.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This programming quandary is not new. Back in the early days of computing, programmers had to manually keep track of where in memory values resided; then we got compilers that did this for us. Then we had to manually keep track of allocation on the heap to later reclaim it; then we got garbage collectors to do this for us. The history of programming languages is full of tasks that programmers did manually until we learned to create language constructs and compilers that could do these automatically. It would be nice if we could do the same here to reduce the burden of writing such programs.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To study these phenomena better, it would be helpful if we could abstract away from the details of servers, clients, JavaScript, Web pages, timeouts, and so on, and examine the phenomenon in its essence.</span></p><h3 class="c79" id="h.anpfmtebwmjm"><span class="c80">Using Closures</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We can simulate the solution by assuming a new primitive, </span><code>get-number/k</code><span class="calibre3">. Instead of taking one argument, the prompt string, it also takes a second argument. This second argument is a closure that represents the </span><span class="c7">rest</span><span class="calibre3"> of the computation—i.e., it’s the stack represented as a closure. This function binds that closure to a variable, </span><code>resume</code><span class="c4">, and then…does nothing:</span></p><p class="c3"><span class="c4"/></p><pre>(defvar yielder #false)</pre><p class="c3"><span class="c41"/></p><pre>(deffun (get-number/k s rest)
  (set! resume rest))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Recall that we want the program to invoke this function and then halt; all remaining computation—the context—needs to be in the second parameter given to </span><code>get-number/k</code><span class="c4">. Thus, our program now looks like this:</span></p><p class="c3"><span class="c4"/></p><pre>(get-number/k "first"
              (λ (•1)
                (get-number/k "second"
                              (λ (•2)
                                (+ •1 •2)))))</pre><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology: </span><span class="calibre3">The second argument—embodying the entire rest of the computation—is called the </span><span class="c7">continuation</span><span class="calibre3">, and it’s traditional to use the letter </span><code>k</code><span class="c4"> for it.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Terminology: </span><span class="calibre3">The program structure above has been turned inside-out: instead of the first operation being innermost and last operation outermost, the first one is outermost and the last one is innermost. This unwieldy program structure has a name: </span><span class="c7">inversion of control</span><span class="calibre3">. Instead of the client calling the helper function whose values it wants (in this case, </span><code>get-number</code><span class="calibre3">), the helper function (in this case </span><code>get-number/k</code><span class="c4">) calls the client. This leads to an unnatural, unwieldy, and error-prone programming style.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Sure enough, when we run this program, it just…halts with no output. It is instructive to look at the state of the program when it ends:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre35"><img alt="" src="image5.png" title="" class="calibre36"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Notice that </span><code>resume</code><span class="c4"> is bound to a function that is awaiting a number. If we invoke it:</span></p><p class="c3"><span class="c4"/></p><pre>(resume 5)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">then our state (unfortunately, we had to re-run the program) becomes:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre37"><img alt="" src="image15.png" title="" class="calibre38"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that resume is now bound to a closure whose environment remembers the value of </span><code>•1</code><span class="c4">. If we now resume again:</span></p><p class="c3"><span class="c4"/></p><pre>(resume 7)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">the “program” halts naturally, with an output of </span><code>12</code><span class="c4">! (We use quotes around “program” because we have really fragmented our simple program into three: one that gets the prompts for the first input, one that remembers that value and prompts for the second, and the third that sums those two values.)</span></p><h3 class="c79" id="h.jsygzmm9gzkk"><span class="c80">Using Racket</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4"> It turns out that Racket also has tools for manipulating continuations.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Imagine we have two tabs in DrRacket. In the first (let’s suppose we save it as </span><code>"yielder.rkt"</code><span class="c4">) we have the following mysterious program:</span></p><p class="c3"><span class="c4"/></p><pre>#lang racket</pre><p class="c3"><span class="c41"/></p><pre>(provide yield resume)</pre><p class="c3"><span class="c41"/></p><pre>(define resumer #false)</pre><p class="c3"><span class="c41"/></p><pre>(define (yield)
  (let/cc k
    (set! resumer k)
    (raise 'yield)))</pre><p class="c3"><span class="c41"/></p><pre>(define (resume)
  (resumer 'dummy))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The operation </span><code>let/cc</code><span class="calibre3"> binds the named variable (here, </span><code>k</code><span class="c4">) to a continuation value: it turns the current stack into a value that can be treated as a function.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In another tab, we will write a simple program that pretends to be our long-running computation: a factorial function. We can run this directly in Racket, of course. But </span><code>fact</code><span class="calibre3"> could run for a very long time, depending on the input; so following the rules of JavaScript, we want it to halt periodically, let’s say every time </span><code>n</code><span class="calibre3"> is divisible by </span><code>5</code><span class="c4"> (i.e., roughly every five iterations). That is, we would like to run:</span></p><p class="c3"><span class="c4"/></p><pre>#lang racket</pre><p class="c3"><span class="c41"/></p><pre>(require "yielder.rkt")</pre><p class="c3"><span class="c41"/></p><pre>(define (fact n)
  (if (= n 0)
      1
      (if (zero? (modulo n 5))
          (begin
            (yield)
            (* n (fact (- n 1))))
          (* n (fact (- n 1))))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">where </span><code>(yield)</code><span class="calibre3"> makes it pause in a way that, when we run </span><code>(resume)</code><span class="c4">, the computation will pick up exactly where it left off. Indeed, we see the following outcome:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (fact 7)
uncaught exception: 'yield
&gt; (resume)
5040</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The first time it yields is when </span><code>n</code><span class="calibre3"> is </span><code>5</code><span class="calibre3">. Yielding, in this case, means </span><span class="c7">terminating</span><span class="c4"> the computation using the Racket exception mechanism. Resuming somehow causes computation to continue and run to completion but, remarkably, it produces the exact same answer as if computation had never halted at all!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that thanks to the use of </span><code>let/cc</code><span class="calibre3">, we have been able to invert the inverted control, i.e., write the program in what is called </span><span class="c7">direct style</span><span class="calibre3">. The language has taken care of storing and restoring the computation without the user program having to do it manually. Thus, continuations are useful tools for inverting inverted control. We will also see another language mechanism that does this: </span><span class="c71"><a class="c11" href="https://www.google.com/url?q=https://docs.google.com/document/d/1ECyFV88K-jU-i0qHLfUNjbIYthChzpcjZ0eiostD3d8/edit%23&amp;sa=D&amp;source=editors&amp;ust=1695232021608622&amp;usg=AOvVaw1WfaeEjiDupGmDBj0AuHdK">Non-SMoL: Reactivity</a></span><span class="c4">.</span></p>

<h2 class="c27" id="h.r1ucqb2c2bz7"><span class="c4">Yielding on a Web Server</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The Racket Web server has a special primitive that does just this for the Web. We’ll build it up in stages. First, we’ll use a special Racket language, designed to make it easier to write server-side Web programs:</span></p><p class="c3"><span class="c4"/></p><pre>#lang web-server/insta</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Programs in this language must have a “main” function, called </span><code>start</code><span class="calibre3">, which is given an initial request (whatever information is provided when we first run the computation). This function is then written assuming a convenient fiction: the existence of a function </span><code>get-number</code><span class="calibre3"> that will print a prompt, send out a Web page, </span><span class="c7">wait for its response</span><span class="c4">, extract the value entered, and return it as a number:</span></p><p class="c3"><span class="c4"/></p><pre>(define (start req)</pre><p class="c5"><code>  (let ([result </code><span class="c64">(+ (get-number "first") (get-number "second"))</span><code>])</code></p><pre>    (response/xexpr
     `(html (body (p "The result is " ,(number-&gt;string result)))))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If we can make this fiction reality, then we can write a program like the above: it calls </span><code>get-number</code><span class="c4"> in a “deep” context, twice, adds the results, and then converts the result into a string to embed it into a Web page.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The question, of course, is how such a function can exist. First, we have to discuss some Web mechanics. When we create a Web form, it needs a field called the </span><code>action</code><span class="calibre3">, which holds a URL. When the user submits the form, the browser bundles up the information entered into the fields of the form and sends them—effectively, as a set of key-value pairs—</span><span class="c7">to the URL</span><span class="c4">, i.e., to the server, requesting it to run the program at that URL and provide the key-value pairs to that program.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Therefore, we can see that we’ve turned the problem of suspending the program’s execution into one of being able to fill in this URL with something meaningful. If the URL can somehow correspond to the stack, then perhaps the stack (and hence the computation) can be restored, and can be provided with these key-value pairs, from which the program can extract the required information.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The “secret sauce” that the Racket Web server provides is a primitive called </span><code>send/suspend</code><span class="c4">. It does the following:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">It takes a </span><span class="c7">single-argument function</span><span class="c4"> as a parameter. </span></li><li class="c25 pcalibre"><span class="c4">It records the current stack as a value.</span></li><li class="c25 pcalibre"><span class="c4">It stores this stack in a hash-table, associated with a unique, unguessable string.</span></li><li class="c25 pcalibre"><span class="c4">It turns this string into a URL.</span></li><li class="c25 pcalibre"><span class="calibre3">It then </span><span class="c7">calls</span><span class="c4"> the given function with this URL string.</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The resulting function can then use this URL string as the </span><code>action</code><span class="c4"> field of the form.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="c4"> This is not the only way to use it. The URL could also, for instance, be sent in an email message. This is a handy way to validate email addresses. Because the URL is unique and unguessable, the only way for someone to resume the computation would be to receive that URL, i.e., to have access to the email address. Thus, resuming the computation can be thought of as having validated the email address (assuming, of course, that an intruder is not reading emails and clicking on validation links that the email’s owner would not have clicked on).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">So here is an actual working implementation of get-number:</span></p><p class="c3"><span class="c4"/></p><pre>(define (get-number which)
  (define title (format "What is the ~a number?" which))
  (define req
    (send/suspend
     (lambda (k-url)</pre><p class="c5"><code>       </code><span class="c141">(response/xexpr</span></p><p class="c5"><code>        </code><span class="c142">`(html (head (title ,title))</span></p><p class="c5"><span class="c115">               (body</span></p><p class="c5"><span class="c115">                (form ([action ,</span><span class="c143">k-url</span><span class="c142">])</span></p><p class="c5"><span class="c142">                      ,title ": "</span></p><p class="c5"><span class="c142">                      (input ([name "number"]))</span></p><p class="c5"><span class="c115">                      (input ([type "submit"]))))</span><span class="c144">)</span><code>))))</code></p><pre>  (string-&gt;number</pre><p class="c5"><code>    </code><span class="c141">(extract-binding/single 'number</span></p><p class="c5"><span class="c144">      (request-bindings req))</span><code>))</code></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that most of this function is just </span><span class="c145">HTML</span><span class="calibre3"> and </span><span class="c146">API</span><span class="calibre3"> bookkeeping. We have to construct the Web page with the relevant components. When (if) the computation resumes, it returns with the key-value pairs sent from the form. These are bound to </span><code>req</code><span class="c4">. From there, it’s a simple matter of extracting the right value using the APIs.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">And that’s it! That gives us a full, working program.</span></p>

<h2 class="c27" id="h.h0rx77tbfh7k"><span class="c4">Interaction with State</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s think about how all this interacts with state. Let’s write a simple Web program that simply counts how many times we submitted a form.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">One natural way to write it is as follows. We’ll have a mutable variable, </span><code>count</code><span class="c4">, that keeps the count. We’ll have a page that shows the current count and provides the user a button. When they click it, computation resumes; the resumed computation increments the count, and loops:</span></p><p class="c3"><span class="c4"/></p><pre>#lang web-server/insta</pre><p class="c3"><span class="c41"/></p><pre>(define count 0)</pre><p class="c3"><span class="c41"/></p><pre>(define (show-count)
  (send/suspend
     (lambda (k-url)
       (response/xexpr
        `(html (head "Counter")
               (body
                (p () "The current count is " ,(number-&gt;string count))
                (form ([action ,k-url])
                      (input ([type "submit"])))))))))</pre><p class="c3"><span class="c41"/></p><pre>(define (start req)
  (show-count)
  (set! count (add1 count))
  (start 'dummy))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We’ll call it the </span><span class="c7">stateful counter</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This works as you might expect. </span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But now let’s think about a different way to write this same program. Instead of using a global mutable variable, we could instead keep the count as a local variable and functionally update it:</span></p><p class="c3"><span class="c4"/></p><pre>#lang web-server/insta</pre><p class="c3"><span class="c41"/></p><pre>(define (show-count count)
  (send/suspend
     (lambda (k-url)
       (response/xexpr
        `(html (head "Counter")
               (body
                (p () "The current count is " ,(number-&gt;string count))
                (form ([action ,k-url])
                      (input ([type "submit"])))))))))</pre><p class="c3"><span class="c41"/></p><pre>(define (loop count)
  (show-count count)
  (loop (add1 count)))</pre><p class="c3"><span class="c41"/></p><pre>(define (start req)
  (loop 0))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We’ll call this the </span><span class="c7">functional counter</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This, too, works as you would expect. And it works the same as the previous program. And yet, somehow, these programs seem to be different. Are they in fact </span><span class="c7">exactly</span><span class="c4"> the same?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">They’re not!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="c4">Map out the stacks, environments, and stores to simulate how these programs would run.</span></p>

<h2 class="c27" id="h.1c0ju4jazk82"><span class="c4">Web Interactions</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In conventional, desktop software, concurrency is an artifact of the </span><span class="c7">program</span><span class="c4">. If the program is not concurrent, we can’t really force it to behave concurrently.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Not so on the Web. There, we can copy URLs, duplicate them, and replay them. Therefore, the same program state can be invoked multiple times, returned to, and so on.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Consider the following sequence of interactions on the Web:</span></p><p class="c3"><span class="c4"/></p><ol class="c147" start="1"><li class="c148 pcalibre21"><span class="c4">A user visits a travel Web site.</span></li><li class="c148 pcalibre21"><span class="c4">They enter a city and search for hotels.</span></li><li class="c148 pcalibre21"><span class="c4">They are given a list of hotels, L.</span></li><li class="c148 pcalibre21"><span class="c4">They click on one of the hotels, say L1.</span></li><li class="c148 pcalibre21"><span class="c4">This takes them to a page for L1.</span></li><li class="c148 pcalibre21"><span class="c4">They click the reservation link.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">They obtain a reservation at L1. All this seems perfectly normal.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now suppose instead they do the following:</span></p><p class="c3"><span class="c4"/></p><ol class="c149" start="1"><li class="pcalibre22 c150"><span class="c4">A user visits a travel Web site.</span></li><li class="pcalibre22 c150"><span class="c4">They enter a city and search for hotels.</span></li><li class="pcalibre22 c150"><span class="c4">They are given a list of hotels, L.</span></li><li class="pcalibre22 c150"><span class="calibre3">They click on one of the hotels, say L1, in a </span><span class="c7">new</span><span class="c4"> tab.</span></li><li class="pcalibre22 c150"><span class="calibre3">They click on another of the hotels, say L2, in </span><span class="c7">another</span><span class="c4"> new tab.</span></li><li class="pcalibre22 c150"><span class="c4">They go back to L1’s tab.</span></li><li class="pcalibre22 c150"><span class="c4">They click the reservation link.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Think about these two questions:</span></p><ol class="c151" start="1"><li class="pcalibre23 c152"><span class="calibre3">At which hotel would you </span><span class="c7">like</span><span class="c4"> the reservation to be made: L1 or L2?</span></li><li class="pcalibre23 c152"><span class="calibre3">Where do you </span><span class="c7">expect</span><span class="c4"> the site to make the reservation: L1 or L2?</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Naturally, we would </span><span class="c7">expect</span><span class="calibre3"> the reservation at L1, because we clicked on the reservation link from L1’s page. But on many Web sites, you used to get a reservation at L</span><span class="c7">2</span><span class="calibre3">, not L</span><span class="c7">1</span><span class="c4">. This suggests that there is some interaction between the two tabs: specifically, there seems to be mutable state, the “current hotel”, that is shared between the two tabs. Opening a hotel’s page sets this. Thus, this is initially set to L1; the new tab for L2 sets it to L2; when we return to L1’s tab and make a reservation, this act reads the mutable state, which makes the reservation at the “current hotel”, namely L2.</span></p>

<h2 class="c27" id="h.eppk5x66e87a"><span class="c4">Returning to the Counters</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s return to the two counters, armed with the ideas from the interactions above.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Run the stateful counter program and submit, say, 3 times. After that, the page will list the count as 3, and the URL will look something like</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">http://localhost:51264/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2097639995)%22))?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now copy this URL, create a </span><span class="c7">new</span><span class="calibre3"> tab, paste it, and enter. This runs the computation associated with this URL. Perhaps surprisingly, this shows the count as 4. Now go back to the previous tab and submit the form. That tab now shows a count not of 4 but of 5. Return to the second tab and submit; it now shows 6. The stacks help us see why: every return mutates the </span><span class="c7">same</span><span class="calibre3"> </span><code>counter</code><span class="c4"> variable.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now repeat the same process with the functional counter. After 3 submissions, we get a URL like</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">http://localhost:51379/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2028533532)%22))?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">which seems very similar. Now copy </span><span class="c7">this</span><span class="c4"> URL into a new tab, and repeat the interactions above.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What we see is very different. Each tab has its own local “memory”, much as we expected of the pages on the travel Web site. The continuation does not mutate a single shared variable, but rather makes a new </span><span class="c7">call</span><span class="c4"> to loop, which creates a new binding that is distinct from previous bindings. Each time we submit we make another call, which makes another stack frame and its corresponding environment frame, which are distinct.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This distinction between creating a single, shared, mutable variable and creating distinct variables that each have their own immutable value should be familiar: it’s the exact same problem that we saw in the Loops assignment [</span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/courses/cs173/2022/loops.html&amp;sa=D&amp;source=editors&amp;ust=1695232021622985&amp;usg=AOvVaw0xjaprMcAAUZTQQEvCfWVs">https://cs.brown.edu/courses/cs173/2022/loops.html</a></span><span class="c4">].</span></p>

<h2 class="c27" id="h.vzke3j99ylj4"><span class="c4">Mapping between Web and Programming Language Features</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Interestingly, there is a deep connection between features of Web programs and ideas from programming languages. On the Web, we have</span></p><p class="c3"><span class="c4"/></p><a id="t.cce6b34dcd4316983f8ed795c6ba79e0b216b4a7"/><a id="t.3"/><table class="c45"><tbody class="calibre14"><tr class="c46"><td class="c81" colspan="1" rowspan="1"><p class="c52"><span class="c4"/></p></td><td class="c81" colspan="1" rowspan="1"><p class="c48"><span class="c49">Server-side</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c48"><span class="c49">Client-side</span></p></td></tr><tr class="c46"><td class="c81" colspan="1" rowspan="1"><p class="c153"><span class="c49">Mutable</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c50"><span class="c4">Database (page-independent)</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c50"><span class="c4">Cookie (page-independent)</span></p></td></tr><tr class="c46"><td class="c81" colspan="1" rowspan="1"><p class="c153"><span class="c49">Immutable</span></p></td><td class="c81" colspan="1" rowspan="1"><p class="c52"><span class="c4"/></p></td><td class="c81" colspan="1" rowspan="1"><p class="c50"><span class="c4">Hidden field (page-specific)</span></p></td></tr></tbody></table><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that when we have a single mutable entry, the net result will be that all pages that share it will end up seeing the effects of each other. Therefore, the bad travel Web site pattern is inherent in this style of programming. Unfortunately, Web APIs make cookies very easy to use, leading to programs following this bad pattern. In contrast, when we have immutable data that is specific to the page (the field is on the page…it’s just hidden), then each page keeps its own information separate from all the other pages. Notice also that hidden fields are key-value mappings. Therefore, a collection of hidden fields is an </span><span class="c7">environment</span><span class="calibre3">. Since a page also has a reference to code to run, a page with hidden fields is effectively a </span><span class="c7">closure</span><span class="calibre3">! In contrast, a page with shared mutable state is using the </span><span class="c7">store</span><span class="calibre3"> (or </span><span class="c7">heap</span><span class="c4">). The Racket Web server simply makes these implicit ideas explicit.</span></p>

<h2 class="c27" id="h.49bobs4fhzwm"><span class="c4">Readings</span></h2><p class="c5"><span class="c4">The work in this chapter is elaborated in several papers:</span></p><ul class="c24"><li class="c25 pcalibre"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/&amp;sa=D&amp;source=editors&amp;ust=1695232021626503&amp;usg=AOvVaw0dteFuRcMEar0kOBZ7ejqS">Automatically Restructuring Programs for the Web</a></span></li><li class="c25 pcalibre"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/&amp;sa=D&amp;source=editors&amp;ust=1695232021627009&amp;usg=AOvVaw0OKynkecNBanIitj-dtIoI">Modeling Web Interactions and Errors</a></span></li><li class="c25 pcalibre"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/&amp;sa=D&amp;source=editors&amp;ust=1695232021627310&amp;usg=AOvVaw2VVyDnhdzHGBVmpsp7j3xb">Implementation and Use of the PLT Scheme Web Server</a></span></li><li class="c25 pcalibre"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/bnpkg-stopify/&amp;sa=D&amp;source=editors&amp;ust=1695232021627644&amp;usg=AOvVaw0ZxiewB1AmM3Se5hWPXBGb">Putting in All the Stops: Execution Control for JavaScript</a></span></li></ul><p class="c3"><span class="c4"/></p>

<h1 class="c22" id="h.1blokr31ae55"><span class="c4">Reactivity</span></h1><p class="c5"><span class="calibre3">We learned early on that SMoL languages evaluate formal arguments at a function call. We then saw laziness as a contrast to this: an argument is evaluated </span><span class="c7">zero</span><span class="c4"> times at the call, and is maybe only evaluated later. (Of course, if the result is not cached, it may be evaluated many times.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now we will see another contrast to SMoL, focusing this time on the function call itself: where what syntactically looks like a single function call can actually be numerous, even an unbounded number.</span></p>

<h2 class="c27" id="h.mfmgpx4ry0f0"><span class="c4">GUIs through Callbacks</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">To do so, it helps to remind ourselves of the evaluation model in most graphical applications, these days embodied by JavaScript. Suppose we want to make a Web page with a timer that counts up every second, and whose value resets when we click on a Reset button:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre39"><img alt="" src="image24.png" title="" class="calibre40"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">One version of the JavaScript code would look as follows:</span></p><p class="c3"><span class="c4"/></p><pre>&lt;script type="text/javascript"&gt;
var timerID = null;
var elapsedTime = 0;</pre><p class="c3"><span class="c41"/></p><pre>function doEverySecond() {
  elapsedTime += 1;
  document.getElementById('curTime').innerHTML = elapsedTime; }
function startTimer() {
  timerId = setInterval(doEverySecond, 1000); }
function resetElapsed() {
  elapsedTime = 0; }
&lt;/script&gt;</pre><p class="c3"><span class="c41"/></p><pre>&lt;body onload="startTimer()"&gt;
  &lt;center&gt;Elapsed time&lt;/center&gt;
  &lt;center&gt;
    &lt;div id='curTime'&gt;&amp;nbsp;&lt;/div&gt;
  &lt;/center&gt;
  &lt;center&gt;
    &lt;input id="reset" type="button" value="Reset" onclick="resetElapsed()" /&gt;
  &lt;/center&gt;
&lt;/body&gt;</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">There are three parts to the logic here:</span></p><p class="c3"><span class="c4"/></p><ol class="c154" start="1"><li class="pcalibre24 c155"><span class="c4">Updating the elapsed time every second.</span></li><li class="pcalibre24 c155"><span class="c4">Resetting the timer on a button-press.</span></li><li class="pcalibre24 c155"><span class="c4">Initiating the computation.</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">These are accomplished as follows:</span></p><p class="c3"><span class="c4"/></p><ol class="c156" start="1"><li class="pcalibre25 c157"><span class="calibre3">When loaded, the Web page invokes </span><code>startTimer</code><span class="c4">. </span></li><li class="pcalibre25 c157"><span class="calibre3">We use </span><code>elapsedTime</code><span class="calibre3"> to record how much time has elapsed, and create a timer, referenced by </span><code>timerID</code><span class="calibre3">. This installs a timer (and records a reference to it in case we need it later, which we don’t in this program) that runs every second (1000 milliseconds). Whenever the timer goes off, it invokes the function </span><code>doEverySecond</code><span class="c4">. That function increments the elapsed time, and writes the current value into the Web page.</span></li><li class="pcalibre25 c157"><span class="calibre3">Finally, the reset button has </span><code>resetElapsed</code><span class="calibre3"> as its callback. This resets the value of </span><code>elapsedTime</code><span class="c4">, whose updated value is then shown the next time the display is updated. (In principle, we might want to update the display in this callback too.)</span></li></ol><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Let us suppose we were given this program to maintain. We want to ask a simple question: what is the value of the Web page’s </span><code>curTime</code><span class="c4"> element? Observe the reasoning we have to perform:</span></p><ul class="c24"><li class="c25 pcalibre3"><span class="calibre3">It is set inside </span><code>doEverySecond</code><span class="c4">.</span></li><li class="c25 pcalibre3"><span class="calibre3">It’s set to the value of </span><code>elapsedTime</code><span class="c4">.</span></li><li class="c25 pcalibre3"><span class="c4">That value is incremented in the previous statement.</span></li><li class="c25 pcalibre3"><span class="calibre3">That increment takes place every time </span><code>doEverySecond</code><span class="c4"> is called.</span></li><li class="c25 pcalibre3"><span class="calibre3">That call takes place in the first argument of </span><code>setInterval</code><span class="c4">.</span></li><li class="c25 pcalibre3"><span class="calibre3">That event is installed by </span><code>startTimer</code><span class="c4">.</span></li><li class="c25 pcalibre3"><span class="c4">Which is called on page load.</span></li><li class="c25 pcalibre3"><span class="calibre3">Wait. We also need to know the initial value, where </span><code>elapsedTime</code><span class="c4"> is declared.</span></li><li class="c25 pcalibre3"><span class="c4">Oh, but wait. We also see it reset.</span></li><li class="c25 pcalibre3"><span class="calibre3">That happens inside </span><code>resetElapsed</code><span class="c4">.</span></li><li class="c25 pcalibre3"><span class="c4">Which is called when the button is clicked.</span></li></ul><p class="c5"><span class="c4">In short, we have to follow all this:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre41"><img alt="" src="image19.png" title="" class="calibre42"/></span></p>

<h2 class="c27" id="h.44w0t98wrgzg"><span class="c4">Reactivity</span></h2><p class="c5"><span class="calibre3">There is an alternative, called </span><span class="c7">functional-reactive programming</span><span class="calibre3"> (FRP). We will see one particular instantiation, which is baked into Racket with an interesting user interface. The language is called FrTime. For technical reasons, we will not use a </span><code>#lang</code><span class="c4"> but rather choose it from the Language menu (under Other Languages).</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Do Now! </span><span class="c4">Below are some expressions whose output is best experienced in DrRacket. Run them in DrRacket and see the output for yourself!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">FrTime essentially provides a basic version of Racket, so basic computations work exactly as we would expect:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; 5
5
&gt; (+ 2 3)
5
&gt; (string-length "hello")
5</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can also ask for values like the current system time:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (current-seconds)
1668363009
&gt; (add1 (current-seconds))
1668363010</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">You will likely see a different value than the one shown above, because you are not reading this at the same time as when I wrote it. But that is a problem: indeed, even I am seeing a </span><span class="c7">stale</span><span class="c4"> value, because time has passed since I ran the command.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The typical solution is to use callbacks. We can imagine a timer that takes a callback, which is called every time the time changes. However, this would invert control, which is exactly what happens in our timer example.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But FrTime, following the principles of FRP, provides a special kind of value. Try it:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; seconds</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">See what happens? </span><code>seconds</code><span class="calibre3"> is a </span><span class="c7">time-varying value</span><span class="c4">: i.e., it is (technically: evaluates to) a value, but what it evaluates to changes over time. (It changes, in fact, every second.)</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Naturally, we should ask: if </span><code>seconds</code><span class="c4"> evaluates to a value, we can use it in expressions, so what happens if we write expressions like these?</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (add1 seconds)</pre><p class="c3"><span class="c4"/></p><pre>&gt; (modulo seconds 10)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Notice that both </span><code>add1</code><span class="calibre3"> and </span><code>modulo</code><span class="calibre3"> demand that their first argument be numbers. </span><code>seconds</code><span class="c4"> is a time-varying value that at every point in time is a number. Therefore, these expressions are well-typed, producing no errors, and in fact produce the answer we might expect (but also perhaps be a bit surprised by).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Nothing prevents us from writing even longer expressions. Consider the function </span><code>build-list</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (build-list 5 (lambda (n) n))
'(0 1 2 3 4)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What happens if we now use a time-varying value?</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (build-list (modulo seconds 10) (lambda (n) n))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Or build an even deeper expression:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; (length (build-list (modulo seconds 10) (lambda (n) n)))</pre>

<h2 class="c27" id="h.rnh3ftykhtvd"><span class="c4">How Evaluation Works</span></h2><h3 class="c79" id="h.vh2f13ojlzfv"><span class="c80">Dataflow Graphs</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What happens when we write these expressions? FrTime rewrites the way function applications happen. If </span><span class="c7">no</span><span class="calibre3"> argument to a function is time-varying, then the function evaluates just as it would in regular Racket. If, however, any of its arguments is time-varying, then FrTime constructs a node in a </span><span class="c7">dataflow</span><span class="c4"> graph. This node is attached to the nodes corresponding to the time-varying arguments.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Consider this expression:</span></p><p class="c3"><span class="c4"/></p><pre>(length (build-list (modulo seconds 10) (lambda (n) n)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The act of calling length evaluates its argument, which is a call to build-list, which evaluates its two arguments. The second argument is an ordinary closure. The first argument is a call to modulo, which evaluates </span><span class="c7">its</span><span class="c4"> two arguments. Again, the second argument is just a number, but the first argument is time-varying. Consequently, this turns into a dataflow graph node, where we use the context notation to indicate where time-varying values go:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3"> </span><span class="calibre43"><img alt="" src="image6.png" title="" class="calibre44"/></span></p><p class="c5"><span class="calibre3">Because </span><code>(modulo seconds 10)</code><span class="c4"> evaluates to a time-varying value, so does the next outer expression:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre45"><img alt="" src="image22.png" title="" class="calibre46"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and finally the outermost one:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre47"><img alt="" src="image8.png" title="" class="calibre48"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The program source therefore evaluates to this dataflow graph. Now, each time-varying value may evaluate at different rates and for different reasons. </span><code>seconds</code><span class="calibre3">, naturally, updates once every second. When it does, its updated value is </span><span class="c7">pushed</span><span class="c4"> to all the nodes that depend on it, which update their value and push their values, and so on all the way through the graph. Finally, values may arrive at the REPL, which in FrTime is designed to display them automatically updating.</span></p><h3 class="c79" id="h.328tryaip5b9"><span class="c80">Rewriting Application</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Essentially, we can think of reactivity being implemented by rewriting how function application works. In the simplest case, imagine we have a function application, </span><code>(f a)</code><span class="calibre3">. Let us assume that </span><code>f</code><span class="calibre3"> is itself not a time-varying value. Then, this application rewrites </span><code>(f a)</code><span class="c4"> as</span></p><p class="c3"><span class="c4"/></p><pre>(let ([a-value a])
  (if (time-varying? a-value)
    …
    (f a-value)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We will return to the </span><code>…</code><span class="calibre3"> in a moment. Observe that this evaluates the argument expression and, if it is not currently a time-varying value, then computation proceeds exactly as it would have in regular Racket. This means that progams that don’t use time-varying values behave </span><span class="c7">exactly</span><span class="calibre3"> as they would in Racket, so this is a </span><span class="c7">conservative</span><span class="c4"> extension of Racket.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now let’s consider what happens if the parameter </span><span class="c7">is</span><span class="calibre3"> time-varying. That means, instead of immediately computing an answer, we have to create a node in the dataflow graph. We can imagine a time-varying value is an object of the class </span><code>tvv%</code><span class="calibre3"> (</span><code>tvv</code><span class="calibre3"> for time-varying value, and </span><code>%</code><span class="calibre3"> using the Racket convention for classes). We will first illustrate how this might be used, then show its definition. This class has two methods: </span><code>add-consumer</code><span class="calibre3">, which provides another object of </span><code>tvv%</code><span class="calibre3"> that will receive updated values, and </span><code>update</code><span class="calibre3">, which receives updated values. We reproduce the bottom three parts of the above dataflow graph as follows and, to keep the output short, compute the remainder relative to </span><code>5</code><span class="calibre3"> rather than </span><code>10</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>(define seconds
  (new tvv% [updater (λ (v) v)]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In practice, </span><code>seconds</code><span class="calibre3"> would be attached to a system timer that pushes an update every second. For simplicity, we make it an inert object that only changes when we manually call its </span><code>updater</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The remainder node now looks like this:</span></p><p class="c3"><span class="c4"/></p><pre>(define mod•5
  (new tvv% [updater (λ (v) (modulo v 5))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That is, every time it receives a value from </span><code>seconds</code><span class="calibre3">, it computes that value </span><code>modulo</code><span class="calibre3"> </span><code>5</code><span class="calibre3">. Of course, right now it has no way of knowing that it must listen to </span><code>seconds</code><span class="c4">; we have to register it as a consumer:</span></p><p class="c3"><span class="c4"/></p><pre>(send seconds add-consumer mod•5)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Similarly, the </span><code>build-list</code><span class="c4"> expression creates a time-varying value object:</span></p><p class="c3"><span class="c4"/></p><pre>(define bl•id
  (new tvv% [updater (λ (v) (build-list v (λ (n) n)))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">which too we must attach to its value producer:</span></p><p class="c3"><span class="c4"/></p><pre>(send mod•5 add-consumer bl•id)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe how the </span><code>v</code><span class="calibre3"> parameters in </span><code>mod•5</code><span class="calibre3"> and in </span><code>bl•id</code><span class="c4"> correspond to the • in the dataflow graph.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Finally, just as </span><code>seconds</code><span class="calibre3"> is a source in the graph, we will define a sink that prints results, and send values from </span><code>bl•id</code><span class="c4"> to it:</span></p><p class="c3"><span class="c4"/></p><pre>(define show
  (new tvv% [updater (λ (v) (println v))]))</pre><p class="c3"><span class="c41"/></p><pre>(send bl•id add-consumer show)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we’re ready to test it all! If we simulate </span><code>seconds</code><span class="c4"> updating for the first ten seconds:</span></p><p class="c3"><span class="c4"/></p><pre>(for-each (λ (n) (send seconds update n)) (range 0 10))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">we see the following output printed, just as we would expect:</span></p><p class="c3"><span class="c4"/></p><pre>'()
'(0)
'(0 1)
'(0 1 2)
'(0 1 2 3)
'()
'(0)
'(0 1)
'(0 1 2)
'(0 1 2 3)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">So how did this work? The </span><code>tvv%</code><span class="calibre3"> class keeps track of a list of consumers, of which above we have had only one per object. </span><code>add-consumer</code><span class="calibre3"> merely augments this list. The </span><code>update</code><span class="calibre3"> method receives a value, uses its </span><code>updater</code><span class="c4"> function to compute a new current value, and broadcasts it to all of its consumers:</span></p><p class="c3"><span class="c4"/></p><pre>(define tvv%
  (class object%
    (init updater)
    (define updater-function updater)</pre><p class="c3"><span class="c41"/></p><pre>    (super-new)</pre><p class="c3"><span class="c41"/></p><pre>    (define consumers empty)
    (define/public (add-consumer new-consumer)
      (set! consumers (cons new-consumer consumers)))</pre><p class="c3"><span class="c41"/></p><pre>    (define/public (update pushed-value)
      (let ([new-current-value (updater-function pushed-value)])
        (for-each (λ (c) (send c update new-current-value))
                  consumers)))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">That’s (most of) the core logic (but read on). This brings us back to the rewriting of applications: what goes in </span><code>…</code><span class="c4">? Well, we have to</span></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">make a new </span><code>tvv%</code><span class="c4"> instance</span></li><li class="c25 pcalibre"><span class="calibre3">supply it an updater function that corresponds to </span><code>(f •)</code></li><li class="c25 pcalibre"><span class="calibre3">registers that node as a consumer to the </span><code>tvv%</code><span class="calibre3"> object that </span><code>a-value</code><span class="c4"> references</span></li><li class="c25 pcalibre"><span class="calibre3">return the new </span><code>tvv%</code><span class="c4"> instance as the result of this function “application”</span></li></ul><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="calibre3">Turn the above rewriting idea into a proper macro. If you can, turn it into the </span><code>#%app</code><span class="calibre3"> of a </span><code>#lang</code><span class="c4"> so that one can program a module in a FrTime-like style.</span></p><p class="c3"><span class="c4"/></p><h3 class="c79" id="h.oua1qbfq1uof"><span class="c80">Non-Linear Graphs</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The above example may be a bit misleading in suggesting that an expression must always have at most one time-varying parameter. Consider this program:</span></p><p class="c3"><span class="c4"/></p><pre>(= (modulo seconds 3) (modulo seconds 5))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Its dataflow graph looks like</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre49"><img alt="" src="image13.png" title="" class="calibre50"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">On every update of </span><code>seconds</code><span class="calibre3">, </span><span class="c7">both</span><span class="c4"> expressions that depend on it update, and their result flows to the equality comparison. Every 15 seconds, we would expect to see 12 consecutive false values followed by three consecutive true values, and that is what we see.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="calibre3">Does the above definition of </span><code>tvv%</code><span class="c4"> permit non-linear graphs? Can you write the above example with it? If so, show how. If not, modify it to allow such a definition.</span></p><h3 class="c79" id="h.yd5zbx8tkgze"><span class="c80">Avoiding Glitches</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">These forks in the graph, however, might be a cause for concern. Let us see an even simpler example:</span></p><p class="c3"><span class="c4"/></p><pre>(&lt; seconds (add1 seconds))</pre><p class="c3"><span class="c41"/></p><p class="c5"><span class="calibre3">Let us first be clear about what we expect this to produce: we want it to always be </span><code>#true</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">However, let us view how a simplistic dataflow graph evaluator might work. Here is the graph:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre51"><img alt="" src="image7.png" title="" class="calibre52"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Suppose the value of </span><code>seconds</code><span class="calibre3"> updates to become 10. This value is pushed, as we would expect, to </span><span class="c7">both</span><span class="calibre3"> its </span><span class="c7">listeners</span><span class="calibre3">. This causes the </span><code>(add1 seconds)</code><span class="calibre3"> node to update its value from </span><code>10</code><span class="calibre3"> to </span><code>11</code><span class="calibre3">. However, the update to </span><code>seconds</code><span class="calibre3"> might have caused the comparison to occur immediately. At that point FrTime would be evaluating </span><code>(&lt; 10 10)</code><span class="calibre3">, which is clearly false. So for one instant this expression would evaluate to </span><code>#true</code><span class="calibre3">, before the update from </span><code>(add1 seconds)</code><span class="calibre3"> arrives and it reverts to </span><code>#false</code><span class="calibre3">. This is called a </span><span class="c7">glitch</span><span class="calibre3">, a term borrowed from the same phenomenon in </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Glitch&amp;sa=D&amp;source=editors&amp;ust=1695232021650816&amp;usg=AOvVaw2D-DrKG6J0VAjm-pDxm4Ri">electrical circuits</a></span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Avoiding glitches is actually quite simple. Rather than updating a node in this eager manner, FrTime schedules the graph to be updated in </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Topological_sorting&amp;sa=D&amp;source=editors&amp;ust=1695232021651423&amp;usg=AOvVaw17recAG9rHgwYI9lEViEXR">topographical order</a></span><span class="calibre3">. That ensures that no node will ever see old, or “stale”, values, and the expression will evaluate correctly. Of course, we can only apply topological sorting to directed </span><span class="c7">acyclic</span><span class="c4"> graphs, so handling cycles requires some additional work, which we do not discuss here.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise: </span><span class="c4">Make the above definition of non-linear graphs behave glitch-free.</span></p>

<h2 class="c27" id="h.2ff45baqcttt"><span class="c4">Other Time-Varying Values</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">So far we have seen only one basic time-varying value, </span><code>seconds</code><span class="calibre3">. FrTime provides many others. For instance, </span><code>mouse-pos</code><span class="c4"> is the current position of the mouse. If we run the following program:</span></p><p class="c3"><span class="c4"/></p><pre>(require frtime/animation)</pre><p class="c3"><span class="c41"/></p><pre>(display-shapes
 (list
  (make-circle mouse-pos 10 "blue")))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">we see a blue circle, and it </span><span class="c7">automatically</span><span class="c4"> follows the mouse.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">The function </span><code>display-shapes</code><span class="calibre3"> in the FrTime animation library takes a list of shapes; above, we have only one. This function builds a list of (four) circles whose positions are determined by the mouse’s location, except each one is </span><span class="c7">delayed</span><span class="c4">, i.e., represents where the mouse used to be. (One might call this the Rhode Island mouse.) Therefore, as the mouse moves these circles appear to “follow” it around.</span></p><p class="c3"><span class="c4"/></p><pre>(display-shapes
 (let ([n 4])
   (build-list
    n
    (lambda (i)
      (make-circle (delay-by mouse-pos (* 200 (- (- n 1) i)))
                   10
                   "green")))))</pre>

<h2 class="c27" id="h.8bshm18bkbcf"><span class="c4">Even More Time-Varying Values</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We have actually seen only one kind of time-varying value, called a </span><span class="c7">behavior</span><span class="c4">. There are actually two kinds of time-varying values, which is easy to see if we consider a few different kinds of stimuli from the world:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre"><span class="c4">Current mouse position</span></li><li class="c25 pcalibre"><span class="c4">Sequence of keystrokes</span></li><li class="c25 pcalibre"><span class="c4">Current user location</span></li><li class="c25 pcalibre"><span class="c4">Sequence of network responses</span></li><li class="c25 pcalibre"><span class="c4">Current status of mode keys</span></li><li class="c25 pcalibre"><span class="c4">Sequence of mouse-clicks</span></li><li class="c25 pcalibre"><span class="c4">Current time</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Notice that several of those are “current…” and others are “sequence of…”. The former have the property that they always have a value, and the value may change at any time. The latter have the property that at any given moment they may not have a value—for instance, there may not be a “current keystroke”—and we don’t know when (or if) the next one will come, and there may be an infinite number of them. The latter are, of course, just </span><span class="c7">streams</span><span class="calibre3">, often called </span><span class="c7">event streams</span><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">If we go back to our original counter example, we had both present. The elapsed time was a behavior (always has a value, which changes either when a second finishes or when a button is clicked). The sequence of button presses is, conversely, an event stream: at any given moment there may not be a press, we don’t know when or even if the next one will come, and there may be an unbounded number of them (from a very bored user). To learn more, see the papers about the design and implementation of </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ck-frtime/&amp;sa=D&amp;source=editors&amp;ust=1695232021655719&amp;usg=AOvVaw1rTfSyu1ttBqGmZrO7l9th">FrTime</a></span><span class="calibre3">, and a similar language for JavaScript called </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mgbcgbk-flapjax/&amp;sa=D&amp;source=editors&amp;ust=1695232021656156&amp;usg=AOvVaw05OqgMykYggyiyBjsWWIJU">Flapjax</a></span><span class="c4">.</span></p>

<h2 class="c27" id="h.1vry9xp4q0qh"><span class="c4">Returning to Our Timer</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can write the original timer program using FrTime’s GUI library. Here is the program, explained.</span></p><h3 class="c79" id="h.qqvpxt94c7zg"><span class="c80">Elapsed Time Without Resetting</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">First we will write a simpler version that simply shows the elapsed time since the program began. To do so, we need to load the GUI library:</span></p><p class="c3"><span class="c4"/></p><pre>(require frtime/gui)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and then we need to determine how much time has elapsed. It may be tempting to write</span></p><p class="c3"><span class="c4"/></p><pre>(define init-time seconds)
(define elapsed-time (- seconds init-time))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and then make a GUI display object that presents this (after converting the number into a string):</span></p><p class="c3"><span class="c4"/></p><pre>(make-message (number-&gt;string elapsed-time))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">When we run this, however, we get a rather disappointing display that seems to always show </span><code>0</code><span class="calibre3">. That is because that’s what we asked for! We can check this by asking for the value of </span><code>init-time</code><span class="c4"> in the REPL:</span></p><p class="c3"><span class="c4"/></p><pre>&gt; init-time</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">When we do, we see that it is constantly changing. But that’s what we should expect: we defined it to be the same as </span><code>seconds</code><span class="calibre3">! Instead, we need to hold on to the value of </span><code>seconds</code><span class="calibre3"> </span><span class="c7">at the time</span><span class="calibre3"> we started the program: i.e., we do </span><span class="c7">not</span><span class="c4"> want it to automatically update. For that, we instead write</span></p><p class="c3"><span class="c4"/></p><pre>(define init-time (value-now seconds))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">and then the rest of the program works as we would expect.</span></p><h3 class="c79" id="h.25o8auykyyi0"><span class="c80">Adding Resets</span></h3><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now let’s add the button. We create a button object, which returns an event stream of its clicks:</span></p><p class="c3"><span class="c4"/></p><pre>(define reset-clicks (make-button "Reset"))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Every time there’s a click, we want the elapsed time to reset to </span><code>0</code><span class="calibre3">. That is, we want to keep track of when the reset occurred. Note that again we need to use </span><code>value-now</code><span class="calibre3"> to get the time when it </span><span class="c7">occurred</span><span class="calibre3">, not the current time. We use </span><code>map-e</code><span class="c4"> to map over event streams:</span></p><p class="c3"><span class="c4"/></p><pre>(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">So we have two kinds of events: the start of the program, and the clicks. We want a single behavior that reflects when these occurred: starting with when the program began, and updating whenever there’s a click. The function </span><code>switch</code><span class="c4"> does this, “switching” the behavior’s value whenever an event occurs:</span></p><p class="c3"><span class="c4"/></p><pre>(define event-times (switch click-times init-time))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">At this point, the elapsed time to show is how far the current time is from the last event:</span></p><p class="c3"><span class="c4"/></p><pre>(define elapsed-time (- seconds event-times))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Visually:</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre53"><img alt="" src="image16.png" title="" class="calibre54"/></span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Putting this all together, and adding the output directive:</span></p><p class="c3"><span class="c4"/></p><pre>(define init-time (value-now seconds))</pre><p class="c3"><span class="c41"/></p><pre>(define reset-clicks (make-button "Reset"))
(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))
(define event-times (switch click-times init-time))
(define elapsed-time (- seconds event-times))</pre><p class="c3"><span class="c41"/></p><pre>(make-message (number-&gt;string elapsed-time))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Observe that in this program, there are two kinds of changes that can occur:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">Another second elapses. Thus, </span><code>seconds</code><span class="calibre3"> changes; so does </span><code>elapsed-time</code><span class="calibre3">; and so </span><code>make-message</code><span class="c4"> updates its output.</span></li><li class="c25 pcalibre"><span class="calibre3">The user clicks the button. Then </span><code>reset-clicks</code><span class="calibre3"> has an event, so </span><code>click-times</code><span class="calibre3"> has an event, </span><code>event-times</code><span class="calibre3"> updates, and so does </span><code>elapsed-time</code><span class="calibre3">, thereby also causing </span><code>make-message</code><span class="c4"> to also update its output.</span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In both cases </span><code>elapsed-time</code><span class="calibre3"> updates, triggering a change in the output. But there are two inputs to the subtraction in </span><code>elapsed-time</code><span class="c4">, and they update for different reasons.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What may be lost in the above presentation, which is incremental to enhance readability, is that we actually have deeply nested expressions that we can think of algebraically. To make that clearer, here is the whole program written as a single expression, with each name replaced with the expression it was bound to (though this is almost certainly a less readable version):</span></p><p class="c3"><span class="c4"/></p><pre>(make-message (number-&gt;string
               (- seconds
                  (switch
                   (map-e (lambda (_) (value-now seconds))
                          (make-button "Reset"))
                   (value-now seconds)))))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The interested reader can prove properties of the time shown based purely on the rules of algebra, perhaps even identifying a slightly unsatisfying behavior in the time shown by the timer (which was also a problem with the callback version).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This example shows that we really can compose expressions in a conventional manner </span><span class="c7">even though</span><span class="c4"> we are writing a reactive program using a GUI library. It is worth comparing the structure of this program against the callback-based version that we started with.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ick-adapt-oo-fwk-frp/&amp;sa=D&amp;source=editors&amp;ust=1695232021664301&amp;usg=AOvVaw1WOPAKU7HpkFtzRQxaaDl3">This paper</a></span><span class="c4"> shows how the GUI library was given a functional-reactive interface by exploiting the encapsulation of object-oriented state.</span></p>

<h1 class="c14" id="h.rxri2v4se7rh"><span class="c4">••••• What’s Next? •••••</span></h1><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">You have just finished a detailed look at the landscape of programming languages.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">It’s a broad and rich landscape with many, many dimensions to consider.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This book has largely eschewed programming language </span><span class="c7">theory</span><span class="c4">, because there are already many wonderful books about that. I recommend:</span></p><p class="c3"><span class="c4"/></p><ul class="c24"><li class="c25 pcalibre"><span class="calibre3">Felleisen, Findler, Flatt: </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://mitpress.mit.edu/9780262062756/semantics-engineering-with-plt-redex/&amp;sa=D&amp;source=editors&amp;ust=1695232021665409&amp;usg=AOvVaw1KqS_Jy_nK815yWIVBp7ex">Semantics Engineering with PLT Redex</a></span></li><li class="c25 pcalibre"><span class="calibre3">Harper: </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/practical-foundations-programming-languages-2nd-edition?format%3DHB%26isbn%3D9781107150300&amp;sa=D&amp;source=editors&amp;ust=1695232021665792&amp;usg=AOvVaw1AAwlEjddhBK-I2YGlk71l">Practical Foundations for Programming Languages</a></span></li><li class="c25 pcalibre"><span class="calibre3">Pierce: </span><span class="c26"><a class="c11" href="https://www.google.com/url?q=https://mitpress.mit.edu/9780262162098/types-and-programming-languages/&amp;sa=D&amp;source=editors&amp;ust=1695232021666106&amp;usg=AOvVaw3g2h6FqQKLiHwO8ZNmsd-O">Types and Programming Languages</a></span></li></ul><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">for three rather different, but all foundational, perspectives on the further study of the subject.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Equally, programming languages are more popular than ever before. Working programmers not only contribute to their development but also put a great deal of effort into understanding more advanced features and distilling them for others. Their work tends to be found on blogs or at various conferences (such as those </span><span class="c16"><a class="c11" href="https://www.google.com/url?q=https://twitter.com/ShriramKMurthi/status/1600574419914854400&amp;sa=D&amp;source=editors&amp;ust=1695232021666661&amp;usg=AOvVaw0QxljIxYwpEq2ec0JQcfOL">listed here</a></span><span class="calibre3">).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">We’re done! </span><span class="c4">I hope you’ve enjoyed reading this as much as I enjoyed writing it!</span></p><p class="c3"><span class="c4"/></p><div class="calibre55"><p class="c158"><span class="c4"/></p></div></body></html>
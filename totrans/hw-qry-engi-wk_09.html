<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Logical Plans and Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Logical Plans and Expressions</h1>
<blockquote>原文：<a href="https://howqueryengineswork.com/05-logical-plan.html">https://howqueryengineswork.com/05-logical-plan.html</a></blockquote>
                        
<p><em>The source code discussed in this chapter can be found in the <code>logical-plan</code> module of the <a href="https://github.com/andygrove/how-query-engines-work">KQuery project</a>.</em></p>
<p>When you write a SQL query, you describe what data you want. The query engine must figure out how to get it. The first step is building a logical plan: a tree structure that represents the computation without specifying exactly how to execute it.</p>
<p>Consider this query:</p>
<pre><code class="language-sql">SELECT name, salary * 1.1 AS new_salary
FROM employees
WHERE department = 'Engineering'
</code></pre>
<p>Before we can execute this, we need a structured representation. The logical plan captures:</p>
<ul>
<li>Read from the <code>employees</code> table</li>
<li>Keep only rows where <code>department = 'Engineering'</code></li>
<li>Compute <code>name</code> and <code>salary * 1.1</code> for each remaining row</li>
</ul>
<p>This chapter covers how to represent these operations as a tree of logical plans and expressions.</p>
<h2 id="why-separate-logical-from-physical"><a class="header" href="#why-separate-logical-from-physical">Why Separate Logical from Physical?</a></h2>
<p>We could jump straight from SQL to execution, but separating logical and physical planning has advantages:</p>
<ol>
<li>Validation: We can check that columns exist and types are compatible before doing any work</li>
<li>Optimization: We can transform the logical plan to make it more efficient</li>
<li>Flexibility: The same logical plan might execute differently depending on data size or available resources</li>
</ol>
<p>A logical plan says “filter rows where X” without specifying whether to use an index, a hash table, or a sequential scan. Those are physical execution details decided later.</p>
<h2 id="the-logicalplan-interface"><a class="header" href="#the-logicalplan-interface">The LogicalPlan Interface</a></h2>
<p>A logical plan represents a relation: a set of rows with a known schema. Each plan can have child plans as inputs, forming a tree.</p>
<pre><code class="language-kotlin">interface LogicalPlan {

  / Returns the schema of the data that will be produced by this logical plan. */
  fun schema(): Schema

  /
   * Returns the children (inputs) of this logical plan. This method is used to
   * enable use of the visitor pattern to walk a query tree.
   */
  fun children(): List&lt;LogicalPlan&gt;
}
</code></pre>
<p>schema() returns the output schema, the columns and their types that this plan produces. This is essential for validation. If a later plan references a column, we can check that it exists in the input schema.</p>
<p>children() returns the input plans. A scan has no children (it reads from a data source). A filter has one child (its input). A join has two children (left and right inputs). This method enables walking the plan tree.</p>
<h2 id="printing-logical-plans"><a class="header" href="#printing-logical-plans">Printing Logical Plans</a></h2>
<p>Debugging query engines requires seeing what the plan looks like. We print plans as indented trees where children are nested under parents:</p>
<pre><code class="language-kotlin">fun format(plan: LogicalPlan, indent: Int = 0): String {
  val b = StringBuilder()
  0.until(indent).forEach { b.append("\t") }
  b.append(plan.toString()).append("\n")
  plan.children().forEach { b.append(format(it, indent + 1)) }
  return b.toString()
}
</code></pre>
<p>Our example query might print as:</p>
<pre><code>Projection: #name, #salary * 1.1 AS new_salary
  Filter: #department = 'Engineering'
    Scan: employees; projection=None
</code></pre>
<p>Read this bottom-up: scan the employees table, filter to Engineering, project the columns we want.</p>
<h2 id="logical-expressions"><a class="header" href="#logical-expressions">Logical Expressions</a></h2>
<p>Plans describe data flow. Expressions describe computations within a plan. A filter plan contains an expression that evaluates to true or false for each row. A projection plan contains expressions that compute output columns.</p>
<p>Expressions can be simple (a column reference, a literal value) or complex (nested arithmetic, function calls). Here are common expression types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression Type</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td>Literal Value</td><td><code>"hello"</code>, <code>12.34</code>, <code>true</code></td></tr>
<tr><td>Column Reference</td><td><code>user_id</code>, <code>first_name</code>, <code>salary</code></td></tr>
<tr><td>Math Expression</td><td><code>salary * 0.1</code>, <code>price + tax</code></td></tr>
<tr><td>Comparison Expression</td><td><code>age &gt;= 21</code>, <code>status != 'inactive'</code></td></tr>
<tr><td>Boolean Expression</td><td><code>age &gt;= 21 AND country = 'US'</code></td></tr>
<tr><td>Aggregate Expression</td><td><code>MIN(salary)</code>, <code>MAX(salary)</code>, <code>SUM(amount)</code>, <code>COUNT(*)</code></td></tr>
<tr><td>Scalar Function</td><td><code>UPPER(name)</code>, <code>CONCAT(first_name, ' ', last_name)</code></td></tr>
<tr><td>Aliased Expression</td><td><code>salary * 1.1 AS new_salary</code></td></tr>
</tbody>
</table>
</div>
<p>Expressions form trees. The expression <code>(a + b) * c</code> has a multiply at the root with two children: an add expression (with children <code>a</code> and <code>b</code>) and a column reference <code>c</code>.</p>
<h2 id="the-logicalexpr-interface"><a class="header" href="#the-logicalexpr-interface">The LogicalExpr Interface</a></h2>
<p>During planning, we need to know what type of value an expression produces. If you write <code>a + b</code>, that is only valid if both columns are numeric. The interface captures this:</p>
<pre><code class="language-kotlin">interface LogicalExpr {

  /
   * Return meta-data about the value that will be produced by this expression
   * when evaluated against a particular input.
   */
  fun toField(input: LogicalPlan): Field
}
</code></pre>
<p>The <code>toField</code> method returns the name and data type of the expression’s output. It takes the input plan because some expressions depend on the input schema. A column reference has the type of whatever column it references. A comparison expression always returns boolean regardless of its inputs.</p>
<h2 id="column-expressions"><a class="header" href="#column-expressions">Column Expressions</a></h2>
<p>The simplest expression references a column by name:</p>
<pre><code class="language-kotlin">class Column(val name: String) : LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return input.schema().fields.find { it.name == name }
        ?: throw SQLException("No column named '$name'")
  }

  override fun toString(): String {
    return "#$name"
  }
}
</code></pre>
<p>The <code>toField</code> implementation looks up the column in the input schema. If it does not exist, that is an error, which we catch during planning rather than execution.</p>
<p>The <code>#</code> prefix in <code>toString</code> is a convention to distinguish column references from literal strings when printing plans.</p>
<h2 id="literal-expressions"><a class="header" href="#literal-expressions">Literal Expressions</a></h2>
<p>Expressions like <code>salary * 1.1</code> need to represent the literal value <code>1.1</code>. We need literal expressions for each data type:</p>
<pre><code class="language-kotlin">class LiteralString(val str: String) : LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return Field(str, ArrowTypes.StringType)
  }

  override fun toString(): String {
    return "'$str'"
  }
}

class LiteralLong(val n: Long) : LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return Field(n.toString(), ArrowTypes.Int64Type)
  }

  override fun toString(): String {
    return n.toString()
  }
}

class LiteralDouble(val n: Double) : LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return Field(n.toString(), ArrowTypes.DoubleType)
  }

  override fun toString(): String {
    return n.toString()
  }
}
</code></pre>
<p>Literal expressions do not depend on the input plan since their type is fixed.</p>
<h2 id="binary-expressions"><a class="header" href="#binary-expressions">Binary Expressions</a></h2>
<p>Most operators take two inputs: comparison (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>), boolean logic (<code>AND</code>, <code>OR</code>), and arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>). We can share structure across these:</p>
<pre><code class="language-kotlin">abstract class BinaryExpr(
    val name: String,
    val op: String,
    val l: LogicalExpr,
    val r: LogicalExpr
) : LogicalExpr {

  override fun toString(): String {
    return "$l $op $r"
  }
}
</code></pre>
<p>The <code>name</code> identifies the expression type. The <code>op</code> is the operator symbol for printing. The <code>l</code> and <code>r</code> are the left and right operands.</p>
<h3 id="comparison-and-boolean-expressions"><a class="header" href="#comparison-and-boolean-expressions">Comparison and Boolean Expressions</a></h3>
<p>Comparisons and boolean operators always produce boolean results:</p>
<pre><code class="language-kotlin">abstract class BooleanBinaryExpr(
    name: String,
    op: String,
    l: LogicalExpr,
    r: LogicalExpr
) : BinaryExpr(name, op, l, r) {

  override fun toField(input: LogicalPlan): Field {
    return Field(name, ArrowTypes.BooleanType)
  }
}

// Comparisons
class Eq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("eq", "=", l, r)
class Neq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("neq", "!=", l, r)
class Gt(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("gt", "&gt;", l, r)
class GtEq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("gteq", "&gt;=", l, r)
class Lt(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("lt", "&lt;", l, r)
class LtEq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("lteq", "&lt;=", l, r)

// Boolean logic
class And(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("and", "AND", l, r)
class Or(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr("or", "OR", l, r)
</code></pre>
<h3 id="math-expressions"><a class="header" href="#math-expressions">Math Expressions</a></h3>
<p>In KQuery, arithmetic expressions preserve the type of the left operand. This is a simplified approach. A production system would handle type promotion):</p>
<pre><code class="language-kotlin">abstract class MathExpr(
    name: String,
    op: String,
    l: LogicalExpr,
    r: LogicalExpr
) : BinaryExpr(name, op, l, r) {

  override fun toField(input: LogicalPlan): Field {
    return Field(name, l.toField(input).dataType)
  }
}

class Add(l: LogicalExpr, r: LogicalExpr) : MathExpr("add", "+", l, r)
class Subtract(l: LogicalExpr, r: LogicalExpr) : MathExpr("subtract", "-", l, r)
class Multiply(l: LogicalExpr, r: LogicalExpr) : MathExpr("mult", "*", l, r)
class Divide(l: LogicalExpr, r: LogicalExpr) : MathExpr("div", "/", l, r)
class Modulus(l: LogicalExpr, r: LogicalExpr) : MathExpr("mod", "%", l, r)
</code></pre>
<h2 id="aggregate-expressions"><a class="header" href="#aggregate-expressions">Aggregate Expressions</a></h2>
<p>Aggregates reduce multiple rows to a single value: <code>SUM</code>, <code>MIN</code>, <code>MAX</code>, <code>AVG</code>, <code>COUNT</code>. They appear in aggregate plans (covered later) and have special semantics.</p>
<pre><code class="language-kotlin">abstract class AggregateExpr(
    val name: String,
    val expr: LogicalExpr
) : LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return Field(name, expr.toField(input).dataType)
  }

  override fun toString(): String {
    return "$name($expr)"
  }
}

class Sum(input: LogicalExpr) : AggregateExpr("SUM", input)
class Min(input: LogicalExpr) : AggregateExpr("MIN", input)
class Max(input: LogicalExpr) : AggregateExpr("MAX", input)
class Avg(input: LogicalExpr) : AggregateExpr("AVG", input)
</code></pre>
<p>Most aggregates return the same type as their input. <code>COUNT</code> is different since it always returns an integer:</p>
<pre><code class="language-kotlin">class Count(input: LogicalExpr) : AggregateExpr("COUNT", input) {

  override fun toField(input: LogicalPlan): Field {
    return Field("COUNT", ArrowTypes.Int32Type)
  }
}
</code></pre>
<h2 id="aliased-expressions"><a class="header" href="#aliased-expressions">Aliased Expressions</a></h2>
<p>SQL’s <code>AS</code> keyword renames an expression’s output:</p>
<pre><code class="language-kotlin">class Alias(val expr: LogicalExpr, val alias: String) : LogicalExpr {

  override fun toField(input: LogicalPlan): Field {
    return Field(alias, expr.toField(input).dataType)
  }

  override fun toString(): String {
    return "$expr as $alias"
  }
}
</code></pre>
<p>The alias changes the name but preserves the type.</p>
<h2 id="logical-plans"><a class="header" href="#logical-plans">Logical Plans</a></h2>
<p>With expressions defined, we can build the plans that use them.</p>
<h3 id="scan"><a class="header" href="#scan">Scan</a></h3>
<p><code>Scan</code> reads from a data source. It is the leaf node in every query tree, the place where data enters the plan.</p>
<pre><code class="language-kotlin">class Scan(
    val path: String,
    val dataSource: DataSource,
    val projection: List&lt;String&gt;
) : LogicalPlan {

  val schema = deriveSchema()

  override fun schema(): Schema {
    return schema
  }

  private fun deriveSchema(): Schema {
    val schema = dataSource.schema()
    if (projection.isEmpty()) {
      return schema
    } else {
      return schema.select(projection)
    }
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf()
  }

  override fun toString(): String {
    return if (projection.isEmpty()) {
      "Scan: $path; projection=None"
    } else {
      "Scan: $path; projection=$projection"
    }
  }
}
</code></pre>
<p>The <code>projection</code> parameter lists which columns to read. If empty, read all columns. This optimization matters because reading fewer columns means less I/O and less memory.</p>
<h3 id="selection-filter"><a class="header" href="#selection-filter">Selection (Filter)</a></h3>
<p><code>Selection</code> keeps only rows where an expression evaluates to true. This corresponds to SQL’s <code>WHERE</code> clause.</p>
<pre><code class="language-kotlin">class Selection(
    val input: LogicalPlan,
    val expr: LogicalExpr
) : LogicalPlan {

  override fun schema(): Schema {
    return input.schema()  // filtering doesn't change the schema
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf(input)
  }

  override fun toString(): String {
    return "Filter: $expr"
  }
}
</code></pre>
<p>The schema passes through unchanged since filtering only removes rows, not columns.</p>
<h3 id="projection"><a class="header" href="#projection">Projection</a></h3>
<p><code>Projection</code> computes new columns from expressions. This corresponds to SQL’s <code>SELECT</code> list.</p>
<pre><code class="language-kotlin">class Projection(
    val input: LogicalPlan,
    val expr: List&lt;LogicalExpr&gt;
) : LogicalPlan {

  override fun schema(): Schema {
    return Schema(expr.map { it.toField(input) })
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf(input)
  }

  override fun toString(): String {
    return "Projection: ${expr.map { it.toString() }.joinToString(", ")}"
  }
}
</code></pre>
<p>The output schema comes from the expressions. If you project <code>name</code> and <code>salary * 1.1 AS bonus</code>, the output schema has two columns with those names and appropriate types.</p>
<h3 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h3>
<p><code>Aggregate</code> groups rows and computes aggregate functions. This corresponds to SQL’s <code>GROUP BY</code> with aggregate functions.</p>
<pre><code class="language-kotlin">class Aggregate(
    val input: LogicalPlan,
    val groupExpr: List&lt;LogicalExpr&gt;,
    val aggregateExpr: List&lt;AggregateExpr&gt;
) : LogicalPlan {

  override fun schema(): Schema {
    return Schema(
      groupExpr.map { it.toField(input) } +
      aggregateExpr.map { it.toField(input) }
    )
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf(input)
  }

  override fun toString(): String {
    return "Aggregate: groupExpr=$groupExpr, aggregateExpr=$aggregateExpr"
  }
}
</code></pre>
<p>The output schema has the grouping columns first, followed by the aggregate results. For <code>SELECT department, AVG(salary) FROM employees GROUP BY department</code>, the output has two columns: <code>department</code> and <code>AVG(salary)</code>.</p>
<h3 id="join"><a class="header" href="#join">Join</a></h3>
<p><code>Join</code> combines rows from two inputs based on a condition. Unlike the plans we have seen so far, joins have two children: a left input and a right input.</p>
<pre><code class="language-kotlin">class Join(
    val left: LogicalPlan,
    val right: LogicalPlan,
    val joinType: JoinType,
    val condition: LogicalExpr
) : LogicalPlan {

  override fun schema(): Schema {
    return Schema(left.schema().fields + right.schema().fields)
  }

  override fun children(): List&lt;LogicalPlan&gt; {
    return listOf(left, right)
  }

  override fun toString(): String {
    return "Join: type=$joinType, condition=$condition"
  }
}

enum class JoinType {
  INNER, LEFT, RIGHT, FULL, SEMI, ANTI
}
</code></pre>
<p>The output schema combines columns from both inputs. The join type determines which rows appear in the output: inner joins return only matching rows, outer joins include unmatched rows with nulls, and so on.</p>
<p>Joins are fundamental to relational queries but come with significant complexity: multiple join types, various join algorithms with different performance characteristics, and optimization challenges. The Joins chapter covers these topics in depth.</p>
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting It Together</a></h2>
<p>Here is how our example query becomes a logical plan:</p>
<pre><code class="language-sql">SELECT name, salary * 1.1 AS new_salary
FROM employees
WHERE department = 'Engineering'
</code></pre>
<p>Building bottom-up:</p>
<pre><code class="language-kotlin">val scan = Scan("employees", employeeDataSource, listOf())

val filter = Selection(
    scan,
    Eq(Column("department"), LiteralString("Engineering"))
)

val project = Projection(
    filter,
    listOf(
        Column("name"),
        Alias(Multiply(Column("salary"), LiteralDouble(1.1)), "new_salary")
    )
)
</code></pre>
<p>Printed:</p>
<pre><code>Projection: #name, #salary * 1.1 as new_salary
  Filter: #department = 'Engineering'
    Scan: employees; projection=None
</code></pre>
<p>This logical plan can now be validated (do the columns exist?), optimized (can we push the projection into the scan?), and eventually converted to a physical plan for execution.</p>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Query plans sometimes need to be serialized: sent across a network, stored for later, or passed between systems in different languages.</p>
<p>Options include language-specific serialization (JSON with Jackson in Java, kotlinx.serialization in Kotlin) or language-agnostic formats like Protocol Buffers or Avro.</p>
<p>A newer standard called <a href="https://substrait.io/">Substrait</a> aims to provide cross-language serialization for relational algebra. This is exciting because it enables mixing components: use Apache Calcite for query planning in Java, serialize to Substrait, execute in a Rust or C++ engine. If you are building a query engine today, Substrait is worth investigating.</p>
<p><em>This book is also available for purchase in ePub, MOBI, and PDF format from <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a></em></p>
<p><strong>Copyright © 2020-2025 Andy Grove. All rights reserved.</strong></p>

                        
</body>
</html>
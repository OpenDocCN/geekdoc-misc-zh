["```rs\nfn main() {\n    let pattern = \"him\";\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    for line in poem.lines() {\n        match line.contains(pattern) {\n            true => println!(\"{line}\"),\n            false => (),\n        }\n    }\n}\n```", "```rs\n Compiling playground v0.0.1 (/playground)\nerror[E0004]: non-exhaustive patterns: `false` not covered\n  --> src/main.rs:14:15\n   |\n14 |         match line.contains(pattern) {\n   |               ^^^^^^^^^^^^^^^^^^^^^^ pattern `false` not covered\n   |\n   = note: the matched value is of type `bool`\nhelp: ensure that all possible cases are being handled by adding a match arm with a\n   |  wildcard pattern or an explicit pattern as shown\n   |\n15 ~             true => println!(\"{line}\"),\n16 ~             false => todo!(),\n   |\n\nFor more information about this error, try `rustc --explain E0004`.\nerror: could not compile `playground` (bin \"playground\") due to 1 previous error \n```", "```rs\n$ rustc --explain E0004\nThis error indicates that the compiler cannot guarantee a matching pattern for\none or more possible inputs to a match expression. Guaranteed matches are\nrequired in order to assign values to match expressions, or alternatively,\ndetermine the flow of execution.\n\nErroneous code example:\n\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n    Terminator::TalkToMyHand => {}\n}\n\nIf you encounter this error you must alter your patterns so that every possible\nvalue of the input type is matched. For types with a small number of variants\n(like enums) you should probably cover all cases explicitly. Alternatively, the\nunderscore `_` wildcard pattern can be added after all other patterns to match\n\"anything else\". Example:\n\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    Terminator::HastaLaVistaBaby => {}\n}\n\n// or:\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    _ => {}\n}\n```", "```rs\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n} \n```", "```rs\nfn main() {\n    let pattern = \"him\";\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    for line in poem.lines() {\n        if line.contains(pattern) {\n            println!(\"{line}\");\n        }\n    }\n}\n```"]
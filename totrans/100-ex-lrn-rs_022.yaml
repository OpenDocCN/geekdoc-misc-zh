- en: Memory layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存布局
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/08_stack.html](https://rust-exercises.com/100-exercises/03_ticket_v1/08_stack.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/08_stack.html](https://rust-exercises.com/100-exercises/03_ticket_v1/08_stack.html)
- en: 'We''ve looked at ownership and references from an operational point of view—what
    you can and can''t do with them. Now it''s a good time to take a look under the
    hood: let''s talk about **memory**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从操作的角度探讨了所有权和引用——你可以用它们做什么，不能做什么。现在是时候揭开盖子看看了：让我们来谈谈**内存**。
- en: '[Stack and heap](#stack-and-heap)'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[栈和堆](#stack-and-heap)'
- en: When discussing memory, you'll often hear people talk about the **stack** and
    the **heap**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论内存时，你经常会听到人们谈论**栈**和**堆**。
- en: These are two different memory regions used by programs to store data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是程序用来存储数据的两个不同的内存区域。
- en: Let's start with the stack.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从栈开始。
- en: '[Stack](#stack)'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[栈](#stack)'
- en: The **stack** is a **LIFO** (Last In, First Out) data structure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**是一个**后进先出**（LIFO）的数据结构。'
- en: When you call a function, a new **stack frame** is added on top of the stack.
    That stack frame stores the function's arguments, local variables and a few "bookkeeping"
    values.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，一个新的**栈帧**会被添加到栈顶。这个栈帧存储了函数的参数、局部变量和一些“记账”值。
- en: When the function returns, the stack frame is popped off the stack^([1](#footnote-stack-overflow)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数返回时，栈帧会被从栈中弹出^([1](#footnote-stack-overflow))。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From an operational point of view, stack allocation/de-allocation is **very
    fast**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作的角度来看，栈的分配/释放是非常快的。
- en: 'We are always pushing and popping data from the top of the stack, so we don''t
    need to search for free memory. We also don''t have to worry about fragmentation:
    the stack is a single contiguous block of memory.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是从栈顶推入和弹出数据，所以我们不需要搜索空闲内存。我们也不必担心碎片化：栈是一个单一的连续内存块。
- en: '[Rust](#rust)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Rust](#rust)'
- en: Rust will often allocate data on the stack.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Rust经常会将数据分配在栈上。
- en: You have a `u32` input argument in a function? Those 32 bits will be on the
    stack.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你在函数中有一个`u32`输入参数？这32位将会在栈上。
- en: You define a local variable of type `i64`? Those 64 bits will be on the stack.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个类型为`i64`的局部变量？这64位将会在栈上。
- en: It all works quite nicely because the size of those integers is known at compile
    time, therefore the compiled program knows how much space it needs to reserve
    on the stack for them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都工作得相当好，因为这些整数的尺寸在编译时是已知的，因此编译后的程序知道它需要为它们在栈上预留多少空间。
- en: '[`std::mem::size_of`](#stdmemsize_of)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`std::mem::size_of`](#stdmemsize_of)'
- en: You can verify how much space a type would take on the stack using the [`std::mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html)
    function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`[`std::mem::size_of](https://doc.rust-lang.org/std/mem/fn.size_of.html)`函数来验证一个类型在栈上会占用多少空间。
- en: 'For a `u8`, for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于一个`u8`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 1 makes sense, because a `u8` is 8 bits long, or 1 byte.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 1 有意义，因为`u8`是8位长，或者说1字节。
- en: '[Exercise](#exercise)'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`03_ticket_v1/08_stack`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/08_stack)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于[`03_ticket_v1/08_stack`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/08_stack)
- en: '* * *'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: If you have nested function calls, each function pushes its data onto the stack
    when it's called but it doesn't pop it off until the innermost function returns.
    If you have too many nested function calls, you can run out of stack space—the
    stack is not infinite! That's called a [**stack overflow**](https://en.wikipedia.org/wiki/Stack_overflow).
    [↩](#fr-stack-overflow-1)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有多层嵌套的函数调用，每个函数在调用时会将其数据推入栈中，但它不会在内部函数返回之前将其弹出。如果你有太多的嵌套函数调用，你可能会耗尽栈空间——栈不是无限的！这被称为[**栈溢出**](https://en.wikipedia.org/wiki/Stack_overflow)。[↩](#fr-stack-overflow-1)

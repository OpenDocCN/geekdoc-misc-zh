<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Benchmarks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Benchmarks</h1>
<blockquote>原文：<a href="https://howqueryengineswork.com/17-benchmarks.html">https://howqueryengineswork.com/17-benchmarks.html</a></blockquote>
                        
<p>Each query engine is unique in terms of performance, scalability, and resource requirements, often with different trade-offs. Benchmarks help us understand these characteristics and make informed decisions about which query engine to use for a particular workload. They also help query engine developers identify performance regressions and track improvements over time.</p>
<h2 id="measuring-performance"><a class="header" href="#measuring-performance">Measuring Performance</a></h2>
<p>Performance is often the simplest characteristic to measure and usually refers to the time it takes to perform a particular operation. For example, benchmarks can be built to measure the performance of specific queries or categories of query.</p>
<p>Performance tests typically involve executing a query multiple times and measuring elapsed time.</p>
<h2 id="measuring-scalability"><a class="header" href="#measuring-scalability">Measuring Scalability</a></h2>
<p>Scalability can be an overloaded term and there are many different types of scalability. The term scalability generally refers to how performance varies with different values for some variable that affects performance.</p>
<p>One example would be measuring scalability as total data size increases to discover how performance is impacted, when querying 10 GB of data versus 100 GB or 1 TB. A common goal is to demonstrate linear scalability, meaning that querying 100 GB of data should take 10 times as long as querying 10 GB of data. Linear scalability makes it easy for users to reason about expected behavior.</p>
<p>Other examples of variables that affect performance are:</p>
<ul>
<li>Number of concurrent users, requests, or queries.</li>
<li>Number of data partitions.</li>
<li>Number of physical disks.</li>
<li>Number of cores.</li>
<li>Number of nodes.</li>
<li>Amount of RAM available.</li>
<li>Type of hardware (Raspberry Pi versus Desktop, for example).</li>
</ul>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<p>When measuring scalability based on number of concurrent requests, we are often more interested in throughput (total number of queries executed per period of time) rather than the duration of individual queries, although we typically would collect that information as well.</p>
<h2 id="automation"><a class="header" href="#automation">Automation</a></h2>
<p>Benchmarks are often very time-consuming to run and automation is essential so that the benchmarks can be run often, perhaps once per day or once per week, so that any performance regressions can be caught early.</p>
<p>Automation is also important for ensuring that benchmarks are executed consistently and that results are collected with all relevant details that might be needed when analyzing the results.</p>
<p>Here are some examples of the type of data that should be collected when executing benchmarks:</p>
<h3 id="hardware-configuration"><a class="header" href="#hardware-configuration">Hardware Configuration</a></h3>
<ul>
<li>Type of hardware</li>
<li>Number of CPU cores</li>
<li>Available memory and disk space</li>
<li>Operating system name and version</li>
</ul>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<ul>
<li>Environment variables (being careful not to leak secrets)</li>
</ul>
<h3 id="benchmark-configuration"><a class="header" href="#benchmark-configuration">Benchmark Configuration</a></h3>
<ul>
<li>Version of benchmark software used</li>
<li>Version of software under test</li>
<li>Any configuration parameters or files</li>
<li>Filenames of any data files being queried</li>
<li>Data sizes and checksums for the data files</li>
<li>Details about the query that was executed</li>
</ul>
<h3 id="benchmark-results"><a class="header" href="#benchmark-results">Benchmark Results</a></h3>
<ul>
<li>Date/time benchmark was started</li>
<li>Start time and end time for each query</li>
<li>Error information for any failed queries</li>
</ul>
<h2 id="comparing-benchmarks"><a class="header" href="#comparing-benchmarks">Comparing Benchmarks</a></h2>
<p>It is important to compare benchmarks between releases of the software so that changes in performance characteristics are apparent and can be investigated further. Benchmarks produce a lot of data that is often hard to compare manually, so it can be beneficial to build tooling to help with this process.</p>
<p>Rather than comparing two sets of performance data directly, tooling can perform a “diff” of the data and show percentage differences between two or more runs of the same benchmark. It is also useful to be able to produce charts showing multiple benchmark runs.</p>
<h2 id="visualising-benchmark-results"><a class="header" href="#visualising-benchmark-results">Visualising Benchmark Results</a></h2>
<p>Raw benchmark data in tabular form can be difficult to interpret. Charts and graphs make it much easier to see patterns, identify anomalies, and communicate results to others.</p>
<p>When visualising performance data, consider charting throughput rather than raw execution times. Throughput, often expressed as queries per minute or queries per second, provides a more intuitive measure of system capacity. If a query takes 5 seconds to execute, then the system can handle 12 queries per minute on a single thread. This framing makes it easier to understand real-world capacity.</p>
<p>Line charts work well for showing how performance scales with increasing resources such as CPU cores or memory, or with increasing data sizes. Bar charts are useful for comparing different configurations or different query engines side by side.</p>
<p>Be careful when creating visualisations to use appropriate scales. Starting a y-axis at zero rather than at some arbitrary value gives a more honest representation of differences between data points. Using logarithmic scales can be appropriate when dealing with data that spans several orders of magnitude.</p>
<h2 id="transaction-processing-council-tpc-benchmarks"><a class="header" href="#transaction-processing-council-tpc-benchmarks">Transaction Processing Council (TPC) Benchmarks</a></h2>
<p>The Transaction Processing Council is a consortium of database vendors that collaborate on creating and maintaining various database benchmark suites to allow for fair comparisons between vendor’s systems. Current TPC member companies include Microsoft, Oracle, IBM, Hewlett Packard Enterprise, AMD, Intel, and NVIDIA.</p>
<p>The first benchmark, TPC-A, was published in 1989 and other benchmarks have been created since then. TPC-C is a well known OLTP benchmark used when comparing traditional RDBMS databases, and TPC-H (discontinued) and TPC-DS are often used for measuring performance of “Big Data” query engines.</p>
<p>TPC benchmarks are seen as the “gold standard” in the industry and are complex and time consuming to implement fully. Also, results for these benchmarks can only be published by TPC members and only after the benchmarks have been audited by the TPC. Taking TPC-DS as an example, the only companies to have ever published official results at the time of writing are Alibaba.com, H2C, SuperMicro, and Databricks.</p>
<p>However, the TPC has a Fair Use policy that allows non-members to create unofficial benchmarks based on TPC benchmarks, as long as certain conditions are followed, such as prefixing any use of the term TPC with “derived from TPC”. For example, “Performance of Query derived from TPC-DS Query 14”. TPC Copyright Notice and License Agreements must also be maintained. There are also limitations on the types of metrics that can be published.</p>
<p>Many open source projects simply measure the time to execute individual queries from the TPC benchmark suites and use this as a way to track performance over time and for comparison with other query engines.</p>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p>There are several common mistakes to avoid when designing and running benchmarks.</p>
<p>The first run of a query is often slower than subsequent runs due to JIT compilation, cache population, and other startup effects. Running several warm-up iterations before collecting measurements helps ensure that results reflect steady-state performance rather than cold-start behaviour.</p>
<p>Running benchmarks on a machine that is also doing other work can introduce significant variability. Dedicated benchmark environments, or at least ensuring minimal background activity, produce more reliable results.</p>
<p>Running a query once and reporting that single result tells you very little. Running multiple iterations and reporting statistics such as mean, median, and standard deviation gives a much better picture of typical performance and its variability.</p>
<p>Benchmarks that use tiny datasets or trivially simple queries may not reveal performance characteristics that matter for real workloads. Using realistic data sizes and query complexity is important for meaningful results.</p>
<p>It can be tempting to only show results that make your query engine look good, but publishing complete results, including queries where performance is poor, builds credibility and helps identify areas for improvement.</p>
<h2 id="building-your-own-benchmarks"><a class="header" href="#building-your-own-benchmarks">Building Your Own Benchmarks</a></h2>
<p>While industry-standard benchmarks like TPC-DS are valuable for comparing different systems, they may not reflect your specific workload. Building custom benchmarks based on real queries from your application can provide more relevant insights.</p>
<p>When building custom benchmarks, start by identifying the queries that matter most to your users. These might be the most frequently executed queries, or the queries that are most sensitive to latency. Instrument your application to collect query logs, then select representative queries for benchmarking.</p>
<p>Create datasets that match your production data in terms of size, distribution, and schema complexity. Synthetic data generators can help create large datasets with controlled characteristics, but be aware that randomly generated data may have different statistical properties than real data.</p>
<p>Document your benchmark methodology thoroughly so that results can be reproduced. This includes not just the queries and data, but also the hardware, operating system, and any configuration settings that might affect performance.</p>
<p><em>This book is also available for purchase in ePub, MOBI, and PDF format from <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a></em></p>
<p><strong>Copyright © 2020-2025 Andy Grove. All rights reserved.</strong></p>

                        
</body>
</html>
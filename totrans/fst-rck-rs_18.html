<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Vec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Vec</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/vec.html">https://freddiehaddad.github.io/fast-track-to-rust/vec.html</a></blockquote>
                        
<p>A <code>Vec</code>, short for vector, is a contiguous growable array type, written as
<code>Vec&lt;T&gt;</code>. Although we haven't covered user-defined types yet, <code>Vec</code> is
implemented using a <code>struct</code>.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> It supports many familiar operations like
<code>push</code>, <code>pop</code>, and <code>len</code>, but also includes some operations you might not be
familiar with.</p>
<h2 id="storing-our-lines-in-a-vector"><a class="header" href="#storing-our-lines-in-a-vector">Storing our Lines in a Vector</a></h2>
<p>Let's populate a vector with the input we've been using so far in our rustle
program. There are several ways to create a vector, and the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">documentation</a>
provides plenty of examples. We'll explore a few of them.</p>
<h3 id="using-push"><a class="header" href="#using-push">Using <code>push</code></a></h3>
<p>Someone with a C++ background might be inclined to achieve this using a variant
of the following form:</p>
<blockquote>
<p>Hidden code</p>
<p>To make reading the code easier, only the new parts are visible. You can view
previously seen code by clicking the <em>Show hidden lines</em> button when hovering
over the code block.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span>    let mut lines = Vec::new(); // each call to push mutates the vector
    for line in poem.lines() {
        lines.push(line);
    }

    // format text for debugging purposes
    println!("{lines:?}");
<span class="boring">}</span></code></pre></pre>
<p>We haven't discussed traits yet, so for now, just know that <code>:?</code> specifies
formatting the output with the <code>Debug</code><sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> trait. The vector type implements the
<code>fmt::Debug</code> trait.</p>
<h3 id="using-an-iterator"><a class="header" href="#using-an-iterator">Using an Iterator</a></h3>
<p>While using <code>push</code> is functionally correct, it introduces a mutable variable
unnecessarily. An idiomatic solution would look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::iter::FromIterator; // this line addresses a rust playground bug
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span>    // convert poem into lines
    let lines = Vec::from_iter(poem.lines());
<span class="boring">
</span><span class="boring">    // format text for debugging purposes
</span><span class="boring">    println!("{lines:?}");
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Favoring immutability</p>
<p>The concept of being <em>immutable by default</em> is one of the many ways Rust
encourages you to write code that leverages its safety features and supports
easy concurrency.</p>
</blockquote>
<h2 id="tracking-all-matches"><a class="header" href="#tracking-all-matches">Tracking all Matches</a></h2>
<p>Now that we have a vector containing all the lines in our poem, let's create
another vector to hold the line numbers where the pattern was found.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::iter::FromIterator; // this line addresses a rust playground bug
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span>    let pattern = "all";

<span class="boring">    // convert the poem into lines
</span><span class="boring">    let lines = Vec::from_iter(poem.lines());
</span><span class="boring">
</span>    // store the 0-based line number for any matched line
    let match_lines: Vec&lt;_&gt; = lines // inferred type (_)
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match line.contains(pattern) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect(); // turns anything iterable into a collection
<span class="boring">
</span><span class="boring">    // format text for debugging purposes
</span><span class="boring">    println!("{match_lines:?}");
</span><span class="boring">}</span></code></pre></pre>
<p>Instead of using <code>from_iter</code>, you can also use <code>collect</code>.</p>
<blockquote>
<p>The inferred type (<code>_</code>) in <code>Vec&lt;_&gt;</code> <em>asks</em> the compiler to infer the type if
possible based on the surrounding context.<sup class="footnote-reference" id="fr-2-2"><a href="#footnote-2">2</a></sup></p>
</blockquote>
<h2 id="creating-intervals-from-matched-lines"><a class="header" href="#creating-intervals-from-matched-lines">Creating Intervals from Matched Lines</a></h2>
<p>The <code>map</code> function invokes the <code>closure</code> once for each value in the vector,
passing <code>line_no</code> (the line number) to the function. We use this to identify the
lines before and after the match that we want to print. To handle potential
out-of-bounds indexing, we use <code>saturating_add</code> and <code>saturating_sub</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::iter::FromIterator; // this line addresses a rust playground bug
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let pattern = "all";
</span>    let before_context = 1;
    let after_context = 1;

<span class="boring">    // convert the poem into lines
</span><span class="boring">    let lines = Vec::from_iter(poem.lines());
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines: Vec&lt;_&gt; = lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match line.contains(pattern) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect(); // turns anything iterable into a collection
</span><span class="boring">
</span>    // create intervals of the form [a,b] with the before/after context
    let intervals: Vec&lt;_&gt; = match_lines
        .iter()
        .map(|line_no| {
            (
                // prevent underflow
                line_no.saturating_sub(before_context),
                // prevent overflow
                line_no.saturating_add(after_context),
            )
        })
        .collect();
<span class="boring">
</span><span class="boring">    // format text for debugging purposes
</span><span class="boring">    println!("{intervals:?}");
</span><span class="boring">}</span></code></pre></pre>
<h2 id="merging-intervals"><a class="header" href="#merging-intervals">Merging Intervals</a></h2>
<p>Merging overlapping intervals is straightforward because they are already
sorted, and the ending value of the next interval must be greater than the
current one. We could store the merged intervals in a new Vector, but that would
be inefficient. Instead, we'll make our <code>intervals</code> vector mutable and take
advantage of the <code>dedup_by</code> iterator adaptor to perform the merge.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::iter::FromIterator; // this line addresses a rust playground bug
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let pattern = "all";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span><span class="boring">
</span><span class="boring">    // convert the poem into lines
</span><span class="boring">    let lines = Vec::from_iter(poem.lines());
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines: Vec&lt;_&gt; = lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match line.contains(pattern) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect(); // turns anything iterable into a collection
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span>    let mut intervals: Vec&lt;_&gt; = match_lines
<span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            (
</span><span class="boring">                line.saturating_sub(before_context),
</span><span class="boring">                line.saturating_add(after_context),
</span><span class="boring">            )
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span>    // merge overlapping intervals
    intervals.dedup_by(|next, prev| {
        if prev.1 &lt; next.0 {
            false
        } else {
            prev.1 = next.1;
            true
        }
    });
<span class="boring">
</span><span class="boring">    // format text for debugging purposes
</span><span class="boring">    println!("{intervals:?}");
</span><span class="boring">}</span></code></pre></pre>
<p>The <a href="https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.dedup_by"><code>dedup_by</code></a> iterator adaptor removes consecutive identical elements based
on a provided closure. It starts by calling the closure with the first (<code>prev</code>)
and second (<code>next</code>) elements in the collection. If the closure returns <code>false</code>,
<code>prev</code> becomes <code>next</code>, <code>next</code> is advanced, and the closure is called with the
new elements. If the closure returns <code>true</code>, only <code>next</code> is advanced. This
behavior allows us to update <code>prev</code> to be the merged interval, enabling
efficient merging of overlapping intervals.</p>
<blockquote>
<p>Tuple fields are accessed using a 0-based index, just like array elements.</p>
</blockquote>
<h2 id="print-the-results"><a class="header" href="#print-the-results">Print the Results</a></h2>
<p>With our intervals merged, we can now print out the results correctly!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::iter::FromIterator; // this line addresses a rust playground bug
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let pattern = "all";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span><span class="boring">
</span><span class="boring">    // convert the poem into lines
</span><span class="boring">    let lines = Vec::from_iter(poem.lines());
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines: Vec&lt;_&gt; = lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match line.contains(pattern) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect(); // turns anything iterable into a collection
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let mut intervals: Vec&lt;_&gt; = match_lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            (
</span><span class="boring">                line.saturating_sub(before_context),
</span><span class="boring">                line.saturating_add(after_context),
</span><span class="boring">            )
</span><span class="boring">        })
</span><span class="boring">        .collect();
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals.dedup_by(|next, prev| {
</span><span class="boring">        if prev.1 &lt; next.0 {
</span><span class="boring">            false
</span><span class="boring">        } else {
</span><span class="boring">            prev.1 = next.1;
</span><span class="boring">            true
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span>    // print the lines
    for (start, end) in intervals {
        for (line_no, line) in lines
                .iter()
                .enumerate()
                .take(end + 1)
                .skip(start) {
            println!("{}: {}", line_no + 1, line)
        }
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="we-did-it"><a class="header" href="#we-did-it">We Did It!</a></h2>
<p>We have a working rustle program! Take some time to review everything we've
covered so far. The rest of the course is going to move quickly.</p>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>We covered quite a bit in this section:</p>
<ul>
<li><code>collect</code> converts any iterable into a collection.</li>
<li><code>saturating_add</code> and <code>saturating_sub</code> prevent overflow.</li>
<li><code>skip</code> creates an iterator that skips elements until <code>n</code> elements are skipped
or the end of the iterator is reached, whichever comes first.</li>
<li><code>take</code> creates an iterator that yields elements until <code>n</code> elements are yielded
or the end of the iterator is reached, whichever comes first.</li>
<li>The <code>println!</code> macro supports the <a href="https://doc.rust-lang.org/std/fmt/index.html#fmtdisplay-vs-fmtdebug"><code>:?</code></a> format specifier, which is intended
to help with debugging Rust code. All public types should implement the
<code>fmt::Debug trait</code>.<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup></li>
</ul>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>Let's dive into the concepts of ownership and borrowing.</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>Refer to the <a href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html"><code>Vec</code> source code</a> see it's full implementation. The <code>struct</code>
definition is on line <a href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#397">397</a>. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>The <a href="https://doc.rust-lang.org/reference/types/inferred.html?highlight=Vec%3C_%3E#inferred-type">Inferred type</a> is part of the type system in Rust. <a href="#fr-2-1">↩</a> <a href="#fr-2-2">↩2</a></p>
</li>
<li id="footnote-3">
<p>Details about the <code>Debug</code> trait can be found
<a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">here</a>. <a href="#fr-3-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
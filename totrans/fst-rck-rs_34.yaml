- en: Struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/struct.html](https://freddiehaddad.github.io/fast-track-to-rust/struct.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We're going to create a type to represent an interval. Rust follows a standardized
    naming convention for types, where structures use `UpperCamelCase`^([1](#footnote-1))
    for "type-level" constructs. Therefore, we'll name our `struct` `Interval`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Defining our Struct](#defining-our-struct)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our closed interval is going to represent the start and end of the lines to
    print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Defining Behavior](#defining-behavior)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions and methods are added by defining them inside an `impl` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[The `new` Function](#the-new-function)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it is common convention in Rust to define a function called `new` for creating
    an object, we'll begin by defining one to return an `Interval`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `Self`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `Self` keywords in the return type and the body of the function are aliases
    for the type specified after the `impl` keyword, which in this case is `Interval`.
    While the type can be explicitly stated, the common convention is to use `Self`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exclusion of the `return` keyword and (`;`)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `return` keyword is unnecessary when the returned value is the final expression
    in a function. In this scenario, the semicolon (`;`) is omitted. ^([2](#footnote-2))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Methods](#methods)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall from our rustle program that we merged overlapping intervals to prevent
    printing the same line multiple times. It would be useful to create a method to
    check if two intervals overlap and another method to merge overlapping intervals.
    Let's outline these methods!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `todo!()` and `unimplemented!()` macros can be useful if you are prototyping
    and just want a placeholder to let your code pass type analysis.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[The `self` Method Receiver](#the-self-method-receiver)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You're probably accustomed to using the implicit `this` pointer (a hidden first
    parameter) in your class methods. In Rust, the [`self`](https://doc.rust-lang.org/std/keyword.self.html)
    keyword is used to represent the receiver of a method and the convention is to
    omit the type for this parameter. Depending on the intended behavior, it can be
    specified as `self`, `&self` or `&mut self`.^([3](#footnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: 'Omitting the type after `self` is syntactic sugar. It''s short for `self: Self`.
    As `Self` is an alias to the actual type, the full expansion would be `self: Interval`,
    `self: &Interval` or `self: &mut Interval`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Implementing the Methods](#implementing-the-methods)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that our rustle program processes lines sequentially. This allows us
    to optimize the detection of overlapping intervals. However, this approach limits
    the versatility of our `Interval` type. As an exercise, you can work on making
    it more generic.
  prefs: []
  type: TYPE_NORMAL
- en: '[`overlaps`](#overlaps)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `overlaps` method is fairly straightforward. We check if the `end` of the
    first interval is greater than or equal to the `start` of the next interval. The
    only caveat is the order of the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[`merge`](#merge)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `merge` method returns a new `Interval` using the `start` of the first
    interval and the `end` of the second. The same caveat applies: the receiver must
    be the interval that comes first in the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, an immutable borrow for both intervals is sufficient since we
    do not need to mutate either value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Implementing `merge_intervals`](#implementing-merge_intervals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rust programmers coming from a C++ background might be inclined to implement
    this function using some variation of the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While functionally correct, Rust features powerful crates that can make implementing
    this behavior more concise. One such crate is [`Itertools`](https://docs.rs/itertools/latest/itertools),
    which provides extra iterator adaptors. To use this crate, specify it as a dependency
    in `Crates.toml` and include it in `main.rs` with `use itertools::Itertools`.
    Let''s see how the [`coalesce`](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.coalesce)
    adaptor can simplify the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`into_iter`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In both implementations, we use `into_iter`, which creates a consuming iterator
    that moves each value out of the vector from start to end. This is another example
    of how we can take advantage of move semantics.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'NOTE: Because the iterator consumes the data, the vector cannot be used afterward.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Updating Rustle](#updating-rustle)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's time to update our rustle program to utilize our new type. Additionally,
    a few minor changes have been made to enhance the design, demonstrate some additional
    language features, and leverage move semantics. Give the program a run!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use itertools::Itertools;'
  prefs: []
  type: TYPE_NORMAL
- en: 'use regex::Regex; use std::fs::File; use std::io::Read; use std::io::{BufRead,
    BufReader}; use std::process::exit;   fn find_matching_lines(lines: &[String],
    regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }
  prefs: []
  type: TYPE_NORMAL
- en: fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'before_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'after_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Vec<Interval> {
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let start = line.saturating_sub(before_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let end = line.saturating_add(after_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Interval::new(start, end)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .into_iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .coalesce(|p, c| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if p.overlaps(&c) {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(p.merge(&c))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err((p, c))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_results(intervals: Vec<Interval>, lines: Vec<String>) {'
  prefs: []
  type: TYPE_NORMAL
- en: for interval in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in lines
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .take(interval.end + 1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .skip(interval.start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};   // compile the regular expression let regex = match Regex::new(pattern)
    { Ok(re) => re, // bind re to regex Err(e) => { eprintln!("{e}"); // write to
    standard error exit(1); } };   // store the 0-based line number for any matched
    line let match_lines = find_matching_lines(&lines, regex);   // create intervals
    of the form [a,b] with the before/after context let intervals = create_intervals(match_lines,
    before_context, after_context);      // merge overlapping intervals'
  prefs: []
  type: TYPE_NORMAL
- en: let intervals = merge_intervals(intervals);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // print the lines print_results(intervals, lines); }
  prefs: []
  type: TYPE_NORMAL
- en: struct Interval {
  prefs: []
  type: TYPE_NORMAL
- en: 'start: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Interval {
  prefs: []
  type: TYPE_NORMAL
- en: 'fn new(start: usize, end: usize) -> Self {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Self { start, end }
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn overlaps(&self, other: &Interval) -> bool {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.end >= other.start
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn merge(&self, other: &Self) -> Self {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Interval::new(self.start, other.end)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Summarizing the Changes](#summarizing-the-changes)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our rustle program now makes use of our custom type and includes a few other
    enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_intervals` was updated with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The return type was changed to `Vec<Interval>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tuple created from `start` and `end` are now used to create an `Interval`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge_intervals` was updated with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The argument `intervals` now has a type of `Vec<Interval>` and is *moved* instead
    of the mutable borrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dedup_by` was replaced with `coalesce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_results` was updated with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The argument `intervals` is now a `Vec<Interval>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `take` and `skip` iterator adaptors were updated to use the fields from
    the `Interval`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each interval is *dropped* at the end of the loop iteration when written as
    `for interval in intervals`. If the loop were written as `for interval in &intervals`,
    we would *borrow* each value. The same applies if we had written the loop as `for
    interval in intervals.iter()`. The former is syntactic sugar for the latter.^([4](#footnote-4))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Casing conforms to [RFC 430](https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md)
    (C-CASE). [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exclusion of `return` is discussed [here](https://doc.rust-lang.org/std/keyword.return.html).
    [↩](#fr-2-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method syntax is covered in full detail [here](https://doc.rust-lang.org/book/ch05-03-method-syntax.html).
    [↩](#fr-3-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Details about consuming collections with `for in` and `into_iter` can be found
    [here](https://doc.rust-lang.org/rust-by-example/flow_control/for.html). [↩](#fr-4-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

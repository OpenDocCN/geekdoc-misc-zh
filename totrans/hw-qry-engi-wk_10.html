<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>DataFrame API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>DataFrame API</h1>
<blockquote>原文：<a href="https://howqueryengineswork.com/06-dataframe.html">https://howqueryengineswork.com/06-dataframe.html</a></blockquote>
                        
<p><em>The source code discussed in this chapter can be found in the <code>logical-plan</code> module of the <a href="https://github.com/andygrove/how-query-engines-work">KQuery project</a>.</em></p>
<p>The previous chapter showed how to represent queries as logical plans. But constructing those plans by hand is tedious. This chapter introduces the DataFrame API, a fluent interface that makes building logical plans natural and readable.</p>
<h2 id="building-plans-the-hard-way"><a class="header" href="#building-plans-the-hard-way">Building Plans The Hard Way</a></h2>
<p>Consider this query:</p>
<pre><code class="language-sql">SELECT id, first_name, last_name, state, salary
FROM employee
WHERE state = 'CO'
</code></pre>
<p>To build this as a logical plan, we construct each piece separately and then wire them together:</p>
<pre><code class="language-kotlin">val csv = CsvDataSource("employee.csv")
val scan = Scan("employee", csv, listOf())
val filterExpr = Eq(Column("state"), LiteralString("CO"))
val selection = Selection(scan, filterExpr)
val projectionList = listOf(
    Column("id"),
    Column("first_name"),
    Column("last_name"),
    Column("state"),
    Column("salary")
)
val plan = Projection(selection, projectionList)
</code></pre>
<p>This works, but it is verbose and the code structure does not mirror the query structure. We can improve this slightly by nesting the constructors:</p>
<pre><code class="language-kotlin">val plan = Projection(
    Selection(
        Scan("employee", CsvDataSource("employee.csv"), listOf()),
        Eq(Column("state"), LiteralString("CO"))
    ),
    listOf(
        Column("id"),
        Column("first_name"),
        Column("last_name"),
        Column("state"),
        Column("salary")
    )
)
</code></pre>
<p>This is more compact, but harder to read. The nesting goes from inside out, opposite to how we think about query execution (scan first, then filter, then project).</p>
<h2 id="the-dataframe-approach"><a class="header" href="#the-dataframe-approach">The DataFrame Approach</a></h2>
<p>A DataFrame wraps a logical plan and provides methods that return new DataFrames. Each method call adds a node to the plan. This creates a fluent API where code reads top-to-bottom in execution order:</p>
<pre><code class="language-kotlin">val df = ctx.csv("employee.csv")
    .filter(Eq(Column("state"), LiteralString("CO")))
    .project(listOf(
        Column("id"),
        Column("first_name"),
        Column("last_name"),
        Column("state"),
        Column("salary")
    ))
</code></pre>
<p>Read this as: start with the CSV file, filter to Colorado, project the columns we want. The code structure matches the mental model.</p>
<h2 id="the-dataframe-interface"><a class="header" href="#the-dataframe-interface">The DataFrame Interface</a></h2>
<p>The interface is simple:</p>
<pre><code class="language-kotlin">interface DataFrame {

  / Apply a projection */
  fun project(expr: List&lt;LogicalExpr&gt;): DataFrame

  / Apply a filter */
  fun filter(expr: LogicalExpr): DataFrame

  / Aggregate */
  fun aggregate(
      groupBy: List&lt;LogicalExpr&gt;,
      aggregateExpr: List&lt;AggregateExpr&gt;
  ): DataFrame

  / Join with another DataFrame */
  fun join(right: DataFrame, joinType: JoinType, condition: LogicalExpr): DataFrame

  / Returns the schema of the data that will be produced by this DataFrame. */
  fun schema(): Schema

  / Get the logical plan */
  fun logicalPlan(): LogicalPlan
}
</code></pre>
<p>Each transformation method (<code>project</code>, <code>filter</code>, <code>aggregate</code>, <code>join</code>) returns a new DataFrame. This enables method chaining. The <code>schema</code> method exposes the output schema for inspection. The <code>logicalPlan</code> method retrieves the underlying plan when we need it for optimization or execution.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>The implementation wraps a logical plan and creates new plan nodes on each method call:</p>
<pre><code class="language-kotlin">class DataFrameImpl(private val plan: LogicalPlan) : DataFrame {

  override fun project(expr: List&lt;LogicalExpr&gt;): DataFrame {
    return DataFrameImpl(Projection(plan, expr))
  }

  override fun filter(expr: LogicalExpr): DataFrame {
    return DataFrameImpl(Selection(plan, expr))
  }

  override fun aggregate(
      groupBy: List&lt;LogicalExpr&gt;,
      aggregateExpr: List&lt;AggregateExpr&gt;
  ): DataFrame {
    return DataFrameImpl(Aggregate(plan, groupBy, aggregateExpr))
  }

  override fun join(
      right: DataFrame,
      joinType: JoinType,
      condition: LogicalExpr
  ): DataFrame {
    return DataFrameImpl(Join(plan, right.logicalPlan(), joinType, condition))
  }

  override fun schema(): Schema {
    return plan.schema()
  }

  override fun logicalPlan(): LogicalPlan {
    return plan
  }
}
</code></pre>
<p>Each method constructs a new logical plan node with the current plan as input, then wraps it in a new DataFrame. The original DataFrame is unchanged (DataFrames are immutable), so you can branch from any point:</p>
<pre><code class="language-kotlin">val employees = ctx.csv("employee.csv")
val colorado = employees.filter(Eq(Column("state"), LiteralString("CO")))
val texas = employees.filter(Eq(Column("state"), LiteralString("TX")))
</code></pre>
<p>Joins combine two DataFrames based on a condition:</p>
<pre><code class="language-kotlin">val employees = ctx.csv("employee.csv")
val departments = ctx.csv("department.csv")

val joined = employees.join(
    departments,
    JoinType.INNER,
    Eq(Column("dept_id"), Column("id"))
)
</code></pre>
<p>The Joins chapter covers join types and algorithms in detail.</p>
<h2 id="execution-context"><a class="header" href="#execution-context">Execution Context</a></h2>
<p>We need a starting point for building DataFrames. The execution context creates initial DataFrames from data sources:</p>
<pre><code class="language-kotlin">class ExecutionContext {

  fun csv(filename: String): DataFrame {
    return DataFrameImpl(Scan(filename, CsvDataSource(filename), listOf()))
  }

  fun parquet(filename: String): DataFrame {
    return DataFrameImpl(Scan(filename, ParquetDataSource(filename), listOf()))
  }
}
</code></pre>
<p>Later chapters expand this context to handle query execution. For now, it just creates DataFrames.</p>
<h2 id="convenience-methods"><a class="header" href="#convenience-methods">Convenience Methods</a></h2>
<p>The basic API works but is still verbose. Kotlin’s features let us make it more expressive.</p>
<p>Helper functions create expressions concisely:</p>
<pre><code class="language-kotlin">fun col(name: String) = Column(name)
fun lit(value: String) = LiteralString(value)
fun lit(value: Long) = LiteralLong(value)
fun lit(value: Double) = LiteralDouble(value)
</code></pre>
<p>Infix operators let us write expressions naturally:</p>
<pre><code class="language-kotlin">infix fun LogicalExpr.eq(rhs: LogicalExpr): LogicalExpr = Eq(this, rhs)
infix fun LogicalExpr.neq(rhs: LogicalExpr): LogicalExpr = Neq(this, rhs)
infix fun LogicalExpr.gt(rhs: LogicalExpr): LogicalExpr = Gt(this, rhs)
infix fun LogicalExpr.gteq(rhs: LogicalExpr): LogicalExpr = GtEq(this, rhs)
infix fun LogicalExpr.lt(rhs: LogicalExpr): LogicalExpr = Lt(this, rhs)
infix fun LogicalExpr.lteq(rhs: LogicalExpr): LogicalExpr = LtEq(this, rhs)
infix fun LogicalExpr.mult(rhs: LogicalExpr): LogicalExpr = Multiply(this, rhs)
infix fun LogicalExpr.alias(name: String): LogicalExpr = Alias(this, name)
</code></pre>
<p>Now we can write queries that read almost like SQL:</p>
<pre><code class="language-kotlin">val df = ctx.csv("employee.csv")
    .filter(col("state") eq lit("CO"))
    .project(listOf(
        col("id"),
        col("first_name"),
        col("last_name"),
        col("salary"),
        (col("salary") mult lit(0.1)) alias "bonus"
    ))
    .filter(col("bonus") gt lit(1000))
</code></pre>
<p>This reads: take the CSV, keep rows where state equals CO, compute id, names, salary, and a 10% bonus column, then keep only rows where bonus exceeds 1000.</p>
<h2 id="dataframes-vs-sql"><a class="header" href="#dataframes-vs-sql">DataFrames vs SQL</a></h2>
<p>Both DataFrames and SQL describe what data you want. Why offer both?</p>
<p>SQL is familiar to analysts and can be embedded in applications as strings. But SQL strings are opaque to the compiler. Typos and type errors only appear at runtime.</p>
<p>DataFrames integrate with the programming language. The compiler catches method name typos. IDEs provide autocomplete. You can build queries dynamically using normal programming constructs:</p>
<pre><code class="language-kotlin">var df = ctx.csv("employee.csv")

if (stateFilter != null) {
    df = df.filter(col("state") eq lit(stateFilter))
}

if (minSalary != null) {
    df = df.filter(col("salary") gteq lit(minSalary))
}
</code></pre>
<p>Most modern query engines support both interfaces. Users choose based on their needs.</p>
<h2 id="the-underlying-plan"><a class="header" href="#the-underlying-plan">The Underlying Plan</a></h2>
<p>However we build it, the result is a logical plan. Our example query:</p>
<pre><code class="language-kotlin">val df = ctx.csv("employee.csv")
    .filter(col("state") eq lit("CO"))
    .project(listOf(col("id"), col("first_name"), col("last_name"), col("salary")))
</code></pre>
<p>Produces this plan:</p>
<pre><code>Projection: #id, #first_name, #last_name, #salary
  Filter: #state = 'CO'
    Scan: employee.csv; projection=None
</code></pre>
<p>The DataFrame is just a convenient way to construct this tree. Once built, the plan goes through optimization and physical planning regardless of how it was created.</p>
<p><em>This book is also available for purchase in ePub, MOBI, and PDF format from <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a></em></p>
<p><strong>Copyright © 2020-2025 Andy Grove. All rights reserved.</strong></p>

                        
</body>
</html>
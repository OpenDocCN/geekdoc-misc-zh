- en: Static Scoping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'introduces us to a very important concept: indeed, one of the central ideas
    behind SMoL. This is that a variable’s binding is determined by its position in
    the source program, and notby the order of the program’s execution. That is, the
    `x` on the last line is bound by the same place—and hence obtains the same value—irrespective
    of other bindings that took place before it was evaluated. To understand this
    better, let’s see a progression of programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You might think it’s okay whether it produces `3`or `4`. How about this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should expect the same out of this: the conditional is always true, so
    clearly we are always going to evaluate the inner binding, so its answer should
    be the same as for the previous program. But how about this?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '{let1 {x 2} x}`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now you might not be so sure. Since the conditional is never taken, you probably
    don’t want the inner binding to have an influence. That is, you are willing to
    let the program’s control flow influence the bindings. On its face that sounds
    reasonable, but now how about this program?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`{+ {if` {random}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`{+ {if` {moon-is-currently-full}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Are you okay with the binding structure changing every two weeks? What about
    this version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`         {let1 {`y` 2} x}}`'
  prefs: []
  type: TYPE_NORMAL
- en: y`}}`
  prefs: []
  type: TYPE_NORMAL
- en: Then, depending on the phase of the moon, the program either produces an answer
    or results in an unbound-variable error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decision to let control flow determine binding is called dynamic scope.
    It is the one unambiguously wrong design decision in programming languages. It
    has a long and sordid history: the original Lisp had it, and it was not until
    over a decade later that Scheme fixed it. Unfortunately, those who don’t know
    history are doomed to repeat it: early versions of Python and JavaScript also
    had dynamic scope. Taking it back out has been a herculean effort. Dynamic scope
    means:'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t be sure about the binding structure of our programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evaluator can’t be sure, either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nor can programmer tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, a program refactoring tool needs to know binding structure: even
    a simple “variable renaming” tool needs to know which variables to rename. In
    DrRacket, there is no ambiguity, so variable renaming works correctly. This is
    not true in other languages: see, for instance, Appendix 2 of [this paper](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&sa=D&source=editors&ust=1695232021187018&usg=AOvVaw137u3e7Dklg2SwW_JHiS7q) on
    the semantics of Python.'
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of dynamic scope—where we can determine the binding by following
    the structure of the AST—is called static scope. Static scope is a defining characteristic
    of SMoL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic scope occurred in early implementations because it was easy to obtain:
    it was the default behavior. We have to work a bit harder to obtain static scope,
    as we will see.'
  prefs: []
  type: TYPE_NORMAL

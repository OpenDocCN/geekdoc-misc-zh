- en: Scope and Privacy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/scope_and_privacy.html](https://freddiehaddad.github.io/fast-track-to-rust/scope_and_privacy.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We're going to convert all our `Interval` related code into a module. To define
    a module, we use the `mod` keyword followed by the module's name and enclose the
    body within curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here's the new version of our rustle program with the `Interval` related parts
    moved inside the `interval` module. In addition, comments have been added to the
    module which will be used to generate documentation in an upcoming section. Go
    ahead and run the code to see it in action!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]rust'
  prefs: []
  type: TYPE_NORMAL
- en: /// let interval = Interval::new(1, 10).unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(interval.start, 1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(interval.end, 10);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE2]rust
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let interval = Interval::new(1, 10).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(interval.start, 1);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(interval.end, 10);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE3]rust
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let a = Interval::new(1, 3).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let b = Interval::new(3, 5).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(a.overlaps(&b), true);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(b.overlaps(&a), true);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE4]rust
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let a = Interval::new(1, 5).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let b = Interval::new(2, 4).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(a.overlaps(&b), true);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(b.overlaps(&a), true);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE5]rust
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let a = Interval::new(1, 3).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let b = Interval::new(4, 6).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(a.overlaps(&b), false);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(b.overlaps(&a), true);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE6]rust
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let a = Interval::new(1, 3).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let b = Interval::new(3, 5).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// let c = a.merge(&b).unwrap();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(c.start, 1);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// assert_eq!(c.end, 5);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE7]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Uh-oh! Looks like we have all kinds of compiler errors! Among the chaos is two
    different errors having to do with scope and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: '[E0412](https://doc.rust-lang.org/stable/error_codes/E0412.html): cannot find
    type `Interval` in this scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E0433](https://doc.rust-lang.org/stable/error_codes/E0433.html): failed to
    resolve: use of undeclared type `Interval`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember you can always use `rustc --explain EXXXX` which provides a detailed
    explanation of an error message.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Scope](#scope)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first error indicates that the `Interval` type is not in scope. This is
    because it is now part of the `interval` module. To access it, we can use the
    full path name `interval::Interval` or create a shortcut with `use`. Since we
    don't want to replace every occurrence of `Interval` in our code with `interval::Interval`,
    we'll take advantage of `use`. Additionally, we need access to `IntervalError`,
    so we'll bring that into scope at the same time. When bringing multiple types
    into scope, we can wrap them in `{}` and separate them with `,`.
  prefs: []
  type: TYPE_NORMAL
- en: With that change in place, run the code again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]rust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start,
    1); /// assert_eq!(interval.end, 10); /// [PRE9]rust /// let interval = Interval::new(1,
    10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end,
    10); /// [PRE10]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE11]rust /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2,
    4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE12]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4,
    6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE13]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); ///
    assert_eq!(c.end, 5); /// [PRE14]'
  prefs: []
  type: TYPE_NORMAL
- en: Bugger! More compiler errors!
  prefs: []
  type: TYPE_NORMAL
- en: '[Privacy](#privacy)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we defined the `interval` module, all the types and their methods were
    public. However, once we enclosed everything in a module, they became private!
    By default, code within a module is private from its parent modules. To make a
    module public, we need to declare it with `pub mod` instead of just `mod`. Let's
    add the `pub` prefix and run the program again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]rust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start,
    1); /// assert_eq!(interval.end, 10); /// [PRE16]rust /// let interval = Interval::new(1,
    10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end,
    10); /// [PRE17]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE18]rust /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2,
    4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE19]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4,
    6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE20]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); ///
    assert_eq!(c.end, 5); /// [PRE21]'
  prefs: []
  type: TYPE_NORMAL
- en: More compiler errors! Who would have thought creating a module could be this
    complicated? The reason for this series of errors is to help us understand module
    scope and privacy. The emerging pattern is that modules default everything to
    private. Simply declaring the module public isn't enough; every type and method
    within the module must also be explicitly declared public if that is the intended
    design. So, let's prefix the methods and types with `pub` and hopefully achieve
    a successful compile!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]rust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start,
    1); /// assert_eq!(interval.end, 10); /// [PRE23]rust /// let interval = Interval::new(1,
    10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end,
    10); /// [PRE24]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE25]rust /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2,
    4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE26]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4,
    6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE27]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); ///
    assert_eq!(c.end, 5); /// [PRE28]'
  prefs: []
  type: TYPE_NORMAL
- en: Alright, last time, I promise! As a final note on privacy, and as the compiler
    error pointed out, even the fields of a `struct` are private by default. So, the
    last step is to make the fields public. Let's do that and finally achieve a successful
    compile. Fingers crossed!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]rust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start,
    1); /// assert_eq!(interval.end, 10); /// [PRE30]rust /// let interval = Interval::new(1,
    10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end,
    10); /// [PRE31]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE32]rust /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2,
    4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE33]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4,
    6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a),
    true); /// [PRE34]rust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3,
    5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); ///
    assert_eq!(c.end, 5); /// [PRE35]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the code compiles! Now, you might be wondering why we didn''t have
    to declare the `enum` variants as public. If you are, good catch! The reason is
    that there are two exceptions to Rust''s *everything is private*^([1](#footnote-1))
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Associated items in a `pub` Trait are public by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`enum` variants in a `pub enum` are public by default.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focused heavily on emphasizing Rust's *everything is private* default
    behavior when it comes to modules. As you develop software, use privacy to your
    advantage and carefully decide what parts of the API should be made public.
  prefs: []
  type: TYPE_NORMAL
- en: Rust goes into great detail with regard to project management. As you create
    your own modules and crates, reviewing the section on [Managing Growing Projects
    with Packages, Crates, and Modules](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
    will be extremely valuable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercises](#exercises)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These exercises must be completed locally.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Move the `interval` module out of `main.rs` and into a separate file. Explore
    two approaches:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, create a file `interval.rs` in the `src` directory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a directory under `src` called `interval` and move `interval.rs`
    inside.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Advanced**: Creating an external crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a library crate `cargo new --lib interval` and move the interval code
    into it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you haven't already, create a binary crate `cargo new rustle` and update
    the `Cargo.toml` file to use the external crate from the previous step. Refer
    to the section on [Specifying Dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)
    in [The Cargo Book](https://doc.rust-lang.org/cargo/) for guidance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's dive into generic types and make our `Interval` generic!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the [Visibility and Privacy](https://doc.rust-lang.org/reference/visibility-and-privacy.html)
    reference for details. [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

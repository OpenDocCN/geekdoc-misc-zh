- en: Scope and Privacy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/scope_and_privacy.html](https://freddiehaddad.github.io/fast-track-to-rust/scope_and_privacy.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We're going to convert all our `Interval` related code into a module. To define
    a module, we use the `mod` keyword followed by the module's name and enclose the
    body within curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here's the new version of our rustle program with the `Interval` related parts
    moved inside the `interval` module. In addition, comments have been added to the
    module which will be used to generate documentation in an upcoming section. Go
    ahead and run the code to see it in action!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use itertools::Itertools; use regex::Regex; use std::fs::File; use std::io::Read;
    use std::io::{BufRead, BufReader}; use std::process::exit;   fn find_matching_lines(lines:
    &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }   fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Result<Vec<Interval>,
    IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'lines .iter() .map(|line| { let start = line.saturating_sub(before_context);
    let end = line.saturating_add(after_context); Interval::new(start, end) }) .collect()
    }   fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: '// merge overlapping intervals intervals .into_iter() .coalesce(|p, c| p.merge(&c).map_err(|_|
    (p, c))) .collect() }   fn print_results(intervals: Vec<Interval>, lines: Vec<String>)
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'for interval in intervals { for (line_no, line) in lines .iter() .enumerate()
    .take(interval.end + 1) .skip(interval.start) { println!("{}: {}", line_no + 1,
    line) } } }   fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};   // compile the regular expression let regex = match Regex::new(pattern)
    { Ok(re) => re, // bind re to regex Err(e) => { eprintln!("{e}"); // write to
    standard error exit(1); } };   // store the 0-based line number for any matched
    line let match_lines = find_matching_lines(&lines, regex);   // create intervals
    of the form [a,b] with the before/after context let intervals = match create_intervals(match_lines,
    before_context, after_context) { Ok(intervals) => intervals, Err(_) => { eprintln!("An
    error occurred while creating intervals"); exit(1); } };   // merge overlapping
    intervals let intervals = merge_intervals(intervals);   // print the lines print_results(intervals,
    lines); }   mod interval {'
  prefs: []
  type: TYPE_NORMAL
- en: /// A list specifying general categories of Interval errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: enum IntervalError {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Start is not less than or equal to end
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: StartEndRangeInvalid,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Two intervals to be merged do not overlap
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: NonOverlappingInterval,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// A closed-interval [`start`, `end`] type used for representing a range of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// values between `start` and `end` inclusively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// You can create an `Interval` using `new`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: struct Interval {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'start: usize,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: usize,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: impl Interval {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Creates a new `Interval` set to `start` and `end`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE3]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn new(start: usize, end: usize) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if start <= end {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self { start, end })
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::StartEndRangeInvalid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Checks if two intervals overlap. Overlapping intervals have at least
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// one point in common.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE4]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE5]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE6]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn overlaps(&self, other: &Interval) -> bool {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.end >= other.start
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Merges two intervals returning a new `Interval`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// The merged `Interval` range includes the union of ranges from each
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// `Interval`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '/// # Examples'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ///
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE7]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn merge(&self, other: &Self) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if self.overlaps(other) {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'start: self.start,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: other.end,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::NonOverlappingInterval)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Uh-oh! Looks like we have all kinds of compiler errors! Among the chaos is two
    different errors having to do with scope and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: '[E0412](https://doc.rust-lang.org/stable/error_codes/E0412.html): cannot find
    type `Interval` in this scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E0433](https://doc.rust-lang.org/stable/error_codes/E0433.html): failed to
    resolve: use of undeclared type `Interval`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember you can always use `rustc --explain EXXXX` which provides a detailed
    explanation of an error message.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Scope](#scope)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first error indicates that the `Interval` type is not in scope. This is
    because it is now part of the `interval` module. To access it, we can use the
    full path name `interval::Interval` or create a shortcut with `use`. Since we
    don't want to replace every occurrence of `Interval` in our code with `interval::Interval`,
    we'll take advantage of `use`. Additionally, we need access to `IntervalError`,
    so we'll bring that into scope at the same time. When bringing multiple types
    into scope, we can wrap them in `{}` and separate them with `,`.
  prefs: []
  type: TYPE_NORMAL
- en: With that change in place, run the code again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use interval::{Interval, IntervalError};'
  prefs: []
  type: TYPE_NORMAL
- en: 'use itertools::Itertools; use regex::Regex; use std::fs::File; use std::io::Read;
    use std::io::{BufRead, BufReader}; use std::process::exit;   fn find_matching_lines(lines:
    &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }   fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Result<Vec<Interval>,
    IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'lines .iter() .map(|line| { let start = line.saturating_sub(before_context);
    let end = line.saturating_add(after_context); Interval::new(start, end) }) .collect()
    }   fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: '// merge overlapping intervals intervals .into_iter() .coalesce(|p, c| p.merge(&c).map_err(|_|
    (p, c))) .collect() }   fn print_results(intervals: Vec<Interval>, lines: Vec<String>)
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'for interval in intervals { for (line_no, line) in lines .iter() .enumerate()
    .take(interval.end + 1) .skip(interval.start) { println!("{}: {}", line_no + 1,
    line) } } }   fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};   // compile the regular expression let regex = match Regex::new(pattern)
    { Ok(re) => re, // bind re to regex Err(e) => { eprintln!("{e}"); // write to
    standard error exit(1); } };   // store the 0-based line number for any matched
    line let match_lines = find_matching_lines(&lines, regex);   // create intervals
    of the form [a,b] with the before/after context let intervals = match create_intervals(match_lines,
    before_context, after_context) { Ok(intervals) => intervals, Err(_) => { eprintln!("An
    error occurred while creating intervals"); exit(1); } };   // merge overlapping
    intervals let intervals = merge_intervals(intervals);   // print the lines print_results(intervals,
    lines); }   mod interval {'
  prefs: []
  type: TYPE_NORMAL
- en: '/// A list specifying general categories of Interval errors. enum IntervalError
    { /// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals
    to be merged do not overlap NonOverlappingInterval, }   /// A closed-interval
    [`start`, `end`] type used for representing a range of /// values between `start`
    and `end` inclusively. /// /// # Examples /// /// You can create an `Interval`
    using `new`. /// /// [PRE10] struct Interval { start: usize, end: usize, }   impl
    Interval { /// Creates a new `Interval` set to `start` and `end`. /// /// # Examples
    /// /// [PRE11] fn new(start: usize, end: usize) -> Result<Self, IntervalError>
    { if start <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid)
    } }   /// Checks if two intervals overlap. Overlapping intervals have at least
    /// one point in common. /// /// # Examples /// /// [PRE12] /// /// [PRE13] ///
    /// [PRE14] fn overlaps(&self, other: &Interval) -> bool { self.end >= other.start
    }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval`
    range includes the union of ranges from each /// `Interval`. /// /// # Examples
    /// /// [PRE15] fn merge(&self, other: &Self) -> Result<Self, IntervalError> {
    if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) } else
    { Err(IntervalError::NonOverlappingInterval) } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Bugger! More compiler errors!
  prefs: []
  type: TYPE_NORMAL
- en: '[Privacy](#privacy)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we defined the `interval` module, all the types and their methods were
    public. However, once we enclosed everything in a module, they became private!
    By default, code within a module is private from its parent modules. To make a
    module public, we need to declare it with `pub mod` instead of just `mod`. Let's
    add the `pub` prefix and run the program again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use interval::{Interval, IntervalError}; use itertools::Itertools; use regex::Regex;
    use std::fs::File; use std::io::Read; use std::io::{BufRead, BufReader}; use std::process::exit;   fn
    find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }   fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Result<Vec<Interval>,
    IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'lines .iter() .map(|line| { let start = line.saturating_sub(before_context);
    let end = line.saturating_add(after_context); Interval::new(start, end) }) .collect()
    }   fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: '// merge overlapping intervals intervals .into_iter() .coalesce(|p, c| p.merge(&c).map_err(|_|
    (p, c))) .collect() }   fn print_results(intervals: Vec<Interval>, lines: Vec<String>)
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'for interval in intervals { for (line_no, line) in lines .iter() .enumerate()
    .take(interval.end + 1) .skip(interval.start) { println!("{}: {}", line_no + 1,
    line) } } }   fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};   // compile the regular expression let regex = match Regex::new(pattern)
    { Ok(re) => re, // bind re to regex Err(e) => { eprintln!("{e}"); // write to
    standard error exit(1); } };   // store the 0-based line number for any matched
    line let match_lines = find_matching_lines(&lines, regex);   // create intervals
    of the form [a,b] with the before/after context let intervals = match create_intervals(match_lines,
    before_context, after_context) { Ok(intervals) => intervals, Err(_) => { eprintln!("An
    error occurred while creating intervals"); exit(1); } };   // merge overlapping
    intervals let intervals = merge_intervals(intervals);   // print the lines print_results(intervals,
    lines); }   pub mod interval {'
  prefs: []
  type: TYPE_NORMAL
- en: '/// A list specifying general categories of Interval errors. enum IntervalError
    { /// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals
    to be merged do not overlap NonOverlappingInterval, }   /// A closed-interval
    [`start`, `end`] type used for representing a range of /// values between `start`
    and `end` inclusively. /// /// # Examples /// /// You can create an `Interval`
    using `new`. /// /// [PRE18] struct Interval { start: usize, end: usize, }   impl
    Interval { /// Creates a new `Interval` set to `start` and `end`. /// /// # Examples
    /// /// [PRE19] fn new(start: usize, end: usize) -> Result<Self, IntervalError>
    { if start <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid)
    } }   /// Checks if two intervals overlap. Overlapping intervals have at least
    /// one point in common. /// /// # Examples /// /// [PRE20] /// /// [PRE21] ///
    /// [PRE22] fn overlaps(&self, other: &Interval) -> bool { self.end >= other.start
    }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval`
    range includes the union of ranges from each /// `Interval`. /// /// # Examples
    /// /// [PRE23] fn merge(&self, other: &Self) -> Result<Self, IntervalError> {
    if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) } else
    { Err(IntervalError::NonOverlappingInterval) } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: More compiler errors! Who would have thought creating a module could be this
    complicated? The reason for this series of errors is to help us understand module
    scope and privacy. The emerging pattern is that modules default everything to
    private. Simply declaring the module public isn't enough; every type and method
    within the module must also be explicitly declared public if that is the intended
    design. So, let's prefix the methods and types with `pub` and hopefully achieve
    a successful compile!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use interval::{Interval, IntervalError}; use itertools::Itertools; use regex::Regex;
    use std::fs::File; use std::io::Read; use std::io::{BufRead, BufReader}; use std::process::exit;   fn
    find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }   fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Result<Vec<Interval>,
    IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'lines .iter() .map(|line| { let start = line.saturating_sub(before_context);
    let end = line.saturating_add(after_context); Interval::new(start, end) }) .collect()
    }   fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: '// merge overlapping intervals intervals .into_iter() .coalesce(|p, c| p.merge(&c).map_err(|_|
    (p, c))) .collect() }   fn print_results(intervals: Vec<Interval>, lines: Vec<String>)
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'for interval in intervals { for (line_no, line) in lines .iter() .enumerate()
    .take(interval.end + 1) .skip(interval.start) { println!("{}: {}", line_no + 1,
    line) } } }   fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};   // compile the regular expression let regex = match Regex::new(pattern)
    { Ok(re) => re, // bind re to regex Err(e) => { eprintln!("{e}"); // write to
    standard error exit(1); } };   // store the 0-based line number for any matched
    line let match_lines = find_matching_lines(&lines, regex);   // create intervals
    of the form [a,b] with the before/after context let intervals = match create_intervals(match_lines,
    before_context, after_context) { Ok(intervals) => intervals, Err(_) => { eprintln!("An
    error occurred while creating intervals"); exit(1); } };   // merge overlapping
    intervals let intervals = merge_intervals(intervals);   // print the lines print_results(intervals,
    lines); }   pub mod interval {'
  prefs: []
  type: TYPE_NORMAL
- en: /// A list specifying general categories of Interval errors.    pub enum IntervalError
    {
  prefs: []
  type: TYPE_NORMAL
- en: '/// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals
    to be merged do not overlap NonOverlappingInterval, }   /// A closed-interval
    [`start`, `end`] type used for representing a range of /// values between `start`
    and `end` inclusively. /// /// # Examples /// /// You can create an `Interval`
    using `new`. /// /// [PRE26]    pub struct Interval {'
  prefs: []
  type: TYPE_NORMAL
- en: 'start: usize, end: usize, }   impl Interval { /// Creates a new `Interval`
    set to `start` and `end`. /// /// # Examples /// /// [PRE27]        pub fn new(start:
    usize, end: usize) -> Result<Self, IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'if start <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid)
    } }   /// Checks if two intervals overlap. Overlapping intervals have at least
    /// one point in common. /// /// # Examples /// /// [PRE28] /// /// [PRE29] ///
    /// [PRE30]        pub fn overlaps(&self, other: &Interval) -> bool {'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.end >= other.start }   /// Merges two intervals returning a new `Interval`.
    /// /// The merged `Interval` range includes the union of ranges from each ///
    `Interval`. /// /// # Examples /// /// [PRE31]        pub fn merge(&self, other:
    &Self) -> Result<Self, IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) }
    else { Err(IntervalError::NonOverlappingInterval) } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Alright, last time, I promise! As a final note on privacy, and as the compiler
    error pointed out, even the fields of a `struct` are private by default. So, the
    last step is to make the fields public. Let's do that and finally achieve a successful
    compile. Fingers crossed!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use interval::{Interval, IntervalError}; use itertools::Itertools; use regex::Regex;
    use std::fs::File; use std::io::Read; use std::io::{BufRead, BufReader}; use std::process::exit;   fn
    find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }   fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Result<Vec<Interval>,
    IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'lines .iter() .map(|line| { let start = line.saturating_sub(before_context);
    let end = line.saturating_add(after_context); Interval::new(start, end) }) .collect()
    }   fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: '// merge overlapping intervals intervals .into_iter() .coalesce(|p, c| p.merge(&c).map_err(|_|
    (p, c))) .collect() }   fn print_results(intervals: Vec<Interval>, lines: Vec<String>)
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'for interval in intervals { for (line_no, line) in lines .iter() .enumerate()
    .take(interval.end + 1) .skip(interval.start) { println!("{}: {}", line_no + 1,
    line) } } }   fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};   // compile the regular expression let regex = match Regex::new(pattern)
    { Ok(re) => re, // bind re to regex Err(e) => { eprintln!("{e}"); // write to
    standard error exit(1); } };   // store the 0-based line number for any matched
    line let match_lines = find_matching_lines(&lines, regex);   // create intervals
    of the form [a,b] with the before/after context let intervals = match create_intervals(match_lines,
    before_context, after_context) { Ok(intervals) => intervals, Err(_) => { eprintln!("An
    error occurred while creating intervals"); exit(1); } };   // merge overlapping
    intervals let intervals = merge_intervals(intervals);   // print the lines print_results(intervals,
    lines); }   pub mod interval {'
  prefs: []
  type: TYPE_NORMAL
- en: '/// A list specifying general categories of Interval errors. pub enum IntervalError
    { /// Start is not less than or equal to end StartEndRangeInvalid, /// Two intervals
    to be merged do not overlap NonOverlappingInterval, }   /// A closed-interval
    [`start`, `end`] type used for representing a range of /// values between `start`
    and `end` inclusively. /// /// # Examples /// /// You can create an `Interval`
    using `new`. /// /// [PRE34] pub struct Interval {        pub start: usize,'
  prefs: []
  type: TYPE_NORMAL
- en: 'pub end: usize,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}   impl Interval { /// Creates a new `Interval` set to `start` and `end`.
    /// /// # Examples /// /// [PRE35] pub fn new(start: usize, end: usize) -> Result<Self,
    IntervalError> { if start <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid)
    } }   /// Checks if two intervals overlap. Overlapping intervals have at least
    /// one point in common. /// /// # Examples /// /// [PRE36] /// /// [PRE37] ///
    /// [PRE38] pub fn overlaps(&self, other: &Interval) -> bool { self.end >= other.start
    }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval`
    range includes the union of ranges from each /// `Interval`. /// /// # Examples
    /// /// [PRE39] pub fn merge(&self, other: &Self) -> Result<Self, IntervalError>
    { if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) }
    else { Err(IntervalError::NonOverlappingInterval) } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the code compiles! Now, you might be wondering why we didn''t have
    to declare the `enum` variants as public. If you are, good catch! The reason is
    that there are two exceptions to Rust''s *everything is private*^([1](#footnote-1))
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Associated items in a `pub` Trait are public by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`enum` variants in a `pub enum` are public by default.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focused heavily on emphasizing Rust's *everything is private* default
    behavior when it comes to modules. As you develop software, use privacy to your
    advantage and carefully decide what parts of the API should be made public.
  prefs: []
  type: TYPE_NORMAL
- en: Rust goes into great detail with regard to project management. As you create
    your own modules and crates, reviewing the section on [Managing Growing Projects
    with Packages, Crates, and Modules](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
    will be extremely valuable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercises](#exercises)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These exercises must be completed locally.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Move the `interval` module out of `main.rs` and into a separate file. Explore
    two approaches:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, create a file `interval.rs` in the `src` directory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a directory under `src` called `interval` and move `interval.rs`
    inside.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Advanced**: Creating an external crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a library crate `cargo new --lib interval` and move the interval code
    into it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you haven't already, create a binary crate `cargo new rustle` and update
    the `Cargo.toml` file to use the external crate from the previous step. Refer
    to the section on [Specifying Dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)
    in [The Cargo Book](https://doc.rust-lang.org/cargo/) for guidance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's dive into generic types and make our `Interval` generic!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the [Visibility and Privacy](https://doc.rust-lang.org/reference/visibility-and-privacy.html)
    reference for details. [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

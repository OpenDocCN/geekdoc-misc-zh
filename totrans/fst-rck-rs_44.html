<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Non-scoped Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Non-scoped Threads</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/non-scoped_threads.html">https://freddiehaddad.github.io/fast-track-to-rust/non-scoped_threads.html</a></blockquote>
                        
<p>The simplest way to enable multithreading support in our rustle program is to
spawn a thread for each specified file, perform the pattern matching steps we've
developed, and print the results using a fork/join pattern. If you have a C++
background, you might start by exploring the functions in the <a href="https://doc.rust-lang.org/std/thread/">thread</a> module,
discovering the <a href="https://doc.rust-lang.org/stable/std/thread/fn.spawn.html">spawn</a> function, and diving right in.</p>
<p>However, this approach is flawed! While it might be a valuable learning
experience, it will likely be time-consuming, frustrating, and confusing. Let's
examine some of the pitfalls of this approach and then explore a more effective
solution.</p>
<h2 id="the-spawn-function"><a class="header" href="#the-spawn-function">The <code>spawn</code> Function</a></h2>
<p>Here's the signature for the <code>spawn</code> function:</p>
<pre><code class="language-rust noplayground">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T + Send + 'static,
    T: Send + 'static,</code></pre>
<p>The <code>spawn</code> function takes a closure (<code>f</code>) as an argument, spawns a new thread
to run the closure, and returns a <a href="https://doc.rust-lang.org/stable/std/thread/struct.JoinHandle.html"><code>JoinHandle</code></a>. As the name suggests, the
<code>JoinHandle</code> provides a <a href="https://doc.rust-lang.org/stable/std/thread/struct.JoinHandle.html#method.join"><code>join</code></a> method to wait for the spawned thread to
finish. So far, so good. However, the <code>'static</code><sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> constraint on <code>F</code> and the
return value <code>T</code> is where, as the Bard would say, lies the rub.</p>
<p>The <code>'static</code> constraint requires that the closure and its return value must
live for the entire duration of the program's execution. This is necessary
because threads can outlive the context in which they were created.</p>
<p>If a thread, and by extension its return value, can outlive its caller, we need
to ensure they remain valid afterward. Since we <em>can't</em> predict when the thread
will finish, they must be valid until the end of the program. Hence, the
<code>'static</code> lifetime.</p>
<blockquote>
<p>Don't worry if this concept is still unclear; it's one of the most challenging
aspects of Rust, and many developers find it difficult at first.</p>
</blockquote>
<p>Let's examine a simple program to better understand these concepts. Review the
following code snippet and then run the program.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::thread;

    let error = 0373; // Compiler error E0373

    let handler = thread::spawn(|| {
        println!("{error}");
    });

    handler.join().unwrap();
}</code></pre></pre>
<p>This simple program seems perfectly valid. So why does the Rust compiler
complain about code that would run without issues in most other languages? Even
though it's not the case in this example, in a more general sense, the spawned
thread created in <code>main</code> could potentially outlive the thread from which it was
created. Because the closure borrows the <code>error</code> value, the parent thread could
go out of scope, causing the <code>error</code> value to be dropped rendering the reference
invalid. Because the compiler <em>can't</em> know whether or not that's going to
happen, we see the error:</p>
<blockquote>
<p>error<a href="https://doc.rust-lang.org/stable/error_codes/E0373.html">E0373</a>: closure may outlive the current function, but it borrows
<code>error</code>, which is owned by the current function</p>
</blockquote>
<p>The compiler does offer a solution that may work under some circumstances:</p>
<blockquote>
<p>help: to force the closure to take ownership of <code>error</code> (and any other
referenced variables), use the <a href="https://doc.rust-lang.org/std/keyword.move.html"><code>move</code></a> <sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> keyword</p>
</blockquote>
<p>Let's see what happens if we do that:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::thread;

    let error = 0373; // Compiler error E0373

    let handler = thread::spawn(move || {
        println!("{error}");
    });

    handler.join().unwrap();
}</code></pre></pre>
<p>Recalling our discussion on <em>copy semantics</em>, it probably makes sense why this
worked. The value was <em>copied</em> into the scope of the spawned thread, making it
independent from the original and solving the lifetime problem. The variable is
now guaranteed to live for as long as the thread. This works fine for primitive
types and types implementing the <code>Copy</code> trait. But what if copying is an
expensive operation, or the object can't be copied? This leads to the next
challenge that developers learning Rust often face: what happens if we need to
spawn additional threads that also need access to the same variable?</p>
<p>For example, consider this case:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::thread;

    let error = String::from("E0373"); // Compiler error E0373

    let handler1 = thread::spawn(move || {
        println!("{error}");
    });

    let handler2 = thread::spawn(move || {
        println!("{error}");
    });

    handler1.join().unwrap();
    handler2.join().unwrap();
}</code></pre></pre>
<p>While these strict rules may seem daunting, especially in larger programs, they
are the foundation of Rust's <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html#fearless-concurrency">fearless concurrency</a> goals. These rules ensure
that concurrency in your programs is both safe and efficient.</p>
<p>Now that we understand why the traditional fork/join model, which works in many
other languages, is likely to fail in Rust, let's explore how to correctly
implement this approach!</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>Lifetimes are another type of generic. However, instead of ensuring that a
type has the desired behavior, they ensure that references remain valid for
the desired duration. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p><code>move</code> converts any variables captured by reference or mutable reference to
variables captured by value. <a href="#fr-2-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
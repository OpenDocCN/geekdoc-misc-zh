- en: Readers and writers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取者和写入者
- en: 原文：[https://rust-exercises.com/100-exercises/07_threads/12_rw_lock.html](https://rust-exercises.com/100-exercises/07_threads/12_rw_lock.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/07_threads/12_rw_lock.html](https://rust-exercises.com/100-exercises/07_threads/12_rw_lock.html)
- en: 'Our new `TicketStore` works, but its read performance is not great: there can
    only be one client at a time reading a specific ticket, because `Mutex<T>` doesn''t
    distinguish between readers and writers.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`TicketStore`可以工作，但它的读取性能并不出色：一次只能有一个客户端读取特定的票据，因为`Mutex<T>`无法区分读取者和写入者。
- en: 'We can solve the issue by using a different locking primitive: `RwLock<T>`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用不同的锁定原语来解决这个问题：`RwLock<T>`。
- en: '`RwLock<T>` stands for **read-write lock**. It allows **multiple readers**
    to access the data simultaneously, but only one writer at a time.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`RwLock<T>`代表**读写锁**。它允许**多个读取者**同时访问数据，但一次只能有一个写入者。'
- en: '`RwLock<T>` has two methods to acquire a lock: `read` and `write`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`RwLock<T>`有两种获取锁的方法：`read`和`write`。'
- en: '`read` returns a guard that allows you to read the data, while `write` returns
    a guard that allows you to modify it.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`返回一个保护器，允许你读取数据，而`write`返回一个保护器，允许你修改它。'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Trade-offs](#trade-offs)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[权衡](#trade-offs)'
- en: 'On the surface, `RwLock<T>` seems like a no-brainer: it provides a superset
    of the functionality of `Mutex<T>`. Why would you ever use `Mutex<T>` if you can
    use `RwLock<T>` instead?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，`RwLock<T>`似乎是一个不费脑力的选择：它提供了`Mutex<T>`功能集的超集。为什么你还要使用`Mutex<T>`，而不是`RwLock<T>`呢？
- en: 'There are two key reasons:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键原因：
- en: Locking a `RwLock<T>` is more expensive than locking a `Mutex<T>`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定`RwLock<T>`比锁定`Mutex<T>`更昂贵。
- en: This is because `RwLock<T>` has to keep track of the number of active readers
    and writers, while `Mutex<T>` only has to keep track of whether the lock is held
    or not. This performance overhead is not an issue if there are more readers than
    writers, but if the workload is write-heavy `Mutex<T>` might be a better choice.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为`RwLock<T>`必须跟踪活动读取者和写入者的数量，而`Mutex<T>`只需要跟踪锁是否被持有。如果读取者多于写入者，这种性能开销不是问题，但如果工作负载是写入密集型，`Mutex<T>`可能是一个更好的选择。
- en: '`RwLock<T>` can cause **writer starvation**.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RwLock<T>`可能会导致**写入者饥饿**。'
- en: If there are always readers waiting to acquire the lock, writers might never
    get a chance to run.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果总是有读取者等待获取锁，那么写入者可能永远没有机会运行。
- en: '`RwLock<T>` doesn''t provide any guarantees about the order in which readers
    and writers are granted access to the lock. It depends on the policy implemented
    by the underlying OS, which might not be fair to writers.'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RwLock<T>`不提供关于读取者和写入者被授予访问锁的顺序的任何保证。这取决于底层操作系统实现的策略，这可能对写入者不公平。'
- en: In our case, we can expect the workload to be read-heavy (since most clients
    will be reading tickets, not modifying them), so `RwLock<T>` is a good choice.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可以预期工作负载将是读取密集型（因为大多数客户端将读取票据，而不是修改它们），所以`RwLock<T>`是一个不错的选择。
- en: '[Exercise](#exercise)'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`07_threads/12_rw_lock`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`07_threads/12_rw_lock`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock)

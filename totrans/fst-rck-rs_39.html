<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Interval</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Interval</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/interval.html">https://freddiehaddad.github.io/fast-track-to-rust/interval.html</a></blockquote>
                        
<p>The current version of our <code>Interval</code> is limited to the <code>usize</code> type. If we want
to support floating point values, negative integers, or other exotic numeric
types, it won't work. We're going to address this by making it compatible with
any numeric type, with some restrictions.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<h2 id="generic-data-type"><a class="header" href="#generic-data-type">Generic Data Type</a></h2>
<p>The current definition of our <code>Interval</code> <code>struct</code> specifies the field types as
<code>usize</code>. To redefine the <code>struct</code> to use a generic type parameter for its
fields, we use the <code>&lt;&gt;</code> syntax.</p>
<pre><code class="language-rust noplayground">pub struct Interval&lt;T&gt; {
    pub start: T,
    pub end: T,
}</code></pre>
<blockquote>
<p>By using a single generic type to define <code>Interval&lt;T&gt;</code>, we indicate that the
<code>Interval&lt;T&gt;</code> <code>struct</code> is generic over some type <code>T</code>, and the fields <code>start</code>
and <code>end</code> are both of that same type, whatever it may be. If we attempt to
create an instance of <code>Interval&lt;T&gt;</code> with fields of different types, our code
won't compile. To support different types for the fields, we would need to
specify additional generic types, such as <code>struct Interval&lt;T, U&gt;</code>.</p>
</blockquote>
<p>You've probably guessed it already, but this code won't compile. Take a moment
to think about why that might be, and then run the code to see what the compiler
has to say.</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate regex; // this is needed for the playground
</span><span class="boring">use interval::{Interval, IntervalError};
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match regex.is_match(line) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Result&lt;Vec&lt;Interval&gt;, IntervalError&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            let start = line.saturating_sub(before_context);
</span><span class="boring">            let end = line.saturating_add(after_context);
</span><span class="boring">            Interval::new(start, end)
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: Vec&lt;Interval&gt;) -&gt; Vec&lt;Interval&gt; {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals
</span><span class="boring">        .into_iter()
</span><span class="boring">        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_results(intervals: Vec&lt;Interval&gt;, lines: Vec&lt;String&gt;) {
</span><span class="boring">    for interval in intervals {
</span><span class="boring">        for (line_no, line) in lines
</span><span class="boring">            .iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .take(interval.end + 1)
</span><span class="boring">            .skip(interval.start)
</span><span class="boring">        {
</span><span class="boring">            println!("{}: {}", line_no + 1, line)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let mock_file = std::io::Cursor::new(poem);
</span><span class="boring">
</span><span class="boring">    // command line arguments
</span><span class="boring">    let pattern = "(all)|(little)";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span><span class="boring">
</span><span class="boring">    // attempt to open the file
</span><span class="boring">    let lines = read_file(mock_file);
</span><span class="boring">    //let lines = match File::open(filename) {
</span><span class="boring">    //    // convert the poem into lines
</span><span class="boring">    //    Ok(file) =&gt; read_file(file),
</span><span class="boring">    //    Err(e) =&gt; {
</span><span class="boring">    //        eprintln!("Error opening {filename}: {e}");
</span><span class="boring">    //        exit(1);
</span><span class="boring">    //    }
</span><span class="boring">    //};
</span><span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, regex);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let intervals =
</span><span class="boring">        match create_intervals(match_lines, before_context, after_context) {
</span><span class="boring">            Ok(intervals) =&gt; intervals,
</span><span class="boring">            Err(_) =&gt; {
</span><span class="boring">                eprintln!("An error occurred while creating intervals");
</span><span class="boring">                exit(1);
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    let intervals = merge_intervals(intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod interval {
</span><span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span>    pub struct Interval&lt;T&gt; {
        pub start: T,
        pub end: T,
    }
<span class="boring">
</span><span class="boring">    impl Interval {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: usize, end: usize) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As you guessed it, there's a lot of compiler errors and they're very helpful!</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/error_codes/E0107.html">E0107</a>: missing generics for <code>struct</code> <code>Interval</code></li>
</ul>
<p>Let's walk through the errors one by one. The first error informs us that the
return value on line 26 references a generic type but fails to specify one. It
shows the definition of the type on line 141 and provides a helpful tip for how
to correct it. The compiler suggests appending <code>&lt;T&gt;</code> to <code>Interval</code> and
specifying the type for <code>T</code>, which in our case will be <code>usize</code>.</p>
<pre><code class="language-console">error[E0107]: missing generics for struct `Interval`
   --&gt; src/main.rs:26:17
    |
26  | ) -&gt; Result&lt;Vec&lt;Interval&gt;, IntervalError&gt; {
    |                 ^^^^^^^^ expected 1 generic argument
    |
note: struct defined here, with 1 generic parameter: `T`
   --&gt; src/main.rs:141:16
    |
141 |     pub struct Interval&lt;T&gt; {
    |                ^^^^^^^^ -
help: add missing generic argument
    |
26  | ) -&gt; Result&lt;Vec&lt;Interval&lt;T&gt;&gt;, IntervalError&gt; {
    |                         +++
</code></pre>
<p>The fix should be relatively straightforward to understand, as we've used the
same approach for other generic types we've worked with. Let's apply the fix to
all the functions and try again!</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate regex; // this is needed for the playground
</span><span class="boring">use interval::{Interval, IntervalError};
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match regex.is_match(line) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span>fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
        .collect()
}

fn print_results(intervals: Vec&lt;Interval&lt;usize&gt;&gt;, lines: Vec&lt;String&gt;) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            println!("{}: {}", line_no + 1, line)
        }
    }
}
<span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let mock_file = std::io::Cursor::new(poem);
</span><span class="boring">
</span><span class="boring">    // command line arguments
</span><span class="boring">    let pattern = "(all)|(little)";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span><span class="boring">
</span><span class="boring">    // attempt to open the file
</span><span class="boring">    let lines = read_file(mock_file);
</span><span class="boring">    //let lines = match File::open(filename) {
</span><span class="boring">    //    // convert the poem into lines
</span><span class="boring">    //    Ok(file) =&gt; read_file(file),
</span><span class="boring">    //    Err(e) =&gt; {
</span><span class="boring">    //        eprintln!("Error opening {filename}: {e}");
</span><span class="boring">    //        exit(1);
</span><span class="boring">    //    }
</span><span class="boring">    //};
</span><span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, regex);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let intervals =
</span><span class="boring">        match create_intervals(match_lines, before_context, after_context) {
</span><span class="boring">            Ok(intervals) =&gt; intervals,
</span><span class="boring">            Err(_) =&gt; {
</span><span class="boring">                eprintln!("An error occurred while creating intervals");
</span><span class="boring">                exit(1);
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    let intervals = merge_intervals(intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod interval {
</span><span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl Interval {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: usize, end: usize) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>As expected, we still have some more compiler errors to work through and these
lead us into how we implement methods for a generic type!</p>
<pre><code class="language-console">error[E0107]: missing generics for struct `Interval`
   --&gt; src/main.rs:146:10
    |
146 |     impl Interval {
    |          ^^^^^^^^ expected 1 generic argument
    |
note: struct defined here, with 1 generic parameter: `T`
   --&gt; src/main.rs:141:16
    |
141 |     pub struct Interval&lt;T&gt; {
    |                ^^^^^^^^ -
help: add missing generic argument
    |
146 |     impl Interval&lt;T&gt; {
    |                  +++

error[E0107]: missing generics for struct `Interval`
   --&gt; src/main.rs:189:40
    |
189 |         pub fn overlaps(&amp;self, other: &amp;Interval) -&gt; bool {
    |                                        ^^^^^^^^ expected 1 generic argument
    |
note: struct defined here, with 1 generic parameter: `T`
   --&gt; src/main.rs:141:16
    |
141 |     pub struct Interval&lt;T&gt; {
    |                ^^^^^^^^ -
help: add missing generic argument
    |
189 |         pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
    |                                                +++

For more information about this error, try `rustc --explain E0107`.
</code></pre>
<h2 id="inherent-implementation"><a class="header" href="#inherent-implementation">Inherent Implementation</a></h2>
<p>There are two main types of implementation we define: inherent implementations
(standalone) and trait implementations.<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> We'll focus on inherent
implementation first and explore trait implementations towards the end of this
section.</p>
<p>We need to update our <code>impl</code> block to support generic type parameters for our
generic type, and the syntax is as follows:</p>
<pre><code class="language-rust noplayground">impl&lt;T&gt; Type&lt;T&gt; {}  // Type is replaced with Interval for our case</code></pre>
<p>Here are the necessary changes. Review them and run the program again.</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate regex; // this is needed for the playground
</span><span class="boring">use interval::{Interval, IntervalError};
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match regex.is_match(line) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            let start = line.saturating_sub(before_context);
</span><span class="boring">            let end = line.saturating_add(after_context);
</span><span class="boring">            Interval::new(start, end)
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals
</span><span class="boring">        .into_iter()
</span><span class="boring">        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_results(intervals: Vec&lt;Interval&lt;usize&gt;&gt;, lines: Vec&lt;String&gt;) {
</span><span class="boring">    for interval in intervals {
</span><span class="boring">        for (line_no, line) in lines
</span><span class="boring">            .iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .take(interval.end + 1)
</span><span class="boring">            .skip(interval.start)
</span><span class="boring">        {
</span><span class="boring">            println!("{}: {}", line_no + 1, line)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let mock_file = std::io::Cursor::new(poem);
</span><span class="boring">
</span><span class="boring">    // command line arguments
</span><span class="boring">    let pattern = "(all)|(little)";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span><span class="boring">
</span><span class="boring">    // attempt to open the file
</span><span class="boring">    let lines = read_file(mock_file);
</span><span class="boring">    //let lines = match File::open(filename) {
</span><span class="boring">    //    // convert the poem into lines
</span><span class="boring">    //    Ok(file) =&gt; read_file(file),
</span><span class="boring">    //    Err(e) =&gt; {
</span><span class="boring">    //        eprintln!("Error opening {filename}: {e}");
</span><span class="boring">    //        exit(1);
</span><span class="boring">    //    }
</span><span class="boring">    //};
</span><span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, regex);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let intervals =
</span><span class="boring">        match create_intervals(match_lines, before_context, after_context) {
</span><span class="boring">            Ok(intervals) =&gt; intervals,
</span><span class="boring">            Err(_) =&gt; {
</span><span class="boring">                eprintln!("An error occurred while creating intervals");
</span><span class="boring">                exit(1);
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    let intervals = merge_intervals(intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod interval {
</span><span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span>    impl&lt;T&gt; Interval&lt;T&gt; {
<span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span>        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
            if start &lt;= end {
                Ok(Self { start, end })
            } else {
                Err(IntervalError::StartEndRangeInvalid)
            }
        }

<span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span>        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
            self.end &gt;= other.start
        }
<span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Well, that didn't work! Now we have two new compiler errors:</p>
<ul>
<li>[E0369]: binary operation <code>&lt;=</code> cannot be applied to type <code>T</code></li>
<li>[E0507]: cannot move out of <code>self.start</code> which is behind a shared reference</li>
</ul>
<p>That's okay, because these errors are a perfect segue into trait bounds!</p>
<h2 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h2>
<p>The compiler generated a few very helpful error messages, which we can
categorize into two types, both of which suggest the use of trait bounds:</p>
<pre><code class="language-console">error[E0369]: binary operation `&lt;=` cannot be applied to type `T`
   --&gt; src/main.rs:157:22
    |
157 |             if start &lt;= end {
    |                ----- ^^ --- T
    |                |
    |                T
    |
help: consider restricting type parameter `T`
    |
146 |     impl&lt;T: std::cmp::PartialOrd&gt; Interval&lt;T&gt; {
    |           ++++++++++++++++++++++

error[E0507]: cannot move out of `self.start` which is behind a shared reference
   --&gt; src/main.rs:210:28
    |
210 |                     start: self.start,
    |                            ^^^^^^^^^^ move occurs because `self.start` has
                                            type `T`, which does not implement the
                                            `Copy` trait
    |
help: if `T` implemented `Clone`, you could clone the value
   --&gt; src/main.rs:146:10
    |
146 |     impl&lt;T&gt; Interval&lt;T&gt; {
    |          ^ consider constraining this type parameter with `Clone`
...
210 |                     start: self.start,
    |                            ---------- you could clone this value
</code></pre>
<p>With an introduction to trait bounds, everything will become clear. Let's begin
with the first error. The compiler indicates that a comparison between two
generic types is being attempted in the <code>new</code> function, and not all types
support this capability. In other words, not all types implement the
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> trait, which is necessary for using comparison operators like
<code>&lt;=</code> and <code>&gt;=</code>.</p>
<blockquote>
<p>For those with an object-oriented programming background, a trait can be
thought of as similar to an interface.</p>
</blockquote>
<pre><code class="language-rust noplayground">pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
    if start &lt;= end {
        Ok(Self { start, end })
    } else {
        Err(IntervalError::StartEndRangeInvalid)
    }
}</code></pre>
<p>Since our <code>Interval</code> <code>struct</code> is generic over <code>T</code>, the types for <code>start</code> and
<code>end</code> can be anything, including types that aren't comparable. Therefore, the
compiler is instructing us to restrict <code>T</code> to any type that implements the
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> trait. In other words, we need to place a <em>bound</em> on <code>T</code>.</p>
<p>The next error requires us to revisit the topic of move semantics in Rust.
Except for primitive types, most standard library types and those found in
third-party crates do not implement the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait. In other words, they do
not have <em>copy semantics</em>. Let's examine the function where the error occurs:</p>
<pre><code class="language-rust noplayground">pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
    if self.overlaps(other) {
        Ok(Self {
            start: self.start,
            end: other.end,
        })
    } else {
        Err(IntervalError::NonOverlappingInterval)
    }
}</code></pre>
<p>The <code>merge</code> function borrows the values for <code>self</code> and <code>other</code>. If the two
intervals overlap, a new interval is returned with the values copied into it.
Since we have been using <code>usize</code>, a type that implements the <code>Copy</code> trait, this
worked. To ensure it continues to work, we need to place another bound on <code>T</code>,
limiting it to types that implement the <code>Copy</code> trait.</p>
<blockquote>
<p>The compiler also mentions the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> trait, which allows for explicit
duplication of an object via the <code>clone</code> method. This means we could specify
the trait bound as <code>Clone</code> instead of <code>Copy</code> and update the method to
explicitly call <code>clone</code>.</p>
</blockquote>
<p>With an understanding of trait bounds, let's examine how to impose these
restrictions on our <code>Interval</code>. Does the program work now?</p>
<pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate regex; // this is needed for the playground
</span><span class="boring">use interval::{Interval, IntervalError};
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match regex.is_match(line) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            let start = line.saturating_sub(before_context);
</span><span class="boring">            let end = line.saturating_add(after_context);
</span><span class="boring">            Interval::new(start, end)
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals
</span><span class="boring">        .into_iter()
</span><span class="boring">        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_results(intervals: Vec&lt;Interval&lt;usize&gt;&gt;, lines: Vec&lt;String&gt;) {
</span><span class="boring">    for interval in intervals {
</span><span class="boring">        for (line_no, line) in lines
</span><span class="boring">            .iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .take(interval.end + 1)
</span><span class="boring">            .skip(interval.start)
</span><span class="boring">        {
</span><span class="boring">            println!("{}: {}", line_no + 1, line)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let mock_file = std::io::Cursor::new(poem);
</span><span class="boring">
</span><span class="boring">    // command line arguments
</span><span class="boring">    let pattern = "(all)|(little)";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span><span class="boring">
</span><span class="boring">    // attempt to open the file
</span><span class="boring">    let lines = read_file(mock_file);
</span><span class="boring">    //let lines = match File::open(filename) {
</span><span class="boring">    //    // convert the poem into lines
</span><span class="boring">    //    Ok(file) =&gt; read_file(file),
</span><span class="boring">    //    Err(e) =&gt; {
</span><span class="boring">    //        eprintln!("Error opening {filename}: {e}");
</span><span class="boring">    //        exit(1);
</span><span class="boring">    //    }
</span><span class="boring">    //};
</span><span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, regex);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let intervals =
</span><span class="boring">        match create_intervals(match_lines, before_context, after_context) {
</span><span class="boring">            Ok(intervals) =&gt; intervals,
</span><span class="boring">            Err(_) =&gt; {
</span><span class="boring">                eprintln!("An error occurred while creating intervals");
</span><span class="boring">                exit(1);
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    let intervals = merge_intervals(intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod interval {
</span><span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span>    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
<span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Voila! And we now have a generic <code>Interval</code> module that can support any type
implementing the <code>Copy</code> and <code>PartialOrd</code> traits!</p>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<ul>
<li>Modify the program to use the <code>Clone</code> trait instead of <code>Copy</code>.</li>
</ul>
<details>
    <summary>Solution</summary>
<pre><code class="language-rust noplayground">impl&lt;T: Clone + PartialOrd&gt; Interval&lt;T&gt; {
    pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
        if self.overlaps(other) {
            Ok(Self {
                start: self.start.clone(),
                end: other.end.clone(),
            })
        } else {
            Err(IntervalError::NonOverlappingInterval)
        }
    }
}</code></pre>
</details>
<pre class="playground"><code class="language-rust editable edition2021">#![allow(unused_imports)]
extern crate regex; // this is needed for the playground
use interval::{Interval, IntervalError};
use itertools::Itertools;
use regex::Regex;
use std::fs::File;
use std::io::Read;
use std::io::{BufRead, BufReader};
use std::process::exit;

fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match regex.is_match(line) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
}

fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
        .collect()
}

fn print_results(intervals: Vec&lt;Interval&lt;usize&gt;&gt;, lines: Vec&lt;String&gt;) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            println!("{}: {}", line_no + 1, line)
        }
    }
}

fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

fn main() {
    let poem = "I have a little shadow that goes in and out with me,
                And what can be the use of him is more than I can see.
                He is very, very like me from the heels up to the head;
                And I see him jump before me, when I jump into my bed.

                The funniest thing about him is the way he likes to grow -
                Not at all like proper children, which is always very slow;
                For he sometimes shoots up taller like an india-rubber ball,
                And he sometimes gets so little that there's none of him at all.";

    let mock_file = std::io::Cursor::new(poem);

    // command line arguments
    let pattern = "(all)|(little)";
    let before_context = 1;
    let after_context = 1;

    // attempt to open the file
    let lines = read_file(mock_file);
    //let lines = match File::open(filename) {
    //    // convert the poem into lines
    //    Ok(file) =&gt; read_file(file),
    //    Err(e) =&gt; {
    //        eprintln!("Error opening {filename}: {e}");
    //        exit(1);
    //    }
    //};

    // compile the regular expression
    let regex = match Regex::new(pattern) {
        Ok(re) =&gt; re, // bind re to regex
        Err(e) =&gt; {
            eprintln!("{e}"); // write to standard error
            exit(1);
        }
    };

    // store the 0-based line number for any matched line
    let match_lines = find_matching_lines(&amp;lines, regex);

    // create intervals of the form [a,b] with the before/after context
    let intervals =
        match create_intervals(match_lines, before_context, after_context) {
            Ok(intervals) =&gt; intervals,
            Err(_) =&gt; {
                eprintln!("An error occurred while creating intervals");
                exit(1);
            }
        };

    // merge overlapping intervals
    let intervals = merge_intervals(intervals);

    // print the lines
    print_results(intervals, lines);
}

pub mod interval {
    /// A list specifying general categories of Interval errors.
    pub enum IntervalError {
        /// Start is not less than or equal to end
        StartEndRangeInvalid,
        /// Two intervals to be merged do not overlap
        NonOverlappingInterval,
    }

    /// A closed-interval [`start`, `end`] type used for representing a range of
    /// values between `start` and `end` inclusively.
    ///
    /// # Examples
    ///
    /// You can create an `Interval` using `new`.
    ///
    /// ```rust
    /// let interval = Interval::new(1, 10).unwrap();
    /// assert_eq!(interval.start, 1);
    /// assert_eq!(interval.end, 10);
    /// ```
    pub struct Interval&lt;T&gt; {
        pub start: T,
        pub end: T,
    }

    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
        /// Creates a new `Interval` set to `start` and `end`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let interval = Interval::new(1, 10).unwrap();
        /// assert_eq!(interval.start, 1);
        /// assert_eq!(interval.end, 10);
        /// ```
        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
            if start &lt;= end {
                Ok(Self { start, end })
            } else {
                Err(IntervalError::StartEndRangeInvalid)
            }
        }

        /// Checks if two intervals overlap. Overlapping intervals have at least
        /// one point in common.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 5).unwrap();
        /// let b = Interval::new(2, 4).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(4, 6).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), false);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
            self.end &gt;= other.start
        }

        /// Merges two intervals returning a new `Interval`.
        ///
        /// The merged `Interval` range includes the union of ranges from each
        /// `Interval`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// let c = a.merge(&amp;b).unwrap();
        /// assert_eq!(c.start, 1);
        /// assert_eq!(c.end, 5);
        /// ```
        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
            if self.overlaps(other) {
                Ok(Self {
                    start: self.start,
                    end: other.end,
                })
            } else {
                Err(IntervalError::NonOverlappingInterval)
            }
        }
    }
}</code></pre>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>Let's dive deeper into traits!</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>The restrictions we place on the supported types are known as
<a href="https://doc.rust-lang.org/reference/trait-bounds.html">trait bounds</a>. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>For more information on <code>impl Trait</code> syntax, see the <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits">Rust book</a> <a href="#fr-2-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
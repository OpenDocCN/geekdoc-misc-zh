- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/regular_expression.html](https://freddiehaddad.github.io/fast-track-to-rust/regular_expression.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the `Regex` crate added to our project, we'll replace the `pattern` string
    slice we've been using with a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Regex](#using-regex)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Regex` modules defines a `new` method that takes a regular expression,
    attempts to compile it, and returns a `Regex` object.^([1](#footnote-1))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since compiling a regular expression can fail (e.g., due to an invalid pattern),
    `new` returns a `Result`. Here is the function signature for `new`^([2](#footnote-2)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The function signature indicates that the `Ok` variant returns a `Regex`, while
    the `Err` variant returns an `Error`. Since our rustle program can't continue
    with an invalid regular expression, we need to catch that case, display a helpful
    error message, and exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put all this together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: extern crate regex; // this is needed for the playground
  prefs: []
  type: TYPE_NORMAL
- en: use regex::Regex;
  prefs: []
  type: TYPE_NORMAL
- en: use std::process::exit;
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let pattern = "(missing the closing parenthesis"; // invalid expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // compile the regular expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match Regex::new(pattern) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // the underscore (_) means we are ignoring the value returned by new
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(_) => println!("{pattern} is a valid regular expression!"),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // e is the error value returned by new
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(e) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: eprintln!("{e}"); // eprintln! writes to standard error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);          // exit with error code 1
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run the code to see the error. Then, correct the it by adding the missing parenthesis
    `)` and re-run the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Updating Rustle](#updating-rustle)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have enough context to modify our rustle program to include regular
    expression support. Below are the changes, with the unrelated parts of the program
    hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] use std::fs::File; use std::io::Read; use std::io::{BufRead,
    BufReader}; use std::process::exit; extern crate regex; // this is needed for
    the playground use regex::Regex;'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match regex.is_match(line) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect() // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Vec<(usize,
    usize)> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'lines .iter() .map(|line| { ( line.saturating_sub(before_context), line.saturating_add(after_context),
    ) }) .collect() }   fn merge_intervals(intervals: &mut Vec<(usize, usize)>) {'
  prefs: []
  type: TYPE_NORMAL
- en: '// merge overlapping intervals intervals.dedup_by(|next, prev| { if prev.1
    < next.0 { false } else { prev.1 = next.1; true } }) }   fn print_results(intervals:
    Vec<(usize, usize)>, lines: Vec<String>) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (start, end) in intervals { for (line_no, line) in lines.iter().enumerate().take(end
    + 1).skip(start) { println!("{}: {}", line_no + 1, line) } } }   fn read_file(file:
    impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};      // compile the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: let regex = match Regex::new(pattern) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(re) => re, // bind re to regex
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(e) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: eprintln!("{e}"); // write to standard error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // store the 0-based line number for any matched line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let match_lines = find_matching_lines(&lines, regex);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // create intervals of the form [a,b] with the before/after context let mut
    intervals = create_intervals(match_lines, before_context, after_context);   //
    merge overlapping intervals merge_intervals(&mut intervals);   // print the lines
    print_results(intervals, lines); }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget, you can reveal the hidden parts by clicking *Show hidden lines*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `let regex = match Regex::new(pattern)` variable binding expression might
    seem a bit unusual. The pattern is discussed in the Rust documentation section
    on [Recoverable Errors with Result](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#recoverable-errors-with-result).
    To briefly explain: When the result is `Ok`, this code extracts the inner `re`
    value from the `Ok` variant and moves it to the variable `regex`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Onward to creating our own module!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `Regex` crate includes excellent [documentation](https://docs.rs/regex/latest/regex/)
    and detailed [examples](https://docs.rs/regex/latest/regex/#examples) to learn
    from. [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The source code for `new` can be found [here](https://docs.rs/regex/latest/src/regex/regex/string.rs.html#180-182).
    [↩](#fr-2-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

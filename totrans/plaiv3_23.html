<html><head></head><body>
<h1 class="c22" id="h.lwn8ow5i4shv"><span class="c4">Parsing: From Source to ASTs</span></h1><h2 class="c23" id="h.jabunlft2rb1"><span class="c4">The Problem</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Earlier we went through the basic steps of the SImPl, but we left open a big question: how do we get programs </span><span class="c7">into</span><span class="c4"> the AST representation? Of course, the simplest way is what we already did: to write the AST constructors directly, e.g.,</span></p><p class="c3"><span class="c4"/></p><pre>(num 1)</pre><p class="c52"><span class="c41"/></p><pre>(plus (num 1) (num 2))</pre><p class="c3"><span class="c4"/></p><pre>(plus (num 1)
      (plus (num 2) (num 3)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">which, as we noted, has the virtue of also ignoring exactly how the program source was written.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">However, this can get very tedious. We don’t want to have to write </span><code>(num …)</code><span class="calibre3"> every time we want to write a number, for instance! In particular, the more tedious it is the less likely we are to write many or complex tests, and that would be especially unfortunate. Therefore, we’d like a more convenient surface syntax, along with a </span><span class="c7">program</span><span class="c4"> to translate that into ASTs.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">As we have already seen, there is a large number of surface syntaxes we can use, and we aren’t even limited to textual syntax: it could be graphical; spoken; gestural (imagine you’re in a virtual reality environment); and so on. As we have noted, this wide range of modalities is important—especially so if the programmer has physical constraints—but it’s outside the range of our current study. Even with textual syntax, we have to deal with issues like ambiguity (e.g., order of operations in arithmetic).</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">In general, the process of converting the input syntax into ASTs is called </span><span class="c7">parsing</span><span class="c4">. We could write a whole booklet just on parsing…so we won’t. Instead, we’re going to pick one syntax that strikes a reasonable balance between convenience and simplicity, which is the parenthetical syntax of Racket, and has special support in plait. That is, we will write the above examples as</span></p><p class="c3"><span class="c4"/></p><pre>1
(+ 1 2)
(+ 1 (+ 2 3))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">and see how Racket can help us make these convenient to work with. In fact, in this book we will follow a convention (that Racket doesn’t care about, because it treats </span><code>()</code><span class="calibre3">, </span><code>[]</code><span class="calibre3">, and </span><code>{}</code><span class="calibre3"> interchangeably): we’ll write programs to be represented using </span><code>{}</code><span class="calibre3"> instead of </span><code>()</code><span class="c4">. Thus, the above three programs become</span></p><p class="c3"><span class="c4"/></p><pre>1
{+ 1 2}
{+ 1 {+ 2 3}}</pre></body></html>
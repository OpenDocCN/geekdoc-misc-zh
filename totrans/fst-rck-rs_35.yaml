- en: Enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/enum.html](https://freddiehaddad.github.io/fast-track-to-rust/enum.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An *[enumeration](https://doc.rust-lang.org/reference/items/enumerations.html)*,
    commonly known as an *[enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html)*,
    is declared using the keyword `enum`. Compared to other languges, enums in Rust
    offer greater flexibility and power. For instance, they support generics (as seen
    with the `Option` `enum`) and can encapsulate values within their variants! ^([1](#footnote-1))
  prefs: []
  type: TYPE_NORMAL
- en: '[Using an `enum` for Errors](#using-an-enum-for-errors)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our rustle program, we'll create an `enum` to represent possible errors
    during `Interval` operations. For example, when a user creates an `Interval`,
    the starting value must be less than or equal to the ending value. Additionally,
    if a user wants to merge two intervals, they must overlap. If these conditions
    aren't met, we'll return an error (`Err`) using one of our `enum` variants.
  prefs: []
  type: TYPE_NORMAL
- en: '[Defining an `enum`](#defining-an-enum)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Below is the `IntervalError` `enum`, which lists the errors that we may need
    to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Updating our Interval](#updating-our-interval)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll change the return type for the function `new` and the method
    `merge` to a `Result` with the `Ok` variant being an `Interval` and the `Err`
    variant the appropriate `IntervalError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Observe how an `Interval` is created in `new` as opposed to `merge`. Since the
    parameter names in new precisely match the fields in the `Interval` `struct` definition,
    you can omit the field specifiers. This technique is referred to as *field init
    shorthand* syntax. ^([2](#footnote-2))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Updating Rustle](#updating-rustle)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `Interval` changes implemented, we need to update the `create_intervals`
    and `merge_intervals` functions to accommodate the `Result` return type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In `create_intervals`, the only change was the return type, which changed from
    `Vec<Interval>` to `Result<Vec<Interval>, IntervalError>`. You might wonder why
    this works. The concise answer is that the `Result` type implements the [`FromIterator`](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an intermediary collection of `Result` values created from calls to
    `Interval::new(start, end)`. The `FromIterator` trait implementation allows an
    iterator over `Result` values to be collected *into* a `Result` containing a collection
    of the underlying values or an `Err`. ^([3](#footnote-3)) In other words, the
    value contained in the `Result` returned by `Interval::new(start, end)` is stored
    in the `Vec<Interval>` collection which is then wrapped in a `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be exploring traits in the next section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In `merge_intervals`, the only change required is to the closure used in `coalesce`.
    We attempt to merge two intervals and invoke the [`or`](https://doc.rust-lang.org/std/result/enum.Result.html#method.or)
    method of `Result`. If the merge is successful, returning `Ok`, the value is passed
    back to `coalesce`. Otherwise, the `Err((p, c))` value provided to `or` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`Result` methods like `map_err`, `or`, and `or_else` are often used in error
    handling because they allow benign errors to be managed while letting successful
    results pass through. Since the `merge` method only merges overlapping intervals,
    we replace the `Err` variant it returns with the tuple `(p, c)` needed by `coalesce`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Eager vs Lazy Evaluation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Depending on the use case, different `Result` methods may be more efficient.
    It's important to read the documentation to determine the best choice. For example,
    arguments passed to [`or`](https://doc.rust-lang.org/std/result/enum.Result.html#method.or)
    are eagerly evaluated. If you're passing the result of a function call, it's better
    to use [`or_else`](https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else),
    which is lazily evaluated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final change required is in `main`. Since `create_intervals` now returns
    a `Result`, we use a `match` expression to check if the operation was successful.
    In the case of an `Err`, since it's unrecoverable, we print an error message and
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Updating Rustle](#updating-rustle-1)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our changes in place, our Interval now supports error handling via `Result`
    and our rustle program properly handles any errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use itertools::Itertools; use regex::Regex; use std::fs::File; use std::io::Read;
    use std::io::{BufRead, BufReader}; use std::process::exit;   fn find_matching_lines(lines:
    &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }   fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'before_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'after_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Result<Vec<Interval>, IntervalError> {
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let start = line.saturating_sub(before_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let end = line.saturating_add(after_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Interval::new(start, end)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .into_iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .coalesce(|p, c| p.merge(&c).or(Err((p, c))))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_results(intervals: Vec<Interval>, lines: Vec<String>) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'for interval in intervals { for (line_no, line) in lines .iter() .enumerate()
    .take(interval.end + 1) .skip(interval.start) { println!("{}: {}", line_no + 1,
    line) } } }   fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there''s none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern
    = "(all)|(little)"; let before_context = 1; let after_context = 1;   // attempt
    to open the file let lines = read_file(mock_file); //let lines = match File::open(filename)
    { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e)
    => { //        eprintln!("Error opening {filename}: {e}"); //        exit(1);
    //    } //};   // compile the regular expression let regex = match Regex::new(pattern)
    { Ok(re) => re, // bind re to regex Err(e) => { eprintln!("{e}"); // write to
    standard error exit(1); } };   // store the 0-based line number for any matched
    line let match_lines = find_matching_lines(&lines, regex);      // create intervals
    of the form [a,b] with the before/after context'
  prefs: []
  type: TYPE_NORMAL
- en: let intervals =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match create_intervals(match_lines, before_context, after_context) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(intervals) => intervals,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(_) => {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: eprintln!("An error occurred while creating intervals");
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // merge overlapping intervals let intervals = merge_intervals(intervals);   //
    print the lines print_results(intervals, lines); }
  prefs: []
  type: TYPE_NORMAL
- en: enum IntervalError {
  prefs: []
  type: TYPE_NORMAL
- en: StartEndRangeInvalid,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NonOverlappingInterval,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: struct Interval {
  prefs: []
  type: TYPE_NORMAL
- en: 'start: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Interval {
  prefs: []
  type: TYPE_NORMAL
- en: 'fn new(start: usize, end: usize) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if start <= end {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self { start, end })
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::StartEndRangeInvalid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn overlaps(&self, other: &Interval) -> bool {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.end >= other.start
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn merge(&self, other: &Self) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if self.overlaps(other) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'start: self.start,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: other.end,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::NonOverlappingInterval)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decision to use the [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)
    type for error handling in Rust provides a robust and flexible way of managing
    errors such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicit Error Handling**: Using `Result` makes error handling explicit.
    Functions that can fail return a `Result`, which forces the caller to handle the
    potential error, making the code more reliable and less prone to unexpected failures.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Recoverable Errors**: The `Result` type allows for recoverable errors. By
    returning a `Result`, the function gives the caller the option to handle the error
    in a way that makes sense for their specific context, rather than immediately
    terminating the program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Type Safety**: Rust''s type system ensures that errors are handled correctly.
    The `Result` type is part of this system, helping to prevent common errors like
    null pointer dereferencing and making the code safer and more predictable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Composability**: The `Result` type implements traits like `FromIterator`,
    which allows for powerful and flexible error handling patterns. This makes it
    easier to work with collections of results and to propagate errors through multiple
    layers of function calls.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overall, the use of `Result` aligns with Rust's goals of safety, concurrency,
    and performance, providing a clear and structured way to handle errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replace `Result::or` with `Result::map_err` in `merge_intervals`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <details><summary>Solution</summary>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]</details>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)]'
  prefs: []
  type: TYPE_NORMAL
- en: extern crate regex; // this is needed for the playground
  prefs: []
  type: TYPE_NORMAL
- en: use itertools::Itertools;
  prefs: []
  type: TYPE_NORMAL
- en: use regex::Regex;
  prefs: []
  type: TYPE_NORMAL
- en: use std::fs::File;
  prefs: []
  type: TYPE_NORMAL
- en: use std::io::Read;
  prefs: []
  type: TYPE_NORMAL
- en: use std::io::{BufRead, BufReader};
  prefs: []
  type: TYPE_NORMAL
- en: use std::process::exit;
  prefs: []
  type: TYPE_NORMAL
- en: 'fn find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match regex.is_match(line) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect() // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'before_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'after_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Result<Vec<Interval>, IntervalError> {
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let start = line.saturating_sub(before_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let end = line.saturating_add(after_context);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Interval::new(start, end)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {'
  prefs: []
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .into_iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .coalesce(|p, c| p.merge(&c).or(Err((p, c))))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_results(intervals: Vec<Interval>, lines: Vec<String>) {'
  prefs: []
  type: TYPE_NORMAL
- en: for interval in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in lines
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .take(interval.end + 1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .skip(interval.start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what can be the use of him is more than I can see.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: He is very, very like me from the heels up to the head;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And I see him jump before me, when I jump into my bed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The funniest thing about him is the way he likes to grow -
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not at all like proper children, which is always very slow;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For he sometimes shoots up taller like an india-rubber ball,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And he sometimes gets so little that there's none of him at all.";
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let mock_file = std::io::Cursor::new(poem);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // command line arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let pattern = "(all)|(little)";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let before_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let after_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // attempt to open the file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let lines = read_file(mock_file);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //let lines = match File::open(filename) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    // convert the poem into lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    Ok(file) => read_file(file),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    Err(e) => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '//        eprintln!("Error opening {filename}: {e}");'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //        exit(1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //    }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //};
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // compile the regular expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let regex = match Regex::new(pattern) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(re) => re, // bind re to regex
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(e) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: eprintln!("{e}"); // write to standard error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // store the 0-based line number for any matched line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let match_lines = find_matching_lines(&lines, regex);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // create intervals of the form [a,b] with the before/after context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let intervals =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match create_intervals(match_lines, before_context, after_context) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(intervals) => intervals,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(_) => {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: eprintln!("An error occurred while creating intervals");
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let intervals = merge_intervals(intervals);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // print the lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_results(intervals, lines);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: enum IntervalError {
  prefs: []
  type: TYPE_NORMAL
- en: StartEndRangeInvalid,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: NonOverlappingInterval,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: struct Interval {
  prefs: []
  type: TYPE_NORMAL
- en: 'start: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Interval {
  prefs: []
  type: TYPE_NORMAL
- en: 'fn new(start: usize, end: usize) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if start <= end {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self { start, end })
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::StartEndRangeInvalid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn overlaps(&self, other: &Interval) -> bool {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.end >= other.start
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn merge(&self, other: &Self) -> Result<Self, IntervalError> {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if self.overlaps(other) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(Self {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'start: self.start,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'end: other.end,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(IntervalError::NonOverlappingInterval)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our Interval complete, let's make it a module!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation on [enum values](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#enum-values).
    [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the documentation on *[field init shorthand](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand)*
    syntax. [↩](#fr-2-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the documentation on [Collecting into a `Result`](https://doc.rust-lang.org/std/result/#collecting-into-result)
    for detailed explanation. [↩](#fr-3-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

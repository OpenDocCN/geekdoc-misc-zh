<html><head></head><body>
<h2 class="c27" id="h.k44dp8d0lvuz"><span class="c4">Adding Booleans</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Okay, so what if we wanted proper Booleans?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Again, to employ SImPl, we need to alter the AST, the evaluator, and the parser.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">We can add Booleans much like we did numbers: with a constructor that wraps a plait representation of the Boolean.</span></p><p class="c3"><span class="c4"/></p><pre>(define-type Exp
Â  [num (n : Number)]
Â  [bool (b : Boolean)]
Â  [plus (left : Exp) (right : Exp)]
Â  [cnd (test : Exp) (then : Exp) (else : Exp)])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Itâ€™s very important to keep in mind what the </span><code>num</code><span class="calibre3">Â and </span><code>bool</code><span class="calibre3">Â constructors stand for. Recall that this is </span><span class="c7">abstract syntax</span><span class="calibre3">: we are just (abstractly) representing the </span><span class="c7">program that the user wrote</span><span class="calibre3">, not the result of its evaluation. Therefore, these constructors are capturing syntactic </span><span class="c7">constants</span><span class="calibre3">Â in the source program: values like </span><code>3.14</code><span class="calibre3">Â and </span><code>-1</code><span class="calibre3">Â for the former and </span><code>#true</code><span class="calibre3">Â and </span><code>#false</code><span class="calibre3">Â for the latter. They do </span><span class="c61">not</span><span class="calibre3">Â represent compound expressions that will </span><span class="c7">evaluate to</span><span class="calibre3">Â numbers or Booleans. What an expression will evaluate to, for now, can only be determined by running it. Later [</span><span class="c16"><a class="c11" href="PLAIVersion3.2.2_split_088.html#h.7rb3ecnk20em">ðŸ‘‰</a></span><span class="c4">], we will see there are other ways of doing it too!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3">Â The abstract syntax does not dictate what concrete syntax we use. For instance, we may write numbers as </span><code>3</code><span class="calibre3">Â or as </span><code>III</code><span class="calibre3">. We might write Boolean values as </span><code>#t</code><span class="calibre3">, </span><code>#true</code><span class="calibre3">, </span><code>true</code><span class="calibre3">, </span><code>True</code><span class="calibre3">, â€¦. We may even have different concrete syntaxes for the same abstract syntax. This is precisely the </span><span class="c7">abstraction</span><span class="c4">Â that abstract syntax provides!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Easy peasy! This naturally suggests what we should do in the evaluator:</span></p><p class="c3"><span class="c4"/></p><pre>(define (calc e)
Â  (type-case Exp e
Â  Â  [(num n) n]
Â  Â  [(bool b) b]
Â  Â  [(plus l r) (+ (calc l) (calc r))]
Â  Â  [(cnd c t e) (if (zero? (calc c))
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â (calc t)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â (calc e))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Ohâ€¦oops. This version of </span><code>calc</code><span class="c4">Â doesnâ€™t type-check, because our calculator is supposed to return only numbers, not Booleans!</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In fact, we had to know that this couldnâ€™t last. We arenâ€™t interested only in calculators; we want to build full-fledged programming languages. They have a wide range of values, i.e., answers: numbers, Boolean, strings, images, functions, and more.</span></p></body></html>
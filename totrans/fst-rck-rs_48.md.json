["```rs\nuse clap::Parser;\nuse interval::{Interval, IntervalError};\nuse itertools::Itertools;\nuse regex::Regex;\nuse std::fs::File;\nuse std::io::Read;\nuse std::io::{BufRead, BufReader};\nuse std::path::PathBuf;\nuse std::process::exit;\nuse std::thread;\n\nfn find_matching_lines(lines: &[String], regex: &Regex) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match regex.is_match(line) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Result<Vec<Interval<usize>>, IntervalError> {\n    lines\n        .iter()\n        .map(|line| {\n            let start = line.saturating_sub(before_context);\n            let end = line.saturating_add(after_context);\n            Interval::new(start, end)\n        })\n        .collect()\n}\n\nfn merge_intervals(intervals: Vec<Interval<usize>>) -> Vec<Interval<usize>> {\n    // merge overlapping intervals\n    intervals\n        .into_iter()\n        .coalesce(|p, c| p.merge(&c).map_err(|_| (p, c)))\n        .collect()\n}\n\nfn print_results(\n    intervals: Vec<Interval<usize>>,\n    lines: Vec<String>,\n    line_number: bool,\n) {\n    for interval in intervals {\n        for (line_no, line) in lines\n            .iter()\n            .enumerate()\n            .take(interval.end + 1)\n            .skip(interval.start)\n        {\n            if line_number {\n                print!(\"{}: \", line_no + 1);\n            }\n            println!(\"{}\", line);\n        }\n    }\n}\n\nfn read_file(file: impl Read) -> Vec<String> {\n    BufReader::new(file).lines().map_while(Result::ok).collect()\n}\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// Prefix each line of output with the 1-based line number within its\n    /// input file.\n    #[arg(short, long, default_value_t = false)]\n    line_number: bool,\n\n    /// Print num lines of trailing context before matching lines.\n    #[arg(short, long, default_value_t = 0, value_name = \"num\")]\n    before_context: u8,\n\n    /// Print num lines of trailing context after matching lines.\n    #[arg(short, long, default_value_t = 0, value_name = \"num\")]\n    after_context: u8,\n\n    /// The regular expression to match.\n    #[arg(required = true)]\n    pattern: String,\n\n    /// List of files to search.\n    #[arg(required = true)]\n    files: Vec<PathBuf>,\n}\n\n// Result from a thread\nstruct RustleSuccess {\n    intervals: Vec<Interval<usize>>,\n    lines: Vec<String>,\n}\n\n// Result from a failed thread\nstruct RustleFailure {\n    error: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // get values from clap\n    let pattern = cli.pattern;\n    let line_number = cli.line_number;\n    let before_context = cli.before_context as usize;\n    let after_context = cli.after_context as usize;\n    let files = cli.files;\n\n    // compile the regular expression\n    let regex = match Regex::new(&pattern) {\n        Ok(re) => re, // bind re to regex\n        Err(e) => {\n            eprintln!(\"{e}\"); // write to standard error\n            exit(1);\n        }\n    };\n\n    thread::scope(|s| {\n        let handles: Vec<_> = files\n            .iter()\n            .map(|file| {\n                let filename = match file.to_str() {\n                    Some(filename) => filename,\n                    None => {\n                        return Err(RustleFailure {\n                            error: format!(\n                                \"Invalid filename: {}\",\n                                file.display()\n                            ),\n                        })\n                    }\n                };\n\n                // attempt to open the file\n                File::open(filename).map_err(|e| RustleFailure {\n                    error: format!(\"Error opening {filename}: {e}\"),\n                })\n            })\n            .map_ok(|file| {\n                // only spawn a thread for accessible file\n                s.spawn(|| {\n                    let lines = read_file(file);\n\n                    // store the 0-based line number for any matched line\n                    let match_lines = find_matching_lines(&lines, &regex);\n\n                    // create intervals of the form [a,b] with the before/after\n                    // context\n                    let intervals = match create_intervals(\n                        match_lines,\n                        before_context,\n                        after_context,\n                    ) {\n                        Ok(intervals) => intervals,\n                        Err(_) => return Err(RustleFailure {\n                            error: String::from(\n                                \"An error occurred while creating intervals\",\n                            ),\n                        }),\n                    };\n\n                    // merge overlapping intervals\n                    let intervals = merge_intervals(intervals);\n                    Ok(RustleSuccess { intervals, lines })\n                })\n            })\n            .collect();\n\n        // process all the results\n        for handle in handles {\n            let result = match handle {\n                Ok(scoped_join_handle) => scoped_join_handle,\n                Err(e) => {\n                    eprintln!(\"{}\", e.error);\n                    continue;\n                }\n            };\n\n            if let Ok(result) = result.join() {\n                match result {\n                    Ok(result) => print_results(\n                        result.intervals,\n                        result.lines,\n                        line_number,\n                    ),\n                    Err(e) => eprintln!(\"{}\", e.error),\n                };\n            };\n        }\n    });\n}\n\npub mod interval {\n    /// A list specifying general categories of Interval errors.\n    #[derive(Debug)]\n    pub enum IntervalError {\n        /// Start is not less than or equal to end\n        StartEndRangeInvalid,\n        /// Two intervals to be merged do not overlap\n        NonOverlappingInterval,\n    }\n\n    /// A closed-interval [`start`, `end`] type used for representing a range of\n    /// values between `start` and `end` inclusively.\n    ///\n    /// # Examples\n    ///\n    /// You can create an `Interval` using `new`.\n    ///\n    /// ~~~rs\n    /// let interval = Interval::new(1, 10).unwrap();\n    /// assert_eq!(interval.start, 1);\n    /// assert_eq!(interval.end, 10);\n    /// ~~~\n    #[derive(Debug, PartialEq)]\n    pub struct Interval<T> {\n        pub start: T,\n        pub end: T,\n    }\n\n    impl<T: Copy + PartialOrd> Interval<T> {\n        /// Creates a new `Interval` set to `start` and `end`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let interval = Interval::new(1, 10).unwrap();\n        /// assert_eq!(interval.start, 1);\n        /// assert_eq!(interval.end, 10);\n        /// ~~~\n        pub fn new(start: T, end: T) -> Result<Self, IntervalError> {\n            if start <= end {\n                Ok(Self { start, end })\n            } else {\n                Err(IntervalError::StartEndRangeInvalid)\n            }\n        }\n\n        /// Checks if two intervals overlap. Overlapping intervals have at least\n        /// one point in common.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 5).unwrap();\n        /// let b = Interval::new(2, 4).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(4, 6).unwrap();\n        /// assert_eq!(a.overlaps(&b), false);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        pub fn overlaps(&self, other: &Interval<T>) -> bool {\n            self.end >= other.start\n        }\n\n        /// Merges two intervals returning a new `Interval`.\n        ///\n        /// The merged `Interval` range includes the union of ranges from each\n        /// `Interval`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// let c = a.merge(&b).unwrap();\n        /// assert_eq!(c.start, 1);\n        /// assert_eq!(c.end, 5);\n        /// ~~~\n        pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n            if self.overlaps(other) {\n                Ok(Self {\n                    start: self.start,\n                    end: other.end,\n                })\n            } else {\n                Err(IntervalError::NonOverlappingInterval)\n            }\n        }\n    }\n\n    use std::fmt;\n    impl<T: fmt::Display> fmt::Display for Interval<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"[{}, {}]\", self.start, self.end)\n        }\n    }\n\n    use std::cmp::Ordering;\n    impl<T: PartialEq + PartialOrd> PartialOrd for Interval<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            if self == other {\n                Some(Ordering::Equal)\n            } else if self.end < other.start {\n                Some(Ordering::Less)\n            } else if self.start > other.end {\n                Some(Ordering::Greater)\n            } else {\n                None // Intervals overlap\n            }\n        }\n    }\n}\n```", "```rs\nuse clap::Parser;\nuse interval::{Interval, IntervalError};\nuse itertools::Itertools;\nuse regex::Regex;\nuse std::fs::File;\nuse std::io::Read;\nuse std::io::{BufRead, BufReader};\nuse std::path::PathBuf;\nuse std::process::exit;\nuse std::thread;\n\nfn find_matching_lines(lines: &[String], regex: &Regex) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match regex.is_match(line) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Result<Vec<Interval<usize>>, IntervalError> {\n    lines\n        .iter()\n        .map(|line| {\n            let start = line.saturating_sub(before_context);\n            let end = line.saturating_add(after_context);\n            Interval::new(start, end)\n        })\n        .collect()\n}\n\nfn merge_intervals(intervals: Vec<Interval<usize>>) -> Vec<Interval<usize>> {\n    // merge overlapping intervals\n    intervals\n        .into_iter()\n        .coalesce(|p, c| p.merge(&c).map_err(|_| (p, c)))\n        .collect()\n}\n\nfn print_results(\n    intervals: Vec<Interval<usize>>,\n    lines: Vec<String>,\n    line_number: bool,\n) {\n    for interval in intervals {\n        for (line_no, line) in lines\n            .iter()\n            .enumerate()\n            .take(interval.end + 1)\n            .skip(interval.start)\n        {\n            if line_number {\n                print!(\"{}: \", line_no + 1);\n            }\n            println!(\"{}\", line);\n        }\n    }\n}\n\nfn read_file(file: impl Read) -> Vec<String> {\n    BufReader::new(file).lines().map_while(Result::ok).collect()\n}\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// Prefix each line of output with the 1-based line number within its\n    /// input file.\n    #[arg(short, long, default_value_t = false)]\n    line_number: bool,\n\n    /// Print num lines of trailing context before matching lines.\n    #[arg(short, long, default_value_t = 0, value_name = \"num\")]\n    before_context: u8,\n\n    /// Print num lines of trailing context after matching lines.\n    #[arg(short, long, default_value_t = 0, value_name = \"num\")]\n    after_context: u8,\n\n    /// The regular expression to match.\n    #[arg(required = true)]\n    pattern: String,\n\n    /// List of files to search.\n    #[arg(required = true)]\n    files: Vec<PathBuf>,\n}\n\n// Result from a thread\nstruct RustleSuccess {\n    intervals: Vec<Interval<usize>>,\n    lines: Vec<String>,\n}\n\n// Result from a failed thread\nstruct RustleFailure {\n    error: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // get values from clap\n    let pattern = cli.pattern;\n    let line_number = cli.line_number;\n    let before_context = cli.before_context as usize;\n    let after_context = cli.after_context as usize;\n    let files = cli.files;\n\n    // compile the regular expression\n    let regex = match Regex::new(&pattern) {\n        Ok(re) => re, // bind re to regex\n        Err(e) => {\n            eprintln!(\"{e}\"); // write to standard error\n            exit(1);\n        }\n    };\n\n    // create the mpsc channel\n    let (tx, rx) = channel::<Result<RustleSuccess, RustleFailure>>();\n\n    // create a non-scoped thread for processing incoming messages\n    let handle = thread::spawn(move || {\n        // process all the results\n        while let Ok(result) = rx.recv() {\n            match result {\n                Ok(result) => {\n                    print_results(result.intervals, result.lines, line_number)\n                }\n                Err(e) => eprintln!(\"{}\", e.error),\n            };\n        }\n    });\n\n    thread::scope(|s| {\n        for file in &files {\n            s.spawn(|| {\n                // check if valid filename\n                let filename = match file.to_str() {\n                    Some(filename) => filename,\n                    None => {\n                        return tx.send(Err(RustleFailure {\n                            error: format!(\n                                \"Invalid filename: {}\",\n                                file.display()\n                            ),\n                        }))\n                    }\n                };\n\n                // attempt to open the file\n                let handle = match File::open(filename) {\n                    Ok(handle) => handle,\n                    Err(e) => {\n                        return tx.send(Err(RustleFailure {\n                            error: format!(\"Error opening {filename}: {e}\"),\n                        }))\n                    }\n                };\n\n                // process a file\n                let lines = read_file(handle);\n\n                // store the 0-based line number for any matched line\n                let match_lines = find_matching_lines(&lines, &regex);\n\n                // create intervals of the form [a,b] with the before/after context\n                let intervals =\n                    match create_intervals(\n                        match_lines,\n                        before_context,\n                        after_context,\n                    ) {\n                        Ok(intervals) => intervals,\n                        Err(_) => return tx.send(Err(RustleFailure {\n                            error: String::from(\n                                \"An error occurred while creating intervals\",\n                            ),\n                        })),\n                    };\n\n                // merge overlapping intervals\n                let intervals = merge_intervals(intervals);\n                tx.send(Ok(RustleSuccess { intervals, lines }))\n            });\n        }\n    });\n\n    // drop the last sender to stop rx from waiting for messages\n    drop(tx);\n\n    // prevent main from returning until all results are processed\n    let _ = handle.join();\n}\n\npub mod interval {\n    /// A list specifying general categories of Interval errors.\n    #[derive(Debug)]\n    pub enum IntervalError {\n        /// Start is not less than or equal to end\n        StartEndRangeInvalid,\n        /// Two intervals to be merged do not overlap\n        NonOverlappingInterval,\n    }\n\n    /// A closed-interval [`start`, `end`] type used for representing a range of\n    /// values between `start` and `end` inclusively.\n    ///\n    /// # Examples\n    ///\n    /// You can create an `Interval` using `new`.\n    ///\n    /// ~~~rs\n    /// let interval = Interval::new(1, 10).unwrap();\n    /// assert_eq!(interval.start, 1);\n    /// assert_eq!(interval.end, 10);\n    /// ~~~\n    #[derive(Debug, PartialEq)]\n    pub struct Interval<T> {\n        pub start: T,\n        pub end: T,\n    }\n\n    impl<T: Copy + PartialOrd> Interval<T> {\n        /// Creates a new `Interval` set to `start` and `end`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let interval = Interval::new(1, 10).unwrap();\n        /// assert_eq!(interval.start, 1);\n        /// assert_eq!(interval.end, 10);\n        /// ~~~\n        pub fn new(start: T, end: T) -> Result<Self, IntervalError> {\n            if start <= end {\n                Ok(Self { start, end })\n            } else {\n                Err(IntervalError::StartEndRangeInvalid)\n            }\n        }\n\n        /// Checks if two intervals overlap. Overlapping intervals have at least\n        /// one point in common.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 5).unwrap();\n        /// let b = Interval::new(2, 4).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(4, 6).unwrap();\n        /// assert_eq!(a.overlaps(&b), false);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ~~~\n        pub fn overlaps(&self, other: &Interval<T>) -> bool {\n            self.end >= other.start\n        }\n\n        /// Merges two intervals returning a new `Interval`.\n        ///\n        /// The merged `Interval` range includes the union of ranges from each\n        /// `Interval`.\n        ///\n        /// # Examples\n        ///\n        /// ~~~rs\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// let c = a.merge(&b).unwrap();\n        /// assert_eq!(c.start, 1);\n        /// assert_eq!(c.end, 5);\n        /// ~~~\n        pub fn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n            if self.overlaps(other) {\n                Ok(Self {\n                    start: self.start,\n                    end: other.end,\n                })\n            } else {\n                Err(IntervalError::NonOverlappingInterval)\n            }\n        }\n    }\n\n    use std::fmt;\n    impl<T: fmt::Display> fmt::Display for Interval<T> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"[{}, {}]\", self.start, self.end)\n        }\n    }\n\n    use std::cmp::Ordering;\n    impl<T: PartialEq + PartialOrd> PartialOrd for Interval<T> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            if self == other {\n                Some(Ordering::Equal)\n            } else if self.end < other.start {\n                Some(Ordering::Less)\n            } else if self.start > other.end {\n                Some(Ordering::Greater)\n            } else {\n                None // Intervals overlap\n            }\n        }\n    }\n}\n```"]
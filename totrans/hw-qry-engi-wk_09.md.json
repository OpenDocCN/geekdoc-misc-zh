["```rs\nSELECT name, salary * 1.1 AS new_salary\nFROM employees\nWHERE department = 'Engineering' \n```", "```rs\ninterface LogicalPlan {\n\n  / Returns the schema of the data that will be produced by this logical plan. */\n  fun schema(): Schema\n\n  /\n   * Returns the children (inputs) of this logical plan. This method is used to\n   * enable use of the visitor pattern to walk a query tree.\n   */\n  fun children(): List<LogicalPlan>\n} \n```", "```rs\nfun format(plan: LogicalPlan, indent: Int = 0): String {\n  val b = StringBuilder()\n  0.until(indent).forEach { b.append(\"\\t\") }\n  b.append(plan.toString()).append(\"\\n\")\n  plan.children().forEach { b.append(format(it, indent + 1)) }\n  return b.toString()\n} \n```", "```rs\nProjection: #name, #salary * 1.1 AS new_salary\n  Filter: #department = 'Engineering'\n    Scan: employees; projection=None \n```", "```rs\ninterface LogicalExpr {\n\n  /\n   * Return meta-data about the value that will be produced by this expression\n   * when evaluated against a particular input.\n   */\n  fun toField(input: LogicalPlan): Field\n} \n```", "```rs\nclass Column(val name: String) : LogicalExpr {\n\n  override fun toField(input: LogicalPlan): Field {\n    return input.schema().fields.find { it.name == name }\n        ?: throw SQLException(\"No column named '$name'\")\n  }\n\n  override fun toString(): String {\n    return \"#$name\"\n  }\n} \n```", "```rs\nclass LiteralString(val str: String) : LogicalExpr {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(str, ArrowTypes.StringType)\n  }\n\n  override fun toString(): String {\n    return \"'$str'\"\n  }\n}\n\nclass LiteralLong(val n: Long) : LogicalExpr {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(n.toString(), ArrowTypes.Int64Type)\n  }\n\n  override fun toString(): String {\n    return n.toString()\n  }\n}\n\nclass LiteralDouble(val n: Double) : LogicalExpr {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(n.toString(), ArrowTypes.DoubleType)\n  }\n\n  override fun toString(): String {\n    return n.toString()\n  }\n} \n```", "```rs\nabstract class BinaryExpr(\n    val name: String,\n    val op: String,\n    val l: LogicalExpr,\n    val r: LogicalExpr\n) : LogicalExpr {\n\n  override fun toString(): String {\n    return \"$l $op $r\"\n  }\n} \n```", "```rs\nabstract class BooleanBinaryExpr(\n    name: String,\n    op: String,\n    l: LogicalExpr,\n    r: LogicalExpr\n) : BinaryExpr(name, op, l, r) {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(name, ArrowTypes.BooleanType)\n  }\n}\n\n// Comparisons\nclass Eq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"eq\", \"=\", l, r)\nclass Neq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"neq\", \"!=\", l, r)\nclass Gt(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"gt\", \">\", l, r)\nclass GtEq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"gteq\", \">=\", l, r)\nclass Lt(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"lt\", \"<\", l, r)\nclass LtEq(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"lteq\", \"<=\", l, r)\n\n// Boolean logic\nclass And(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"and\", \"AND\", l, r)\nclass Or(l: LogicalExpr, r: LogicalExpr) : BooleanBinaryExpr(\"or\", \"OR\", l, r) \n```", "```rs\nabstract class MathExpr(\n    name: String,\n    op: String,\n    l: LogicalExpr,\n    r: LogicalExpr\n) : BinaryExpr(name, op, l, r) {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(name, l.toField(input).dataType)\n  }\n}\n\nclass Add(l: LogicalExpr, r: LogicalExpr) : MathExpr(\"add\", \"+\", l, r)\nclass Subtract(l: LogicalExpr, r: LogicalExpr) : MathExpr(\"subtract\", \"-\", l, r)\nclass Multiply(l: LogicalExpr, r: LogicalExpr) : MathExpr(\"mult\", \"*\", l, r)\nclass Divide(l: LogicalExpr, r: LogicalExpr) : MathExpr(\"div\", \"/\", l, r)\nclass Modulus(l: LogicalExpr, r: LogicalExpr) : MathExpr(\"mod\", \"%\", l, r) \n```", "```rs\nabstract class AggregateExpr(\n    val name: String,\n    val expr: LogicalExpr\n) : LogicalExpr {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(name, expr.toField(input).dataType)\n  }\n\n  override fun toString(): String {\n    return \"$name($expr)\"\n  }\n}\n\nclass Sum(input: LogicalExpr) : AggregateExpr(\"SUM\", input)\nclass Min(input: LogicalExpr) : AggregateExpr(\"MIN\", input)\nclass Max(input: LogicalExpr) : AggregateExpr(\"MAX\", input)\nclass Avg(input: LogicalExpr) : AggregateExpr(\"AVG\", input) \n```", "```rs\nclass Count(input: LogicalExpr) : AggregateExpr(\"COUNT\", input) {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(\"COUNT\", ArrowTypes.Int32Type)\n  }\n} \n```", "```rs\nclass Alias(val expr: LogicalExpr, val alias: String) : LogicalExpr {\n\n  override fun toField(input: LogicalPlan): Field {\n    return Field(alias, expr.toField(input).dataType)\n  }\n\n  override fun toString(): String {\n    return \"$expr as $alias\"\n  }\n} \n```", "```rs\nclass Scan(\n    val path: String,\n    val dataSource: DataSource,\n    val projection: List<String>\n) : LogicalPlan {\n\n  val schema = deriveSchema()\n\n  override fun schema(): Schema {\n    return schema\n  }\n\n  private fun deriveSchema(): Schema {\n    val schema = dataSource.schema()\n    if (projection.isEmpty()) {\n      return schema\n    } else {\n      return schema.select(projection)\n    }\n  }\n\n  override fun children(): List<LogicalPlan> {\n    return listOf()\n  }\n\n  override fun toString(): String {\n    return if (projection.isEmpty()) {\n      \"Scan: $path; projection=None\"\n    } else {\n      \"Scan: $path; projection=$projection\"\n    }\n  }\n} \n```", "```rs\nclass Selection(\n    val input: LogicalPlan,\n    val expr: LogicalExpr\n) : LogicalPlan {\n\n  override fun schema(): Schema {\n    return input.schema()  // filtering doesn't change the schema\n  }\n\n  override fun children(): List<LogicalPlan> {\n    return listOf(input)\n  }\n\n  override fun toString(): String {\n    return \"Filter: $expr\"\n  }\n} \n```", "```rs\nclass Projection(\n    val input: LogicalPlan,\n    val expr: List<LogicalExpr>\n) : LogicalPlan {\n\n  override fun schema(): Schema {\n    return Schema(expr.map { it.toField(input) })\n  }\n\n  override fun children(): List<LogicalPlan> {\n    return listOf(input)\n  }\n\n  override fun toString(): String {\n    return \"Projection: ${expr.map { it.toString() }.joinToString(\", \")}\"\n  }\n} \n```", "```rs\nclass Aggregate(\n    val input: LogicalPlan,\n    val groupExpr: List<LogicalExpr>,\n    val aggregateExpr: List<AggregateExpr>\n) : LogicalPlan {\n\n  override fun schema(): Schema {\n    return Schema(\n      groupExpr.map { it.toField(input) } +\n      aggregateExpr.map { it.toField(input) }\n    )\n  }\n\n  override fun children(): List<LogicalPlan> {\n    return listOf(input)\n  }\n\n  override fun toString(): String {\n    return \"Aggregate: groupExpr=$groupExpr, aggregateExpr=$aggregateExpr\"\n  }\n} \n```", "```rs\nclass Join(\n    val left: LogicalPlan,\n    val right: LogicalPlan,\n    val joinType: JoinType,\n    val condition: LogicalExpr\n) : LogicalPlan {\n\n  override fun schema(): Schema {\n    return Schema(left.schema().fields + right.schema().fields)\n  }\n\n  override fun children(): List<LogicalPlan> {\n    return listOf(left, right)\n  }\n\n  override fun toString(): String {\n    return \"Join: type=$joinType, condition=$condition\"\n  }\n}\n\nenum class JoinType {\n  INNER, LEFT, RIGHT, FULL, SEMI, ANTI\n} \n```", "```rs\nSELECT name, salary * 1.1 AS new_salary\nFROM employees\nWHERE department = 'Engineering' \n```", "```rs\nval scan = Scan(\"employees\", employeeDataSource, listOf())\n\nval filter = Selection(\n    scan,\n    Eq(Column(\"department\"), LiteralString(\"Engineering\"))\n)\n\nval project = Projection(\n    filter,\n    listOf(\n        Column(\"name\"),\n        Alias(Multiply(Column(\"salary\"), LiteralDouble(1.1)), \"new_salary\")\n    )\n) \n```", "```rs\nProjection: #name, #salary * 1.1 as new_salary\n  Filter: #department = 'Engineering'\n    Scan: employees; projection=None \n```"]
- en: There Can Be Only One
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/there_can_be_only_one.html](https://freddiehaddad.github.io/fast-track-to-rust/there_can_be_only_one.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Currently, our entire rustle program is contained within the `main` function.
    This approach was chosen to address the challenges of teaching a course in a way
    that introduces important concepts logically and in an easily digestible manner.
    However, the time has come to refactor some of the code from the `main` function
    into separate functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a function to handle the work of finding all the lines
    in the input that contain the specified pattern. Here is the function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code that we''ll transfer into the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here is the revised code with the changes implemented. Review it and run the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    find_matching_lines(lines: Vec<&str>, pattern: &str) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match line.contains(pattern) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect() // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // The return keyword is unnecessary when the returned value is the
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // final expression in a function. In this scenario, the semicolon (;)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // is omitted.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what can be the use of him is more than I can see.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: He is very, very like me from the heels up to the head;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And I see him jump before me, when I jump into my bed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The funniest thing about him is the way he likes to grow -
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not at all like proper children, which is always very slow;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For he sometimes shoots up taller like an india-rubber ball,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And he sometimes gets so little that there's none of him at all.";
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // command line arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let pattern = "all";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let before_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let after_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // convert the poem into lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let lines = Vec::from_iter(poem.lines());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // store the 0-based line number for any matched line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let match_lines = find_matching_lines(lines, pattern);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // create intervals of the form [a,b] with the before/after context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let mut intervals: Vec<_> = match_lines'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_sub(before_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_add(after_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals.dedup_by(|next, prev| {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if prev.1 < next.0 {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'false'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: prev.1 = next.1;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // print the lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (start, end) in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: lines.iter().enumerate().take(end + 1).skip(start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Uh-oh!](#uh-oh)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A minor code change caused an issue with the program. Fortunately, the Rust
    compiler offers helpful information for diagnosing the problem. However, if you''re
    not familiar with Rust''s ownership rules, understanding this error can be challenging.
    Let''s break down the error and understand what went wrong. Here are the key details
    from the error message, cleaned up for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Unpacking the Error](#unpacking-the-error)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copy trait, value moved, value borrowed. What the heck does all this mean?
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy Trait](#copy-trait)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We'll explore [traits](https://doc.rust-lang.org/book/ch10-02-traits.html) in
    more detail later in the course. For now, just know that when a type implements
    the [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait, its
    values are duplicated when assigned to a new variable. This means that after an
    assignment, both the original and the new variable can be used independently.
  prefs: []
  type: TYPE_NORMAL
- en: The `lines` vector we passed to the `find_matching_lines` function does *not*
    implement the [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait.
  prefs: []
  type: TYPE_NORMAL
- en: '[Value Moved](#value-moved)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, variable bindings in Rust follow *move semantics*.^([1](#footnote-1))
    When a value is *moved*, its ownership is transferred to the new variable, rendering
    the original variable invalid and unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `lines` vector does not implement the [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html)
    trait, its value was *moved*, rendering the original value in *main* invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[Value Borrowed](#value-borrowed)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the `lines` variable in `main` becomes invalid due to the *move*, any
    attempt to [*borrow*](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing)
    or reference its value is invalid. This is why the compiler generates the message
    "value borrowed here after move".
  prefs: []
  type: TYPE_NORMAL
- en: Move Semantics
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rust's move semantics play an integral part in ensuring memory safety by detecting
    common memory-related errors, like null pointer dereferencing, buffer overflows,
    and use-after-free, during compile time, thereby preventing them from happening
    at runtime.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptions in Rust. For example, most primitive types implement
    the [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait. [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

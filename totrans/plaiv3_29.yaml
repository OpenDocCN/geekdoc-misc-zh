- en: The Design Space of Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even the simplest conditional exposes us to many variations in language design.
    The intent is that test-expression is evaluated first; if it results in a true
    value then (only) the then-expression is evaluated, else (only) the else-expression
    is evaluated. (We usually refer to these two parts as branches, since the program‚Äôs
    control must take one or the other.) However, even this simple construct results
    in at least three different, mostly independent design decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: What kind of values can the test-expression be? In some languages they must
    be Boolean values (two values, one representing truth and the other falsehood).
    In other languages this expression can evaluate to just about any value, with
    some set‚Äîcolloquially called truthy‚Äîrepresenting truth (i.e., they result in execution
    of the then-expression) while the remaining ones are falsy, meaning they cause
    the else-expression to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initially, it may seem attractive to design a language with several truthy
    and falsy values: after all, this appears to give the programmer more convenience,
    permitting non-Boolean-valued functions and expressions to be used in conditionals.
    However, this can lead to bewildering inconsistencies across languages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Value | JavaScript | Perl | PHP | Python | Ruby |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '| truthy | truthy | truthy | truthy | truthy |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| falsy | falsy | falsy | falsy | truthy |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| falsy | falsy | falsy | falsy | truthy |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| truthy | falsy | falsy | truthy | truthy |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| falsy | truthy | truthy | truthy | truthy |'
  prefs: []
  type: TYPE_TB
- en: '| `nil`, `null`, `None`, undefined | falsy | falsy | falsy | falsy | falsy
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| truthy | truthy | falsy | falsy | truthy |'
  prefs: []
  type: TYPE_TB
- en: '| empty map or object | truthy | falsy | falsy | falsy | truthy |'
  prefs: []
  type: TYPE_TB
- en: 'Of course, it need not be so complex. Scheme, for instance, has only one value
    that is falsy: false itself (written as `#false`). Everyother value is truthy.
    For those who value allowing non-Boolean values in conditionals, this represents
    an elegant trade-off: it means a function need not worry that a type-consistent
    value resulting from a computation might cause a conditional to reverse itself.
    (For instance, if a function returns strings, it need not worry that the empty
    string might be treated differently from every other string.) Note that Ruby,
    which is inspired in part by Scheme, adopted this simple model. Lua, another Scheme-inspired
    language, is also spartan in its falsy values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What kind of terms are the branches? Some languages make a distinction between
    statementsand expressions; in such languages, designers need to decide which of
    these are permitted. In some languages, there are even two syntactic forms of
    conditional to reflect these two choices: e.g., in C, `if`¬†uses statements (and
    does not return any value) while the ‚Äúternary operator‚Äù (`(...?...:...)`) permits
    expressions and returns a value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the branches are expressions and hence allowed to evaluate to values, how
    do the values relate? Many (but not all) languages with static type systems expect
    the two branches to have the same type [[üëâ](PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk)].
    Languages without static type systems usually place no restrictions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Aside: While writing an earlier version of this very chapter, I stumbled on
    a strange bug in the Pyret programming language: all numeric s-expressions parsed
    as `s-num`values except `0`, which parsed as a `s-sym`. Eventually Justin Pombrio
    reported: ‚ÄúIt‚Äôs a silly bug with an `if`in JavaScript that‚Äôs getting `0`¬†and thinking
    it‚Äôs false.‚Äù Seems fitting.'
  prefs: []
  type: TYPE_NORMAL

["```rs\nfn read_file(file: File) -> Vec<String> {\n    todo!(); // see the footnote [^3]\n}\n```", "```rs\nBufReader::new(file).lines().map_while(Result::ok).collect()\n```", "```rs\nfn main() {\n    // command line arguments\n let pattern = \"all\"; let before_context = 1; let after_context = 1;    let filename = \"poem.txt\";\n\n    // attempt to open the file\n    let lines = match File::open(filename) {\n        // convert the poem into lines\n        Ok(file) => read_file(file),\n        Err(e) => {\n            eprintln!(\"Error opening {filename}: {e}\");\n            exit(1);\n        }\n    };\n  // store the 0-based line number for any matched line let match_lines = find_matching_lines(&lines, pattern);   // create intervals of the form [a,b] with the before/after context let mut intervals = create_intervals(match_lines, before_context, after_context);   // merge overlapping intervals merge_intervals(&mut intervals);   // print the lines print_results(intervals, lines); }\n```", "```rs\nfn read_file(file: File) -> Vec<String> {\n    BufReader::new(file).lines().map_while(Result::ok).collect()\n}\n```", "```rs\n    pub enum Result<T, E> {\n       Ok(T),\n       Err(E),\n    }\n\n    impl<T, E> Result<T, E> {\n        pub fn ok(self) -> Option<T> {\n            match self {\n                Ok(x) => Some(x),\n                Err(_) => None,\n            }\n        }\n    }\n    ```", "```rs\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::process::exit;\n  fn find_matching_lines(lines: &[String], pattern: &str) -> Vec<usize> {\n lines .iter() .enumerate() .filter_map(|(i, line)| match line.contains(pattern) { true => Some(i), false => None, }) .collect() // turns anything iterable into a collection }   fn create_intervals(\n lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Vec<(usize, usize)> {\n lines .iter() .map(|line| { ( line.saturating_sub(before_context), line.saturating_add(after_context), ) }) .collect() }   fn merge_intervals(intervals: &mut Vec<(usize, usize)>) {\n // merge overlapping intervals intervals.dedup_by(|next, prev| { if prev.1 < next.0 { false } else { prev.1 = next.1; true } }) }   fn print_results(intervals: Vec<(usize, usize)>, lines: Vec<String>) {\n for (start, end) in intervals { for (line_no, line) in lines.iter().enumerate().take(end + 1).skip(start) { println!(\"{}: {}\", line_no + 1, line) } } } \nfn read_file(file: File) -> Vec<String> {\n    BufReader::new(file).lines().map_while(Result::ok).collect()\n}\n\nfn main() {\n    // command line arguments\n let pattern = \"all\"; let before_context = 1; let after_context = 1;    let filename = \"poem.txt\";\n\n    // attempt to open the file\n    let lines = match File::open(filename) {\n        // convert the poem into lines\n        Ok(file) => read_file(file),\n        Err(e) => {\n            eprintln!(\"Error opening {filename}: {e}\");\n            exit(1);\n        }\n    };\n  // store the 0-based line number for any matched line let match_lines = find_matching_lines(&lines, pattern);   // create intervals of the form [a,b] with the before/after context let mut intervals = create_intervals(match_lines, before_context, after_context);   // merge overlapping intervals merge_intervals(&mut intervals);   // print the lines print_results(intervals, lines); }\n```"]
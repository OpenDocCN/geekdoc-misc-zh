<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Cursor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Cursor</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/cursor.html">https://freddiehaddad.github.io/fast-track-to-rust/cursor.html</a></blockquote>
                        
<p>Our production rustle program now has the capability to access real files.
However, the Rust Playground does not support opening files directly. To ensure
this course remains functional in your web browser, we need to use an in-memory
buffer to simulate a file. This technique of mocking an open file is also
commonly used in unit testing, making it a valuable concept to explore.</p>
<p>The <a href="https://doc.rust-lang.org/std/io/struct.Cursor.html"><code>Cursor</code></a> <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> is used with in-memory buffers to provide <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> or
<a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> functionality. Without digressing too much, the <code>BufReader</code> we are
using works on objects that implement the <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> trait. For now, think of a
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a> as an interface in object-oriented programming languages, with some
differences.</p>
<h2 id="mocking-a-file-with-cursor"><a class="header" href="#mocking-a-file-with-cursor">Mocking a File with Cursor</a></h2>
<p>We only need to make a few changes to our program to utilize <code>Cursor</code>. Let's
start by updating the <code>read_file</code> function to accept any object that implements
the <code>Read</code> trait as an argument.</p>
<pre><code class="language-rust noplayground">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt;</code></pre>
<p>Next, we'll reintroduce our famous poem and use it as our in-memory buffer to
represent our file.</p>
<pre><code class="language-rust noplayground">let poem = "I have a little shadow that goes in and out with me,
            And what can be the use of him is more than I can see.
            He is very, very like me from the heels up to the head;
            And I see him jump before me, when I jump into my bed.

            The funniest thing about him is the way he likes to grow -
            Not at all like proper children, which is always very slow;
            For he sometimes shoots up taller like an india-rubber ball,
            And he sometimes gets so little that there's none of him at all.";

let mock_file = std::io::Cursor::new(poem);</code></pre>
<p>Finally, we comment out the lines that handled opening a file and calling
<code>read_file</code>, and instead, we directly call <code>read_file</code> with <code>mock_file</code>.</p>
<pre><code class="language-rust noplayground">// attempt to open the file
let lines = read_file(mock_file);
//let lines = match File::open(filename) {
//    // convert the poem into lines
//    Ok(file) =&gt; read_file(file),
//    Err(e) =&gt; {
//        eprintln!("Error opening {filename}: {e}");
//        exit(1);
//    }
//};</code></pre>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it All Together</a></h2>
<p>With these changes applied to our rustle program, we can once again utilize the
Rust Playground to extend its functionality and continue learning Rust.</p>
<pre class="playground"><code class="language-rust edition2021">#![allow(unused_imports)]
<span class="boring">use std::fs::File;
</span>use std::io::Read;
<span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], pattern: &amp;str) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match line.contains(pattern) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Vec&lt;(usize, usize)&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            (
</span><span class="boring">                line.saturating_sub(before_context),
</span><span class="boring">                line.saturating_add(after_context),
</span><span class="boring">            )
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: &amp;mut Vec&lt;(usize, usize)&gt;) {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals.dedup_by(|next, prev| {
</span><span class="boring">        if prev.1 &lt; next.0 {
</span><span class="boring">            false
</span><span class="boring">        } else {
</span><span class="boring">            prev.1 = next.1;
</span><span class="boring">            true
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_results(intervals: Vec&lt;(usize, usize)&gt;, lines: Vec&lt;String&gt;) {
</span><span class="boring">    for (start, end) in intervals {
</span><span class="boring">        for (line_no, line) in
</span><span class="boring">            lines.iter().enumerate().take(end + 1).skip(start)
</span><span class="boring">        {
</span><span class="boring">            println!("{}: {}", line_no + 1, line)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

fn main() {
    let poem = "I have a little shadow that goes in and out with me,
            And what can be the use of him is more than I can see.
            He is very, very like me from the heels up to the head;
            And I see him jump before me, when I jump into my bed.

            The funniest thing about him is the way he likes to grow -
            Not at all like proper children, which is always very slow;
            For he sometimes shoots up taller like an india-rubber ball,
            And he sometimes gets so little that there's none of him at all.";

    let mock_file = std::io::Cursor::new(poem);

    // command line arguments
    let pattern = "all";
    let before_context = 1;
    let after_context = 1;

    // attempt to open the file
    let lines = read_file(mock_file);
<span class="boring">    //let lines = match File::open(filename) {
</span><span class="boring">    //    // convert the poem into lines
</span><span class="boring">    //    Ok(file) =&gt; read_file(file),
</span><span class="boring">    //    Err(e) =&gt; {
</span><span class="boring">    //        eprintln!("Error opening {filename}: {e}");
</span><span class="boring">    //        exit(1);
</span><span class="boring">    //    }
</span><span class="boring">    //};
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, pattern);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let mut intervals =
</span><span class="boring">        create_intervals(match_lines, before_context, after_context);
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    merge_intervals(&amp;mut intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span>}</code></pre>
<p>What? You don't believe me! Give it a whirl and see for yourself!</p>
<blockquote>
<p>Since we commented out the file handling code, some previously necessary
imports are now unused. The <code>#![allow(unused_imports)]</code> attribute in Rust
instructs the compiler to permit these unused imports without issuing
warnings. We'll delve deeper into attributes when we discuss custom types and
implement command line argument support.</p>
</blockquote>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>We're ready to add support for regular expressions for pattern matching. We'll
take a brief detour to learn about project management in Rust, which will allow
us to use packages (also known as crates) to add this functionality.</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>A Cursor wraps an in-memory buffer and provides it with a <a href="https://doc.rust-lang.org/std/io/trait.Seek.html"><code>Seek</code></a>
implementation. <a href="#fr-1-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
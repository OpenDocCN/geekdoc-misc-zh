<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>File I/O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>File I/O</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/file_io.html">https://freddiehaddad.github.io/fast-track-to-rust/file_io.html</a></blockquote>
                        
<p>Our rustle program wouldn't be complete without the ability to search text
files. Given the potential for I/O errors, adding this capability now is
convenient as we explore error handling and the <code>Result</code> type. This also
introduces us to additional packages in Rust's standard library.</p>
<blockquote>
<p>Up to this point, we've been able to use string literals in our rustle program
because dynamic memory allocation wasn't needed. However, now that we will be
reading from a file, dynamic memory allocation becomes necessary. The string
slice is no longer sufficient, so we need to utilize the <a href="https://doc.rust-lang.org/rust-by-example/std/str.html"><code>String</code></a> <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> type
in Rust.</p>
</blockquote>
<blockquote>
<p>Storing Data on the Heap</p>
<p>Should you find yourself needing to allocate memory directly on the heap, the
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> type is commonly used. You can find numerous examples on its usage in
the <a href="https://doc.rust-lang.org/book/ch15-01-box.html">documentation on the <code>Box</code> type</a>.</p>
</blockquote>
<p>Let's start by creating a function that reads a file and returns a vector of
strings (<code>Vec&lt;String&gt;</code>) where each string represents a line. Here is the
function signature:<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> <sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup></p>
<pre><code class="language-rust noplayground">fn read_file(file: File) -&gt; Vec&lt;String&gt; {
    todo!(); // see the footnote [^3]
}</code></pre>
<p>This is the code that we'll add to the <code>read_file</code> function:</p>
<pre><code class="language-rust noplayground">BufReader::new(file).lines().map_while(Result::ok).collect()</code></pre>
<p>The <code>read_file</code> function accepts a file handle and utilizes <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a> to
efficiently read the file line by line, storing each line in a vector of strings
(<code>Vec&lt;String&gt;</code>), which it then returns to the caller.</p>
<blockquote>
<p>Many less efficient methods for reading a file and storing the results in a
collection typically involve iterating over each line, converting it to a
string, and then pushing the string into a vector. This approach requires
intermediate memory allocations, which can become costly for large files.
Additionally, each line read from the file potentially involves a system call.
The <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a> uses an internal buffer to read large chunks of data from
the file, minimizing both memory allocations and system calls.</p>
</blockquote>
<p>The modifications to the <code>main</code> function:</p>
<pre><code class="language-rust noplayground">fn main() {
    // command line arguments
<span class="boring">    let pattern = "all";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span>    let filename = "poem.txt";

    // attempt to open the file
    let lines = match File::open(filename) {
        // convert the poem into lines
        Ok(file) =&gt; read_file(file),
        Err(e) =&gt; {
            eprintln!("Error opening {filename}: {e}");
            exit(1);
        }
    };
<span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, pattern);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let mut intervals =
</span><span class="boring">        create_intervals(match_lines, before_context, after_context);
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    merge_intervals(&amp;mut intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span>}</code></pre>
<h2 id="unpacking-the-code"><a class="header" href="#unpacking-the-code">Unpacking the Code</a></h2>
<p>There's a lot going on here, so let's break it down step by step.</p>
<h3 id="read_file"><a class="header" href="#read_file"><code>read_file</code></a></h3>
<pre><code class="language-rust noplayground">fn read_file(file: File) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}</code></pre>
<ol>
<li>
<p><strong><code>BufReader</code></strong>: <code>BufReader::new(file)</code> creates a buffered reader from the
provided <code>File</code>. This helps in efficiently reading the file line by line.</p>
</li>
<li>
<p><strong><code>lines()</code></strong>: The <code>lines()</code> method on <code>BufReader</code> returns an iterator over
the lines in the file. Because reading from a file can file, each line is
wrapped in a <code>Result</code>, which can be either <code>Ok</code> (containing the line) or
<code>Err</code> (containing an error).</p>
</li>
<li>
<p><strong><code>map_while(Result::ok)</code></strong>: The <code>map_while</code> method is used to transform the
iterator. It applies the <code>Result::ok</code> function to each item, which converts
<code>Ok(line)</code> to <code>Some(line)</code> and <code>Err(_)</code> to <code>None</code>. The iteration stops when
the first <code>None</code> is encountered. Here are the relevant parts from the
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">source code</a>, cleaned
up for readability:</p>
<pre><code class="language-rust noplayground">pub enum Result&lt;T, E&gt; {
   Ok(T),
   Err(E),
}

impl&lt;T, E&gt; Result&lt;T, E&gt; {
    pub fn ok(self) -&gt; Option&lt;T&gt; {
        match self {
            Ok(x) =&gt; Some(x),
            Err(_) =&gt; None,
        }
    }
}</code></pre>
<p>This conversion is necessary because the map method requires the closure to
return an <code>Option</code>. Converting <code>Err</code> to <code>None</code> drops the error value and
causes <code>map_while</code> to stop yielding.</p>
</li>
<li>
<p><strong><code>collect()</code></strong>: The <code>collect()</code> method gathers all the <code>Some(line)</code> values
into a <code>Vec&lt;String&gt;</code> that gets returned to the caller.</p>
</li>
</ol>
<h3 id="main"><a class="header" href="#main"><code>main</code></a></h3>
<p>In the <code>main</code> function, we attempt to open a file, which can fail for various
reasons. If the <code>Result</code> is <code>Ok</code>, we call <code>read_file</code> with the file value. Since
we don't need the file handle afterward, borrowing isn't necessary. If an error
occurs while opening the file, we use the <code>eprintln!</code> macro to print the error
to standard error and then exit.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it All Together</a></h2>
<p>Here are the changes with the unrelated parts of the program hidden:</p>
<pre><code class="language-rust noplayground">use std::fs::File;
use std::io::{BufRead, BufReader};
use std::process::exit;
<span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], pattern: &amp;str) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match line.contains(pattern) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Vec&lt;(usize, usize)&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            (
</span><span class="boring">                line.saturating_sub(before_context),
</span><span class="boring">                line.saturating_add(after_context),
</span><span class="boring">            )
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: &amp;mut Vec&lt;(usize, usize)&gt;) {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals.dedup_by(|next, prev| {
</span><span class="boring">        if prev.1 &lt; next.0 {
</span><span class="boring">            false
</span><span class="boring">        } else {
</span><span class="boring">            prev.1 = next.1;
</span><span class="boring">            true
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_results(intervals: Vec&lt;(usize, usize)&gt;, lines: Vec&lt;String&gt;) {
</span><span class="boring">    for (start, end) in intervals {
</span><span class="boring">        for (line_no, line) in
</span><span class="boring">            lines.iter().enumerate().take(end + 1).skip(start)
</span><span class="boring">        {
</span><span class="boring">            println!("{}: {}", line_no + 1, line)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn read_file(file: File) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

fn main() {
    // command line arguments
<span class="boring">    let pattern = "all";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span>    let filename = "poem.txt";

    // attempt to open the file
    let lines = match File::open(filename) {
        // convert the poem into lines
        Ok(file) =&gt; read_file(file),
        Err(e) =&gt; {
            eprintln!("Error opening {filename}: {e}");
            exit(1);
        }
    };
<span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, pattern);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let mut intervals =
</span><span class="boring">        create_intervals(match_lines, before_context, after_context);
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    merge_intervals(&amp;mut intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span>}</code></pre>
<blockquote>
<p>Don't forget, you can reveal the hidden parts by clicking <em>Show hidden lines</em>.</p>
</blockquote>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<ul>
<li>Rust requires acknowledging and handling errors before code compilation,
ensuring robustness.</li>
<li>Errors are categorized into recoverable (e.g., file not found) and
unrecoverable (e.g., out-of-bounds access).</li>
<li>Rust uses <code>Result&lt;T, E&gt;</code> for recoverable errors and <code>panic!</code> for unrecoverable
errors, unlike other languages that use exceptions.</li>
</ul>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>To continue using the Rust Playground, opening an actual file isn't going to
work. Let's see how we can leverage an in-memory buffer to represent an open
file.</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>Strings are implemented as <code>Vec&lt;u8&gt;</code> in Rust. Reference the
<a href="https://doc.rust-lang.org/stable/std/string/index.html">API</a> for details. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Unfortunately, the Rust Playground doesn't support opening files, so you'll
need to run this part of the code on your local machine. <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>Rust offers several useful macros that are handy for developing and
prototyping your program. <a href="https://doc.rust-lang.org/std/macro.todo.html"><code>todo!()</code></a> is one of them, and another is
<a href="https://doc.rust-lang.org/std/macro.unimplemented.html"><code>unimplemented!()</code></a>. <a href="#fr-3-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
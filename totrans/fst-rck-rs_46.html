<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Multithreaded Rustle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Multithreaded Rustle</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/multithreaded_rustle.html">https://freddiehaddad.github.io/fast-track-to-rust/multithreaded_rustle.html</a></blockquote>
                        
<p>With our understanding of scoped vs non-scoped threads, we are now prepared to
correctly update rustle to process each file specified on the command line in a
separate thread.</p>
<p>Here's the updated version of the program with the changes visible.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">use clap::Parser;
</span><span class="boring">use interval::{Interval, IntervalError};
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span>use std::collections::HashMap;
<span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">use std::process::exit;
</span>use std::thread;

fn find_matching_lines(lines: &amp;[String], regex: &amp;Regex) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match regex.is_match(line) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
}
<span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            let start = line.saturating_sub(before_context);
</span><span class="boring">            let end = line.saturating_add(after_context);
</span><span class="boring">            Interval::new(start, end)
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals
</span><span class="boring">        .into_iter()
</span><span class="boring">        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_results(
</span><span class="boring">    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
</span><span class="boring">    lines: Vec&lt;String&gt;,
</span><span class="boring">    line_number: bool,
</span><span class="boring">) {
</span><span class="boring">    for interval in intervals {
</span><span class="boring">        for (line_no, line) in lines
</span><span class="boring">            .iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .take(interval.end + 1)
</span><span class="boring">            .skip(interval.start)
</span><span class="boring">        {
</span><span class="boring">            if line_number {
</span><span class="boring">                print!("{}: ", line_no + 1);
</span><span class="boring">            }
</span><span class="boring">            println!("{}", line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Parser)]
</span><span class="boring">#[command(version, about, long_about = None)]
</span><span class="boring">struct Cli {
</span><span class="boring">    /// Prefix each line of output with the 1-based line number within its
</span><span class="boring">    /// input file.
</span><span class="boring">    #[arg(short, long, default_value_t = false)]
</span><span class="boring">    line_number: bool,
</span><span class="boring">
</span><span class="boring">    /// Print num lines of trailing context before matching lines.
</span><span class="boring">    #[arg(short, long, default_value_t = 0, value_name = "num")]
</span><span class="boring">    before_context: u8,
</span><span class="boring">
</span><span class="boring">    /// Print num lines of trailing context after matching lines.
</span><span class="boring">    #[arg(short, long, default_value_t = 0, value_name = "num")]
</span><span class="boring">    after_context: u8,
</span><span class="boring">
</span><span class="boring">    /// The regular expression to match.
</span><span class="boring">    #[arg(required = true)]
</span><span class="boring">    pattern: String,
</span><span class="boring">
</span><span class="boring">    /// List of files to search.
</span><span class="boring">    #[arg(required = true)]
</span><span class="boring">    files: Vec&lt;PathBuf&gt;,
</span><span class="boring">}
</span>
// Result from a thread
struct RustleSuccess {
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
}

// Result from a failed thread
struct RustleFailure {
    error: String,
}

fn main() {
    // let cli = Cli::parse(); // for production use
    // mock command line arguments
    let cli = match Cli::try_parse_from([
        "rustle", // executable name
        "--line-number",
        "--before-context",
        "1",
        "--after-context",
        "1",
        "(all)|(will)", // pattern
        // file(s)...
        "poem.txt",
        "bad_file.txt", // intention failure
        "scoped_threads.txt",
    ]) {
        Ok(cli) =&gt; cli,
        Err(e) =&gt; {
            eprintln!("Error parsing command line arguments: {e:?}");
            exit(1);
        }
    };

    // map of filename/file contents to simulate opening a file
    let mock_disk = HashMap::from([
        (
            "poem.txt",
            "I have a little shadow that goes in and out with me,
And what can be the use of him is more than I can see.
He is very, very like me from the heels up to the head;
And I see him jump before me, when I jump into my bed.

The funniest thing about him is the way he likes to grow -
Not at all like proper children, which is always very slow;
For he sometimes shoots up taller like an india-rubber ball,
And he sometimes gets so little that there's none of him at all.",
        ),
        (
            "scoped_threads.txt",
            "When we work with scoped threads, the compiler can clearly see,
if the variables we want to use will be available to me.
Because of this visibility, I'm runtime error free!
And issues in my code will be exposed by rustc.
If this sort of safety is provided at native speeds,
there's simply no compelling case to stick with cpp!",
        ),
    ]);

    // get values from clap
<span class="boring">    let pattern = cli.pattern;
</span><span class="boring">    let line_number = cli.line_number;
</span><span class="boring">    let before_context = cli.before_context as usize;
</span><span class="boring">    let after_context = cli.after_context as usize;
</span>    let files = cli.files;
<span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(&amp;pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span>
    thread::scope(|s| {
        let handles: Vec&lt;_&gt; = files
            .iter()
            .map(|file| {
                let filename = match file.to_str() {
                    Some(filename) =&gt; filename,
                    None =&gt; {
                        return Err(RustleFailure {
                            error: format!(
                                "Invalid filename: {}",
                                file.display()
                            ),
                        })
                    }
                };

                // attempt to open the file
                //let lines = match File::open(filename) {
                //    // convert the poem into lines
                //    Ok(file) =&gt; read_file(file),
                //    Err(e) =&gt; {
                //        eprintln!("Error opening {filename}: {e}");
                //        exit(1);
                //    }
                //};

                if !mock_disk.contains_key(filename) {
                    return Err(RustleFailure {
                        error: format!("File not found: {}", filename),
                    });
                }

                Ok(filename)
            })
            .map_ok(|filename| {
                // only spawn a thread for accessible file
                s.spawn(|| {
                    let contents = mock_disk.get(filename).unwrap();
                    let mock_file = std::io::Cursor::new(contents);
                    let lines = read_file(mock_file);

                    // store the 0-based line number for any matched line
                    let match_lines = find_matching_lines(&amp;lines, &amp;regex);

                    // create intervals of the form [a,b] with the before/after
                    // context
                    let intervals = match create_intervals(
                        match_lines,
                        before_context,
                        after_context,
                    ) {
                        Ok(intervals) =&gt; intervals,
                        Err(_) =&gt; return Err(RustleFailure {
                            error: String::from(
                                "An error occurred while creating intervals",
                            ),
                        }),
                    };

                    // merge overlapping intervals
                    let intervals = merge_intervals(intervals);
                    Ok(RustleSuccess { intervals, lines })
                })
            })
            .collect();

        // process all the results
        for handle in handles {
            let result = match handle {
                Ok(scoped_join_handle) =&gt; scoped_join_handle,
                Err(e) =&gt; {
                    eprintln!("{}", e.error);
                    continue;
                }
            };

            if let Ok(result) = result.join() {
                match result {
                    Ok(result) =&gt; print_results(
                        result.intervals,
                        result.lines,
                        line_number,
                    ),
                    Err(e) =&gt; eprintln!("{}", e.error),
                };
            };
        }
    });
}
<span class="boring">
</span><span class="boring">pub mod interval {
</span><span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    #[derive(Debug)]
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    #[derive(Debug, PartialEq)]
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    use std::fmt;
</span><span class="boring">    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">            write!(f, "[{}, {}]", self.start, self.end)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    use std::cmp::Ordering;
</span><span class="boring">    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
</span><span class="boring">        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
</span><span class="boring">            if self == other {
</span><span class="boring">                Some(Ordering::Equal)
</span><span class="boring">            } else if self.end &lt; other.start {
</span><span class="boring">                Some(Ordering::Less)
</span><span class="boring">            } else if self.start &gt; other.end {
</span><span class="boring">                Some(Ordering::Greater)
</span><span class="boring">            } else {
</span><span class="boring">                None // Intervals overlap
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Missing Error Output</p>
<pre><code class="language-console">File not found: bad_file.txt
</code></pre>
<p>The error message for the bad file doesn't appear in the playground output
because standard error output isn't captured.</p>
</blockquote>
<p>Our rustle program is now multithreaded and processes all the input files in
parallel! Let's walk through the code changes.</p>
<h3 id="mock_disk"><a class="header" href="#mock_disk"><code>mock_disk</code></a></h3>
<p>The <code>mock_disk</code> <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> simulates disk access to check if a file exists and
is accessible. The filename serves as the key, while the file's contents are the
value. This approach aids in testing and development, but its use here is solely
for Rust playground compatibility. To ensure the creation of multiple threads, I
added a new poem written by <code>yours truly</code>.</p>
<h3 id="threadscope"><a class="header" href="#threadscope"><code>thread::scope</code></a></h3>
<ol>
<li>Iterate over all files specified on the command line using the <code>map</code> iterator
adapter, which returns a <code>Result</code>. The <code>Ok</code> variant holds the filename if
valid, while the <code>Error</code> holds the error for an invalid filename.</li>
<li>The <code>map_ok</code> iterator adapter processes each <code>Result</code>, calling the provided
closure on any <code>Ok</code> values, allowing us to ignore any invalid filenames. The
provided <code>Scope</code> (<code>s</code>) spawns one thread per file for processing. The closure
returns a <code>Result</code>: <code>Err</code> with an error message in a <code>RustleFailure</code> struct
if processing fails, or <code>Ok</code> with a <code>RustleSuccess</code> struct containing
intervals and lines from the input file if successful.</li>
<li>Use <code>collect</code> to create a vector (<code>Vec</code>) of results from each file iteration,
binding it to <code>handles</code>.</li>
<li>Finally, iterate over the elements in the <code>handles</code> vector using a for loop.
Print any errors to standard error, and pass successful pattern matching
results to the <code>print_results</code> function for output to standard output.</li>
</ol>
<h3 id="find_matching_lines"><a class="header" href="#find_matching_lines"><code>find_matching_lines</code></a></h3>
<p>Since each thread needs access to the <code>regex</code> object, the value is borrowed
instead of moved.</p>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<ul>
<li>Ownership and type systems are powerful tools for managing memory safety and
concurrency issues. By leveraging ownership and type checking, many
concurrency errors in Rust are caught at compile time rather than at runtime.</li>
<li>Unlike non-scoped threads, scoped threads can borrow non-<code>'static</code> data
because the scope ensures all threads are joined before it ends.</li>
</ul>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<p>The fork/join model implemented is suboptimal because it waits for all threads
to finish and join before printing any results. To address this, we can use the
<a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>mpsc</code></a> (multiple producer, single consumer) module, which allows threads to
send results to a central receiver as soon as they are ready. This enables the
program to start outputting results immediately, enhancing its responsiveness
and efficiency. Modify the program to make use of <code>mpsc</code>.</p>
<p><strong>HINT</strong>: The final solution should have a structure similar to:</p>
<pre><code class="language-rust noplayground">fn main() {
    // create the mpsc channel
    let (tx, rx) = channel::&lt;Result&lt;RustleSuccess, RustleFailure&gt;&gt;();

    // create a non-scoped thread for processing incoming messages
    let handle = thread::spawn(move || {
        // process results as they arrive
    });

    // create scoped threads for file processing
    thread::scope(|s| {
        // spawn threads and do work
        // send result to the channel
    });

    // drop the last sender to stop rx from waiting for messages
    drop(tx);

    // prevent main from returning until all results are processed
    let _ = handle.join();
}</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(unused_imports)]
use clap::Parser;
use interval::{Interval, IntervalError};
use itertools::Itertools;
use regex::Regex;
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::process::exit;
use std::thread;

fn find_matching_lines(lines: &amp;[String], regex: &amp;Regex) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match regex.is_match(line) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
}

fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
        .collect()
}

fn print_results(
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
    line_number: bool,
) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            if line_number {
                print!("{}: ", line_no + 1);
            }
            println!("{}", line);
        }
    }
}

fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Prefix each line of output with the 1-based line number within its
    /// input file.
    #[arg(short, long, default_value_t = false)]
    line_number: bool,

    /// Print num lines of trailing context before matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    before_context: u8,

    /// Print num lines of trailing context after matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    after_context: u8,

    /// The regular expression to match.
    #[arg(required = true)]
    pattern: String,

    /// List of files to search.
    #[arg(required = true)]
    files: Vec&lt;PathBuf&gt;,
}

// Result from a thread
struct RustleSuccess {
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
}

// Result from a failed thread
struct RustleFailure {
    error: String,
}

fn main() {
    // let cli = Cli::parse(); // for production use
    // mock command line arguments
    let cli = match Cli::try_parse_from([
        "rustle", // executable name
        "--line-number",
        "--before-context",
        "1",
        "--after-context",
        "1",
        "(all)|(will)", // pattern
        // file(s)...
        "poem.txt",
        "bad_file.txt", // intention failure
        "scoped_threads.txt",
    ]) {
        Ok(cli) =&gt; cli,
        Err(e) =&gt; {
            eprintln!("Error parsing command line arguments: {e:?}");
            exit(1);
        }
    };

    // map of filename/file contents to simulate opening a file
    let mock_disk = HashMap::from([
        (
            "poem.txt",
            "I have a little shadow that goes in and out with me,
And what can be the use of him is more than I can see.
He is very, very like me from the heels up to the head;
And I see him jump before me, when I jump into my bed.

The funniest thing about him is the way he likes to grow -
Not at all like proper children, which is always very slow;
For he sometimes shoots up taller like an india-rubber ball,
And he sometimes gets so little that there's none of him at all.",
        ),
        (
            "scoped_threads.txt",
            "When we work with scoped threads, the compiler can clearly see,
if the variables we want to use will be available to me.
Because of this visibility, I'm runtime error free!
And issues in my code will be exposed by rustc.
If this sort of safety is provided at native speeds,
there's simply no compelling case to stick with cpp!",
        ),
    ]);

    // get values from clap
    let pattern = cli.pattern;
    let line_number = cli.line_number;
    let before_context = cli.before_context as usize;
    let after_context = cli.after_context as usize;
    let files = cli.files;

    // compile the regular expression
    let regex = match Regex::new(&amp;pattern) {
        Ok(re) =&gt; re, // bind re to regex
        Err(e) =&gt; {
            eprintln!("{e}"); // write to standard error
            exit(1);
        }
    };

    thread::scope(|s| {
        let handles: Vec&lt;_&gt; = files
            .iter()
            .map(|file| {
                let filename = match file.to_str() {
                    Some(filename) =&gt; filename,
                    None =&gt; {
                        return Err(RustleFailure {
                            error: format!(
                                "Invalid filename: {}",
                                file.display()
                            ),
                        })
                    }
                };

                // attempt to open the file
                //let lines = match File::open(filename) {
                //    // convert the poem into lines
                //    Ok(file) =&gt; read_file(file),
                //    Err(e) =&gt; {
                //        eprintln!("Error opening {filename}: {e}");
                //        exit(1);
                //    }
                //};

                if !mock_disk.contains_key(filename) {
                    return Err(RustleFailure {
                        error: format!("File not found: {}", filename),
                    });
                }

                Ok(filename)
            })
            .map_ok(|filename| {
                // only spawn a thread for accessible file
                s.spawn(|| {
                    let contents = mock_disk.get(filename).unwrap();
                    let mock_file = std::io::Cursor::new(contents);
                    let lines = read_file(mock_file);

                    // store the 0-based line number for any matched line
                    let match_lines = find_matching_lines(&amp;lines, &amp;regex);

                    // create intervals of the form [a,b] with the before/after
                    // context
                    let intervals = match create_intervals(
                        match_lines,
                        before_context,
                        after_context,
                    ) {
                        Ok(intervals) =&gt; intervals,
                        Err(_) =&gt; return Err(RustleFailure {
                            error: String::from(
                                "An error occurred while creating intervals",
                            ),
                        }),
                    };

                    // merge overlapping intervals
                    let intervals = merge_intervals(intervals);
                    Ok(RustleSuccess { intervals, lines })
                })
            })
            .collect();

        // process all the results
        for handle in handles {
            let result = match handle {
                Ok(scoped_join_handle) =&gt; scoped_join_handle,
                Err(e) =&gt; {
                    eprintln!("{}", e.error);
                    continue;
                }
            };

            if let Ok(result) = result.join() {
                match result {
                    Ok(result) =&gt; print_results(
                        result.intervals,
                        result.lines,
                        line_number,
                    ),
                    Err(e) =&gt; eprintln!("{}", e.error),
                };
            };
        }
    });
}

pub mod interval {
    /// A list specifying general categories of Interval errors.
    #[derive(Debug)]
    pub enum IntervalError {
        /// Start is not less than or equal to end
        StartEndRangeInvalid,
        /// Two intervals to be merged do not overlap
        NonOverlappingInterval,
    }

    /// A closed-interval [`start`, `end`] type used for representing a range of
    /// values between `start` and `end` inclusively.
    ///
    /// # Examples
    ///
    /// You can create an `Interval` using `new`.
    ///
    /// ```rust
    /// let interval = Interval::new(1, 10).unwrap();
    /// assert_eq!(interval.start, 1);
    /// assert_eq!(interval.end, 10);
    /// ```
    #[derive(Debug, PartialEq)]
    pub struct Interval&lt;T&gt; {
        pub start: T,
        pub end: T,
    }

    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
        /// Creates a new `Interval` set to `start` and `end`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let interval = Interval::new(1, 10).unwrap();
        /// assert_eq!(interval.start, 1);
        /// assert_eq!(interval.end, 10);
        /// ```
        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
            if start &lt;= end {
                Ok(Self { start, end })
            } else {
                Err(IntervalError::StartEndRangeInvalid)
            }
        }

        /// Checks if two intervals overlap. Overlapping intervals have at
        /// least one point in common.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 5).unwrap();
        /// let b = Interval::new(2, 4).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(4, 6).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), false);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
            self.end &gt;= other.start
        }

        /// Merges two intervals returning a new `Interval`.
        ///
        /// The merged `Interval` range includes the union of ranges from each
        /// `Interval`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// let c = a.merge(&amp;b).unwrap();
        /// assert_eq!(c.start, 1);
        /// assert_eq!(c.end, 5);
        /// ```
        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
            if self.overlaps(other) {
                Ok(Self {
                    start: self.start,
                    end: other.end,
                })
            } else {
                Err(IntervalError::NonOverlappingInterval)
            }
        }
    }

    use std::fmt;
    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "[{}, {}]", self.start, self.end)
        }
    }

    use std::cmp::Ordering;
    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
            if self == other {
                Some(Ordering::Equal)
            } else if self.end &lt; other.start {
                Some(Ordering::Less)
            } else if self.start &gt; other.end {
                Some(Ordering::Greater)
            } else {
                None // Intervals overlap
            }
        }
    }
}</code></pre></pre>
<details>
<summary>Solution</summary>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">use clap::Parser;
</span><span class="boring">use interval::{Interval, IntervalError};
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">use std::process::exit;
</span>use std::sync::mpsc::channel;
<span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], regex: &amp;Regex) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match regex.is_match(line) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            let start = line.saturating_sub(before_context);
</span><span class="boring">            let end = line.saturating_add(after_context);
</span><span class="boring">            Interval::new(start, end)
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals
</span><span class="boring">        .into_iter()
</span><span class="boring">        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn print_results(
</span><span class="boring">    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
</span><span class="boring">    lines: Vec&lt;String&gt;,
</span><span class="boring">    line_number: bool,
</span><span class="boring">) {
</span><span class="boring">    for interval in intervals {
</span><span class="boring">        for (line_no, line) in lines
</span><span class="boring">            .iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .take(interval.end + 1)
</span><span class="boring">            .skip(interval.start)
</span><span class="boring">        {
</span><span class="boring">            if line_number {
</span><span class="boring">                print!("{}: ", line_no + 1);
</span><span class="boring">            }
</span><span class="boring">            println!("{}", line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Parser)]
</span><span class="boring">#[command(version, about, long_about = None)]
</span><span class="boring">struct Cli {
</span><span class="boring">    /// Prefix each line of output with the 1-based line number within its
</span><span class="boring">    /// input file.
</span><span class="boring">    #[arg(short, long, default_value_t = false)]
</span><span class="boring">    line_number: bool,
</span><span class="boring">
</span><span class="boring">    /// Print num lines of trailing context before matching lines.
</span><span class="boring">    #[arg(short, long, default_value_t = 0, value_name = "num")]
</span><span class="boring">    before_context: u8,
</span><span class="boring">
</span><span class="boring">    /// Print num lines of trailing context after matching lines.
</span><span class="boring">    #[arg(short, long, default_value_t = 0, value_name = "num")]
</span><span class="boring">    after_context: u8,
</span><span class="boring">
</span><span class="boring">    /// The regular expression to match.
</span><span class="boring">    #[arg(required = true)]
</span><span class="boring">    pattern: String,
</span><span class="boring">
</span><span class="boring">    /// List of files to search.
</span><span class="boring">    #[arg(required = true)]
</span><span class="boring">    files: Vec&lt;PathBuf&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Result from a thread
</span><span class="boring">struct RustleSuccess {
</span><span class="boring">    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
</span><span class="boring">    lines: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Result from a failed thread
</span><span class="boring">struct RustleFailure {
</span><span class="boring">    error: String,
</span><span class="boring">}
</span>
fn main() {
<span class="boring">    // let cli = Cli::parse(); // for production use
</span><span class="boring">    // mock command line arguments
</span><span class="boring">    let cli = match Cli::try_parse_from([
</span><span class="boring">        "rustle", // executable name
</span><span class="boring">        "--line-number",
</span><span class="boring">        "--before-context",
</span><span class="boring">        "1",
</span><span class="boring">        "--after-context",
</span><span class="boring">        "1",
</span><span class="boring">        "(all)|(will)", // pattern
</span><span class="boring">        // file(s)...
</span><span class="boring">        "poem.txt",
</span><span class="boring">        "bad_file.txt", // intention failure
</span><span class="boring">        "scoped_threads.txt",
</span><span class="boring">    ]) {
</span><span class="boring">        Ok(cli) =&gt; cli,
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("Error parsing command line arguments: {e:?}");
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // map of filename/file contents to simulate opening a file
</span><span class="boring">    let mock_disk = HashMap::from([
</span><span class="boring">        (
</span><span class="boring">            "poem.txt",
</span><span class="boring">            "I have a little shadow that goes in and out with me,
</span><span class="boring">And what can be the use of him is more than I can see.
</span><span class="boring">He is very, very like me from the heels up to the head;
</span><span class="boring">And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">The funniest thing about him is the way he likes to grow -
</span><span class="boring">Not at all like proper children, which is always very slow;
</span><span class="boring">For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">And he sometimes gets so little that there's none of him at all.",
</span><span class="boring">        ),
</span><span class="boring">        (
</span><span class="boring">            "scoped_threads.txt",
</span><span class="boring">            "When we work with scoped threads, the compiler can clearly see,
</span><span class="boring">if the variables we want to use will be available to me.
</span><span class="boring">Because of this visibility, I'm runtime error free!
</span><span class="boring">And issues in my code will be exposed by rustc.
</span><span class="boring">If this sort of safety is provided at native speeds,
</span><span class="boring">there's simply no compelling case to stick with cpp!",
</span><span class="boring">        ),
</span><span class="boring">    ]);
</span><span class="boring">
</span><span class="boring">    // get values from clap
</span><span class="boring">    let pattern = cli.pattern;
</span><span class="boring">    let line_number = cli.line_number;
</span><span class="boring">    let before_context = cli.before_context as usize;
</span><span class="boring">    let after_context = cli.after_context as usize;
</span><span class="boring">    let files = cli.files;
</span><span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(&amp;pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span>    // create the mpsc channel
    let (tx, rx) = channel::&lt;Result&lt;RustleSuccess, RustleFailure&gt;&gt;();

    // create a non-scoped thread for processing incoming messages
    let handle = thread::spawn(move || {
        // process all the results
        while let Ok(result) = rx.recv() {
            match result {
                Ok(result) =&gt; {
                    print_results(result.intervals, result.lines, line_number)
                }
                Err(e) =&gt; eprintln!("{}", e.error),
            };
        }
    });

    thread::scope(|s| {
        for file in &amp;files {
            s.spawn(|| {
                // check if valid filename
                let filename = match file.to_str() {
                    Some(filename) =&gt; filename,
                    None =&gt; {
                        return tx.send(Err(RustleFailure {
                            error: format!(
                                "Invalid filename: {}",
                                file.display()
                            ),
                        }))
                    }
                };

                // attempt to open the file
<span class="boring">                //let handle = match File::open(filename) {
</span><span class="boring">                //    Ok(handle) =&gt; handle,
</span><span class="boring">                //    Err(e) =&gt; {
</span><span class="boring">                //        return tx.send(Err(RustleFailure {
</span><span class="boring">                //            error: format!("Error opening {filename}: {e}"),
</span><span class="boring">                //        }))
</span><span class="boring">                //    }
</span><span class="boring">                //};
</span>                if !mock_disk.contains_key(filename) {
                    return tx.send(Err(RustleFailure {
                        error: format!("File not found: {}", filename),
                    }));
                }

                // process a file
                let contents = mock_disk.get(filename).unwrap();
                let mock_file = std::io::Cursor::new(contents);
                let lines = read_file(mock_file);

                // store the 0-based line number for any matched line
                let match_lines = find_matching_lines(&amp;lines, &amp;regex);

                // create intervals of the form [a,b] with the before/after context
                let intervals =
                    match create_intervals(
                        match_lines,
                        before_context,
                        after_context,
                    ) {
                        Ok(intervals) =&gt; intervals,
                        Err(_) =&gt; return tx.send(Err(RustleFailure {
                            error: String::from(
                                "An error occurred while creating intervals",
                            ),
                        })),
                    };

                // merge overlapping intervals
                let intervals = merge_intervals(intervals);
                tx.send(Ok(RustleSuccess { intervals, lines }))
            });
        }
    });

    // drop the last sender to stop rx from waiting for messages
    drop(tx);

    // prevent main from returning until all results are processed
    let _ = handle.join();
}
<span class="boring">
</span><span class="boring">pub mod interval {
</span><span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    #[derive(Debug)]
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    #[derive(Debug, PartialEq)]
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at
</span><span class="boring">        /// least one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    use std::fmt;
</span><span class="boring">    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">            write!(f, "[{}, {}]", self.start, self.end)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    use std::cmp::Ordering;
</span><span class="boring">    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
</span><span class="boring">        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
</span><span class="boring">            if self == other {
</span><span class="boring">                Some(Ordering::Equal)
</span><span class="boring">            } else if self.end &lt; other.start {
</span><span class="boring">                Some(Ordering::Less)
</span><span class="boring">            } else if self.start &gt; other.end {
</span><span class="boring">                Some(Ordering::Greater)
</span><span class="boring">            } else {
</span><span class="boring">                None // Intervals overlap
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</details>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>Wrapping things up!</p>

                        
</body>
</html>
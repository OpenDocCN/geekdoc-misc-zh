<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Apache Arrow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Apache Arrow</h1>
<blockquote>原文：<a href="https://howqueryengineswork.com/02-apache-arrow.html">https://howqueryengineswork.com/02-apache-arrow.html</a></blockquote>
                        
<p>Before we start building our query engine, we need to choose how to represent data in memory. This choice affects everything: how we read files, how we pass data between operators, and how fast our computations run. We will use Apache Arrow, which has become the standard for in-memory columnar data.</p>
<h2 id="why-columnar"><a class="header" href="#why-columnar">Why Columnar?</a></h2>
<p>Traditional databases and programming languages typically store data row by row. If you have a table of employees, each employee record sits together in memory:</p>
<pre><code>Row 0: [1, "Alice", "Engineering", 95000]
Row 1: [2, "Bob", "Sales", 87000]
Row 2: [3, "Carol", "Engineering", 102000]
</code></pre>
<p>This layout is intuitive and works well when you need to access entire records. But query engines often process just a few columns at a time. Consider:</p>
<pre><code class="language-sql">SELECT AVG(salary) FROM employees WHERE department = 'Engineering'
</code></pre>
<p>This query only needs the <code>department</code> and <code>salary</code> columns. With row-based storage, we would load entire rows into memory just to access two fields.</p>
<p>Columnar storage flips this around. Each column is stored contiguously:</p>
<pre><code>ids:         [1, 2, 3]
names:       ["Alice", "Bob", "Carol"]
departments: ["Engineering", "Sales", "Engineering"]
salaries:    [95000, 87000, 102000]
</code></pre>
<p>Now reading <code>salary</code> means reading one contiguous block of memory, with no jumping around to skip unwanted fields. This matters enormously for performance:</p>
<ul>
<li>Modern CPUs load memory in cache lines (typically 64 bytes). Columnar data packs more useful values per cache line.</li>
<li>Similar values grouped together compress much better. A column of departments might compress to just a few distinct values.</li>
<li>CPUs can apply the same operation to multiple values simultaneously (Single Instruction, Multiple Data). Columnar layout enables this.</li>
</ul>
<h2 id="what-is-apache-arrow"><a class="header" href="#what-is-apache-arrow">What Is Apache Arrow?</a></h2>
<p>Apache Arrow is a specification for how to represent columnar data in memory, plus libraries implementing that specification in many languages. Think of it as a universal format that different systems can share.</p>
<p>The key insight behind Arrow is that data analytics involves many tools: Python for exploration, Spark for distributed processing, databases for storage, visualization tools for presentation. Traditionally, each tool has its own internal format, so moving data between tools means serializing and deserializing, converting formats repeatedly.</p>
<p>Arrow eliminates this overhead. If your Python code and your Java code both use Arrow format, they can share memory directly. A pointer to Arrow data is meaningful to any Arrow-aware system.</p>
<h2 id="arrow-memory-layout"><a class="header" href="#arrow-memory-layout">Arrow Memory Layout</a></h2>
<p>An Arrow column (called a “vector” or “array”) consists of:</p>
<ol>
<li>A data buffer containing the actual values, packed contiguously</li>
<li>A validity buffer, which is a bitmap indicating which values are null</li>
<li>An optional offset buffer for variable-length types like strings</li>
</ol>
<p>For a column of 32-bit integers <code>[1, null, 3, 4]</code>:</p>
<pre><code>Validity bitmap: [1, 0, 1, 1]  (bit per value: 1=valid, 0=null)
Data buffer:     [1, ?, 3, 4]  (? = undefined, since null)
</code></pre>
<p>For strings, we need offsets because strings vary in length:</p>
<pre><code>Values: ["hello", "world", "!"]

Offsets: [0, 5, 10, 11]  (start position of each string, plus end)
Data:    "helloworld!"   (all strings concatenated)
</code></pre>
<p>To get string at index 1: read from offset[1]=5 to offset[2]=10, giving “world”.</p>
<p>This layout is simple but powerful. Fixed-width types like integers require just one memory access per value. The validity bitmap uses just one bit per value, so checking for nulls is cheap.</p>
<h2 id="record-batches"><a class="header" href="#record-batches">Record Batches</a></h2>
<p>A single column is not very useful on its own. We need multiple columns together. Query engines typically group columns into record batches: a collection of equal-length columns with a schema describing their names and types. KQuery defines its own <code>RecordBatch</code> class for this purpose.</p>
<pre><code>RecordBatch:
  Schema: {id: Int32, name: Utf8, salary: Float64}
  Columns:
    id:     [1, 2, 3]
    name:   ["Alice", "Bob", "Carol"]
    salary: [95000.0, 87000.0, 102000.0]
  Length: 3
</code></pre>
<p>Query engines process data in batches rather than row by row or all at once. Batch processing hits the sweet spot:</p>
<ul>
<li>Small enough to fit in CPU cache</li>
<li>Large enough to amortize per-batch overhead</li>
<li>Enables streaming (process data as it arrives)</li>
</ul>
<p>Typical batch sizes range from 1,000 to 100,000 rows depending on the workload.</p>
<h2 id="schemas-and-types"><a class="header" href="#schemas-and-types">Schemas and Types</a></h2>
<p>Arrow defines a rich type system covering:</p>
<ul>
<li>Integers: Int8, Int16, Int32, Int64 (signed and unsigned)</li>
<li>Floating point: Float32 (single), Float64 (double)</li>
<li>Binary: Variable-length byte arrays</li>
<li>Strings: UTF-8 encoded text</li>
<li>Temporal: Date, Time, Timestamp, Duration, Interval</li>
<li>Nested: List, Struct, Map, Union</li>
</ul>
<p>A schema names and types the columns:</p>
<pre><code>Schema:
  - id: Int32, not nullable
  - name: Utf8, nullable
  - hire_date: Date32, nullable
  - salary: Float64, not nullable
</code></pre>
<p>Having explicit nullability in the schema lets the query engine optimize. If a column cannot be null, we can skip null checks entirely.</p>
<h2 id="language-implementations"><a class="header" href="#language-implementations">Language Implementations</a></h2>
<p>Arrow has official implementations in C++, Java, Python, Rust, Go, JavaScript, C#, Ruby, and more. For this book, we will use the Java implementation.</p>
<p>The Java API provides:</p>
<ul>
<li>FieldVector: Base class for column vectors (IntVector, VarCharVector, etc.)</li>
<li>VectorSchemaRoot: Container for a record batch</li>
<li>ArrowType: Represents data types</li>
<li>Schema/Field: Describes the structure of data</li>
</ul>
<p>Here is a simple example creating an Arrow vector in Java:</p>
<pre><code class="language-java">try (IntVector vector = new IntVector("id", allocator)) {
    vector.allocateNew(3);
    vector.set(0, 1);
    vector.set(1, 2);
    vector.set(2, 3);
    vector.setValueCount(3);
    // vector now contains [1, 2, 3]
}
</code></pre>
<h2 id="why-arrow-for-our-query-engine"><a class="header" href="#why-arrow-for-our-query-engine">Why Arrow for Our Query Engine?</a></h2>
<p>We will use Arrow as the foundation of our query engine for several reasons:</p>
<ol>
<li>It is a standard format, so we can easily read/write Parquet files and integrate with other tools</li>
<li>The Java library is mature and well-tested</li>
<li>The columnar layout enables efficient query processing</li>
<li>Understanding Arrow helps you understand other data systems</li>
</ol>
<p>The next chapter builds our type system on top of Arrow, adding the abstractions our query engine needs.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<p>The <a href="https://arrow.apache.org/docs/format/Columnar.html">Arrow specification</a> describes the memory format in detail. The <a href="https://arrow.apache.org/">Arrow website</a> has documentation for each language implementation.</p>
<p>Arrow also provides protocols for transferring data over networks (Arrow Flight) and file formats (Arrow IPC, Feather), but we will not use those directly in this book. The core value for us is the in-memory columnar format.</p>
<p><em>This book is also available for purchase in ePub, MOBI, and PDF format from <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a></em></p>
<p><strong>Copyright © 2020-2025 Andy Grove. All rights reserved.</strong></p>

                        
</body>
</html>
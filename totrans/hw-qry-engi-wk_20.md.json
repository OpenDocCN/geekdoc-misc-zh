["```rs\n@Test\nfun `gteq longs`() {\n    val schema = Schema(listOf(\n        Field(\"a\", ArrowTypes.Int64Type),\n        Field(\"b\", ArrowTypes.Int64Type)\n    ))\n\n    val a: List<Long> = listOf(111, 222, 333, Long.MIN_VALUE, Long.MAX_VALUE)\n    val b: List<Long> = listOf(111, 333, 222, Long.MAX_VALUE, Long.MIN_VALUE)\n\n    val batch = Fuzzer().createRecordBatch(schema, listOf(a, b))\n\n    val expr = GtEqExpression(ColumnExpression(0), ColumnExpression(1))\n    val result = expr.evaluate(batch)\n\n    assertEquals(a.size, result.size())\n    (0 until result.size()).forEach {\n        assertEquals(a[it] >= b[it], result.getValue(it))\n    }\n} \n```", "```rs\n@Test\nfun `gteq doubles`() {\n    val schema = Schema(listOf(\n        Field(\"a\", ArrowTypes.DoubleType),\n        Field(\"b\", ArrowTypes.DoubleType)\n    ))\n\n    val a: List<Double> = listOf(0.0, 1.0,\n        Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN)\n    val b = a.reversed()\n\n    val batch = Fuzzer().createRecordBatch(schema, listOf(a, b))\n\n    val expr = GtEqExpression(ColumnExpression(0), ColumnExpression(1))\n    val result = expr.evaluate(batch)\n\n    assertEquals(a.size, result.size())\n    (0 until result.size()).forEach {\n        assertEquals(a[it] >= b[it], result.getValue(it))\n    }\n} \n```", "```rs\nfun createRecordBatch(schema: Schema, columns: List<List<Any?>>): RecordBatch {\n    val rowCount = columns[0].size\n\n    val root = VectorSchemaRoot.create(schema.toArrow(), rootAllocator)\n    root.allocateNew()\n\n    (0 until rowCount).forEach { row ->\n        (0 until columns.size).forEach { col ->\n            val v = root.getVector(col)\n            val value = columns[col][row]\n            when (v) {\n                is BitVector -> v.set(row, if (value as Boolean) 1 else 0)\n                is TinyIntVector -> v.set(row, value as Byte)\n                is SmallIntVector -> v.set(row, value as Short)\n                is IntVector -> v.set(row, value as Int)\n                is BigIntVector -> v.set(row, value as Long)\n                is Float4Vector -> v.set(row, value as Float)\n                is Float8Vector -> v.set(row, value as Double)\n                is VarCharVector -> v.set(row, (value as String).toByteArray())\n                else -> throw IllegalStateException()\n            }\n        }\n    }\n    root.rowCount = rowCount\n\n    return RecordBatch(schema, root.fieldVectors.map { ArrowFieldVector(it) })\n} \n```", "```rs\n@Test\nfun `1 + 2 * 3`() {\n    val expr = parse(\"1 + 2 * 3\")\n    val expected = SqlBinaryExpr(\n        SqlLong(1),\n        \"+\",\n        SqlBinaryExpr(SqlLong(2), \"*\", SqlLong(3))\n    )\n    assertEquals(expected, expr)\n}\n\n@Test\nfun `1 * 2 + 3`() {\n    val expr = parse(\"1 * 2 + 3\")\n    val expected = SqlBinaryExpr(\n        SqlBinaryExpr(SqlLong(1), \"*\", SqlLong(2)),\n        \"+\",\n        SqlLong(3)\n    )\n    assertEquals(expected, expr)\n} \n```", "```rs\n@Test\nfun `parse SELECT with WHERE`() {\n    val select = parseSelect(\n        \"SELECT id, first_name, last_name FROM employee WHERE state = 'CO'\"\n    )\n    assertEquals(\n        listOf(\n            SqlIdentifier(\"id\"),\n            SqlIdentifier(\"first_name\"),\n            SqlIdentifier(\"last_name\")\n        ),\n        select.projection\n    )\n    assertEquals(\n        SqlBinaryExpr(SqlIdentifier(\"state\"), \"=\", SqlString(\"CO\")),\n        select.selection\n    )\n    assertEquals(\"employee\", select.tableName)\n}\n\n@Test\nfun `parse SELECT with aggregates`() {\n    val select = parseSelect(\n        \"SELECT state, MAX(salary) FROM employee GROUP BY state\"\n    )\n    assertEquals(\n        listOf(\n            SqlIdentifier(\"state\"),\n            SqlFunction(\"MAX\", listOf(SqlIdentifier(\"salary\")))\n        ),\n        select.projection\n    )\n    assertEquals(listOf(SqlIdentifier(\"state\")), select.groupBy)\n} \n```", "```rs\n@Test\nfun `employees in CO using DataFrame`() {\n    val ctx = ExecutionContext(mapOf())\n\n    val df = ctx.csv(employeeCsv)\n        .filter(col(\"state\") eq lit(\"CO\"))\n        .project(listOf(col(\"id\"), col(\"first_name\"), col(\"last_name\")))\n\n    val batches = ctx.execute(df).asSequence().toList()\n    assertEquals(1, batches.size)\n\n    val batch = batches.first()\n    assertEquals(\"2,Gregg,Langford\\n\" + \"3,John,Travis\\n\", batch.toCSV())\n}\n\n@Test\nfun `employees in CA using SQL`() {\n    val ctx = ExecutionContext(mapOf())\n\n    val employee = ctx.csv(employeeCsv)\n    ctx.register(\"employee\", employee)\n\n    val df = ctx.sql(\n        \"SELECT id, first_name, last_name FROM employee WHERE state = 'CA'\"\n    )\n\n    val batches = ctx.execute(df).asSequence().toList()\n    assertEquals(1, batches.size)\n\n    val batch = batches.first()\n    assertEquals(\"1,Bill,Hopkins\\n\", batch.toCSV())\n} \n```", "```rs\n@Test\nfun `aggregate query`() {\n    val ctx = ExecutionContext(mapOf())\n\n    val df = ctx.csv(employeeCsv)\n        .aggregate(\n            listOf(col(\"state\")),\n            listOf(Max(cast(col(\"salary\"), ArrowType.Int(32, true))))\n        )\n\n    val batches = ctx.execute(df).asSequence().toList()\n    assertEquals(1, batches.size)\n\n    val batch = batches.first()\n    val expected = \"CO,11500\\n\" + \"CA,12000\\n\" + \",11500\\n\"\n    assertEquals(expected, batch.toCSV())\n}\n\n@Test\nfun `inner join using DataFrame`() {\n    val leftSchema = Schema(listOf(\n        Field(\"id\", ArrowTypes.Int32Type),\n        Field(\"name\", ArrowTypes.StringType)\n    ))\n    val rightSchema = Schema(listOf(\n        Field(\"id\", ArrowTypes.Int32Type),\n        Field(\"dept\", ArrowTypes.StringType)\n    ))\n\n    val leftData = Fuzzer().createRecordBatch(\n        leftSchema,\n        listOf(listOf(1, 2, 3), listOf(\"Alice\", \"Bob\", \"Carol\"))\n    )\n    val rightData = Fuzzer().createRecordBatch(\n        rightSchema,\n        listOf(listOf(1, 2, 4), listOf(\"Engineering\", \"Sales\", \"Marketing\"))\n    )\n\n    val leftSource = InMemoryDataSource(leftSchema, listOf(leftData))\n    val rightSource = InMemoryDataSource(rightSchema, listOf(rightData))\n\n    val ctx = ExecutionContext(mapOf())\n\n    val leftDf = DataFrameImpl(Scan(\"left\", leftSource, listOf()))\n    val rightDf = DataFrameImpl(Scan(\"right\", rightSource, listOf()))\n\n    val joinedDf = leftDf.join(rightDf, JoinType.Inner, listOf(\"id\" to \"id\"))\n\n    val batches = ctx.execute(joinedDf).asSequence().toList()\n    assertEquals(1, batches.size)\n\n    val batch = batches.first()\n    assertEquals(2, batch.rowCount())\n    assertEquals(\"1,Alice,Engineering\\n2,Bob,Sales\\n\", batch.toCSV())\n} \n```", "```rs\nfun createExpression(input: DataFrame, depth: Int, maxDepth: Int): LogicalExpr {\n    return if (depth == maxDepth) {\n        // return a leaf node\n        when (rand.nextInt(4)) {\n            0 -> ColumnIndex(rand.nextInt(input.schema().fields.size))\n            1 -> LiteralDouble(rand.nextDouble())\n            2 -> LiteralLong(rand.nextLong())\n            3 -> LiteralString(randomString(rand.nextInt(64)))\n            else -> throw IllegalStateException()\n        }\n    } else {\n        // binary expressions\n        val l = createExpression(input, depth+1, maxDepth)\n        val r = createExpression(input, depth+1, maxDepth)\n        return when (rand.nextInt(8)) {\n            0 -> Eq(l, r)\n            1 -> Neq(l, r)\n            2 -> Lt(l, r)\n            3 -> LtEq(l, r)\n            4 -> Gt(l, r)\n            5 -> GtEq(l, r)\n            6 -> And(l, r)\n            7 -> Or(l, r)\n            else -> throw IllegalStateException()\n        }\n    }\n} \n```", "```rs\nfun createPlan(input: DataFrame,\n               depth: Int,\n               maxDepth: Int,\n               maxExprDepth: Int): DataFrame {\n\n    return if (depth == maxDepth) {\n        input\n    } else {\n        // recursively create an input plan\n        val child = createPlan(input, depth+1, maxDepth, maxExprDepth)\n        // apply a transformation to the plan\n        when (rand.nextInt(2)) {\n            0 -> {\n                val exprCount = 1.rangeTo(rand.nextInt(1, 5))\n                child.project(exprCount.map {\n                    createExpression(child, 0, maxExprDepth)\n                })\n            }\n            1 -> child.filter(createExpression(input, 0, maxExprDepth))\n            else -> throw IllegalStateException()\n        }\n    }\n} \n```", "```rs\nFilter: 'VejBmVBpYp7gHxHIUB6UcGx' OR 0.7762591612853446\n  Filter: 'vHGbOKKqR' <= 0.41876514212913307\n    Filter: 0.9835090312561898 <= 3342229749483308391\n      Filter: -5182478750208008322 < -8012833501302297790\n        Filter: 0.3985688976088563 AND #1\n          Filter: #5 OR 'WkaZ54spnoI4MBtFpQaQgk'\n            Scan: employee.csv; projection=None \n```", "```rs\nclass EnhancedRandom(val rand: Random) {\n\n    fun nextDouble(): Double {\n        return when (rand.nextInt(8)) {\n            0 -> Double.MIN_VALUE\n            1 -> Double.MAX_VALUE\n            2 -> Double.POSITIVE_INFINITY\n            3 -> Double.NEGATIVE_INFINITY\n            4 -> Double.NaN\n            5 -> -0.0\n            6 -> 0.0\n            7 -> rand.nextDouble()\n            else -> throw IllegalStateException()\n        }\n    }\n\n    fun nextLong(): Long {\n        return when (rand.nextInt(5)) {\n            0 -> Long.MIN_VALUE\n            1 -> Long.MAX_VALUE\n            2 -> -0\n            3 -> 0\n            4 -> rand.nextLong()\n            else -> throw IllegalStateException()\n        }\n    }\n} \n```", "```rs\n@Test\nfun `projection pushdown reduces columns read`() {\n    val plan = // build a plan that selects 3 columns from a 10 column table\n\n    val optimized = Optimizer().optimize(plan)\n\n    // Verify the scan only reads the 3 needed columns\n    val scan = findScan(optimized)\n    assertEquals(3, scan.projection.size)\n}\n\n@Test\nfun `optimization preserves query semantics`() {\n    val plan = // build a query plan\n    val optimized = Optimizer().optimize(plan)\n\n    val originalResult = execute(plan)\n    val optimizedResult = execute(optimized)\n\n    assertEquals(originalResult, optimizedResult)\n} \n```"]
- en: File I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/file_io.html](https://freddiehaddad.github.io/fast-track-to-rust/file_io.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Our rustle program wouldn't be complete without the ability to search text files.
    Given the potential for I/O errors, adding this capability now is convenient as
    we explore error handling and the `Result` type. This also introduces us to additional
    packages in Rust's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we've been able to use string literals in our rustle program
    because dynamic memory allocation wasn't needed. However, now that we will be
    reading from a file, dynamic memory allocation becomes necessary. The string slice
    is no longer sufficient, so we need to utilize the [`String`](https://doc.rust-lang.org/rust-by-example/std/str.html)
    ^([1](#footnote-1)) type in Rust.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Storing Data on the Heap
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Should you find yourself needing to allocate memory directly on the heap, the
    [`Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html) type is commonly
    used. You can find numerous examples on its usage in the [documentation on the
    `Box` type](https://doc.rust-lang.org/book/ch15-01-box.html).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's start by creating a function that reads a file and returns a vector of
    strings (`Vec<String>`) where each string represents a line. Here is the function
    signature:^([2](#footnote-2)) ^([3](#footnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code that we''ll add to the `read_file` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `read_file` function accepts a file handle and utilizes [`BufReader`](https://doc.rust-lang.org/std/io/struct.BufReader.html)
    to efficiently read the file line by line, storing each line in a vector of strings
    (`Vec<String>`), which it then returns to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Many less efficient methods for reading a file and storing the results in a
    collection typically involve iterating over each line, converting it to a string,
    and then pushing the string into a vector. This approach requires intermediate
    memory allocations, which can become costly for large files. Additionally, each
    line read from the file potentially involves a system call. The [`BufReader`](https://doc.rust-lang.org/std/io/struct.BufReader.html)
    uses an internal buffer to read large chunks of data from the file, minimizing
    both memory allocations and system calls.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The modifications to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Unpacking the Code](#unpacking-the-code)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot going on here, so let's break it down step by step.
  prefs: []
  type: TYPE_NORMAL
- en: '[`read_file`](#read_file)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**`BufReader`**: `BufReader::new(file)` creates a buffered reader from the
    provided `File`. This helps in efficiently reading the file line by line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`lines()`**: The `lines()` method on `BufReader` returns an iterator over
    the lines in the file. Because reading from a file can file, each line is wrapped
    in a `Result`, which can be either `Ok` (containing the line) or `Err` (containing
    an error).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**`map_while(Result::ok)`**: The `map_while` method is used to transform the
    iterator. It applies the `Result::ok` function to each item, which converts `Ok(line)`
    to `Some(line)` and `Err(_)` to `None`. The iteration stops when the first `None`
    is encountered. Here are the relevant parts from the [source code](https://doc.rust-lang.org/std/result/enum.Result.html),
    cleaned up for readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This conversion is necessary because the map method requires the closure to
    return an `Option`. Converting `Err` to `None` drops the error value and causes
    `map_while` to stop yielding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**`collect()`**: The `collect()` method gathers all the `Some(line)` values
    into a `Vec<String>` that gets returned to the caller.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[`main`](#main)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `main` function, we attempt to open a file, which can fail for various
    reasons. If the `Result` is `Ok`, we call `read_file` with the file value. Since
    we don't need the file handle afterward, borrowing isn't necessary. If an error
    occurs while opening the file, we use the `eprintln!` macro to print the error
    to standard error and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[Putting it All Together](#putting-it-all-together)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the changes with the unrelated parts of the program hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget, you can reveal the hidden parts by clicking *Show hidden lines*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust requires acknowledging and handling errors before code compilation, ensuring
    robustness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors are categorized into recoverable (e.g., file not found) and unrecoverable
    (e.g., out-of-bounds access).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust uses `Result<T, E>` for recoverable errors and `panic!` for unrecoverable
    errors, unlike other languages that use exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To continue using the Rust Playground, opening an actual file isn't going to
    work. Let's see how we can leverage an in-memory buffer to represent an open file.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Strings are implemented as `Vec<u8>` in Rust. Reference the [API](https://doc.rust-lang.org/stable/std/string/index.html)
    for details. [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, the Rust Playground doesn't support opening files, so you'll
    need to run this part of the code on your local machine. [↩](#fr-2-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust offers several useful macros that are handy for developing and prototyping
    your program. [`todo!()`](https://doc.rust-lang.org/std/macro.todo.html) is one
    of them, and another is [`unimplemented!()`](https://doc.rust-lang.org/std/macro.unimplemented.html).
    [↩](#fr-3-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

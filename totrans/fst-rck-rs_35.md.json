["```rs\nenum IntervalError {\n    StartEndRangeInvalid,\n    NonOverlappingInterval,\n}\n```", "```rs\nfn new(start: usize, end: usize) -> Result<Self, IntervalError> {\n    if start <= end {\n        Ok(Self { start, end })\n    } else {\n        Err(IntervalError::StartEndRangeInvalid)\n    }\n}\n```", "```rs\nfn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n    if self.overlaps(other) {\n        Ok(Self {\n            start: self.start,\n            end: other.end,\n        })\n    } else {\n        Err(IntervalError::NonOverlappingInterval)\n    }\n}\n```", "```rs\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Result<Vec<Interval>, IntervalError> {\n    lines\n        .iter()\n        .map(|line| {\n            let start = line.saturating_sub(before_context);\n            let end = line.saturating_add(after_context);\n            Interval::new(start, end)\n        })\n        .collect()\n}\n```", "```rs\nfn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {\n    // merge overlapping intervals\n    intervals\n        .into_iter()\n        .coalesce(|p, c| p.merge(&c).or(Err((p, c))))\n        .collect()\n}\n```", "```rs\n// create intervals of the form [a,b] with the before/after context\nlet intervals =\n    match create_intervals(match_lines, before_context, after_context) {\n        Ok(intervals) => intervals,\n        Err(_) => {\n            eprintln!(\"An error occurred while creating intervals\");\n            exit(1);\n        }\n    };\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n    fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {\n        // merge overlapping intervals\n        intervals\n            .into_iter()\n            .coalesce(|p, c| p.merge(&c).map_err(|_| (p, c)))\n            .collect()\n    }\n    ```", "```rs\n\n```", "```rs\n\n```"]
["```rs\nenum IntervalError {\n    StartEndRangeInvalid,\n    NonOverlappingInterval,\n}\n```", "```rs\nfn new(start: usize, end: usize) -> Result<Self, IntervalError> {\n    if start <= end {\n        Ok(Self { start, end })\n    } else {\n        Err(IntervalError::StartEndRangeInvalid)\n    }\n}\n```", "```rs\nfn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n    if self.overlaps(other) {\n        Ok(Self {\n            start: self.start,\n            end: other.end,\n        })\n    } else {\n        Err(IntervalError::NonOverlappingInterval)\n    }\n}\n```", "```rs\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Result<Vec<Interval>, IntervalError> {\n    lines\n        .iter()\n        .map(|line| {\n            let start = line.saturating_sub(before_context);\n            let end = line.saturating_add(after_context);\n            Interval::new(start, end)\n        })\n        .collect()\n}\n```", "```rs\nfn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {\n    // merge overlapping intervals\n    intervals\n        .into_iter()\n        .coalesce(|p, c| p.merge(&c).or(Err((p, c))))\n        .collect()\n}\n```", "```rs\n// create intervals of the form [a,b] with the before/after context\nlet intervals =\n    match create_intervals(match_lines, before_context, after_context) {\n        Ok(intervals) => intervals,\n        Err(_) => {\n            eprintln!(\"An error occurred while creating intervals\");\n            exit(1);\n        }\n    };\n```", "```rs\n#![allow(unused_imports)] extern crate regex; // this is needed for the playground use itertools::Itertools; use regex::Regex; use std::fs::File; use std::io::Read; use std::io::{BufRead, BufReader}; use std::process::exit;   fn find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {\n lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line) { true => Some(i), false => None, }) .collect() // turns anything iterable into a collection }   fn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Result<Vec<Interval>, IntervalError> {\n    lines\n        .iter()\n        .map(|line| {\n            let start = line.saturating_sub(before_context);\n            let end = line.saturating_add(after_context);\n            Interval::new(start, end)\n        })\n        .collect()\n}\n\nfn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {\n    // merge overlapping intervals\n    intervals\n        .into_iter()\n        .coalesce(|p, c| p.merge(&c).or(Err((p, c))))\n        .collect()\n}\n\nfn print_results(intervals: Vec<Interval>, lines: Vec<String>) {\n for interval in intervals { for (line_no, line) in lines .iter() .enumerate() .take(interval.end + 1) .skip(interval.start) { println!(\"{}: {}\", line_no + 1, line) } } }   fn read_file(file: impl Read) -> Vec<String> {\n BufReader::new(file).lines().map_while(Result::ok).collect() }   fn main() {\n let poem = \"I have a little shadow that goes in and out with me, And what can be the use of him is more than I can see. He is very, very like me from the heels up to the head; And I see him jump before me, when I jump into my bed.   The funniest thing about him is the way he likes to grow - Not at all like proper children, which is always very slow; For he sometimes shoots up taller like an india-rubber ball, And he sometimes gets so little that there's none of him at all.\";   let mock_file = std::io::Cursor::new(poem);   // command line arguments let pattern = \"(all)|(little)\"; let before_context = 1; let after_context = 1;   // attempt to open the file let lines = read_file(mock_file); //let lines = match File::open(filename) { //    // convert the poem into lines //    Ok(file) => read_file(file), //    Err(e) => { //        eprintln!(\"Error opening {filename}: {e}\"); //        exit(1); //    } //};   // compile the regular expression let regex = match Regex::new(pattern) { Ok(re) => re, // bind re to regex Err(e) => { eprintln!(\"{e}\"); // write to standard error exit(1); } };   // store the 0-based line number for any matched line let match_lines = find_matching_lines(&lines, regex);      // create intervals of the form [a,b] with the before/after context\n    let intervals =\n        match create_intervals(match_lines, before_context, after_context) {\n            Ok(intervals) => intervals,\n            Err(_) => {\n                eprintln!(\"An error occurred while creating intervals\");\n                exit(1);\n            }\n        };\n  // merge overlapping intervals let intervals = merge_intervals(intervals);   // print the lines print_results(intervals, lines); }\n\nenum IntervalError {\n    StartEndRangeInvalid,\n    NonOverlappingInterval,\n}\n\nstruct Interval {\n    start: usize,\n    end: usize,\n}\n\nimpl Interval {\n    fn new(start: usize, end: usize) -> Result<Self, IntervalError> {\n        if start <= end {\n            Ok(Self { start, end })\n        } else {\n            Err(IntervalError::StartEndRangeInvalid)\n        }\n    }\n\n    fn overlaps(&self, other: &Interval) -> bool {\n        self.end >= other.start\n    }\n\n    fn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n        if self.overlaps(other) {\n            Ok(Self {\n                start: self.start,\n                end: other.end,\n            })\n        } else {\n            Err(IntervalError::NonOverlappingInterval)\n        }\n    }\n}\n```", "```rs\n    fn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {\n        // merge overlapping intervals\n        intervals\n            .into_iter()\n            .coalesce(|p, c| p.merge(&c).map_err(|_| (p, c)))\n            .collect()\n    }\n    ```", "```rs\n#![allow(unused_imports)]\nextern crate regex; // this is needed for the playground\nuse itertools::Itertools;\nuse regex::Regex;\nuse std::fs::File;\nuse std::io::Read;\nuse std::io::{BufRead, BufReader};\nuse std::process::exit;\n\nfn find_matching_lines(lines: &[String], regex: Regex) -> Vec<usize> {\n    lines\n        .iter()\n        .enumerate()\n        .filter_map(|(i, line)| match regex.is_match(line) {\n            true => Some(i),\n            false => None,\n        })\n        .collect() // turns anything iterable into a collection\n}\n\nfn create_intervals(\n    lines: Vec<usize>,\n    before_context: usize,\n    after_context: usize,\n) -> Result<Vec<Interval>, IntervalError> {\n    lines\n        .iter()\n        .map(|line| {\n            let start = line.saturating_sub(before_context);\n            let end = line.saturating_add(after_context);\n            Interval::new(start, end)\n        })\n        .collect()\n}\n\nfn merge_intervals(intervals: Vec<Interval>) -> Vec<Interval> {\n    // merge overlapping intervals\n    intervals\n        .into_iter()\n        .coalesce(|p, c| p.merge(&c).or(Err((p, c))))\n        .collect()\n}\n\nfn print_results(intervals: Vec<Interval>, lines: Vec<String>) {\n    for interval in intervals {\n        for (line_no, line) in lines\n            .iter()\n            .enumerate()\n            .take(interval.end + 1)\n            .skip(interval.start)\n        {\n            println!(\"{}: {}\", line_no + 1, line)\n        }\n    }\n}\n\nfn read_file(file: impl Read) -> Vec<String> {\n    BufReader::new(file).lines().map_while(Result::ok).collect()\n}\n\nfn main() {\n    let poem = \"I have a little shadow that goes in and out with me,\n                And what can be the use of him is more than I can see.\n                He is very, very like me from the heels up to the head;\n                And I see him jump before me, when I jump into my bed.\n\n                The funniest thing about him is the way he likes to grow -\n                Not at all like proper children, which is always very slow;\n                For he sometimes shoots up taller like an india-rubber ball,\n                And he sometimes gets so little that there's none of him at all.\";\n\n    let mock_file = std::io::Cursor::new(poem);\n\n    // command line arguments\n    let pattern = \"(all)|(little)\";\n    let before_context = 1;\n    let after_context = 1;\n\n    // attempt to open the file\n    let lines = read_file(mock_file);\n    //let lines = match File::open(filename) {\n    //    // convert the poem into lines\n    //    Ok(file) => read_file(file),\n    //    Err(e) => {\n    //        eprintln!(\"Error opening {filename}: {e}\");\n    //        exit(1);\n    //    }\n    //};\n\n    // compile the regular expression\n    let regex = match Regex::new(pattern) {\n        Ok(re) => re, // bind re to regex\n        Err(e) => {\n            eprintln!(\"{e}\"); // write to standard error\n            exit(1);\n        }\n    };\n\n    // store the 0-based line number for any matched line\n    let match_lines = find_matching_lines(&lines, regex);\n\n    // create intervals of the form [a,b] with the before/after context\n    let intervals =\n        match create_intervals(match_lines, before_context, after_context) {\n            Ok(intervals) => intervals,\n            Err(_) => {\n                eprintln!(\"An error occurred while creating intervals\");\n                exit(1);\n            }\n        };\n\n    // merge overlapping intervals\n    let intervals = merge_intervals(intervals);\n\n    // print the lines\n    print_results(intervals, lines);\n}\n\nenum IntervalError {\n    StartEndRangeInvalid,\n    NonOverlappingInterval,\n}\n\nstruct Interval {\n    start: usize,\n    end: usize,\n}\n\nimpl Interval {\n    fn new(start: usize, end: usize) -> Result<Self, IntervalError> {\n        if start <= end {\n            Ok(Self { start, end })\n        } else {\n            Err(IntervalError::StartEndRangeInvalid)\n        }\n    }\n\n    fn overlaps(&self, other: &Interval) -> bool {\n        self.end >= other.start\n    }\n\n    fn merge(&self, other: &Self) -> Result<Self, IntervalError> {\n        if self.overlaps(other) {\n            Ok(Self {\n                start: self.start,\n                end: other.end,\n            })\n        } else {\n            Err(IntervalError::NonOverlappingInterval)\n        }\n    }\n}\n```"]
- en: Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/borrowing.html](https://freddiehaddad.github.io/fast-track-to-rust/borrowing.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the error in the previous section about borrowing a value after it has
    been moved, let's now focus on how to *borrow* a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[References](#references)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall from the section on the [string slice `str`](types.html#string-slice-str)
    that we said it's usually seen in it's *borrowed* form `&str`. The `&` operator^([1](#footnote-1))
    in the prefix position represents a borrow. In `find_matching_lines`, `pattern`
    is *borrowed*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Borrowing `lines`](#borrowing-lines)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `find_matching_lines`, we can *borrow* `lines` by prefixing the parameter's
    type with an `&`, changing it to `&Vec<&str>`, and by prefixing the variable `lines`
    in `main` to `&lines`. After making these changes and re-running the program,
    we can see that it now works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Continuing to Refactor](#continuing-to-refactor)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create another function to handle the creation of our intervals. Here
    is the function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code that we''ll transfer into the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here is the revised code with the changes implemented. Review it and run the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Moving vs Borrowing
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is it possible to *move* `match_lines` without causing an error?
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering heap allocations, what advantages might there be in moving `match_lines`
    instead of *borrowing* it?
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Develop a function named merge_intervals and transfer the specified code from
    main into this function, making any necessary updates. Construct another function
    called print_results and relocate the specified code from main into this function,
    updating it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Create a function named `merge_intervals` and move the specified code from `main`
    into this function, making any necessary updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create another function called `print_results` and move the specified code from
    `main` into this function, updating it as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify `main` to utilize these newly created functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can complete these exercises by updating the most recent version of the
    code provided above.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <details><summary>Solution</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the concepts of ownership and borrowing are relatively straightforward,
    they can be frustrating when learning Rust. Reading through the official documentation
    on [Understanding Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
    will certainly help overcome this challenge. Keep the following points in mind
    as you continue on your journey with Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ownership Rules**'
  prefs: []
  type: TYPE_NORMAL
- en: Each value in Rust has an owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can only be one owner at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the owner goes out of scope, the value is dropped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Borrowing Rules**'
  prefs: []
  type: TYPE_NORMAL
- en: At any given time, you can have either one mutable reference or any number of
    immutable references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References must always be valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our new understanding of ownership and borrowing, let's switch our focus
    to error handling.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `&` operator can have different meanings depending on the context. For example,
    when used an infix operator, it becomes a bitwise AND. [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

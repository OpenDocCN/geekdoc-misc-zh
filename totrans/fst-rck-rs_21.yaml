- en: Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/borrowing.html](https://freddiehaddad.github.io/fast-track-to-rust/borrowing.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the error in the previous section about borrowing a value after it has
    been moved, let's now focus on how to *borrow* a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[References](#references)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall from the section on the [string slice `str`](types.html#string-slice-str)
    that we said it's usually seen in it's *borrowed* form `&str`. The `&` operator^([1](#footnote-1))
    in the prefix position represents a borrow. In `find_matching_lines`, `pattern`
    is *borrowed*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Borrowing `lines`](#borrowing-lines)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `find_matching_lines`, we can *borrow* `lines` by prefixing the parameter's
    type with an `&`, changing it to `&Vec<&str>`, and by prefixing the variable `lines`
    in `main` to `&lines`. After making these changes and re-running the program,
    we can see that it now works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    find_matching_lines(lines: &Vec<&str>, pattern: &str) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match line.contains(pattern) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect() // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what can be the use of him is more than I can see.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: He is very, very like me from the heels up to the head;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And I see him jump before me, when I jump into my bed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The funniest thing about him is the way he likes to grow -
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not at all like proper children, which is always very slow;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For he sometimes shoots up taller like an india-rubber ball,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And he sometimes gets so little that there's none of him at all.";
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // command line arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let pattern = "all";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let before_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let after_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // convert the poem into lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let lines = Vec::from_iter(poem.lines());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // store the 0-based line number for any matched line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let match_lines = find_matching_lines(&lines, pattern);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // create intervals of the form [a,b] with the before/after context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let mut intervals: Vec<_> = match_lines'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_sub(before_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_add(after_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals.dedup_by(|next, prev| {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if prev.1 < next.0 {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'false'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: prev.1 = next.1;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // print the lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (start, end) in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: lines.iter().enumerate().take(end + 1).skip(start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Continuing to Refactor](#continuing-to-refactor)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create another function to handle the creation of our intervals. Here
    is the function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code that we''ll transfer into the new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here is the revised code with the changes implemented. Review it and run the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'use std::iter::FromIterator; // this line addresses a rust playground bug   fn
    find_matching_lines(lines: &Vec<&str>, pattern: &str) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match line.contains(pattern) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect() // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'before_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'after_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Vec<(usize, usize)> {
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_sub(before_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_add(after_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what can be the use of him is more than I can see.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: He is very, very like me from the heels up to the head;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And I see him jump before me, when I jump into my bed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The funniest thing about him is the way he likes to grow -
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not at all like proper children, which is always very slow;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For he sometimes shoots up taller like an india-rubber ball,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And he sometimes gets so little that there's none of him at all.";
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // command line arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let pattern = "all";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let before_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let after_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // convert the poem into lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let lines = Vec::from_iter(poem.lines());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // store the 0-based line number for any matched line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let match_lines = find_matching_lines(&lines, pattern);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // create intervals of the form [a,b] with the before/after context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut intervals =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: create_intervals(match_lines, before_context, after_context);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals.dedup_by(|next, prev| {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if prev.1 < next.0 {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'false'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: prev.1 = next.1;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // print the lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (start, end) in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: lines.iter().enumerate().take(end + 1).skip(start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Moving vs Borrowing
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is it possible to *move* `match_lines` without causing an error?
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering heap allocations, what advantages might there be in moving `match_lines`
    instead of *borrowing* it?
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Develop a function named merge_intervals and transfer the specified code from
    main into this function, making any necessary updates. Construct another function
    called print_results and relocate the specified code from main into this function,
    updating it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Create a function named `merge_intervals` and move the specified code from `main`
    into this function, making any necessary updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create another function called `print_results` and move the specified code from
    `main` into this function, updating it as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify `main` to utilize these newly created functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can complete these exercises by updating the most recent version of the
    code provided above.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <details><summary>Solution</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: use std::iter::FromIterator; // this line addresses a rust playground bug
  prefs: []
  type: TYPE_NORMAL
- en: 'fn find_matching_lines(lines: &Vec<&str>, pattern: &str) -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .filter_map(|(i, line)| match line.contains(pattern) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: true => Some(i),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: false => None,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect() // turns anything iterable into a collection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'before_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'after_context: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Vec<(usize, usize)> {
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|line| {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_sub(before_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line.saturating_add(after_context),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn merge_intervals(intervals: &mut Vec<(usize, usize)>) {'
  prefs: []
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intervals.dedup_by(|next, prev| {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if prev.1 < next.0 {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'false'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: prev.1 = next.1;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_results(intervals: Vec<(usize, usize)>, lines: Vec<&str>) {'
  prefs: []
  type: TYPE_NORMAL
- en: for (start, end) in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: lines.iter().enumerate().take(end + 1).skip(start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'println!("{}: {}", line_no + 1, line)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And what can be the use of him is more than I can see.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: He is very, very like me from the heels up to the head;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And I see him jump before me, when I jump into my bed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The funniest thing about him is the way he likes to grow -
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not at all like proper children, which is always very slow;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For he sometimes shoots up taller like an india-rubber ball,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: And he sometimes gets so little that there's none of him at all.";
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // command line arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let pattern = "all";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let before_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let after_context = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // convert the poem into lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let lines = Vec::from_iter(poem.lines());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // store the 0-based line number for any matched line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let match_lines = find_matching_lines(&lines, pattern);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // create intervals of the form [a,b] with the before/after context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut intervals =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: create_intervals(match_lines, before_context, after_context);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // merge overlapping intervals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: merge_intervals(&mut intervals);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // print the lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_results(intervals, lines);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the concepts of ownership and borrowing are relatively straightforward,
    they can be frustrating when learning Rust. Reading through the official documentation
    on [Understanding Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
    will certainly help overcome this challenge. Keep the following points in mind
    as you continue on your journey with Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ownership Rules**'
  prefs: []
  type: TYPE_NORMAL
- en: Each value in Rust has an owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can only be one owner at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the owner goes out of scope, the value is dropped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Borrowing Rules**'
  prefs: []
  type: TYPE_NORMAL
- en: At any given time, you can have either one mutable reference or any number of
    immutable references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References must always be valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our new understanding of ownership and borrowing, let's switch our focus
    to error handling.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `&` operator can have different meanings depending on the context. For example,
    when used an infix operator, it becomes a bitwise AND. [↩](#fr-1-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

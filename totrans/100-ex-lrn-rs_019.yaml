- en: Encapsulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/05_encapsulation.html](https://rust-exercises.com/100-exercises/03_ticket_v1/05_encapsulation.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/05_encapsulation.html](https://rust-exercises.com/100-exercises/03_ticket_v1/05_encapsulation.html)
- en: Now that we have a basic understanding of modules and visibility, let's circle
    back to **encapsulation**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对模块和可见性有了基本理解，让我们回到**封装**。
- en: Encapsulation is the practice of hiding the internal representation of an object.
    It is most commonly used to enforce some **invariants** on the object's state.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是将对象的内部表示隐藏起来的实践。它最常用于强制执行对象状态的一些**不变性**。
- en: 'Going back to our `Ticket` struct:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `Ticket` 结构体：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If all fields are made public, there is no encapsulation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有字段都是公开的，就没有封装。
- en: You must assume that the fields can be modified at any time, set to any value
    that's allowed by their type. You can't rule out that a ticket might have an empty
    title or a status that doesn't make sense.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须假设字段可以在任何时候被修改，设置为它们类型允许的任何值。你不能排除票可能有一个空标题或状态不合理的情况。
- en: To enforce stricter rules, we must keep the fields private^([1](#footnote-newtype)).
    We can then provide public methods to interact with a `Ticket` instance. Those
    public methods will have the responsibility of upholding our invariants (e.g.
    a title must not be empty).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制执行更严格的规则，我们必须保持字段私有^([1](#footnote-newtype))。然后我们可以提供公共方法来与 `Ticket` 实例交互。这些公共方法将负责维护我们的不变性（例如，标题不能为空）。
- en: 'If at least one field is private it is no longer possible to create a `Ticket`
    instance directly using the struct instantiation syntax:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个字段是私有的，就不再可能直接使用结构体实例化语法创建 `Ticket` 实例：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You've seen this in action in the previous exercise on visibility.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你在之前的可见性练习中已经看到了这个操作。
- en: We now need to provide one or more public **constructors**—i.e. static methods
    or functions that can be used from outside the module to create a new instance
    of the struct.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要提供一个或多个公共**构造函数**——即可以从模块外部使用的静态方法或函数，用于创建结构体的新实例。
- en: 'Luckily enough we already have one: `Ticket::new`, as implemented in [a previous
    exercise](/100-exercises/03_ticket_v1/02_validation).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经有了一个：`Ticket::new`，如在前一个练习中实现的那样[一个之前的练习](/100-exercises/03_ticket_v1/02_validation)。
- en: '[Accessor methods](#accessor-methods)'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[访问器方法](#accessor-methods)'
- en: 'In summary:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说：
- en: All `Ticket` fields are private
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 `Ticket` 字段都是私有的
- en: We provide a public constructor, `Ticket::new`, that enforces our validation
    rules on creation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提供了一个公共构造函数，`Ticket::new`，在创建时强制执行我们的验证规则
- en: 'That''s a good start, but it''s not enough: apart from creating a `Ticket`,
    we also need to interact with it. But how can we access the fields if they''re
    private?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的开始，但还不够：除了创建 `Ticket`，我们还需要与之交互。但如果字段是私有的，我们如何访问它们？
- en: We need to provide **accessor methods**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供**访问器方法**。
- en: Accessor methods are public methods that allow you to read the value of a private
    field (or fields) of a struct.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器方法是允许你读取结构体（或多个字段）的私有字段值的公共方法。
- en: Rust doesn't have a built-in way to generate accessor methods for you, like
    some other languages do. You have to write them yourself—they're just regular
    methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有内置的方式为你生成访问器方法，就像一些其他语言所做的那样。你必须自己编写它们——它们只是普通的方法。
- en: '[Exercise](#exercise)'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`03_ticket_v1/05_encapsulation`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/05_encapsulation)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于[`03_ticket_v1/05_encapsulation`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/05_encapsulation)
- en: '* * *'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Or refine their type, a technique we'll explore [later on](/100-exercises/05_ticket_v2/15_outro).
    [↩](#fr-newtype-1)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者改进它们的类型，这是一种我们将在[稍后](/100-exercises/05_ticket_v2/15_outro)探讨的技术。[↩](#fr-newtype-1)

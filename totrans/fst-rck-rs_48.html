<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Rustle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rustle</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/rustle.html">https://freddiehaddad.github.io/fast-track-to-rust/rustle.html</a></blockquote>
                        
<p>As we reach the end of this journey, I am pleased to present the final version
of the rustle program, ready for production use. To compile a release version,
be sure to use <code>cargo build --release</code>. I hope you have enjoyed this journey as
much as I have enjoyed guiding you through it. Thank you very much for
completing the course. Have fun on your Rust journey!</p>
<h2 id="forkjoin-solution"><a class="header" href="#forkjoin-solution">Fork/Join Solution</a></h2>
<pre><code class="language-rust noplayground">use clap::Parser;
use interval::{Interval, IntervalError};
use itertools::Itertools;
use regex::Regex;
use std::fs::File;
use std::io::Read;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::process::exit;
use std::thread;

fn find_matching_lines(lines: &amp;[String], regex: &amp;Regex) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match regex.is_match(line) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
}

fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
        .collect()
}

fn print_results(
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
    line_number: bool,
) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            if line_number {
                print!("{}: ", line_no + 1);
            }
            println!("{}", line);
        }
    }
}

fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Prefix each line of output with the 1-based line number within its
    /// input file.
    #[arg(short, long, default_value_t = false)]
    line_number: bool,

    /// Print num lines of trailing context before matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    before_context: u8,

    /// Print num lines of trailing context after matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    after_context: u8,

    /// The regular expression to match.
    #[arg(required = true)]
    pattern: String,

    /// List of files to search.
    #[arg(required = true)]
    files: Vec&lt;PathBuf&gt;,
}

// Result from a thread
struct RustleSuccess {
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
}

// Result from a failed thread
struct RustleFailure {
    error: String,
}

fn main() {
    let cli = Cli::parse();

    // get values from clap
    let pattern = cli.pattern;
    let line_number = cli.line_number;
    let before_context = cli.before_context as usize;
    let after_context = cli.after_context as usize;
    let files = cli.files;

    // compile the regular expression
    let regex = match Regex::new(&amp;pattern) {
        Ok(re) =&gt; re, // bind re to regex
        Err(e) =&gt; {
            eprintln!("{e}"); // write to standard error
            exit(1);
        }
    };

    thread::scope(|s| {
        let handles: Vec&lt;_&gt; = files
            .iter()
            .map(|file| {
                let filename = match file.to_str() {
                    Some(filename) =&gt; filename,
                    None =&gt; {
                        return Err(RustleFailure {
                            error: format!(
                                "Invalid filename: {}",
                                file.display()
                            ),
                        })
                    }
                };

                // attempt to open the file
                File::open(filename).map_err(|e| RustleFailure {
                    error: format!("Error opening {filename}: {e}"),
                })
            })
            .map_ok(|file| {
                // only spawn a thread for accessible file
                s.spawn(|| {
                    let lines = read_file(file);

                    // store the 0-based line number for any matched line
                    let match_lines = find_matching_lines(&amp;lines, &amp;regex);

                    // create intervals of the form [a,b] with the before/after
                    // context
                    let intervals = match create_intervals(
                        match_lines,
                        before_context,
                        after_context,
                    ) {
                        Ok(intervals) =&gt; intervals,
                        Err(_) =&gt; return Err(RustleFailure {
                            error: String::from(
                                "An error occurred while creating intervals",
                            ),
                        }),
                    };

                    // merge overlapping intervals
                    let intervals = merge_intervals(intervals);
                    Ok(RustleSuccess { intervals, lines })
                })
            })
            .collect();

        // process all the results
        for handle in handles {
            let result = match handle {
                Ok(scoped_join_handle) =&gt; scoped_join_handle,
                Err(e) =&gt; {
                    eprintln!("{}", e.error);
                    continue;
                }
            };

            if let Ok(result) = result.join() {
                match result {
                    Ok(result) =&gt; print_results(
                        result.intervals,
                        result.lines,
                        line_number,
                    ),
                    Err(e) =&gt; eprintln!("{}", e.error),
                };
            };
        }
    });
}

pub mod interval {
    /// A list specifying general categories of Interval errors.
    #[derive(Debug)]
    pub enum IntervalError {
        /// Start is not less than or equal to end
        StartEndRangeInvalid,
        /// Two intervals to be merged do not overlap
        NonOverlappingInterval,
    }

    /// A closed-interval [`start`, `end`] type used for representing a range of
    /// values between `start` and `end` inclusively.
    ///
    /// # Examples
    ///
    /// You can create an `Interval` using `new`.
    ///
    /// ```rust
    /// let interval = Interval::new(1, 10).unwrap();
    /// assert_eq!(interval.start, 1);
    /// assert_eq!(interval.end, 10);
    /// ```
    #[derive(Debug, PartialEq)]
    pub struct Interval&lt;T&gt; {
        pub start: T,
        pub end: T,
    }

    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
        /// Creates a new `Interval` set to `start` and `end`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let interval = Interval::new(1, 10).unwrap();
        /// assert_eq!(interval.start, 1);
        /// assert_eq!(interval.end, 10);
        /// ```
        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
            if start &lt;= end {
                Ok(Self { start, end })
            } else {
                Err(IntervalError::StartEndRangeInvalid)
            }
        }

        /// Checks if two intervals overlap. Overlapping intervals have at least
        /// one point in common.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 5).unwrap();
        /// let b = Interval::new(2, 4).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(4, 6).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), false);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
            self.end &gt;= other.start
        }

        /// Merges two intervals returning a new `Interval`.
        ///
        /// The merged `Interval` range includes the union of ranges from each
        /// `Interval`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// let c = a.merge(&amp;b).unwrap();
        /// assert_eq!(c.start, 1);
        /// assert_eq!(c.end, 5);
        /// ```
        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
            if self.overlaps(other) {
                Ok(Self {
                    start: self.start,
                    end: other.end,
                })
            } else {
                Err(IntervalError::NonOverlappingInterval)
            }
        }
    }

    use std::fmt;
    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "[{}, {}]", self.start, self.end)
        }
    }

    use std::cmp::Ordering;
    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
            if self == other {
                Some(Ordering::Equal)
            } else if self.end &lt; other.start {
                Some(Ordering::Less)
            } else if self.start &gt; other.end {
                Some(Ordering::Greater)
            } else {
                None // Intervals overlap
            }
        }
    }
}</code></pre>
<h2 id="mpsc-solution"><a class="header" href="#mpsc-solution">MPSC Solution</a></h2>
<pre><code class="language-rust noplayground">use clap::Parser;
use interval::{Interval, IntervalError};
use itertools::Itertools;
use regex::Regex;
use std::fs::File;
use std::io::Read;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::process::exit;
use std::thread;

fn find_matching_lines(lines: &amp;[String], regex: &amp;Regex) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match regex.is_match(line) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
}

fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
        .collect()
}

fn print_results(
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
    line_number: bool,
) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            if line_number {
                print!("{}: ", line_no + 1);
            }
            println!("{}", line);
        }
    }
}

fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Prefix each line of output with the 1-based line number within its
    /// input file.
    #[arg(short, long, default_value_t = false)]
    line_number: bool,

    /// Print num lines of trailing context before matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    before_context: u8,

    /// Print num lines of trailing context after matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    after_context: u8,

    /// The regular expression to match.
    #[arg(required = true)]
    pattern: String,

    /// List of files to search.
    #[arg(required = true)]
    files: Vec&lt;PathBuf&gt;,
}

// Result from a thread
struct RustleSuccess {
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
}

// Result from a failed thread
struct RustleFailure {
    error: String,
}

fn main() {
    let cli = Cli::parse();

    // get values from clap
    let pattern = cli.pattern;
    let line_number = cli.line_number;
    let before_context = cli.before_context as usize;
    let after_context = cli.after_context as usize;
    let files = cli.files;

    // compile the regular expression
    let regex = match Regex::new(&amp;pattern) {
        Ok(re) =&gt; re, // bind re to regex
        Err(e) =&gt; {
            eprintln!("{e}"); // write to standard error
            exit(1);
        }
    };

    // create the mpsc channel
    let (tx, rx) = channel::&lt;Result&lt;RustleSuccess, RustleFailure&gt;&gt;();

    // create a non-scoped thread for processing incoming messages
    let handle = thread::spawn(move || {
        // process all the results
        while let Ok(result) = rx.recv() {
            match result {
                Ok(result) =&gt; {
                    print_results(result.intervals, result.lines, line_number)
                }
                Err(e) =&gt; eprintln!("{}", e.error),
            };
        }
    });

    thread::scope(|s| {
        for file in &amp;files {
            s.spawn(|| {
                // check if valid filename
                let filename = match file.to_str() {
                    Some(filename) =&gt; filename,
                    None =&gt; {
                        return tx.send(Err(RustleFailure {
                            error: format!(
                                "Invalid filename: {}",
                                file.display()
                            ),
                        }))
                    }
                };

                // attempt to open the file
                let handle = match File::open(filename) {
                    Ok(handle) =&gt; handle,
                    Err(e) =&gt; {
                        return tx.send(Err(RustleFailure {
                            error: format!("Error opening {filename}: {e}"),
                        }))
                    }
                };

                // process a file
                let lines = read_file(handle);

                // store the 0-based line number for any matched line
                let match_lines = find_matching_lines(&amp;lines, &amp;regex);

                // create intervals of the form [a,b] with the before/after context
                let intervals =
                    match create_intervals(
                        match_lines,
                        before_context,
                        after_context,
                    ) {
                        Ok(intervals) =&gt; intervals,
                        Err(_) =&gt; return tx.send(Err(RustleFailure {
                            error: String::from(
                                "An error occurred while creating intervals",
                            ),
                        })),
                    };

                // merge overlapping intervals
                let intervals = merge_intervals(intervals);
                tx.send(Ok(RustleSuccess { intervals, lines }))
            });
        }
    });

    // drop the last sender to stop rx from waiting for messages
    drop(tx);

    // prevent main from returning until all results are processed
    let _ = handle.join();
}

pub mod interval {
    /// A list specifying general categories of Interval errors.
    #[derive(Debug)]
    pub enum IntervalError {
        /// Start is not less than or equal to end
        StartEndRangeInvalid,
        /// Two intervals to be merged do not overlap
        NonOverlappingInterval,
    }

    /// A closed-interval [`start`, `end`] type used for representing a range of
    /// values between `start` and `end` inclusively.
    ///
    /// # Examples
    ///
    /// You can create an `Interval` using `new`.
    ///
    /// ```rust
    /// let interval = Interval::new(1, 10).unwrap();
    /// assert_eq!(interval.start, 1);
    /// assert_eq!(interval.end, 10);
    /// ```
    #[derive(Debug, PartialEq)]
    pub struct Interval&lt;T&gt; {
        pub start: T,
        pub end: T,
    }

    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
        /// Creates a new `Interval` set to `start` and `end`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let interval = Interval::new(1, 10).unwrap();
        /// assert_eq!(interval.start, 1);
        /// assert_eq!(interval.end, 10);
        /// ```
        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
            if start &lt;= end {
                Ok(Self { start, end })
            } else {
                Err(IntervalError::StartEndRangeInvalid)
            }
        }

        /// Checks if two intervals overlap. Overlapping intervals have at least
        /// one point in common.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 5).unwrap();
        /// let b = Interval::new(2, 4).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), true);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(4, 6).unwrap();
        /// assert_eq!(a.overlaps(&amp;b), false);
        /// assert_eq!(b.overlaps(&amp;a), true);
        /// ```
        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
            self.end &gt;= other.start
        }

        /// Merges two intervals returning a new `Interval`.
        ///
        /// The merged `Interval` range includes the union of ranges from each
        /// `Interval`.
        ///
        /// # Examples
        ///
        /// ```rust
        /// let a = Interval::new(1, 3).unwrap();
        /// let b = Interval::new(3, 5).unwrap();
        /// let c = a.merge(&amp;b).unwrap();
        /// assert_eq!(c.start, 1);
        /// assert_eq!(c.end, 5);
        /// ```
        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
            if self.overlaps(other) {
                Ok(Self {
                    start: self.start,
                    end: other.end,
                })
            } else {
                Err(IntervalError::NonOverlappingInterval)
            }
        }
    }

    use std::fmt;
    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "[{}, {}]", self.start, self.end)
        }
    }

    use std::cmp::Ordering;
    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
            if self == other {
                Some(Ordering::Equal)
            } else if self.end &lt; other.start {
                Some(Ordering::Less)
            } else if self.start &gt; other.end {
                Some(Ordering::Greater)
            } else {
                None // Intervals overlap
            }
        }
    }
}</code></pre>
<blockquote>
<p>You can find both versions of the rustle program we built together during this
course <a href="https://github.com/freddiehaddad/rustle">here</a>.</p>
</blockquote>

                        
</body>
</html>
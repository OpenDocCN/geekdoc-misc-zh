["```rs\n\n```", "```rsrust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ```", "```rsrust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ```", "```rsrust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ```", "```rsrust /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2, 4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ```", "```rsrust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4, 6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a), true); /// ```", "```rsrust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); /// assert_eq!(c.end, 5); /// ```", "```rs\n\n```", "```rs\n> File not found: bad_file.txt \n> ```", "```rs\nfn main() {\n    // create the mpsc channel\n    let (tx, rx) = channel::<Result<RustleSuccess, RustleFailure>>();\n\n    // create a non-scoped thread for processing incoming messages\n    let handle = thread::spawn(move || {\n        // process results as they arrive\n    });\n\n    // create scoped threads for file processing\n    thread::scope(|s| {\n        // spawn threads and do work\n        // send result to the channel\n    });\n\n    // drop the last sender to stop rx from waiting for messages\n    drop(tx);\n\n    // prevent main from returning until all results are processed\n    let _ = handle.join();\n}\n```", "```rs\n\n```", "```rsrust\n    /// let interval = Interval::new(1, 10).unwrap();\n    /// assert_eq!(interval.start, 1);\n    /// assert_eq!(interval.end, 10);\n    /// ```", "```rsrust\n        /// let interval = Interval::new(1, 10).unwrap();\n        /// assert_eq!(interval.start, 1);\n        /// assert_eq!(interval.end, 10);\n        /// ```", "```rsrust\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ```", "```rsrust\n        /// let a = Interval::new(1, 5).unwrap();\n        /// let b = Interval::new(2, 4).unwrap();\n        /// assert_eq!(a.overlaps(&b), true);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ```", "```rsrust\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(4, 6).unwrap();\n        /// assert_eq!(a.overlaps(&b), false);\n        /// assert_eq!(b.overlaps(&a), true);\n        /// ```", "```rsrust\n        /// let a = Interval::new(1, 3).unwrap();\n        /// let b = Interval::new(3, 5).unwrap();\n        /// let c = a.merge(&b).unwrap();\n        /// assert_eq!(c.start, 1);\n        /// assert_eq!(c.end, 5);\n        /// ```", "```rs\n\n```", "```rs\n\n```", "```rsrust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ```", "```rsrust /// let interval = Interval::new(1, 10).unwrap(); /// assert_eq!(interval.start, 1); /// assert_eq!(interval.end, 10); /// ```", "```rsrust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ```", "```rsrust /// let a = Interval::new(1, 5).unwrap(); /// let b = Interval::new(2, 4).unwrap(); /// assert_eq!(a.overlaps(&b), true); /// assert_eq!(b.overlaps(&a), true); /// ```", "```rsrust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(4, 6).unwrap(); /// assert_eq!(a.overlaps(&b), false); /// assert_eq!(b.overlaps(&a), true); /// ```", "```rsrust /// let a = Interval::new(1, 3).unwrap(); /// let b = Interval::new(3, 5).unwrap(); /// let c = a.merge(&b).unwrap(); /// assert_eq!(c.start, 1); /// assert_eq!(c.end, 5); /// ```", "```rs\n\n```"]
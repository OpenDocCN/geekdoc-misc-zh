["```rs\nSELECT id, first_name, salary * 1.1 AS new_salary\nFROM employee\nWHERE state = 'CO' \n```", "```rs\ndata class Token(val text: String, val type: TokenType, val endOffset: Int) \n```", "```rs\nlistOf(\n    Token(\"SELECT\", Keyword.SELECT, ...),\n    Token(\"a\", Literal.IDENTIFIER, ...),\n    Token(\"+\", Symbol.PLUS, ...),\n    Token(\"b\", Literal.IDENTIFIER, ...),\n    Token(\"FROM\", Keyword.FROM, ...),\n    Token(\"c\", Literal.IDENTIFIER, ...)\n) \n```", "```rs\ninterface PrattParser {\n\n    fun parse(precedence: Int = 0): SqlExpr? {\n        var expr = parsePrefix() ?: return null\n        while (precedence < nextPrecedence()) {\n            expr = parseInfix(expr, nextPrecedence())\n        }\n        return expr\n    }\n\n    fun nextPrecedence(): Int\n    fun parsePrefix(): SqlExpr?\n    fun parseInfix(left: SqlExpr, precedence: Int): SqlExpr\n} \n```", "```rs\ninterface SqlExpr\n\ndata class SqlIdentifier(val id: String) : SqlExpr\ndata class SqlString(val value: String) : SqlExpr\ndata class SqlLong(val value: Long) : SqlExpr\ndata class SqlDouble(val value: Double) : SqlExpr\ndata class SqlBinaryExpr(val l: SqlExpr, val op: String, val r: SqlExpr) : SqlExpr\ndata class SqlAlias(val expr: SqlExpr, val alias: SqlIdentifier) : SqlExpr\ndata class SqlFunction(val name: String, val args: List<SqlExpr>) : SqlExpr \n```", "```rs\nTokens:      [1]  [+]  [2]  [*]  [3]\nPrecedence:   0   50    0   60    0 \n```", "```rs\nTokens:      [1]  [*]  [2]  [+]  [3]\nPrecedence:   0   60    0   50    0 \n```", "```rs\ndata class SqlSelect(\n    val projection: List<SqlExpr>,\n    val tableName: String,\n    val selection: SqlExpr?,\n    val groupBy: List<SqlExpr>,\n    val having: SqlExpr?,\n    val orderBy: List<SqlSort>,\n    val limit: Int?\n) : SqlRelation \n```", "```rs\nSELECT id, first_name, salary/12 AS monthly_salary\nFROM employee\nWHERE state = 'CO' AND monthly_salary > 1000 \n```", "```rs\nProjection: #id, #first_name, #monthly_salary\n    Filter: #state = 'CO' AND #monthly_salary > 1000\n        Projection: #id, #first_name, #salary/12 AS monthly_salary, #state\n            Scan: employee \n```", "```rs\nfun createLogicalExpr(expr: SqlExpr, input: LogicalPlan): LogicalExpr {\n    return when (expr) {\n        is SqlIdentifier -> Column(expr.id)\n        is SqlString -> LiteralString(expr.value)\n        is SqlLong -> LiteralLong(expr.value)\n        is SqlDouble -> LiteralDouble(expr.value)\n        is SqlAlias -> Alias(createLogicalExpr(expr.expr, input), expr.alias.id)\n        is SqlBinaryExpr -> {\n            val l = createLogicalExpr(expr.l, input)\n            val r = createLogicalExpr(expr.r, input)\n            when (expr.op) {\n                \"=\" -> Eq(l, r)\n                \"!=\" -> Neq(l, r)\n                \">\" -> Gt(l, r)\n                \">=\" -> GtEq(l, r)\n                \"<\" -> Lt(l, r)\n                \"<=\" -> LtEq(l, r)\n                \"AND\" -> And(l, r)\n                \"OR\" -> Or(l, r)\n                \"+\" -> Add(l, r)\n                \"-\" -> Subtract(l, r)\n                \"*\" -> Multiply(l, r)\n                \"/\" -> Divide(l, r)\n                else -> throw SQLException(\"Unknown operator: ${expr.op}\")\n            }\n        }\n        else -> throw SQLException(\"Unsupported expression: $expr\")\n    }\n} \n```", "```rs\nfun findColumnReferences(expr: LogicalExpr, columns: MutableSet<String>) {\n    when (expr) {\n        is Column -> columns.add(expr.name)\n        is Alias -> findColumnReferences(expr.expr, columns)\n        is BinaryExpr -> {\n            findColumnReferences(expr.l, columns)\n            findColumnReferences(expr.r, columns)\n        }\n    }\n} \n```", "```rs\nSELECT department, AVG(salary) AS avg_salary\nFROM employee\nWHERE state = 'CO'\nGROUP BY department\nHAVING avg_salary > 50000 \n```"]
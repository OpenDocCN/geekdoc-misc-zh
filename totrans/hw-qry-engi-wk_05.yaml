- en: What Is a Query Engine?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://howqueryengineswork.com/01-what-is-a-query-engine.html](https://howqueryengineswork.com/01-what-is-a-query-engine.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you have written code to search through a list or filter items in an array,
    you have already implemented a tiny query engine. A query engine is simply software
    that retrieves and processes data based on some criteria. The difference between
    your `for` loop and a production query engine is scale, generality, and optimization,
    but the core idea is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this Python code that finds all students with a GPA above 3.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is querying data. Now imagine you need to do this across millions of records
    stored in files, join data from multiple sources, group results, and compute aggregates,
    all while keeping response times reasonable. That is what query engines do.
  prefs: []
  type: TYPE_NORMAL
- en: '[From Code to Queries](#from-code-to-queries)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code above works, but it has limitations. What if you want to change the
    filter condition? You would need to modify and recompile the code. What if someone
    without programming experience needs to analyze the data?
  prefs: []
  type: TYPE_NORMAL
- en: 'Query languages like SQL solve this by providing a declarative way to express
    what data you want, without specifying how to get it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This query expresses the same logic as our Python loop, but the query engine
    decides how to execute it efficiently. This separation of “what” from “how” is
    powerful. The same query can run against a small file or a distributed cluster
    of servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Anatomy of a Query Engine](#anatomy-of-a-query-engine)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A query engine transforms a query (like the SQL above) into actual results
    through several stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing: Convert the query text into a structured representation (like an abstract
    syntax tree)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Planning: Determine which operations are needed (scan, filter, join, aggregate)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Optimization: Reorder and transform operations for efficiency'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execution: Actually process the data and produce results'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pipeline might remind you of a compiler, and that is no coincidence. Query
    engines are essentially specialized compilers that translate declarative queries
    into efficient execution plans.
  prefs: []
  type: TYPE_NORMAL
- en: '[A Concrete Example](#a-concrete-example)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at a slightly more complex query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This query:'
  prefs: []
  type: TYPE_NORMAL
- en: Scans the `employees` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters to only recent hires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups employees by department
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computes the average salary per department
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorts results by that average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A query engine must determine the most efficient way to execute these operations.
    Should it filter before or after grouping? How should it store intermediate results?
    These decisions significantly impact performance, especially with large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL: The Universal Query Language](#sql-the-universal-query-language)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL (Structured Query Language) has been the dominant query language since
    the 1970s. You will encounter it in:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases (PostgreSQL, MySQL, SQLite)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data warehouses (Snowflake, BigQuery, Redshift)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big data systems (Apache Spark, Presto, Hive)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even embedded analytics (DuckDB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are two more examples showing SQL’s expressiveness:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the top 5 most visited pages yesterday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating month-over-month growth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Beyond SQL: DataFrame APIs](#beyond-sql-dataframe-apis)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whilst SQL is ubiquitous, many query engines also provide programmatic APIs.
    These are especially popular in data science where queries are often built dynamically
    or mixed with custom code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same query expressed using Apache Spark’s DataFrame API in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The DataFrame API provides the same logical operations as SQL but expressed
    as method calls. Under the hood, both approaches generate the same query plan.
  prefs: []
  type: TYPE_NORMAL
- en: '[Why Build a Query Engine?](#why-build-a-query-engine)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understanding query engines helps you:'
  prefs: []
  type: TYPE_NORMAL
- en: Write better queries, because knowing how queries execute helps you write efficient
    ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug performance issues, because understanding the optimizer helps diagnose
    slow queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appreciate database internals, because query engines are at the heart of every
    database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build data tools, because many applications need query-like functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Query engines also touch many areas of computer science: parsing and compilers,
    data structures, algorithms, distributed systems, and optimization. Building one
    is excellent practice.'
  prefs: []
  type: TYPE_NORMAL
- en: '[What This Book Covers](#what-this-book-covers)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book walks through building a complete query engine from scratch. We will
    implement:'
  prefs: []
  type: TYPE_NORMAL
- en: A type system for representing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data source connectors for reading files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical and physical query plans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SQL parser and planner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query optimization rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel and distributed execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query engine (called KQuery) is intentionally simple, optimized for learning
    rather than production use. But the concepts apply directly to real systems like
    Apache Spark, Presto, and DataFusion.
  prefs: []
  type: TYPE_NORMAL
- en: '*This book is also available for purchase in ePub, MOBI, and PDF format from
    [https://leanpub.com/how-query-engines-work](https://leanpub.com/how-query-engines-work)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copyright © 2020-2025 Andy Grove. All rights reserved.**'
  prefs: []
  type: TYPE_NORMAL

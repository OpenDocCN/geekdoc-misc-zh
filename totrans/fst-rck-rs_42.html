<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Command Line Arguments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Command Line Arguments</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/clap.html">https://freddiehaddad.github.io/fast-track-to-rust/clap.html</a></blockquote>
                        
<p>In the <a href="cargo_toml.html"><code>Cargo.toml</code></a> section, you were asked to add the <a href="https://crates.io/crates/clap"><code>clap</code></a> crate as a
dependency to support command line argument parsing for our rustle program. With
our current understanding of attributes, it's an ideal time to utilize this
crate by extending our rustle program to handle command line arguments.</p>
<p>One method for defining command line arguments with <code>clap</code> involves using custom
attributes. This is why we specified the derive feature in the dependency.</p>
<p>If you didn't complete the exercise and are working through this course locally,
you can add the dependency to the rustle crate with:</p>
<pre><code class="language-console">$ cargo add clap --features derive
</code></pre>
<h2 id="advanced-attributes"><a class="header" href="#advanced-attributes">Advanced Attributes</a></h2>
<p>The topic of <a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">macro attributes</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive macro helper attributes</a> is quite
advanced and beyond the scope of this course. Therefore, we won't delve into
their inner workings in depth. However, keep this section in mind as you
continue your Rust journey, because the time will likely come when you will need
to implement similar attributes yourself for code generation.</p>
<h2 id="extending-rustle"><a class="header" href="#extending-rustle">Extending rustle</a></h2>
<p>We're going to add command line argument support to our program. However, we'll
continue to mock the command line arguments to keep developing this course
online. After configuring <code>clap</code>, this will be the auto-generated help (i.e.,
typing <code>rustle --help</code> in the terminal).</p>
<pre><code class="language-console">$ rustle.exe --help
Usage: rustle.exe [OPTIONS] &lt;PATTERN&gt; [FILES]...

Arguments:
  &lt;PATTERN&gt;   The regular expression to match
  [FILES]...  List of files to search

Options:
  -l, --line-number           Prefix each line of output with the 1-based line
                              number within its input file
  -b, --before-context &lt;num&gt;  Print num lines of trailing context before matching
                              lines [default: 0]
  -a, --after-context &lt;num&gt;   Print num lines of trailing context after matching
                              lines [default: 0]
  -h, --help                  Print help
  -V, --version               Print version
</code></pre>
<blockquote>
<p>The <code>CLAP</code> documentation is very extensive and includes plenty of examples to
learn from. If you find yourself building a CLI application, you will most
certainly want to reference the <a href="https://crates.io/crates/clap">documentation</a>.</p>
</blockquote>
<p>Here's the updated version of rustle with command line argument support added:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate regex; // this is needed for the playground
</span>use clap::Parser;
<span class="boring">use interval::{Interval, IntervalError};
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span>use std::path::PathBuf;
<span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match regex.is_match(line) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn create_intervals(
</span><span class="boring">    lines: Vec&lt;usize&gt;,
</span><span class="boring">    before_context: usize,
</span><span class="boring">    after_context: usize,
</span><span class="boring">) -&gt; Result&lt;Vec&lt;Interval&lt;usize&gt;&gt;, IntervalError&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .map(|line| {
</span><span class="boring">            let start = line.saturating_sub(before_context);
</span><span class="boring">            let end = line.saturating_add(after_context);
</span><span class="boring">            Interval::new(start, end)
</span><span class="boring">        })
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn merge_intervals(intervals: Vec&lt;Interval&lt;usize&gt;&gt;) -&gt; Vec&lt;Interval&lt;usize&gt;&gt; {
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    intervals
</span><span class="boring">        .into_iter()
</span><span class="boring">        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
</span><span class="boring">        .collect()
</span><span class="boring">}
</span>
fn print_results(
    intervals: Vec&lt;Interval&lt;usize&gt;&gt;,
    lines: Vec&lt;String&gt;,
    line_number: bool,
) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            if line_number {
                print!("{}: ", line_no + 1);
            }
            println!("{}", line);
        }
    }
}
<span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span>
#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Prefix each line of output with the 1-based line number within its
    /// input file.
    #[arg(short, long, default_value_t = false)]
    line_number: bool,

    /// Print num lines of trailing context before matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    before_context: u8,

    /// Print num lines of trailing context after matching lines.
    #[arg(short, long, default_value_t = 0, value_name = "num")]
    after_context: u8,

    /// The regular expression to match.
    #[arg(required = true)]
    pattern: String,

    /// List of files to search.
    #[arg(required = true)]
    files: Vec&lt;PathBuf&gt;,
}

fn main() {
<span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let mock_file = std::io::Cursor::new(poem);
</span><span class="boring">
</span>    // let cli = Cli::parse(); // for production use
    // mock command line arguments
    let cli = match Cli::try_parse_from([
        "rustle", // executable name
        "--line-number",
        "--before-context",
        "1",
        "--after-context",
        "1",
        "(all)|(little)", // pattern
        "poem.txt",       // file
    ]) {
        Ok(cli) =&gt; cli,
        Err(e) =&gt; {
            eprintln!("Error parsing command line arguments: {e:?}");
            exit(1);
        }
    };

    // get values from clap
    let pattern = cli.pattern;
    let line_number = cli.line_number;
    let before_context = cli.before_context as usize;
    let after_context = cli.after_context as usize;
<span class="boring">
</span><span class="boring">    // attempt to open the file
</span><span class="boring">    let lines = read_file(mock_file);
</span><span class="boring">    //let lines = match File::open(filename) {
</span><span class="boring">    //    // convert the poem into lines
</span><span class="boring">    //    Ok(file) =&gt; read_file(file),
</span><span class="boring">    //    Err(e) =&gt; {
</span><span class="boring">    //        eprintln!("Error opening {filename}: {e}");
</span><span class="boring">    //        exit(1);
</span><span class="boring">    //    }
</span><span class="boring">    //};
</span><span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(&amp;pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, regex);
</span><span class="boring">
</span><span class="boring">    // create intervals of the form [a,b] with the before/after context
</span><span class="boring">    let intervals =
</span><span class="boring">        match create_intervals(match_lines, before_context, after_context) {
</span><span class="boring">            Ok(intervals) =&gt; intervals,
</span><span class="boring">            Err(_) =&gt; {
</span><span class="boring">                eprintln!("An error occurred while creating intervals");
</span><span class="boring">                exit(1);
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    let intervals = merge_intervals(intervals);
</span>
    // print the lines
    print_results(intervals, lines, line_number);
}
<span class="boring">
</span><span class="boring">pub mod interval {
</span><span class="boring">    /// A list specifying general categories of Interval errors.
</span><span class="boring">    #[derive(Debug)]
</span><span class="boring">    pub enum IntervalError {
</span><span class="boring">        /// Start is not less than or equal to end
</span><span class="boring">        StartEndRangeInvalid,
</span><span class="boring">        /// Two intervals to be merged do not overlap
</span><span class="boring">        NonOverlappingInterval,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// A closed-interval [`start`, `end`] type used for representing a range of
</span><span class="boring">    /// values between `start` and `end` inclusively.
</span><span class="boring">    ///
</span><span class="boring">    /// # Examples
</span><span class="boring">    ///
</span><span class="boring">    /// You can create an `Interval` using `new`.
</span><span class="boring">    ///
</span><span class="boring">    /// ```rust
</span><span class="boring">    /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">    /// assert_eq!(interval.start, 1);
</span><span class="boring">    /// assert_eq!(interval.end, 10);
</span><span class="boring">    /// ```
</span><span class="boring">    #[derive(Debug, PartialEq)]
</span><span class="boring">    pub struct Interval&lt;T&gt; {
</span><span class="boring">        pub start: T,
</span><span class="boring">        pub end: T,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl&lt;T: Copy + PartialOrd&gt; Interval&lt;T&gt; {
</span><span class="boring">        /// Creates a new `Interval` set to `start` and `end`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let interval = Interval::new(1, 10).unwrap();
</span><span class="boring">        /// assert_eq!(interval.start, 1);
</span><span class="boring">        /// assert_eq!(interval.end, 10);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn new(start: T, end: T) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if start &lt;= end {
</span><span class="boring">                Ok(Self { start, end })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::StartEndRangeInvalid)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Checks if two intervals overlap. Overlapping intervals have at least
</span><span class="boring">        /// one point in common.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 5).unwrap();
</span><span class="boring">        /// let b = Interval::new(2, 4).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), true);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(4, 6).unwrap();
</span><span class="boring">        /// assert_eq!(a.overlaps(&amp;b), false);
</span><span class="boring">        /// assert_eq!(b.overlaps(&amp;a), true);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn overlaps(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; bool {
</span><span class="boring">            self.end &gt;= other.start
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        /// Merges two intervals returning a new `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// The merged `Interval` range includes the union of ranges from each
</span><span class="boring">        /// `Interval`.
</span><span class="boring">        ///
</span><span class="boring">        /// # Examples
</span><span class="boring">        ///
</span><span class="boring">        /// ```rust
</span><span class="boring">        /// let a = Interval::new(1, 3).unwrap();
</span><span class="boring">        /// let b = Interval::new(3, 5).unwrap();
</span><span class="boring">        /// let c = a.merge(&amp;b).unwrap();
</span><span class="boring">        /// assert_eq!(c.start, 1);
</span><span class="boring">        /// assert_eq!(c.end, 5);
</span><span class="boring">        /// ```
</span><span class="boring">        pub fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
</span><span class="boring">            if self.overlaps(other) {
</span><span class="boring">                Ok(Self {
</span><span class="boring">                    start: self.start,
</span><span class="boring">                    end: other.end,
</span><span class="boring">                })
</span><span class="boring">            } else {
</span><span class="boring">                Err(IntervalError::NonOverlappingInterval)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    use std::fmt;
</span><span class="boring">    impl&lt;T: fmt::Display&gt; fmt::Display for Interval&lt;T&gt; {
</span><span class="boring">        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">            write!(f, "[{}, {}]", self.start, self.end)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    use std::cmp::Ordering;
</span><span class="boring">    impl&lt;T: PartialEq + PartialOrd&gt; PartialOrd for Interval&lt;T&gt; {
</span><span class="boring">        fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
</span><span class="boring">            if self == other {
</span><span class="boring">                Some(Ordering::Equal)
</span><span class="boring">            } else if self.end &lt; other.start {
</span><span class="boring">                Some(Ordering::Less)
</span><span class="boring">            } else if self.start &gt; other.end {
</span><span class="boring">                Some(Ordering::Greater)
</span><span class="boring">            } else {
</span><span class="boring">                None // Intervals overlap
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>We made some minor code changes along with configuring <code>clap</code>. Most of it should
be straightforward by now, so we'll focus on the new aspects:</p>
<ul>
<li>The <a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html"><code>PathBuf</code></a> module facilitates cross-platform path manipulation. Since our
rustle program requires files to search, it's better to use <code>PathBuf</code> for
handling that input.</li>
<li>We updated <code>print_results</code> to take a new boolean argument, <code>line_number</code>,
which specifies whether or not to print line numbers in the output. If <code>true</code>,
the <code>print!</code> macro is used to output the line number without emitting a
newline.</li>
<li>We used <code>clap</code> attributes to derive our command line arguments. The <code>clap</code>
<a href="https://crates.io/crates/clap">documentation</a> covers these attributes in full detail.</li>
<li>In <code>main</code>, we mock command line arguments with an array of string slices that
gets parsed by <code>clap</code>.
<blockquote>
<p>The <code>match</code> expression is for development purposes. If we made any mistakes
in our mock command line arguments, we would catch the error and print it.</p>
</blockquote>
</li>
<li>Since we defined the <code>before_context</code> and <code>after_context</code> variables as <code>u8</code> in
the <code>Cli</code> structure but use <code>usize</code> throughout the code, an explicit cast
using <a href="https://doc.rust-lang.org/std/keyword.as.html"><code>as</code></a> is necessary when assigning these values to local variables.</li>
</ul>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>Onward to concurrency!</p>

                        
</body>
</html>
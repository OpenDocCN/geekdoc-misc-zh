- en: Implementing Conditionals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现条件语句
- en: 'Okay, so we have many decisions to make! To first get a working evaluator,
    without having to go beyond numbers, we can use a slightly different conditional
    construct: one that checks whether evaluates to a special numeric value, such
    as `0`. That is, instead of a proper `if`, we really have something we might call
    `if0` that works only for numbers.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们有很多决定要做！为了首先得到一个可以工作的评估器，而不必超出数字的范围，我们可以使用一个稍微不同的条件构造：一个检查是否评估为特殊数值的条件，比如`0`。也就是说，我们实际上有一个可能称为`if0`的东西，它只适用于数字。
- en: 'How do we make this choice? Luckily, we’re writing our interpreter in plait,
    which of course already has a conditional. Therefore, we can just reuse it:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何做出这个选择？幸运的是，我们正在用plait编写我们的解释器，它当然已经有一个条件语句。因此，我们只需重用它：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Observe that the semantics of the conditional—that `0`is true, and everything
    else is false—is now made manifest in the body of `calc`. If we want a different
    semantics, that’s the part of the program to zero into and change.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在条件语句的语义——`0`为真，其他一切为假——已经在`calc`的主体中得到了体现。如果我们想要不同的语义，那就是程序需要集中改变的部分。
- en: 'This solution, and indeed so far our entire evaluator, might feel a bit… disappointing?
    We have numbers and conditionals, sure, but all we’ve done is (mostly) deferred
    to plait to handle these. Here are some thoughts on this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案，实际上到目前为止我们的整个评估器，可能感觉有点……令人失望？我们确实有数字和条件语句，但我们所做的只是（主要）推迟到plait来处理这些。以下是一些关于这个问题的思考：
- en: This is true!
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是真的！
- en: This is not entirely true. We have made some conscious decisions, like the handling
    of conditionals.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这并不完全正确。我们做出了一些有意识的决策，比如条件语句的处理。
- en: In fact, we have made even more decisions, whether or not we were conscious
    of them, such as the handling of numbers. We just happened to defer those to plait,
    but we could have made other decisions if we wanted.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事实上，我们做出了更多的决定，无论我们是否意识到它们，比如数字的处理。我们只是碰巧把这些推迟给了plait，但如果我们想的话，我们也可以做出其他决定。
- en: 'This reuse is actually part of the power of an interpreter: it lets you exploit
    features that have already been built instead of having to re-implement all of
    them from scratch.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种重用实际上是解释器力量的一个部分：它让你可以利用已经构建好的特性，而不是从头开始重新实现所有这些特性。
- en: By reusing the host language (here, plait), we can zero in on the differences
    (like the handling of conditionals), which would otherwise be lost if we had to
    implement everything. Later we will see stronger departures from the semantics
    of plait.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重用宿主语言（在这里是plait），我们可以专注于差异（比如条件语句的处理），否则如果我们不得不实现所有这些，这些差异可能会丢失。稍后我们将看到对plait语义的更强烈的偏离。

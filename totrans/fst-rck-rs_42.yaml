- en: Command Line Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/clap.html](https://freddiehaddad.github.io/fast-track-to-rust/clap.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the [`Cargo.toml`](cargo_toml.html) section, you were asked to add the [`clap`](https://crates.io/crates/clap)
    crate as a dependency to support command line argument parsing for our rustle
    program. With our current understanding of attributes, it's an ideal time to utilize
    this crate by extending our rustle program to handle command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: One method for defining command line arguments with `clap` involves using custom
    attributes. This is why we specified the derive feature in the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t complete the exercise and are working through this course locally,
    you can add the dependency to the rustle crate with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Advanced Attributes](#advanced-attributes)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of [macro attributes](https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros)
    and [derive macro helper attributes](https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes)
    is quite advanced and beyond the scope of this course. Therefore, we won't delve
    into their inner workings in depth. However, keep this section in mind as you
    continue your Rust journey, because the time will likely come when you will need
    to implement similar attributes yourself for code generation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Extending rustle](#extending-rustle)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to add command line argument support to our program. However, we'll
    continue to mock the command line arguments to keep developing this course online.
    After configuring `clap`, this will be the auto-generated help (i.e., typing `rustle
    --help` in the terminal).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `CLAP` documentation is very extensive and includes plenty of examples to
    learn from. If you find yourself building a CLI application, you will most certainly
    want to reference the [documentation](https://crates.io/crates/clap).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here''s the updated version of rustle with command line argument support added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused_imports)] extern crate regex; // this is needed for the playground
    use clap::Parser;'
  prefs: []
  type: TYPE_NORMAL
- en: use interval::{Interval, IntervalError}; use itertools::Itertools; use regex::Regex;
    use std::fs::File; use std::io::Read; use std::io::{BufRead, BufReader}; use std::path::PathBuf;
  prefs: []
  type: TYPE_NORMAL
- en: 'use std::process::exit;   fn find_matching_lines(lines: &[String], regex: Regex)
    -> Vec<usize> {'
  prefs: []
  type: TYPE_NORMAL
- en: lines .iter() .enumerate() .filter_map(|(i, line)| match regex.is_match(line)
    { true => Some(i), false => None, }) .collect() // turns anything iterable into
    a collection }   fn create_intervals(
  prefs: []
  type: TYPE_NORMAL
- en: 'lines: Vec<usize>, before_context: usize, after_context: usize, ) -> Result<Vec<Interval<usize>>,
    IntervalError> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'lines .iter() .map(|line| { let start = line.saturating_sub(before_context);
    let end = line.saturating_add(after_context); Interval::new(start, end) }) .collect()
    }   fn merge_intervals(intervals: Vec<Interval<usize>>) -> Vec<Interval<usize>>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: // merge overlapping intervals intervals .into_iter() .coalesce(|p, c| p.merge(&c).map_err(|_|
    (p, c))) .collect() }
  prefs: []
  type: TYPE_NORMAL
- en: fn print_results(
  prefs: []
  type: TYPE_NORMAL
- en: 'intervals: Vec<Interval<usize>>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lines: Vec<String>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'line_number: bool,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) {
  prefs: []
  type: TYPE_NORMAL
- en: for interval in intervals {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (line_no, line) in lines
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .take(interval.end + 1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .skip(interval.start)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if line_number {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print!("{}: ", line_no + 1);'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", line);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn read_file(file: impl Read) -> Vec<String> {'
  prefs: []
  type: TYPE_NORMAL
- en: BufReader::new(file).lines().map_while(Result::ok).collect() }
  prefs: []
  type: TYPE_NORMAL
- en: '#[derive(Parser)]'
  prefs: []
  type: TYPE_NORMAL
- en: '#[command(version, about, long_about = None)]'
  prefs: []
  type: TYPE_NORMAL
- en: struct Cli {
  prefs: []
  type: TYPE_NORMAL
- en: /// Prefix each line of output with the 1-based line number within its
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// input file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[arg(short, long, default_value_t = false)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'line_number: bool,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Print num lines of trailing context before matching lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[arg(short, long, default_value_t = 0, value_name = "num")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'before_context: u8,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Print num lines of trailing context after matching lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[arg(short, long, default_value_t = 0, value_name = "num")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'after_context: u8,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// The regular expression to match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[arg(required = true)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pattern: String,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// List of files to search.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#[arg(required = true)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'files: Vec<PathBuf>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let poem = "I have a little shadow that goes in and out with me, And what can
    be the use of him is more than I can see. He is very, very like me from the heels
    up to the head; And I see him jump before me, when I jump into my bed.   The funniest
    thing about him is the way he likes to grow - Not at all like proper children,
    which is always very slow; For he sometimes shoots up taller like an india-rubber
    ball, And he sometimes gets so little that there's none of him at all.";   let
    mock_file = std::io::Cursor::new(poem);      // let cli = Cli::parse(); // for
    production use
  prefs: []
  type: TYPE_NORMAL
- en: // mock command line arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let cli = match Cli::try_parse_from([
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"rustle", // executable name'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"--line-number",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"--before-context",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"1",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"--after-context",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"1",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"(all)|(little)", // pattern'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"poem.txt",       // file'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']) {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(cli) => cli,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err(e) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'eprintln!("Error parsing command line arguments: {e:?}");'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(1);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // get values from clap
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let pattern = cli.pattern;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let line_number = cli.line_number;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let before_context = cli.before_context as usize;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let after_context = cli.after_context as usize;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// attempt to open the file let lines = read_file(mock_file); //let lines =
    match File::open(filename) { //    // convert the poem into lines //    Ok(file)
    => read_file(file), //    Err(e) => { //        eprintln!("Error opening {filename}:
    {e}"); //        exit(1); //    } //};   // compile the regular expression let
    regex = match Regex::new(&pattern) { Ok(re) => re, // bind re to regex Err(e)
    => { eprintln!("{e}"); // write to standard error exit(1); } };   // store the
    0-based line number for any matched line let match_lines = find_matching_lines(&lines,
    regex);   // create intervals of the form [a,b] with the before/after context
    let intervals = match create_intervals(match_lines, before_context, after_context)
    { Ok(intervals) => intervals, Err(_) => { eprintln!("An error occurred while creating
    intervals"); exit(1); } };   // merge overlapping intervals let intervals = merge_intervals(intervals);'
  prefs: []
  type: TYPE_NORMAL
- en: // print the lines
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_results(intervals, lines, line_number);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: pub mod interval {
  prefs: []
  type: TYPE_NORMAL
- en: '/// A list specifying general categories of Interval errors. #[derive(Debug)]
    pub enum IntervalError { /// Start is not less than or equal to end StartEndRangeInvalid,
    /// Two intervals to be merged do not overlap NonOverlappingInterval, }   ///
    A closed-interval [`start`, `end`] type used for representing a range of /// values
    between `start` and `end` inclusively. /// /// # Examples /// /// You can create
    an `Interval` using `new`. /// /// [PRE3] #[derive(Debug, PartialEq)] pub struct
    Interval<T> { pub start: T, pub end: T, }   impl<T: Copy + PartialOrd> Interval<T>
    { /// Creates a new `Interval` set to `start` and `end`. /// /// # Examples ///
    /// [PRE4] pub fn new(start: T, end: T) -> Result<Self, IntervalError> { if start
    <= end { Ok(Self { start, end }) } else { Err(IntervalError::StartEndRangeInvalid)
    } }   /// Checks if two intervals overlap. Overlapping intervals have at least
    /// one point in common. /// /// # Examples /// /// [PRE5] /// /// [PRE6] ///
    /// [PRE7] pub fn overlaps(&self, other: &Interval<T>) -> bool { self.end >= other.start
    }   /// Merges two intervals returning a new `Interval`. /// /// The merged `Interval`
    range includes the union of ranges from each /// `Interval`. /// /// # Examples
    /// /// [PRE8] pub fn merge(&self, other: &Self) -> Result<Self, IntervalError>
    { if self.overlaps(other) { Ok(Self { start: self.start, end: other.end, }) }
    else { Err(IntervalError::NonOverlappingInterval) } } }   use std::fmt; impl<T:
    fmt::Display> fmt::Display for Interval<T> { fn fmt(&self, f: &mut std::fmt::Formatter<''_>)
    -> fmt::Result { write!(f, "[{}, {}]", self.start, self.end) } }   use std::cmp::Ordering;
    impl<T: PartialEq + PartialOrd> PartialOrd for Interval<T> { fn partial_cmp(&self,
    other: &Self) -> Option<Ordering> { if self == other { Some(Ordering::Equal) }
    else if self.end < other.start { Some(Ordering::Less) } else if self.start > other.end
    { Some(Ordering::Greater) } else { None // Intervals overlap } } } }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Summary](#summary)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We made some minor code changes along with configuring `clap`. Most of it should
    be straightforward by now, so we''ll focus on the new aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`PathBuf`](https://doc.rust-lang.org/std/path/struct.PathBuf.html) module
    facilitates cross-platform path manipulation. Since our rustle program requires
    files to search, it's better to use `PathBuf` for handling that input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We updated `print_results` to take a new boolean argument, `line_number`, which
    specifies whether or not to print line numbers in the output. If `true`, the `print!`
    macro is used to output the line number without emitting a newline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used `clap` attributes to derive our command line arguments. The `clap` [documentation](https://crates.io/crates/clap)
    covers these attributes in full detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `main`, we mock command line arguments with an array of string slices that
    gets parsed by `clap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `match` expression is for development purposes. If we made any mistakes
    in our mock command line arguments, we would catch the error and print it.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since we defined the `before_context` and `after_context` variables as `u8`
    in the `Cli` structure but use `usize` throughout the code, an explicit cast using
    [`as`](https://doc.rust-lang.org/std/keyword.as.html) is necessary when assigning
    these values to local variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Next](#next)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Onward to concurrency!
  prefs: []
  type: TYPE_NORMAL

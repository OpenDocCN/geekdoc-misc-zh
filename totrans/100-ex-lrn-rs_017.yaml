- en: Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html](https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html](https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html)
- en: The `new` method you've just defined is trying to enforce some **constraints**
    on the field values for `Ticket`. But are those invariants really enforced? What
    prevents a developer from creating a `Ticket` without going through `Ticket::new`?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚定义的`new`方法试图对`Ticket`的字段值施加一些**约束**。但这些不变量真的被强制执行了吗？什么阻止开发者不通过`Ticket::new`创建`Ticket`？
- en: 'To get proper **encapsulation** you need to become familiar with two new concepts:
    **visibility** and **modules**. Let''s start with modules.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得适当的**封装**，你需要熟悉两个新概念：**可见性**和**模块**。让我们从模块开始。
- en: '[What is a module?](#what-is-a-module)'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[什么是模块？](#what-is-a-module)'
- en: In Rust a **module** is a way to group related code together, under a common
    namespace (i.e. the module's name).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，**模块**是一种将相关代码组合在一起的方式，在公共命名空间（即模块的名称）下。
- en: 'You''ve already seen modules in action: the unit tests that verify the correctness
    of your code are defined in a different module, named `tests`.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了模块的实际应用：验证你的代码正确性的单元测试定义在名为`tests`的不同模块中。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Inline modules](#inline-modules)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[内联模块](#inline-modules)'
- en: 'The `tests` module above is an example of an **inline module**: the module
    declaration (`mod tests`) and the module contents (the stuff inside `{ ... }`)
    are next to each other.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`tests`模块是一个**内联模块**的例子：模块声明（`mod tests`）和模块内容（`{ ... }`内的内容）是相邻的。
- en: '[Module tree](#module-tree)'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[模块树](#module-tree)'
- en: Modules can be nested, forming a **tree** structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以嵌套，形成**树**结构。
- en: The root of the tree is the **crate** itself, which is the top-level module
    that contains all the other modules. For a library crate, the root module is usually
    `src/lib.rs` (unless its location has been customized). The root module is also
    known as the **crate root**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 树的根是**crate**本身，这是包含所有其他模块的最高级模块。对于一个库crate，根模块通常是`src/lib.rs`（除非其位置已被自定义）。根模块也被称为**crate根**。
- en: The crate root can have submodules, which in turn can have their own submodules,
    and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: crate的根目录可以有子模块，这些子模块又可以有自己的子模块，以此类推。
- en: '[External modules and the filesystem](#external-modules-and-the-filesystem)'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[外部模块和文件系统](#external-modules-and-the-filesystem)'
- en: Inline modules are useful for small pieces of code, but as your project grows
    you'll want to split your code into multiple files. In the parent module, you
    declare the existence of a submodule using the `mod` keyword.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 内联模块对于小块代码很有用，但随着你的项目增长，你可能希望将代码拆分成多个文件。在父模块中，你使用`mod`关键字声明子模块的存在。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`cargo`, Rust''s build tool, is then in charge of finding the file that contains
    the module implementation.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo`，Rust的构建工具，负责找到包含模块实现的文件。'
- en: 'If your module is declared in the root of your crate (e.g. `src/lib.rs` or
    `src/main.rs`), `cargo` expects the file to be named either:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块在crate的根目录下声明（例如`src/lib.rs`或`src/main.rs`），`cargo`期望文件被命名为以下之一：
- en: '`src/<module_name>.rs`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/<module_name>.rs`'
- en: '`src/<module_name>/mod.rs`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/<module_name>/mod.rs`'
- en: 'If your module is a submodule of another module, the file should be named:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块是另一个模块的子模块，文件应该命名为：
- en: '`[..]/<parent_module>/<module_name>.rs`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[..]/<parent_module>/<module_name>.rs`'
- en: '`[..]/<parent_module>/<module_name>/mod.rs`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[..]/<parent_module>/<module_name>/mod.rs`'
- en: E.g. `src/animals/dog.rs` or `src/animals/dog/mod.rs` if `dog` is a submodule
    of `animals`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`src/animals/dog.rs`或`src/animals/dog/mod.rs`，如果`dog`是`animals`的子模块。
- en: Your IDE might help you create these files automatically when you declare a
    new module using the `mod` keyword.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你的IDE可能会在你使用`mod`关键字声明新模块时自动创建这些文件。
- en: '[Item paths and `use` statements](#item-paths-and-use-statements)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[项目路径和`use`语句](#item-paths-and-use-statements)'
- en: You can access items defined in the same module without any special syntax.
    You just use their name.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以无特殊语法地访问同一模块中定义的项目。你只需使用它们的名称。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's not the case if you want to access an entity from a different module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从一个不同的模块访问一个实体，情况就不同了。
- en: You have to use a **path** pointing to the entity you want to access.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用指向你想要访问的实体的**路径**。
- en: 'You can compose the path in various ways:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用各种方式组合路径：
- en: starting from the root of the current crate, e.g. `crate::module_1::MyStruct`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从当前crate的根目录开始，例如`crate::module_1::MyStruct`
- en: starting from the parent module, e.g. `super::my_function`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从父模块开始，例如`super::my_function`
- en: starting from the current module, e.g. `sub_module_1::MyStruct`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从当前模块开始，例如`sub_module_1::MyStruct`
- en: Both `crate` and `super` are **keywords**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`crate`和`super`都是**关键字**。'
- en: '`crate` refers to the root of the current crate, while `super` refers to the
    parent of the current module.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`crate`指的是当前crate的根，而`super`指的是当前模块的父模块。'
- en: Having to write the full path every time you want to refer to a type can be
    cumbersome. To make your life easier, you can introduce a `use` statement to bring
    the entity into scope.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想引用一个类型时都必须写出完整的路径可能会很麻烦。为了使你的生活更轻松，你可以引入一个`use`语句来将实体引入作用域。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Star imports](#star-imports)'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[星号导入](#star-imports)'
- en: You can also import all the items from a module with a single `use` statement.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用单个`use`语句从模块中导入所有项目。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is known as a **star import**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**星号导入**。
- en: It is generally discouraged because it can pollute the current namespace, making
    it hard to understand where each name comes from and potentially introducing name
    conflicts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是不被推荐的，因为它可能会污染当前命名空间，使得难以理解每个名称的来源，并可能引入名称冲突。
- en: Nonetheless, it can be useful in some cases, like when writing unit tests. You
    might have noticed that most of our test modules start with a `use super::*;`
    statement to bring all the items from the parent module (the one being tested)
    into scope.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在某些情况下它可能很有用，比如在编写单元测试时。你可能已经注意到，我们的大部分测试模块都以`use super::*;`语句开始，以便将父模块（被测试的模块）中的所有项目引入作用域。
- en: '[Visualizing the module tree](#visualizing-the-module-tree)'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[可视化模块树](#visualizing-the-module-tree)'
- en: If you're struggling to picture the module tree of your project, you can try
    using [`cargo-modules`](https://crates.io/crates/cargo-modules) to visualize it!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以想象你项目的模块树，你可以尝试使用[`cargo-modules`](https://crates.io/crates/cargo-modules)来可视化它！
- en: Refer to their documentation for installation instructions and usage examples.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考它们的文档以获取安装说明和使用示例。
- en: '[Exercise](#exercise)'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`03_ticket_v1/03_modules`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/03_modules)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于[`03_ticket_v1/03_modules`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/03_modules)

- en: Extending the Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Therefore, let’s think about what it takes to evaluate functions-as-values to
    SMoL. We don’t need functions to inherently have a name, because naming can be
    done by `let1`.  We’ll assume, for simplicity, that all functions take only one
    argument; extending this to multiple arguments is left as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: What issues might we have to deal with when we extend functions from
    having one argument only to having multiple arguments?
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to extend our abstract syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now: How many new constructs do we need to add to the abstract syntax?
  prefs: []
  type: TYPE_NORMAL
- en: 'When we added `let1`, you may recall that it didn’t suffice to add one construct;
    we needed two: one for variable bindingand one for variable use. You’ll often
    see this pattern when adding values to the language. For any new kind of value,
     you can expect to see one or more ways to makeit and one or more ways to use it.
    (Even arithmetic: numeric constants were a way to make them, arithmetic operations
    consumed them—but also made them.)'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise with functions, we need a way to represent both
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: for defining new functions, and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology:In more advanced texts, you will sometimes see the (formally correct,
    but perhaps slightly confusing) terms introductionand elimination: introduction
    brings the new concept in, elimination uses them. Thus, the `lam` introduces new
    functions, and an application eliminates them.'
  prefs: []
  type: TYPE_NORMAL
- en: We therefore add
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: to our AST.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we’ve already extended our parser, so that programs like the following
    are legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These parse, respectively, into
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: and should both evaluate to `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s think about the evaluator, which by now we can think of as turning
    into a full-blown interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the (almost) simplest kind of new program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: which is represented as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do Now: What do we want this program to evaluate to? Think in terms of types!
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `calc`produces numbers. What numberdoes the above expression evaluate
    to? What number do you expect it to produce?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we really want to stretch our credibility, we could either make up an encoding
    of it in a number, or use a number in memory. But neither of these is what we
    would expect! Let’s look at what some other languages do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Both Racket and Python agree: the result of creating an anonymous function
    is a function-kind of value, not a number. What this says is that we have to broaden
    the kinds of values that `interp` can produce.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: A side-effect is a change to the system that is visible from outside
    the body of a function. Typical side-effects are modifications to variables that
    are defined outside the function, communication with a network, changes to files,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology:A function is pureif, for a given input, it always produces the
    same output, and has no side-effects. In reality, a computation always has some side-effects,
    such as the consumption of energy and production of heat, but we usually overlook
    these because they are universal. In a few settings, however, they can matter:
    e.g., if a cryptographic key can be stolen by measuring these side-effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminology:Traditionally, some languages have used the terms procedureand function for
    similar but not identical concepts. Both are function-like entities that encapsulate
    a body of code and can be applied (or “called”). A procedure is an encapsulation
    that does not produce a value; therefore, it must have side-effects to be of any
    use. In contrast, a function always produces a value (and may be expected to not
    have any side-effects). This terminology has gotten completely scrambled over
    the years and people now use the terms interchangeably, but if someone seems to
    be making a distinction between the two, they probably mean something like the
    above.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens when evaluating a function? Both Racket and Python seem to suggest
    that we return a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have no additional information about the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '(That syntax means `funV`is a constructor of no parameters. It conveys no information
    at all other than the fact that it’s a `funV`; because we can’t mix types, it
    says, in particular, that a value is not numeric or a Boolean—and nothing more.)
    But now think about a program like this (assuming `x` is bound):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In both cases we’re going to get a `funV` value with no additional information,
    so when we try to perform the application, we…can’t.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it’s clear that the function value needs to tell us about the function.
    We need to know the body, because that’s what we need to evaluate; but the body
    can (and very likely does) reference the name of the formal parameter, so we need
    that too. Therefore, what we really need is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, it seems like we’ve gone to a lot of trouble for nothing. We
    take numeric and Boolean values and simply re-wrap them in new constructors, and
    now we’re doing the same thing for functions.  A certain Shakespeareian play’s
    title comes to mind.
  prefs: []
  type: TYPE_NORMAL
- en: Patience.
  prefs: []
  type: TYPE_NORMAL
- en: 'With what we have, we can already have a functioning interpreter. The lam case
    is obviously very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The application case is a bit more detailed. We need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the function position, to figure out what kind of value it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the argument position, since we’ve agreed that’s what happens in SMoL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the function position really does evaluate to a function. If it does
    not, raise an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the body of the function. But because the body can refer to the formal
    parameter…
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: …first make sure the formal is bound to the actual value of the argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Codifying this, in stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[(appE f a)` (let ([fv (interp f nv)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[av (interp a nv)])'
  prefs: []
  type: TYPE_NORMAL
- en: …)`]`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: (type-case Value fv
  prefs: []
  type: TYPE_NORMAL
- en: '[(funV v b) …]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (error ''app "didn''t get a function")]`))]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (interp b …)`]`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`(interp b` (extend nv v av)`)]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Stepping Back
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Putting it all together, we get the following interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Exercise: We wrote down a particular ordering above, which we put into practice
    in the code. But is that the same ordering that actual languages use? In particular,
    are non-function errors reported after or before evaluating the argument? Experiment
    and find out!
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve taken several steps to get here, it’s easy to lose sight of what
    we’ve just done. In just 20 lines of code (with a few helper functions), we have
    described the implementation of a full programming language. Not only that, a
    language that can express [all computations](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Church%25E2%2580%2593Turing_thesis&sa=D&source=editors&ust=1695232021212601&usg=AOvVaw1o9iRZ1zIR7qNKrD6lFhCa).
    When Turing Award winner [Alan Kay](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Alan_Kay&sa=D&source=editors&ust=1695232021213036&usg=AOvVaw1mQ9COqfNQ40uhDQa8ed0D)first
    saw the equivalent program, [he says](https://www.google.com/url?q=https://queue.acm.org/detail.cfm?id%3D1039523&sa=D&source=editors&ust=1695232021213294&usg=AOvVaw2Jqf_V8SktzbJT9CEIRj32),
  prefs: []
  type: TYPE_NORMAL
- en: Yes, that was the big revelation to me when I was in graduate school—when I
    finally understood that the half page of code on the bottom of page 13 of the
    Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!”
    This is the whole world of programming in a few lines that I can put my hand over.
  prefs: []
  type: TYPE_NORMAL
- en: I realized that anytime I want to know what I’m doing, I can just write down
    the kernel of this thing in a half page and it’s not going to lose any power.
    In fact, it’s going to gain power by being able to reenter itself much more readily
    than most systems done the other way can possibly do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve just rediscovered this same beautiful, powerful idea! If you want to
    see the original, here’s [that manual](https://www.google.com/url?q=https://www.softwarepreservation.org/projects/LISP/book/LISP%25201.5%2520Programmers%2520Manual.pdf&sa=D&source=editors&ust=1695232021214133&usg=AOvVaw2NEGhAo0Lj5kqCqv5LySNb) (by
    McCarthy, Abrahams, Edwards, Hart, Levin). Here it is, copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image3.png)'
  prefs: []
  type: TYPE_IMG
- en: Alright, so we now have a working interpreter for a full-fledged language. But
    before we can feel sure of that, we should try a few more examples to confirm
    that we’re happy with what we have.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Well, actually, we shouldn’t be too happy. Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we expect it to produce? If in doubt, we can write the same thing as
    a Racket program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What we see is that in Racket, the inner binding of `x`does notoverride the
    outer one, the one that was present at the time the function bound to `f`was defined.
    Therefore, this produces `1` in Racket.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should want this! Otherwise, consider this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This corresponds to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: which has an unbound identifier (`x`) error. But our interpreter produces `1`instead
    of halting with an error, which leads us right back to ☠️dynamic scope ☠️!
  prefs: []
  type: TYPE_NORMAL
- en: Return to Static Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise: Run the following programs in the Stacker.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we fix this? The examples above actually give us a clue, but there
    is another source of inspiration as well. Do you remember that we started with
    substitution? We’ll walk through these examples in Racket, so that you can run
    each of them directly and check that they produce the same answer. Consider again
    this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Substituting `1`for `x` produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Substituting `f` produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, substituting `x`with `2`produces (note that there are no `x`s left
    in the program!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When you see it this way, it’s clear whythe later binding of `x`should have
    no impact: it’s a different `x`, and the earlier `x`has effectively already been
    substituted. Since we have agreed that substitution is how we want our programs
    to work, our job now is to make sure that the environment actually implements
    that correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do it is to recognize that the environment represents the substitutions
    waiting to happen, and just remember them. That is, our representation of a function
    needs to also keep track of the environment at the moment of function creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`[funV (var : Symbol) (body : Exp)` (nv : Env)`])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This new and richer kind of `funV`value has a special name: it’s called a closure.
    That’s because the expression is “closed” over the environment in which it was
    defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminology:A closedterm is one that has no unbound variables. The body of a
    function may have unbound variables—like `x`above—but the closure makes sure that
    they aren’t really unbound, because they can get their values from the stored
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Quote: “Save the environment! Create a closure today!” —[Cormac Flanagan](https://www.google.com/url?q=https://users.soe.ucsc.edu/~cormac/&sa=D&source=editors&ust=1695232021221610&usg=AOvVaw0ubwf31ENzplf9Txn7x4SS)
  prefs: []
  type: TYPE_NORMAL
- en: Quote:“Lambdas are relegated to relative obscurity until Java makes them popular
    by not having them.” —James Iry, [A Brief, Incomplete, and Mostly Wrong History
    of Programming Languages](https://www.google.com/url?q=http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html&sa=D&source=editors&ust=1695232021222322&usg=AOvVaw15zUkk_RscjegRPA01Zrxb)
  prefs: []
  type: TYPE_NORMAL
- en: 'That means, when we create a closure, we have to record the environment at
    the time of its creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[(lamE v b) (funV v b` nv`)]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when we use a function (represented by a closure), we have to make
    sure we use the storedenvironment, not the one present at the point of calling
    the function, which is the dynamic one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`[(funV v b` nv`)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to be clear: in the code above, the `nv`in the `funV`case intentionally
    shadowsthe `nv`bound at the top of the interpreter. Thus, the call to `extend`extends
    the environment from the closure, rather than the one present at the point of
    the call.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: Notice that the function and argument expressions (`f`and `a`, respectively)
    are evaluated in the environment given to the interpreter, not the one inside
    the closure. Is this correct? Or should they be using the closure’s environment?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do two things: argue from first principles or argue with examples.
    In the latter case, you would modify the interpreter to make the other choice.
    You would then use a sample input that produces different answers depending on
    which environment is used, indicate which one is correct (showing what the equivalent
    Racket program would produce can be a good argument), and use that to justify
    the chosen environment. Hint: One of these you will need to argue from first principles,
    the other you should be able to argue using a program.'
  prefs: []
  type: TYPE_NORMAL
- en: A Subtle Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples above, we always use the closure in the scope in which it was
    defined. However, our language is actually more powerful than that: we can returna
    closure and use it outside the scope in which it was defined. Here’s a sample
    Racket program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Do Now: Take a moment to read it carefully. What should it produce?
  prefs: []
  type: TYPE_NORMAL
- en: 'First we bind the `x`, then we evaluate the lambda. This creates a closure
    that remembers the binding to `x`. This closure is the value returned by this
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(`(let ([x 3])'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (y) (+ x y)))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This value is now applied to `4`. It’s legal to do this, because the value
    returned is a function. When we apply it to `4`, that evaluates the sum of `4`and
    `3`, producing `7`. Sure enough, translating this and sending it to our interpreter
    produces `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Here’s another test to try out, written as a Racket program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What does it produce in Racket? Translate it and try it in your interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: ••••• Syntactic Sugar •••••
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now seen the essence of a small core language. In practice, programming
    languages need to also be usable. To do this, they have to provide features that
    make programming convenient. We will see they can do this while minimizing their
    effort and pain.
  prefs: []
  type: TYPE_NORMAL
- en: How SMoL Becomes Large
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already been introduced to the idea of SImPl, the Standard Implementation
    Plan. The core idea is that the program’s syntax is represented as abstract syntax
    using a (mutually) recursive algebraic datatype, and we then write a similar (mutually)
    recursive program to process it. What that program produces depends on the process
    we are trying to implement: an interpreter produces values, a compiler produces
    programs(in another language), a type-checker produces judgments about type-correctness (and
    more, as we’ll soon see), and so on. But they all have the same basic structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, this means that a SImPl needs to have a case to handle each of
    the constructs in the language. This is not a problem in principle, but it can
    become onerous in practice. Suppose we have two constructs that have a lot of
    repetition. Not only does it mean we have to duplicate programming, it also means
    we have to duplicate maintenance: if we fix a bug in one, we have to remember
    to fix it in the other in the corresponding way.'
  prefs: []
  type: TYPE_NORMAL
- en: Redundancy in Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Where might we find such redundancy? There are several examples in real languages.
    For instance, many languages have both `for`and `while`loops. Consider a typical
    `for` loop in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, in fact, a general pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: is the same (with some syntactic liberties) as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now imagine you’re writing an interpreter for this. Clearly, the `while`loop’s
    implementation has to make several recursive calls, iterate, check, and perhaps
    perform some other bookkeeping (and maybe even manage temporary scope extensions).
    Allof that work has to be duplicatedfor `for`! Wouldn’t it be much simpler to
    instead implement it just once, and translate the `for`body into a `while` body?
  prefs: []
  type: TYPE_NORMAL
- en: Why have both constructs at all? Because each one is convenient for different
    purposes. In particular, there’s a certain stylistic use of `while`that would
    be harder to spot from a mass of `while`code that is automatically classified
    for us with `for`. It adds to our vocabulary as programmers. It just happens to
    also add to our pain as implementors. We’d like the convenience and richer vocabulary
    without the pain.
  prefs: []
  type: TYPE_NORMAL
- en: Desugaring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This introduces a distinction between a corelanguage and a surfacelanguage.
    The surface language may have various conveniences, but these get translated into
    the core language, whose constructs are all handled directly. The extra constructs—those
    that make it “sweeter” to program—are called syntactic sugar. The program that
    translates surface programs down to the core is called a desugarer, because it
    removes sugar. (In principle, a desugarer is actually a compilerfrom the surface
    language to the core language. However, since the core language is a sub-language
    of the surface, this is a very special case of compilation, and we find it useful
    to have a special term to distinguish it from general compilation. Just like we
    find it useful to have a special term to distinguish `for`from the general `while`…)
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside:In a real implementation, this compilation requires a little more care.
    Suppose you make an error using `for`, but the error was reported in terms of
    `while`: you’d be pretty confused, because you never did type the `while`. As
    a special case, you may be a student who doesn’t even know what `while` is! Modern
    desguaring systems, such as that in Racket, have special support to take care
    of this in most of the common cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually many more desugarings in real languages. For instance, `and`and
    `or`can desugar into nested `if`s. In JavaScript, `o.x`desugars into `o["x"]`(which
    will be relevant in a while). In many languages, `x += y`is sugar for `x = x +
    y`. In Python, `+`desugars into the method `__add__`. In fact, Python has a whole
    bunch of these desugarings; these methods are called “dunder” methods (short for
    double-underscore), and a whole programming style of “[protocols](https://www.google.com/url?q=https://twitter.com/gvanrossum/status/1307712322320785409&sa=D&source=editors&ust=1695232021233535&usg=AOvVaw2ERm9Pb0kR6LijXtV_K83D)”
    has evolved around it. Many languages (like Haskell and Python) have list comprehensions,
    which desugar into function and method calls. And so on. In short, desugaring
    is everywhere in programming. If you don’t notice it, that’s part of the point:
    it feels like you’re working with a larger surface syntax than the implementor
    has to manage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways in which desugaring can be implemented. One way is to parse
    the program normally, then rewrite the AST into a subset of the same AST. But
    in some languages, especially those with parenthetical syntax, there are two levels
    of parsing: the coarser parenthetical level and the finer level of ASTs. This
    means we can perform rewriting on the parenthetical terms, and the internal AST
    never needs to know about the sugars (i.e., it need cover only the core language).
    These are typically called macrosystems: systems in which program source (slightly
    abstracted) is rewritten into program source, before parsing takes place. It’s
    important to understand that mostlanguages have syntactic sugar, but very few languages
    have macro systems, which provide program rewriting capabilities directly to the
    programmer (as opposed to hiding them inside the compiler).'
  prefs: []
  type: TYPE_NORMAL
- en: Macros By Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Racket is one of the few languages to have a macro system, and in fact has a
    very powerful one. Its rarity means ideas we learn using macros will take some
    effort to port to other languages; but its power means we can write quite sophisticated
    systems by leveraging the full power of Racket, and we will do so. In essence,
    Racket macros compile an extended version of Racket—call it Racket++, if you like—down
    to Racket, where we can then exploit the full power of the existing Racket framework.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce the Racket macro system through a series of examples. In what
    follows, please switch to using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: because the restrictions and types of `plait`, while very useful for writing
    interpreters, can get in the way of some of what we’ll write.
  prefs: []
  type: TYPE_NORMAL
- en: A New Conditional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that Racket is a truthy/falsy language, where `if`takes any non-false
    value to be true. Suppose we want a strict `if`that takes only Booleans. That
    is, we want to extend Racket itself with a `strict-if`. Let’s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Try examples like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Seems to work as desired!
  prefs: []
  type: TYPE_NORMAL
- en: Do Now: Do you see what the problem is?
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we have an eager language (this is true of SMoL in general!),
    so `strict-if`s arguments are going to be evaluated before the body begins to
    execute. However, the whole point of a conditional is to avoid evaluating part
    of the evaluation: Try'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Compare this to what happens with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so we can’t use functions for this purpose. We need some other definition
    mechanism that consumes the syntax and rewrites that, instead of letting it evaluate
    right away. These are macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into how the macro is written, because it’s not so different from
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'What are the pieces? `define-syntax`says we’re defining a new piece of syntax(as
    opposed to a function). `syntax-rules`introduces a pattern-matcher (for now, ignore
    what the `()`means: but you do need to include it). Each rule, in brackets, is
    a pattern and output: if the input matches the pattern, then the desugarer (here
    called a macro expander) produces the corresponding output, but with the namesin
    the pattern (here, `C`, `T`, and `E`) copied as program source into the output.
    Thus, given'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: the above macro definition transforms it into
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: which then evaluates exactly as we’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: One nice feature of Racket is the Macro Stepper (![](image25.png)). It shows
    the program expanding step-by-step, which is useful both for understanding macros
    and debugging them. If necessary, change the “Macro hiding” option at the bottom-left
    to read “Standard”.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: Try it out with the above macro definition and use. See what you get.
    Observe how, at each step, it highlights the macro use about to be expanded followed
    by the result of that expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Note:The Macro Stepper is not an evaluator. It does not show the steps of evaluation,
    only the steps of expansion! Thus, if you write a program that will produce an
    error at run-time, the Macro Stepper does not show that error. It only shows syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: Local Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s look at the `let`bindings we’ve been using until now. Imagine we
    want to extend Racket with a `let1` construct: for example, we want'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: to evaluate to 6.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now:Can `let1` be defined as a function? Why or why not?
  prefs: []
  type: TYPE_NORMAL
- en: '`let1`can’t be a function. If it were, we would first try to evaluate each
    of the sub-terms as arguments. There are two things here that look like argument
    expressions: `(x 3)`and `(+ x x)`. Suppose we try to evaluate `(x 3)`. First of
    all, it looks like an application. Second, `x`isn’t even bound. Third, there is
    no meaningful “value” it could produce: its only job is instead to bind `x`. No,
    `let1` is also a new piece of syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminology:We will often refer to these new pieces of syntax as constructs(as
    in, “a new language construct”). In the Lisp/Scheme/Racket community, these are
    sometimes also called special forms, because they are syntactic forms with their
    own special rules for binding and evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: From now on we’ll use the prefix `my-` on our macros, because we don’t want
    to clash with the names of macros already built into Racket.
  prefs: []
  type: TYPE_NORMAL
- en: 'From what we’ve seen above, we can probably figure out half of the macro for
    `my-let1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: But what would it `expan`d into? We certainly couldjust expand it into the existing
    `let` construct in Racket, but there’s another interesting option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think about what `my-let1`does: it bindsa name to a value, and then immediately
    evaluatesits body in an environment extended by its name. Now, can we think of
    anything else that binds names to values? Yes, functions. And functions evaluate
    a body in an extended environment. When do functions evaluate their body? When
    they are applied to an argument. Therefore, we can express `my-let1` in terms
    of an anonymous function that is applied immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: will produce `6`. Use the Macro Stepper to see how!
  prefs: []
  type: TYPE_NORMAL
- en: Terminology:This pattern, of an anonymous function that is used right away,
    is commonly called left-left-lambda(where “left” stands for left-parenthesis).
    For a long time this remained an obscure term in the Lisp/Scheme community. But
    JavaScript made this pattern popular again under the name Immediately Invoked
    Function Expression (IIFE), because of problems with the handling of scope in
    earlier versions of the language. If you think the parentheses look bad here,
    look up some examples of IIFE on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Suppose we make a mistake in the macro and swap two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: What happens when we try to evaluate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '? Use the Macro Stepper to see what happened.'
  prefs: []
  type: TYPE_NORMAL
- en: Binding More Locals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have noticed in Racket, however, the `let` can bind many names at once,
    not only one. It becomes clear how: the function takes formal arguments, and is
    applied to just as many actual arguments. There can be as many as we want! But
    how do we express this in macro syntax?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, it’s common to use ellipses (…) to denote a sequence of arbitrary
    length. Therefore, it would be nice if we could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This would say, `my-let2`is followed by any number of `var`-`val`pairs, followed
    by a body. Turn that into a `lambda`with all the `var`s as formal arguments, whose
    body is `body`, applied to all the same `val`s as the actual argument expressions.
    We would use it like so (the extra parens are to help us group the bindings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, that is exactly the syntax supported by Racket! Try out the above
    program: run it, and also examine it in the Macro Stepper!'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Armed Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s one last example that clarifies what … means: it means “zero or more
    instances of the preceding pattern”. Using it, we can define our own multi-armed
    conditional. Suppose we want to define a function called `sign` that produces
    a string based on the sign of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Again, it’s clear that `my-cond` can’t be a function; we need to extend the
    language with a new construct, using a macro.
  prefs: []
  type: TYPE_NORMAL
- en: How many arms should our multi-armed conditional have? As many as the programmer
    wants, of course. We’ll further stipulate that if we have exhausted all the questions
    and none has yielded a true value, the “falling through” produces an error.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we want to peel off the first question-answer pair and evaluate the question.
    If it succeeds, we evaluate the answer. Otherwise, we want to recur on the remaining
    questions…which is essentially a smaller instance of `my-cond`. (That’s right,
    we’re recurring on syntax now!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `…`means “zero or more”, we end up with a pattern where we repeat a pattern:
    the first copy peels off the first instance, while the second, followed by a `…`,
    captures all the remaining instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise:Examine this code in detail. Try out the example above. It’s essential that
    you run this through the Macro Stepper: you’ll learn a lot about macros from this
    example!'
  prefs: []
  type: TYPE_NORMAL
- en: More on Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note:All the examples from this chapter you can find in a video on YouTube,
    so if you prefer, you can watch that instead: [More on Macros](https://www.google.com/url?q=https://youtu.be/2FK6jpAcX9Q&sa=D&source=editors&ust=1695232021251280&usg=AOvVaw2wCzzJcOXLR7zXUAetXhxF).
    Be sure to stop and reflect after each example, and try each of them out for yourself!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s start to look at various idiomatic aspects of using Racket macros.
    We’ll want this understanding under our belt because we’ll make use of several
    of these features. Here are five concrete things we’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: A convenience in definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A major and critical macro feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important idiom in truthy/falsy languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A peril in macro definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A push to generalize definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Definitional Convenience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Supposing we want to define a “one-armed `if`” (e.g., useful for checking erroneous
    conditions and proceeding only if the coast is clear): this is commonly called
    `unless`. We can write it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, we can use it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the pattern, we don’t have to repeat the `unless`; we can just
    use an `_` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Aside:The full truth is, this isn’t just a convenience. They actually do slightly
    different things that you can detect in subtle situations. You can safely, and
    should, just use `_` instead of repeating the name of the macro.
  prefs: []
  type: TYPE_NORMAL
- en: Name Capture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'But now, what if we use the above code in this kind of context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems problematic: it seems to expand into'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'which is pretty much the opposite of what we want. That’s because the `not`outside
    the macro seems to have captured the `not` inside the macro. This is roughly analogous
    to dynamic scope: any use context can modify what happens inside the abstraction.
    If this were true, it would be terrifying to be a macro writer!'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now: Run both versions. Do they produce the same answer?
  prefs: []
  type: TYPE_NORMAL
- en: 'But running the macro version makes clear that the name `not`is notbeing captured.
    Most of all, use the Macro Stepper to see how the expansion works. The important
    thing is that variables are more than just names; they record binding information,
    which keeps names introduced in different settings separate. They may print the
    same way, but internally Racket keeps them separate (and shows this separation
    in the Macro Stepper using colors). That is, it’s as if we start with this program:'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([not (λ (v) v)])
  prefs: []
  type: TYPE_NORMAL
- en: (unless false
  prefs: []
  type: TYPE_NORMAL
- en: (println 1)
  prefs: []
  type: TYPE_NORMAL
- en: (println 2)))
  prefs: []
  type: TYPE_NORMAL
- en: 'which, after expansion, turns into this program:'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([not (λ (v) v)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (not false)
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (println 1)
  prefs: []
  type: TYPE_NORMAL
- en: (println 2))
  prefs: []
  type: TYPE_NORMAL
- en: (void)))
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can easily keep the identifiers apart: the red notis different from
    the blue not. The actual internal representation is an efficient analog to colors.
    If necessary, the macro expander can also use distinct fresh (i.e., previously
    unused) names—`not1`, `not2`, etc.—to represent the different variables of the
    same name.'
  prefs: []
  type: TYPE_NORMAL
- en: This property, which recovers an analog of static scoping for macros, and is
    called hygiene. Hygiene is a critical feature for macros (and, notably, is one
    not given by the C pre-processor). It lets programmers use whatever name they
    want in the macro definition without worrying about what names will be bound in
    the use context; and similarly, lets users use whatever variable names they want
    without worrying about the macro’s code.
  prefs: []
  type: TYPE_NORMAL
- en: That said, you may wonder whether hygiene is just for built-in functions like
    `not`. We’ll see that it’s not. But to get there, we’ll work through some other
    idiomatic examples.
  prefs: []
  type: TYPE_NORMAL
- en: A Truthy/Falsy Idiom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unrelated to macros, here’s something we often see in truthy/falsy languages.
    Consider a two-arm `or`, which we can define as a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This works well enough for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'However, consider a function like `member`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When it succeeds, it doesn’t just return `true`, it returns the entire rest
    of the list (which is a truthy value). But if we combine this with `or-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is clearly not the result we want: we’ve lost the useful return value.
    Instead, here’s a different macro that returns rather than suppressing that result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This makes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: A Macro Definition Peril
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, this macro contains a subtle (almost hidden), important peril. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: That also returns a truthy value, but now we see the print twice. So we need
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Exercise: Confirm that this produces the correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Hygiene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This now works fine for the printing example. But now we have to worry about
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Using fresh names, there are two things this could expand into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Which does the macro version produce? That’s right, the latter: the one corresponding
    to'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v 1])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v false])
  prefs: []
  type: TYPE_NORMAL
- en: (if v
  prefs: []
  type: TYPE_NORMAL
- en: v
  prefs: []
  type: TYPE_NORMAL
- en: v)))
  prefs: []
  type: TYPE_NORMAL
- en: In other words, hygiene works just as well for local variables, not just for
    built-in functions! In other words, we have spent a whole bunch of time on something
    you don’t need to worry about. In return, it means you can use names with impunity
    in your macro programs, just as you do inside functions and methods because of
    static scoping.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, unlike the poor programmers stuck with their infix syntaxes and binary
    operators, parenthetical syntax programmers can generalize constructs to arbitrary
    arity. We’ve seen `…`already; let’s put it to work here to create an n-ary `or`.
    A natural first definition is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Do Now: However,  see what happens when we try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so that doesn’t work. It’s important to pay attention to the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'orN: bad syntax in: (orN)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This highlights the need for a base case. The problem is our definition above
    requires one or more sub-expressions: `e1`is the first, and `e2 …`means zero or
    more from the second position onward. But nothing covers the case of no sub-terms.
    So we need'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: and of course this works fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: The problem above appears to have been self-inflicted: why did we
    start with the pattern `(_ e1 e2 ...)`, which requires one-or-more (`e1`is the
    first, `e2 …`is zero or more)? We should have just written `(_ e...)`instead,
    which would be zero-or-more! Rewrite the `orN` macro using this pattern: can you
    make it work?'
  prefs: []
  type: TYPE_NORMAL
- en: ••••• Objects •••••
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects—the bundling of data with operations over them—are a generalization
    of closures. Many languages have objects, but in a variety of different forms.
  prefs: []
  type: TYPE_NORMAL
- en: A Standard Model of Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we’re ready to start looking at our first major language feature that goes
    beyond SMoL: objects. Not all SMoL languages have objects; though many do, they
    have them in very different ways. Nevertheless, what we will see is that there
    is a fairly uniform way to think about objects across all these languages, and
    furthermore this way of thinking really builds on our understanding of SMoL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When building the essence of objects, though, we now have a choice: we can
    do it either in the core or through syntactic sugar. The former is frustrating
    in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to do more low-level bookkeeping (e.g., with environments) that may
    not necessarily be instructive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter gets larger and more unwieldy, because all the new constructs
    go in the same place rather than each being independent definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of all: it becomes a lot harder to write illustrative programs and tests,
    because the core language may not have all the features we need to make this convenient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In contrast, all these problems go away if we use syntactic sugar instead.
    Therefore, even though a real implementation may well have at least parts of objects
    (especially the parts needed for efficiency) in the core language, we are going
    to build objects entirely through desugaring, using macros. In fact, in this book,
    we will do something even simpler: we will give concrete examples of what programs
    desugar to. Figuring out the general desugaring will be left as an exercise for
    you. To aid in that process, we will write code in as stylized a form as possible,
    not using any short-cuts that might obscure the macro rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Note:The programs in this section cannot be written in the language `plait`.
    Instead, we will use  `#lang racket`, which does not perform static type-checking.
    Add the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: at the top to access the testing operator and printing control parameter from
    `plait`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:Spot the point at which the type-checker would become problematic.
    Hint:The easiest way is, of course, to keep using `#lang plait` until you run
    into a problem. Make sure you understand what the problem is!
  prefs: []
  type: TYPE_NORMAL
- en: What is an Object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central question we must answer, before we start thinking about implementations,
    is what an object is. There is a lot of variation between languages, but they
    all seem to agree that an object is
  prefs: []
  type: TYPE_NORMAL
- en: a value, that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maps names to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'stuff: either other values or “methods”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a minimalist perspective, methods seem to be just functions, and since
    we already have those in the language, we can put aside this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology:We will use the term member to refer to a generic entry in an object,
    when we don’t want to make a distinction between fields and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we capture this? An object is just a value that dispatches on a given
    name. For simplicity, we’ll use `lambda`to represent the object and Racket’s `case` construct
    to implement the dispatching. Here’s an object that responds to either add1 or
    sub1, and in each case returns a function that either increments or decrements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We would use this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Aside:Observe that basic objects are a generalization of `lambda`to have multiple
    “entry-points”. Conversely, a `lambda`is an object with only one entry-point;
    therefore, it doesn’t need a “method name” to disambiguate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, writing method invocations with these nested function calls is unwieldy
    (and is about to become even more so), so we’d be best off equipping ourselves
    with a convenient syntax for invoking methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables us to rewrite our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside:We’ve taken advantage of Racket’s variable-arity syntax: `. a`says “bind
    all the remaining—zero or more—arguments to a list named `a`”. The `apply` function
    “splices” in such lists of arguments to call functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe something very subtle about our language: nothing precludes us from
    writing an arbitrary expression in the second position of a call to `msg`. That
    is, we can compute which member we want to access. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This is unlike many languages with objects, which force you to write the literal
    name of the member (e.g., in Java, in most cases). We’ll return to this later!
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside:This is a general problem with desugaring: the target language may allow
    expressions that have no counterpart in the source, and hence cannot be mapped
    back to it. Fortunately we don’t often need to perform this inverse mapping, though
    it does arise in some debugging and program comprehension tools. More subtly,
    however, we must ensure that the target language does not produce values that
    have no corresponding equivalent in the source.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have basic objects, let’s start adding the kinds of features we’ve
    come to expect from most object systems.
  prefs: []
  type: TYPE_NORMAL
- en: The “Object” Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can consolidate what we have written above as the “object” pattern: code
    that looks like'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A constructor is simply a function that is invoked at object construction time.
    We currently lack such a feature, but by turning an object from a literal into
    a function that takes constructor parameters, we achieve this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we pass 5 as the constructor’s argument, so adding 3 yields
    8\. The second is similar, and shows that the two invocations of the constructors
    don’t interfere with one another (just as we would expect from static scope).
  prefs: []
  type: TYPE_NORMAL
- en: The “Class” Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve actually made quite a momentous change with this small addition: we’ve
    gone from objects to functions-that-make-objects (notice the object pattern inside
    the function). But traditionally, what makes objects? Classes! And classes typically
    have constructors. So in the process of introducing constructors, we have actually
    also shifted from objects to classes. The “class” pattern, at its simplest, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people believe that objects primarily exist to encapsulate state.
  prefs: []
  type: TYPE_NORMAL
- en: Aside:Curiously, Alan Kay, who won a Turing Award for inventing Smalltalk and
    modern object technology, disagrees. In [The Early History of Smalltalk](https://www.google.com/url?q=http://worrydream.com/EarlyHistoryOfSmalltalk/&sa=D&source=editors&ust=1695232021277736&usg=AOvVaw2Jq9XZtuuo6438N_xh50ZK),
    he says, “[t]he small scale [motivation for OOP] was to find a more flexible version
    of assignment, and then to try to eliminate it altogether”. He adds, “It is unfortunate
    that much of what is called ‘object-oriented programming’ today is simply old
    style programming with fancier constructs. Many programs are loaded with ‘assignment-style’
    operations now done by more expensive attached procedures.”
  prefs: []
  type: TYPE_NORMAL
- en: 'We certainly haven’t lost that ability. If we desugar to a language with variables,
    we can easily have multiple methods mutate common state, such as a constructor
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We have changed the name to `mk-o-…` to reflect the fact that this is an object-maker,
    i.e., analogous to a class. For instance, we can test a sequence of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'and also notice that mutating one object doesn’t affect another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Private Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common object language feature is private members: ones that are visible
    only inside the object, not outside it.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside: Except that, in Java, instances of other classes of the same type are
    privy to “private” members. Otherwise, you would simply never be able to implement
    an Abstract Data Type. Note that classes are not Abstract Data Types!
  prefs: []
  type: TYPE_NORMAL
- en: 'These may seem like an additional feature we need to implement, but we already
    have the necessary mechanism in the form of locally-scoped, lexically-bound variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The code above uses lexical scoping to ensure that `count`remains hidden to
    the world. Trying to access `count` directly from the outside will fail.
  prefs: []
  type: TYPE_NORMAL
- en: A Refined “Class” Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this change, we can now refine our pattern for classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'which we can also write as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We’ll see in a moment why we might want to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Static Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another feature often valuable to users of objects is static members: those
    that are common to all instances of the same type of object. This, however, is
    merely a lexically-scoped identifier (making it private) that lives outside the
    constructor (making it common to all uses of the constructor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to keep a count of how many instances of a kind of object are
    created. This count cannot be inside any one of those objects, because they would
    not “know” about each other; rather, the constructor needs to keep track of this.
    This is the role of static members, and the variable `counter` plays this role
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We’ve written the counter increment where the “constructor” for this object
    would go, though it could just as well be manipulated inside the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it, we should make multiple objects and ensure they each affect the
    global count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'It is productive to see how this program runs through the Stacker. For simplicity,
    we can ignore most of the details and focus just on the core static pattern. Here
    is a Stacker-friendly translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Run this and see how the static member works!
  prefs: []
  type: TYPE_NORMAL
- en: A Re-Refined “Class” Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can refine our pattern for classes even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Put differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Statics, as defined here, are accessed through objects. However,
    statics by definition belong to a class, not to objects, and hence should be accessible
    through the class itself—for instance, even if no instances of the class have
    ever been created. (In the working example above, one should be able to access
    the count when it is still `0`.) Modify the pattern above to respect this by making
    static members be accessible directly through the class rather than through objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Objects with Self Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, our objects have simply been packages of named functions: functions
    with multiple named entry-points, if you will. We’ve seen that many of the features
    considered important in object systems are actually simple patterns over functions
    and scope, and have indeed been used—without names assigned to them—for decades
    by programmers armed with lambdas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that the different members are actually independent of each
    other: they can’t, for instance, directly reference one another. This is too limiting
    for a true object system, where a method has a way of referencing the object it
    is part of so that it can use other members of that object. To enable this, many
    object systems automatically equip each object with a reference to itself, often
    called `self`or `this`. Can we implement this?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: I prefer this slightly dry way of putting it to the anthropomorphic
    “knows about itself” terminology often adopted by object advocates. Indeed, note
    that we have gotten this far into object system properties without ever needing
    to resort to anthropomorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: Self-Reference Using Mutation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yes, we can! This relies on a pattern that sets up the name for the recursive
    reference, then uses that to create the body that will employ the recursion, and
    finally uses mutation to make the name refer to the defined body. For simplicity,
    we will go back to the object pattern, ignoring the class-related features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test it by having `first`invoke `second`. Sure enough, this produces
    the expected answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the above program translated into the simpler smol/fun language. Once
    translated, we can run it in the Stacker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Run it for yourself! What do you learn from it? Do you see how `self` works?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:This change to the object pattern is essentially independent of the
    class pattern. Extend the class pattern to include self-reference.
  prefs: []
  type: TYPE_NORMAL
- en: Self-Reference Without Mutation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s another pattern we can use that avoids mutation, which is to send the
    object itself as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Each method now takes `self` as an argument. That means method invocation must
    be modified to follow this new pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: That is, when invoking a method on `o`, we must pass `o` as a parameter to the
    method. Notice that we did not do any such thing when invoking a function! This
    distinguishes functions and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, this approach is dangerous because we can potentially pass a different
    object as the “self”. Exposing this to the developer is therefore probably a bad
    idea; if this implementation technique is used, it should only be done in desugaring.
    (Unfortunately, Python exposes exactly this in its surface syntax.) Sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic Dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we should make sure our objects can handle a characteristic attribute
    of object systems, which is the ability to invoke a method without the caller
    having to know or decide which object will handle the invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a binary tree data structure, where a tree consists of either
    empty nodes or leaves that hold a value. In traditional functions, we are forced
    to implement some form of conditional—such as a `type-case`—that exhaustively
    lists and selects between the different kinds of trees. If the definition of a
    tree grows to include new kinds of trees, each of these code fragments must be
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic dispatch solves this problem by making that conditional branch disappear
    from the user’s program and instead be handled by the method selection code built
    into the language. The key feature that this provides is an extensible conditional.
    This is one dimension of the extensibility that objects provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first define our two kinds of tree objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'With these, we can make a concrete tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Observe that both in the test case and in the `sum`method of `node`, there is
    a reference to `’sum`without checking whether the recipient is a `mt`or `node`.
    Instead, the language’s run-time systemextracts the recipient’s `sum` method and
    invokes it. This conditional missing from the user’s program, and handled automatically
    by the language,  is the essence of dynamic dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that we didn’t have to change our pattern to add dynamic dispatch;
    it simply followed as a result of the rest of the design.
  prefs: []
  type: TYPE_NORMAL
- en: Aside:This property—which appears to make systems more black-box extensible
    because one part of the system can grow without the other part needing to be modified
    to accommodate those changes—is often hailed as a key benefit of object-orientation.
    While this is indeed an advantage objects have over functions, there is a dual
    advantage that functions have over objects, and indeed many object programmers
    end up contorting their code—using the Visitor pattern—to make it look more like
    a function-based organization. Read [Synthesizing Object-Oriented and Functional
    Design to Promote Re-Use](https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&sa=D&source=editors&ust=1695232021299288&usg=AOvVaw3CC6NAYK9gN3UxWzQtILYg)for
    a running example that will lay out the problem in its full glory. Try to solve
    it in your favorite language, and see the [Racket solution](https://www.google.com/url?q=http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml&sa=D&source=editors&ust=1695232021299768&usg=AOvVaw1BZuSy7k1EJ8XRqphKUm57).
  prefs: []
  type: TYPE_NORMAL
- en: What Else do Objects Have?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Member Name Design Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will focus on the names of members (a term we use to not distinguish
    between fields and methods). Also, let’s set aside the distinction between classes
    and objects for a moment: whether through classes or not, we eventually end up
    with objects, which programs use. So the two questions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the set of member names statically fixed, or can it be changed dynamically?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the member being accessed at a point statically fixed, or can it be computed
    dynamically?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This gives us a 2x2 table, and it’s worthwhile to ask whether each cell makes
    sense (and whether we’ve seen it in any real languages). We get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Name is Static | Name is Computed |'
  prefs: []
  type: TYPE_TB
- en: '| Fixed Set of Members | As in base Java. | As in Java with reflection to compute
    the name. |'
  prefs: []
  type: TYPE_TB
- en: '| Variable Set of Members | Difficult to envision (what use would it be?).
    | Most “scripting” languages. |'
  prefs: []
  type: TYPE_TB
- en: 'Only one case does not quite make sense: if the member being accessed must
    be fixed in the source program, then the set of names is pre-decided, so it doesn’t
    seem to make sense to be able to dynamically change the set of members (new members
    would not be accessible, while deleted members would cause some existing accesses
    might fail). All other points in this design space have, however, been explored
    by languages.'
  prefs: []
  type: TYPE_NORMAL
- en: The lower-right quadrant corresponds closely with languages that use hash-tables
    to represent objects. Then the name is simply the index into the hash-table. Some
    languages carry this to an extreme and use the same representation even for numeric
    indices, thereby (for instance) conflating objects with dictionaries and even
    arrays. Even when the object only handles “member names”, this style of object
    creates significant difficulty for type-checking and is hence not automatically
    desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in the rest of this section, we will stick with “traditional” objects
    that have a fixed set of names and even static member name references (the top-left
    quadrant). Even then, we will find there is much, much more to study.
  prefs: []
  type: TYPE_NORMAL
- en: What (Goes In) Else?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, our case statements have not had an `else`clause. One reason to
    do so would be if we had a variable set of members in an object, though that is
    probably better handled through a different representation than a conditional:
    a hash-table, for instance, as we’ve discussed above. In contrast, if an object’s
    set of members is fixed, desugaring to a conditional works well for the purpose
    of illustration (because it emphasizesthe fixed nature of the set of member names,
    which a hash table leaves open to interpretation—and also error). There is, however,
    another reason for an `else`clause, which is to “chain” control to another, parent,
    object. This is called inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to our model of desugared objects. To implement inheritance, the
    object must be given “something” to which it can delegate method invocations that
    it does not recognize. A great deal will depend on what that “something” is.
  prefs: []
  type: TYPE_NORMAL
- en: 'One answer could be that it is simply another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Due to our representation of objects, this application effectively searches
    for the member in the parent object (and, presumably, recursively in its parents).
    If a member matching the name is found, it returns through this chain to the original
    call in `msg` that sought the member. If none is found, the final object presumably
    signals a “message not found” error.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:If you know what an l-value is, then you might notice that the application
    `(parent-object m)`is like “half a `msg`”, just like an l-value was “half a value
    lookup”. Is there any connection?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this by extending our trees to implement another method, `size`.
    We’ll write an “extension” (you may be tempted to say “sub-class”, but hold off
    for now!) for each `node`and `mt`to implement the `size`method. We intend these
    to extend the existing definitions of `node`and `mt`, so we’ll use the extension
    pattern described above. In other words, if we previously had the rough equivalent
    of this Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'now we want to extend it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside: We’re not editing the existing definitions because that is supposed
    to be the whole point of object inheritance: to reuse code in a black-box fashion.
    This also means different parties, who do not know one another, can each extend
    the same base code. If they had to edit the base, first they have to find out
    about each other, and in addition, one might dislike the edits of the other. Inheritance
    is meant to sidestep these issues entirely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: Relatedly, read about the [fragile base class problem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Fragile_base_class&sa=D&source=editors&ust=1695232021308845&usg=AOvVaw0jUQoyWZ_AaVZEFstRRSte).'
  prefs: []
  type: TYPE_NORMAL
- en: A Java Excursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first understand what’s going on in Java. For simplicity, let’s use a
    canonical “2d point” and “3d point” example. We’ll start with this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make instances of it easily enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'and this prints the expected output. Now suppose we extend this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This won’t even compile. We will get a somewhat strange-looking error. The error
    is because Java is expecting to make an instance of `Pt2`as well, but we have
    not told it how to. In the absence of anything else, it invokes a “default constructor”,
    which takes noparameters (because Java has no way of knowing which parameters
    to pass). If we modify `Pt2` to instead be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: then we find that the program compiles and, if we change `Main` suitably,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'it runs, but perhaps without the effect we were expecting. The solution, in
    Java terms, is to explicitly invoke the constructor of the super-class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'but this won’t work either: Java expects the `super`invocation to be the first thing
    in the sub-class’s constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the error message above reveals, hidden in the constructor of the extended
    class is lurking something important: it tries to create an instanceof the super-class,
    just as if we had written `new Pt2`. This is entirely masked by the syntactic
    sugar of `super`. The actual `Pt2` instance is hidden out of sight, and it takes
    a little effort to coax it into view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it, let’s first add some instance variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve purposely made the instance variables have values that look different
    from those of the parameters, so that when we try to examine them, we can tell
    them apart. Now let’s modify the constructor to make two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Twoobjects…how many objects did we really make? Well, we made at least two,
    because adding
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: to the constructor shows that there are two different objects with two different
    values for `x`. So far, so unsurprising.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I’ve claimed that there are two more objects, of type `Pt2`. Can we
    seethem? Yes, in fact, we can. The problem is that they’re of type `Pt2`, and
    what we have are `Pt3`objects. We can’t just make a `Pt2`, because that doesn’t
    reveal the hidden `Pt2`. But in fact the Java type system lets us get to the `Pt2`by
    casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: And that’s how we can see that there are actually two `Pt2` objects lurking
    as well!
  prefs: []
  type: TYPE_NORMAL
- en: Extending Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have to port all this code over to our world of desugaring. Is this the
    constructor pattern?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: That suggests that the parent is at the “same level” as the object’s constructor
    fields. That seems reasonable, in that once all these parameters are given, the
    object is “fully defined”. However, we also still have
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The crucial issue here is that we need to make twoobjects: one of `node/size`and
    one more of `node`. We could imagine a protocol where the user of `node/size`constructs
    a `node`object and passes it to `node/size`, but in doing so, they could make
    any number of mistakes. Alternatively, we can leave it to `node/size`to invoke
    node, and keep track of the object constructed through this process. That is,
    `node/size`’s parent parameter should not be the parent objectbut rather the parent
    object’s maker.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the object constructor must remember to pass the parent-object maker on
    every invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside:Note the repeated pattern of invoking the “super” class: e.g., `(mt/size
    mt)`. We would instead want to do this just once. Essentially, this binding of
    `mt/size`to `mt`is precisely what the `extends` clause of Java does. We could
    simulate that here, but later in this chapter we’ll see a much more elegant way
    of achieving this end while also making programming with classes much more flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm that both the old and new tests still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Exercise: Rewrite this block of code using self-application instead of mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have done is capture the essence of a class. Each function parameterized
    over a parent is...well, it’s a bit tricky, really. Let’s call it a class extension—we’ll
    soon see why. A class extension corresponds to what a Java programmer defines
    when they write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Exercise: So why are we going out of the way to not call it a “class”?
  prefs: []
  type: TYPE_NORMAL
- en: When a developer invokes a Java class’s constructor, it in effect constructs
    objects all the way up the inheritance chain (in practice, a compiler might optimize
    this to require only one constructor invocation and one object allocation). These
    are effectively “personal” copies of the objects corresponding to the parent classes
    (personal, that is, up to the presence of static members). There is, however,
    a question of how much of these objects is visible. Java chooses that—unlike in
    our implementation above—only one method of a given name (and signature) remains,
    no matter how many there might have been on the inheritance chain, whereas every
    field remains in the result, and can be accessed by casting. The latter makes
    some sense because each field presumably has invariants governing it, so keeping
    them separate (and hence all present) is wise. In contrast, it is easy to imagine
    an implementation that also makes all the methods available, not only the ones
    lowest (i.e., most refined) in the inheritance hierarchy. Many scripting languages
    take the latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise:The code above is not what we would reallywant as programmers. The
    self-reference is to the same syntactic object, whereas it needs to refer to the
    most-refined object: this is known as open recursion. Modify the object representations
    so that self always refers to the most refined version of the object. Hint: You
    will find the self-application method (Self-Reference Without Mutation) of recursion
    handy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside:This demonstrates the other form of extensibility we get from traditional
    objects: extensible recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our description above, we’ve supplied each class with a description of its
    parent class. Object construction then makes instances of each as it goes up the
    inheritance chain. There is another way to think of the parent: not as a class
    to be instantiated but, instead, directly as an object itself. Then all children
    with the same parent would observe the very same object, which means changes to
    it from one child object would be visible to another child. The shared parent
    object is known as a prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside:The archetypal prototype-based language is [Self](https://www.google.com/url?q=http://selflanguage.org/&sa=D&source=editors&ust=1695232021325680&usg=AOvVaw34T7y09URpNkHh7uTLFlXk).
    Though you may have read that languages like JavaScript are “based on” Self, there
    is value to studying the idea from its source, especially because Self presents
    these ideas in their purest form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some language designers have argued that prototypes are more primitive than
    classes in that, with other basic mechanisms such as functions, one can recover
    classes from prototypes—but not the other way around. That is essentially what
    we have done above: each “class” function contains inside it an object description,
    so a class is an object-returning-function. Had we exposed these as two different
    operations and chosen to inherit directly an object, we would have something akin
    to prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: Modify the inheritance pattern above to implement a Self-like, prototype-based
    language, instead of a class-based language. Because classes provide each object
    with distinct copies of their parent objects, a prototype-language might provide
    a “clone” operation to simplify creation of the operation that simulates classes
    atop prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you might ask, why is there only one fall-through option? It’s easy to generalize
    this to there being many, which leads naturally to multiple inheritance. In effect,
    we have multiple objects to which we can chain the lookup, which of course raises
    the question of what order in which we should do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be bad enough if the ascendants were arranged in a tree, because even
    a tree does not have a canonical order of traversal: take just breadth-first and
    depth-first traversal, for instance (each of which has compelling uses). Worse,
    suppose a blob A extends B and C; but now suppose B and C each extend D. Now we
    have to confront this question: will there be one or two D objects in the instance
    of A? Having only one saves space and might interact better with our expectations,
    but then, will we visit this object once or twice? Visiting it twice should not
    make any difference, so it seems unnecessary. But visiting it once means the behavior
    of one of B or C might change. And so on. As a result, virtually every multiple-inheritance
    language is accompanied by a subtle algorithm merely to define the lookup order.'
  prefs: []
  type: TYPE_NORMAL
- en: This infamous situation is called the [“diamond problem”](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Multiple_inheritance&sa=D&source=editors&ust=1695232021327121&usg=AOvVaw33E5ifiPPmd1ChrRegan9z) (or
    even, “the Deadly Diamond of Death”!). If you choose to include multiple inheritance
    in your language you can lose yourself for days in design decisions on this. Because
    it is highly unlikely you will find a canonical answer, your pain will have only
    begun. Multiple inheritance is only attractive until you’ve thought it through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class Extensions: Mixins and Traits'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we write `class`in Java, what are we really defining between the opening
    and closing braces? It is not the entire class: that depends on the parent that
    it extends, and so on recursively. Rather, what we define inside the braces is
    a class extension. It only becomes a full-blown class because we also identify
    the parent class in the same place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we should ask: Why? Why not separate the act of definingan extension
    from applying the extension to a base class? That is, suppose instead of'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'we instead write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: and separately
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: where `B` is some already-defined class?
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far, it looks like we’ve just gone to great lengths to obtain what we
    had before. However, the function-application-like syntax is meant to be suggestive:
    we can “apply” this extension to several different base classes. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'and so on. What we have done by separating the definition of `E`from that of
    the class it extends is to liberate class extensions from the tyranny of the fixed
    base class. We have a name for these extensions: they’re called mixins.'
  prefs: []
  type: TYPE_NORMAL
- en: Mixins make class definition more compositional. They provide many of the benefits
    of multiple-inheritance (reusing multiple fragments of functionality) but within
    the aegis of a single-inheritance language (i.e., no complicated rules about lookup
    order). Observe that when desugaring, it’s actually quite easy to add mixins to
    the language. A mixin is just a “function over classes”. Because we have already
    determined how to desugar classes, and our target language for desugaring also
    has functions, and classes desugar to expressions that can be nested inside functions,
    it becomes almost trivial to implement a simple model of mixins.
  prefs: []
  type: TYPE_NORMAL
- en: Aside:This is a case where the greater generality of the target language of
    desugaring can lead us to a better construct, if we reflect it back into the source
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a typed language, a good design for mixins can actually improve object-oriented
    programming practice. Suppose we’re defining a mixin-based version of Java. If
    a mixin is effectively a class-to-class function, what is the “type” of this “function”?
    Clearly, mixins ought to use interfacesto describe what they expect and what they
    provide. Java already enables (but does not require) the latter, namely classes
    can say what interfaces they provide. However, it does not enable the former,
    namely specifying its parent as an interface: a class (extension) in Java extends
    its parent class—with all the parent’s members visible to the extension—rather
    than an interface that stands forthe parent (or any other class that matches that
    same interface). That means it obtains all of the parent’s behavior, not a specification
    thereof. In turn, if the parent changes, the class might break. Mixins help break
    this asymmetry between extension and provision.'
  prefs: []
  type: TYPE_NORMAL
- en: In a mixin language, we can instead write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'where `I1`and `I2` are interfaces. Then `M`can only be applied to a class that
    satisfies the interface `I1`, and in turn the language can ensure that only members
    specified in` I1`are visible in `M`. This becomes directly analogous to how a
    client of `M`can only see what is provided by `I2`, and follows one of the important
    principles of good software design:'
  prefs: []
  type: TYPE_NORMAL
- en: Quote: “Program to an interface, not an implementation.” —[Design Patterns](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Design_Patterns&sa=D&source=editors&ust=1695232021331399&usg=AOvVaw0oLqFKll63oSL1E3kTxWev)
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, a mixin is a class that has been turned into a function over parent
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'A good design for mixins can go even further. A class can only be used once
    in an inheritance chain, by definition (if a class eventually referred back to
    itself, there would be a cycle in the inheritance chain, causing potential infinite
    loops). In contrast, when we compose functions, we have no qualms about using
    the same function twice (e.g.: `(map ... (filter ... (map ...))))`. Is there value
    to using a mixin twice?'
  prefs: []
  type: TYPE_NORMAL
- en: Aside:There certainly is! See sections 3 and 4 of [Classes and Mixins](https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/&sa=D&source=editors&ust=1695232021332340&usg=AOvVaw2wOohANSHEwTtdW3WtYZHP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixins solve an important problem that arises in the design of libraries. Suppose
    we have a dozen different features which can be combined in different ways. How
    many classes should we provide? Furthermore, not all of these can be combined
    with each other. It is obviously impractical to generate the entire combinatorial
    explosion of classes. It would be better if the developer could pick and choose
    the features they care about, with some mechanism to prevent unreasonable combinations.
    This is precisely the problem that mixins solve: they provide the class extensions,
    which the developers can combine, in an interface-preserving way, to create just
    the classes they need.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside:Mixins are used extensively in the Racket GUI library. For instance, `color:text-mixin` consumes
    basic text editor interfaces and implements the colored text editor interface.
    The latter is itself a basic text editor interface, so additional basic text mixins
    can be applied to the result.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: How does the analogous library in your favorite object-oriented language
    solve this same problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixins do have one limitation: they enforce a linearity of composition. This
    strictness is sometimes misplaced, because it puts a burden on programmers that
    may not be necessary. A generalization of mixins called traits says that instead
    of extending a single mixin, we can extend a set of them. Of course, the moment
    we extend more than one, we must again contend with potential name-clashes. Thus
    traits must be equipped with mechanisms for resolving name clashes, often in the
    form of some name-combination algebra. Traits thus offer a nice complement to
    mixins, enabling programmers to choose the mechanism that best fits their needs.
    As a result, Racket provides both mixins and traits.'
  prefs: []
  type: TYPE_NORMAL
- en: ••••• Types •••••
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types that are checked before program execution—what are known as static types—are
    a vital part of programming, and a growing number of languages either have them
    from the start or, realizing their importance, are adding them in various forms.
    Types are a common first step towards proving properties about programs. If you
    use a typed language, you write small proofs about your programs every day, whether
    you realize it or not.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re done with objects. Why weren’t objects in SMoL?
  prefs: []
  type: TYPE_NORMAL
- en: Not all languages have them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ones that do have them can’t seem to agree on the details (classes versus
    prototypes, single- versus multiple-inheritance, classes versus traits and mixins,
    etc.). There’s very little “standard” there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can add most notions through desugaring!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we move on to types. We will always use the term typeto refer to a static check,
    i.e., one that can be done purely with the program source. This means types cannot
    refer to dynamic conditions, and may suffer from either false-positive or false-negative
    errors (e.g., something that is in the code but can never run in practice may
    still cause a type error); in return, they give us guarantees without ever having
    to run the program. This is important when the program is expensive to run, impossible
    (e.g., it depends on conditions that can’t be reproduced by the developer), or
    dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types aren’t really a part of SMoL either, but not because we can add them
    through desugaring (which we can’t); rather, it’s for the first two reasons: many
    languages don’t have them, and those that do don’t often agree on their form (in
    large part because of their disagreement over the nature of objects). However,
    there are parts they do (largely) agree on, which we will begin with.'
  prefs: []
  type: TYPE_NORMAL
- en: A Standard Model of Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Types can be thought of as abstractions of run-time values. That is, whereas
    at run-time we can have a very large number of numbers and strings and images
    (and two Booleans), we will collapse the distinctions withinthese and preserve
    only the distinctions between them. Therefore, it is instructive to start with
    a basic interpreter and try to build a type checker from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see what needs to happen with a type-checker. The label on the tin
    says “checker”: that is, the job of a type-checker is to pass judgment on programs,
    i.e., to determine whether or not they are type-correct. Thus, a natural type
    (for the type checker) would be'
  prefs: []
  type: TYPE_NORMAL
- en: '`(tc : (Exp ->` Boolean`))`'
  prefs: []
  type: TYPE_NORMAL
- en: '(In practice, of course, we would want more information in case the program
    is not type-correct, i.e., we’d like an error diagnostic. But we’re ignoring human
    factors considerations here.) With this type, we can now rewrite the relevant
    parts of the interpreter above:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (`tc` e)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '`       [(plus) (`and` (`tc` l) (`tc` r))])]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[(numE v)` #true`]))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(test (`tc`(binE (plus) (numE 5) (numE 6)))` #true`)`'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, let’s peer at this for a moment. Given a number, the type-checker
    returns `#true`. In the recursive cases, it computes the `and`of type-checking
    the pieces. And that’s it. Since there is no way to return `#false`, the entire
    type-checker must always only return `#true`. That is, every program is type-correct.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is because we have only one type, numbers, and only one operation,
    also on numbers, so what could possibly go wrong? We need to extend the types
    and operations so that there are meaningful possibilities for errors. Therefore,
    suppose we add a `++` operation that concatenates strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '`[plus]` [++]`)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[strE (value : String)]`)`'
  prefs: []
  type: TYPE_NORMAL
- en: Various things break, and need to be fixed. How about this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[(++)   (and (tc l) (tc r))]`)]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[(strE v) #true]`))`'
  prefs: []
  type: TYPE_NORMAL
- en: '(test (tc (binE (++) (strE "hello") (strE "world"))) #true)'
  prefs: []
  type: TYPE_NORMAL
- en: So this looks pretty good, right?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now: This is not at all what we want! Write a test case that demonstrates
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two tests that demonstrate desirable behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The first string-concatenates two numbers, the second adds two strings. Therefore,
    both should be rejected by the type-checker. Yet both of them pass (i.e., the
    tests above fail).
  prefs: []
  type: TYPE_NORMAL
- en: What is the core problem here? It’s that, given an expression, we only know
    whetherits sub-expressions typed correctly, but not whattheir types are.  That
    is insufficient to determine whether the current expression is type-correct. For
    instance, the `++` operator needs to check not only whether its two sub-expressions
    are well-typed, but also whether they produced strings; if they did not, then
    the concatenation is erroneous.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this shows is that we need the type-checker to have a richer type: it
    must instead be'
  prefs: []
  type: TYPE_NORMAL
- en: '`(tc : (Exp ->` Type`))`'
  prefs: []
  type: TYPE_NORMAL
- en: That is, the type “checker” must actually be a type calculator, i.e., it even
    more closely parallels the evaluator, just over the universe of abstracted values
    (types) rather than concrete ones. Following convention, however, we’ll continue
    to call it a checker, because it also checks in the process of calculating types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the type declaration above, `Type` is a new (`plait` type) definition that
    records the possible types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can rewrite our type-“checker”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three take-aways from this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type-checker follows the same implementation schema as the interpreter:
    an algebraic datatype to represent the AST, and structural recursion to process
    it. This is the schema we’re calling SImPl.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A type-checker, unlike an interpreter, operates with “weak” values: note, for
    instance, how the `numE` case ignores the actual numeric values. Both the strengths
    and weaknesses of traditional type-checking arise from this ignorance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In mathematical terms, the upgrade we performed in going from a type-checker
    to a type-calculator was a process of strengthening the inductive hypothesis:
    instead of returning only a `Boolean`, we had to return the actual type of each
    expression. This may not seem like a literal strengthening; but it is inasmuch
    as the former `#true`has been replaced by a `Type`and the `#false` by an error.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise: Add division to the language and type-check it.
  prefs: []
  type: TYPE_NORMAL
- en: A Concise Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we extend our type system, it is increasingly unwieldy to write everything
    out as code. Instead, we will adopt a notation commonly used in the world of types
    (though it can also be used for interpreters and other SImPl programs). We will
    write terms of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'where the `e`are expressions, `T`are types, and `:` is pronounced as “has type”:
    i.e., the notation above says “`e`has type `T`”. For now we won’t pronounce `|-` as
    anything at all; later, we will see that it should be read as “proves”.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can very concisely say that all numeric expressions have numeric
    type and all string expressions have string type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: where `n`stands for all the syntactic terms with the syntax of numbers, and
    `s` likewise for strings. (We can think of this as an infinite number of rules,
    one for each number and each string. We’re in the realm of mathematics, so what’s
    an infinite number of rules between friends?) The former is exactly equivalent
    to writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: but much more concisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we get to Booleans, we have a choice: we can either write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'where `b` stands for all the syntactic terms with the syntax of Booleans, or—because
    there are only two of them—just enumerate them explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so these correspond to the base cases of the type-checker. These are
    called axioms. Now let’s get to the conditionalcases, which are called (typing)
    rules. Remember our code for typing addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write it in this notation very concisely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the line as “if (what’s above) then (what’s below)”, and the space
    as “and”. So this says: “if `e1`has type `Num`and `e2`has type `Num`, then `(+
    e1 e2)`has type `Num`”. This is of course the exact same thing the code says,
    but with rather less noise.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminology:The part above is called the antecedent(that which goes before)
    and the part below is called the consequent (that which comes after). Don’t call
    these the numerator and denominator!
  prefs: []
  type: TYPE_NORMAL
- en: 'Growing Types: Division, Conditionals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Division
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Addition, multiplication, and subtraction are totalfunctions over numbers:
    they consume two numbers and produce one. In contrast, division is a partial function:
    it isn’t defined when the denominator is zero. Therefore, we need a strategy for
    handling it. There are several available strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: We can declare that division doesn’t returna number but instead something else
    that captures its partiality, such as `(Optionof Number)`. This can work just
    fine. However, it means every single use of division will need to check whether
    it obtained a proper number or not. This can get quite onerous.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can declare that division only consumesnon-zero numbers in its second argument.
    This is a major change to our type system, because until now we had lumped all
    numbers together into a single numeric type. This now affects all callers of division,
    who must now prove that they are not calling it on zero as the second argument.
    This is onerous in a different way. Observe that the type checker cannot automatically
    prove that a value is non-zero without error, because this is not decidable (see
    [Rice’s Theorem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&sa=D&source=editors&ust=1695232021350115&usg=AOvVaw1sfdnpfOgVLtiDbnXxEjlG)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We give it the same type as other binary numeric operations, and declare that
    the exceptional case will be handled by an exception or error. This implicitly
    puts the burden on the rest of the program, which must be aware of this possibility
    and handle it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more about general strategies for handling partial functions, see
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dcic-world.org/2022-08-28/partial-domains.html](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&sa=D&source=editors&ust=1695232021350790&usg=AOvVaw1xa-O5dafyrpg45paMpzmj)'
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages have taken the third option above, which seems the
    most pragmatic. However, a growing number of languages are exploring the first
    two options. They get around Rice’s Theorem in the second case by trying to prove
    non-zero-ness and, when they cannot, putting the burden on the programmer. While
    this creates more effort for the programmer, it increases the program’s robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Another Perspective on Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen how we can think of types as abstractions of values, and
    type-checking as running a program over these abstract values. As we’ll soon see,
    the analogy will break down a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another perspective is to think of types as a static discipline: a way of statically
    making judgments about programs. In a way, we have already been doing just this:
    it’s called parsing. A parser statically (i.e., before the program runs) passes
    judgment (i.e., decides that some programs are good and others are bad). Types
    can be viewed as an extension of this idea.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside:In computability theory terms, parsers are usually context-free, whereas
    types usually reflect context-sensitiveconstraints. Computability theory then
    helps us understand why we might separate these checks into two separate phases,
    and in particular why we might do one before the other. Essentially, the type-checker
    only needs to deal with programs that have already passed the parsing, i.e., context-free
    check, so it has much less complexity than if it had to do everything. We already
    saw this: our previous checker only consumed `Expr`s, which are produced by the
    parser.'
  prefs: []
  type: TYPE_NORMAL
- en: From Axioms and Rules to Judgments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we need to apply type rules to a program, we compose them recursively,
    just as the type-checker runs. Consider this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To decide its type, we will use our current rules [[👉](PLAIVersion3.2.2_split_091.html#h.bd3i224rr6yk)].
    Observe that it does not fit any axiom, because the program does not match the
    syntax of a single number or string. Therefore, we have to use a conditional rule.
    We have seen only one so far, and fortunately this term does match the consequent:
    it requires two terms, and we have two terms, so `e1`is `5`and `e2`is `(+ 6 7)`.
    Therefore, applying this conditional rule, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Now let’s look at the two terms in the antecedent. The first
    one now actually matches to an axiom; therefore, we’ll mark that in green and
    can stop with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- 5 : Num`    |- (+ 6 7) : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'For the other, we have to apply the same conditional rule again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '|- 5 : Num`    |- (+ 6 7) : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'These new terms also match the axiom for numbers, so we can mark them also
    in green:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- 6 : Num|- 7 : Num'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '|- 5 : Num`    |- (+ 6 7) : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Every part of the tree now terminates in an axiom. We therefore consider this
    program to have successfully type-checked. This tree is called a judgment, because
    it passes judgment on the initial term: in this case, judging it to have type-checked
    and to produce a value of type `Num`.'
  prefs: []
  type: TYPE_NORMAL
- en: Observe closely that this is the same pattern of execution we had with the type-checker!
    The difference is that we were able to skip the tedious details of passing and
    returning things, and instead simply used pattern-matching. This will save us
    a fair bit of work as we go forward.
  prefs: []
  type: TYPE_NORMAL
- en: Judgments and Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see another example, which will illustrate an important principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'This proceeds analogously to the previous example. This leaves us with the
    following attempted judgment:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- 6 : Num`    |- "hi" : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '|- 5 : Num`    |- (+ 6 "hi") : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'But now we have a problem: we need to type-check'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'but we don’t have a rule that matches. Therefore, we cannot construct a successful
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- 6 : Num|- "hi" : Num'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '|- 5 : Num`    |- (+ 6 "hi") :`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Remember the “if … and … then” interpretation. Because we cannot satisfy all
    the antecedents, we cannot prove anything about the consequents, leaving the tree
    incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: A type error is simply a failure to construct a judgment. It may not be the
    most satisfying user feedback, but our concern here is with a concise way of expressing
    ideas; going from this to an implementation is not too hard, and the user interface
    details can be added to the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requires some clarification. We only call it a judgment if the tree is
    “checked off” completely: i.e., every antecedent is generated using given rules,
    and all the leaves are actual axioms. In this example, we are unable to check
    off the tree: there is no available rule oraxiom that lets us conclude that `"hi"`is
    a `Num`. Therefore, we cannot “judge” the initial expression. This is a technical
    meaning of the word judgment, not to be confused with potentially colloquial interpretations
    of the term.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, imagine that we started with this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get this far:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- 5 : Num|- (- 6 7) : Num'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Again we would fail, this time because we haven’t provided a (conditional) rule
    for `(- e1 e2)`. Obviously it’s not difficult to define one; we just haven’t done
    so yet, so our pattern-matcher would fail.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:Construct the conditional rule for `++` (string concatenation). Compare
    it to the code in the type-checker.
  prefs: []
  type: TYPE_NORMAL
- en: Typing Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re ready to add a rule for `if`. As we have seen, different languages
    have different rules for what can go in the conditional clause. Since the goal
    of a type-checker is to catch type errors, it is common for languages with type-checkers
    to demand that the conditional be a Boolean (without a truthy/falsy set of Boolean
    values). Our goal here is not to make a value judgment but rather to illustrate
    how we would add a type rule for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, we can see that we will need a conditional rule (because we want to
    type-check more than just constants); following SImPl, and we will need the antecedent
    to say something about the sub-expressions. Clearly, we need at least:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, what now? What is the type of the entire conditional expression? Technically,
    it should be whatever type is returned by the branch that was executed. However,
    a type-checker can’t know which branch will be executed; over time, both might.
    So we have to somehow capture the uncertainty in this situation. There are two
    common solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce a new kind of type that stands for “this type orthat type” (a union).
    This is easy to introduce but creates a burden for every piece of code that will
    consume such a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just rule that both branches should have the same type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The latter is a very elegant solution, because it eliminates the uncertainty
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we need to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the type of T.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the type of E.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure T and E have the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make this (same) type the result of the conditional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That seems like a lot: how will we express all that? Very easily, actually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `U`is a placeholder: it isn’t a concrete type but rather stands forwhatever
    type might go in that place. The repeated use of `U`accomplishes all of our goals
    above. Read this as: “if `C` has type `Bool`and `T`has type `U`and `E` has [the
    same] type `U`, then `(if C T E)`has [the same] type `U`”.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action on the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'We get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- true : Bool`    |- 1 : U    |- 2 : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Either of the axioms for the other two antecedents tells us what U must be,
    which lets us fill in the result of U everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- true : Bool`    |- 1 : Num    |- 2 : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, the other two antecedents are also axioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- true : Bool|- 1 : Num|- 2 : Num'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: This lets us conclude that the overall term is well-typed, and that it has type
    `Num`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the conditional rule gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we do not have any axiom or conditional rule that lets us conclude
    that `4`has type `Bool` (because, in fact, it does not). Therefore, we cannot
    complete the judgment:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- 4 : Bool`    |- 1 : U    |- 2 : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: and the program is (rightly) judged to have a type error.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, applying the conditional rule and checking off the first antecedent:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- true : Bool`    |- 1 : U    |- "hi" : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'But now we have a problem. If we apply the axiom for numbers, we replace all
    instances of `U`with `Num` to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- true : Bool|- 1 : Num|- "hi" : Num'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe we just tried the wrong axiom? We do have one more option! However, it
    ends up with the same net effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '|- true : Bool|- 1 : Str|- "hi" : Str'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Because there is no way to construct a judgment for this program, it too has
    a type error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Let’s now add functions. We need two new constructs: one to introduce
    them (`lambda`) and one to use them (function application). Write down judgments
    for each. Hint: You may need to revisit the set of types, too.'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that because `let`desugars into `lambda`, once we have this, in principle
    we also have a conditional rule for `let`. (For more sophisticated language constructs
    this is not so straightforward; [this paper](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pk-resuarging-types/&sa=D&source=editors&ust=1695232021368048&usg=AOvVaw3PHiJldDLQfYPUNuwxOBi_) works
    out some of the details.)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: Add desugaring to the type-checker.
  prefs: []
  type: TYPE_NORMAL
- en: Where Types Diverge from Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something very important, and subtle, happened above. Compare the type rulefor
    a conditional with the evaluation process [[👉](PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936)].
    If the rule is too abstract, just look at the example judgments (or failed judgments)
    above. The evaluator evaluates only onebranch out of `T`and `E`; indeed, that
    is the entire pointof a conditional. The type-checker, in contrast, traverses
    bothbranches! In other words, it looks at code that mightevaluate, not only code
    that absolutely doesevaluate.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the idea that a type-checker is like an “evaluator that runs
    over simple values” is a convenient starting analogy, but it is in fact false.
    An evaluator and type-checker follow different traversal strategies. That is why
    a program like `(if true 1 "hi")` might run without any difficulty but is rejected
    by a type-checker. While this particular example may make the type-checker look
    overly pedantic, what if the same program were
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: What now? Should the type-checker pass the program every month? Should it consider
    the moon’s phase at the time of type-checking or at execution? Unfortunately,
    the type-checker doesn’t know when the program will run; indeed, the program is
    type-checked once but may run an arbitrary number of times. Therefore, a type-checker
    must necessarily be conservative.
  prefs: []
  type: TYPE_NORMAL
- en: This also lets us relate type-checking to testing. In software testing, making
    sure that all branches are visited is called branch coverage, and making sure
    all branches have coverage is both important and very difficult (because each
    branch may have additional branches which in turn may have even more branches
    which…). In contrast, a type-checker effortlessly covers both branches. The trade-off
    is that it does so only at the type level (and indeed, the abstraction of values
    to types is precisely what enables it to do this).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, testing and type-checking are complementary. Type-checking provides code
    coverage at a lightweight level; testing typically provides only partial coverage
    but at the deep level of specific values. In recent years, people have invented
    a notion of [concolic](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Concolic_testing&sa=D&source=editors&ust=1695232021370424&usg=AOvVaw1QJrbACLLfoZOf01gPppBi)—i.e.,
    “concrete” + “symbolic”—testing to try to create the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Growing Types: Typing Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we’re ready to grow our language further, to include functions. As we’ve
    noted before, concepts like functions come in pairs: a way to introduce them and
    a way to use (“eliminate”) them. As in our interpreter, we’ll use a `lambda`form
    to represent the former and application for the latter. We’ve already seen that
    once we have `lambda`, we use syntactic sugar to obtain other forms like `let`,
    so this suffices for our core language. (Mostly, as we’ll see…)'
  prefs: []
  type: TYPE_NORMAL
- en: So we have to come up with typing rules for application and `lambda`. Let’s
    do them in that order.
  prefs: []
  type: TYPE_NORMAL
- en: Typing Function Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function application expression has two parts: the function and the arguments.
    For simplicity, we’re going to assume that we’re working with single-argument
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:Extend the rules below to deal with functions of arbitrary number of
    parameters (formally called arity).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because functions are first-class values, the function position is itself an
    expression. We have to check each sub-expression before we can type the whole
    expression. Therefore, function applications are conditional rules with two terms
    in the antecedent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let’s notice that functions are different kinds of values than other
    values: a function is not itself a number, or string, or Boolean—it may produceone
    of those, but it is not itselfone of those (an important distinction). Therefore,
    we need a different type for functions, which reflects what functions consume
    and what they produce. A natural idea is to assume functions have some “function”
    type, here called `Fun`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: What do we know about the argument expression (the actual parameter)? It had
    better match the type demanded by the formal parameter. But how do we check that
    here? We’ve collapsed allfunctions in the world into a single type, `Fun`. That’s
    far too coarse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, following convention, we’ll use the “arrow” syntax for functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: (Technically, the arrow is a constructor of function types. It’s a two-place
    constructor, for reasons we will see below.)
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can now say that the function’s formal parameter’s type had better
    match up with the type of the actual argument. Which type, exactly? Functions
    could consume numbers, strings, even other functions…all we know is that these
    should be consistent. Notice that this is very similar to the consistency we expected
    of the branches of a conditional. We can again encode this by using the same placeholder
    in both places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what about what the function returns? Again, it could return values of
    any type. Whatever that type is, that is what the entire application produces.
    Again, we use a common placeholder to reflect this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'So here’s how we read this:'
  prefs: []
  type: TYPE_NORMAL
- en: Type-check the `F` position. Make sure it’s a function type (`->`). Assuming
    it is, call the formal parameter’s type `T`and the return type `U`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-check the actual parameter (the argument). Make sure it has the same type
    as what the function is expecting in its formal parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both of those hold, then the function’s return type is the type of the entire
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list of steps is what a conventional type-checker would implement. Observe
    that again, a type error is the result of a failure to construct a judgment. If,
    for instance, the actual argument’s type doesn’t match that of the formal parameter,
    then the conditional rule above doesn’t apply(it applies only when we can write
    the same type for the `T` placeholder), which is how we learn that the program
    has a type error.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: Construct an example to illustrate the above type-error case.
  prefs: []
  type: TYPE_NORMAL
- en: Aside:We intentionally don’t use a numberedlist because formally, the semantics
    of judgments doesn’t say that these steps have to occur in this order! For instance,
    the argument can be type-checked before the function; if so, that determines what
    the placeholder `T`stands for, and the checking of `F`confirms that `F`’s type
    matches that.
  prefs: []
  type: TYPE_NORMAL
- en: Even more perversely, you can imagine checking the application, determining—from
    the context—what its type needsto be (e.g., if it’s in an addition, it had better
    produce a number), and using that to drive the checking of `F`. In fact, all of
    these things can happen if instead of a checker, we implement type-inference—as
    we will soon see.
  prefs: []
  type: TYPE_NORMAL
- en: Typing Function Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to type `lambda`. Here, we have to be careful about how many
    sub-expressions there are. Given `(lambda V B)`, it is tempting to think that
    there are two: `V`(the formal parameter) and `B`(the body). This is wrong! The
    formal parameter is a literal name, notan expression: we can’t replace that name
    with some larger expression, which is what it would mean for it to be an expression.
    Furthermore, we can’t evaluate it: it would (most likely) produce an unbound variable
    error, because its whole job is to bindthat variable, so it can’t assume it has
    already been bound. Therefore, there is only one sub-expression, the body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we expect to end up with a conditional rule that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'If we think about this for a moment, we can see that there’s going to be a
    problem.  We just said that the `lambda`introduces a binding for the variable
    in the `V`position. This is precisely so that the body, `B`, can make use of that
    variable. So let’s imagine the simplest function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: But we don’t have any typing rule that covers variables! Furthermore, we have
    no way of knowing what the type of any old variable will be. So we have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Typing Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember how we addressed this problem in our interpreter: we had an environmentfor
    recording the value bound to each variable. We will use this same idea again:
    we’ll have a type environmentfor recording the type of each variable. That is,
    just as our interpreter had the type'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: our type-checker will have the type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'In our type-checker notation, we will use a slightly different way of writing
    it, which will finally make make `|-` stop being silent and take it proper pronounciation,
    “proves”: all type rules will have the form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ `|- e : T`'
  prefs: []
  type: TYPE_NORMAL
- en: where Γ, the capital Greek letter gamma, is conventionally used for the environment.
    We read this as “the environment Γproves that `e`has type `T`”. So in fact there’s
    been an environment hiding in all our judgments, but we didn’t have to worry about
    it when we didn’t have variables; but now we do, so from now on we have to make
    it explicit. Fortunately, in most cases the environment is unchanged, and just
    passes recursively to the sub-terms, as you would expect from writing the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can write a type for variables. What is the type of a variable?
    It’s whatever the environment says it is! We’ll treat the environment as a function,
    so we can just write the following axiom (where `v` stands for all the syntactically
    valid variable names):'
  prefs: []
  type: TYPE_NORMAL
- en: Γ `|- v :` Γ`(v)`
  prefs: []
  type: TYPE_NORMAL
- en: Back to Typing Function Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re in a position to fill in the holes. When we check the body of the
    function, we should do it in an extended environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ[V <- ???] `|- B : ???`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (lambda V B) : ???`'
  prefs: []
  type: TYPE_NORMAL
- en: 'where Γ[V <- _] is how we write “Γis extended with `V` bound to _”: this is
    the same environment-extension function that we’ve written before, for type environments
    instead of value environments, but operationally the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, but two questions: extend whichenvironment, and extend it with what?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which is easy: it’s the environment of the function definition (static scope!).
    The repetition of Γ in both the consequent and antecedent accomplishes that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of what:  We need to provide a type for the variable so that, when
    we try to look up its type, the environment can return something. But we don’t
    know what to extend it with! The type-checker needs the programmer to tell it what
    type the function is expecting. This is one of the reasons why programming languages
    expect annotations in function and method definitions. (Another—equally good—reason
    is because it better documents the function for people who have to use it and
    maintain it.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we have to extend the syntax of functions to include a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'which says that `V`is expecting to be bound to a value of type `T`in body `B`.
    Once we accept this modification, we can make progress on the conditional rule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ[V <- T] `|- B : ???`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (lambda V :` T` B) : ???`'
  prefs: []
  type: TYPE_NORMAL
- en: 'What type are we expecting for the function definition? Clearly it must be
    a function type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ[V <- T] `|- B : ???`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (lambda V : T B) :` (??? -> ???)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we know that the type expected by the function must be `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ[V <- T] `|- B : ???`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (lambda V : T B) : (`T` -> ???)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a value of type `T`, the function will return whatever the body produces:'
  prefs: []
  type: TYPE_NORMAL
- en: Γ[V <- T] `|- B :` U
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (lambda V : T B) : (T ->` U`)`'
  prefs: []
  type: TYPE_NORMAL
- en: And that gives us our final rule for function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: More Divergence Between Types and Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is interesting to contrast the above pair of typing rules with the corresponding
    evaluation rules. In the evaluator, we visit the body of the function on every
    application—which could be as many as an infinite number of times in a program.
    In contrast, we visit the body of the function on definition, which happens only
    once. Therefore, even if the program runs forever, the type-checker is guaranteed
    to terminate!
  prefs: []
  type: TYPE_NORMAL
- en: Why can we get away with this? The evaluator has to run the body with the specific value
    it was given. The type-checker, however, has abstracted the concrete values away.
    Therefore, it only needs to make one pass through the body with the “abstract
    value”, the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: Earlier, when we proposed the type `Fun`, we said that it collapsed
    all functions in the world into one type. This was too coarse, and we had to refine
    the type of a function. However, we are stillcollapsing an infinite number of
    functions into each of those function types—just as we collapse an infinite number
    of strings into `Str`, and so on. Both the strength and weakness of type-checking
    lies in this collapsing.'
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, observe that a function application rule only cares about
    the typeof the function, not whichspecific function is being applied. Therefore,
    any function that has that type can be used. For that same reason, the type-checker
    cannot traverse the function’s body at application time—it doesn’t even know which
    function might be used! All communication between the function body and application
    must happen entirely through the type boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Assume-Guarantee Reasoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a delicate dance going on between these typing rules for application
    and definition (now updated to have the environment). We’ll use colors to highlight
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Γ `|- F :` (T -> U)`Γ |- A :` T
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (F A) : U`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ[V <- T] `|- B : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (lambda V : T B) :` (T -> U)'
  prefs: []
  type: TYPE_NORMAL
- en: The rule for `lambda` assumesthe parameter will be given a value of type T;
    the application rule guaranteesthat that the actual parameter will indeed have
    the expected type. The application rule assumesthat the function, if given a `T`,
    will produce a `U`(because the type is (T -> U)); the `lambda`rule guarantees that
    the function will indeed perform that way.
  prefs: []
  type: TYPE_NORMAL
- en: Aside:The notation `(T -> U)`is not chosen at random. The `->`may remind you
    of the notation for implication in mathematics. That’s intentional. We can read
    the type as “giving the function a `T`implies that it will produce a `U`” (not
    giving it a `T`implies nothing about what it will do…). It is that implication that
    is assumed in the application rule, and that is guaranteed by the rule for lambda.
  prefs: []
  type: TYPE_NORMAL
- en: This assume-guarantee reasoning shows up in many places, so look out for this
    pattern in other places as well.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion and Infinite Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We alluded, earlier, to how we can desugar more interesting features into functions
    and application. Let’s take a look at a very specific feature: an infinite loop.
    Let’s first confirm that we can write an infinite loop. Here’s a program that
    does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'But this assumes we already have recursion. Can we write it without recursion?
    Actually we can! We’ll use historical names (ω is the lower-case Greek omega):'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([`ω` (lambda (x) (x x))])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  (`ωω`))`'
  prefs: []
  type: TYPE_NORMAL
- en: Run this in Racket and confirm that it runs forever!
  prefs: []
  type: TYPE_NORMAL
- en: Do Now:Write a conditional type rule for `let`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see what happens when we try to type this. We have to provide a type
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([`ω` (lambda (x : ???) (x x))])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  (`ωω`))`'
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the overall term is called Ω (the capital Greek omega).
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so what is the annotation? To determine a type for `x`, we have to see
    how it’s used. It’s used twice. One use is in a function application position,
    so we know that the type must be of the form `(T -> U)`; now we have to determine
    what `T`and `U`are. Let’s focus on the parameter type, `T`. But what are we passing
    in? We’re passing in `x`, whose type is `(T -> U)`. So we need a solution to the
    equation
  prefs: []
  type: TYPE_NORMAL
- en: '`T`= `(T -> U)`'
  prefs: []
  type: TYPE_NORMAL
- en: with one coming from the application position and the other from the argument
    position. Of course, there is no finite type that can fit this equation! Therefore,
    it appears that this program cannot be typed!
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this is not a proof. However, there is a formal property associated
    with this programming language, which is called the Simply Typed Lambda Calculus
    (STLC): the property is called strong normalization, and it means that all programs
    in this language terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside: If you have heard about the Halting Problem, how does that square with
    what you just read?
  prefs: []
  type: TYPE_NORMAL
- en: It may seem rather useless to have a language in which all programs terminate—you
    can’t write an operating system, or Web server, or many other programs in such
    a language. However, that misses two things.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, there are many cases where we wantprograms to always terminate. You
    don’t want a network packet filter or a device driver or a compiler or a type-checker
    or … to run forever. Of course we also want them to run quickly, but it would
    be nice if we had a guarantee that no matter what we did, we cannot create an
    infinite loop. The STLC is very useful in some of these settings. Another example
    of a place where we want guaranteed termination is in program linking, and the
    module language of Standard ML is therefore built atop the STLC: it lets you even
    write higher-order programs, but the type language guarantees that all module
    compositions (linkages) will terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, many long-running programs are actually a composition of an infinite
    loop and a short-running program. Think about an operating system with device
    drivers, a Web server with a Web application, a GUI with callbacks, etc. In each
    case, there is a “spine” of an infinite loop that simply keeps the program reactive,
    and “ribs” of short computations that do a little specific work and terminate.
    In fact, on the Web these programs mustterminate quickly, otherwise the Web browser
    thinks the server has hung and offers to kill the window! These kinds of reactive
    systems are therefore a composition of a very generic infinite loop calling out
    to specific programs for which a termination guarantee will often be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, observe that we’ve learned something profound. Until now, we have probably
    thought of types as just a convenience or as a way of eliminating basic errors.
    However, we have just now seen that adding a type system can change the expressive
    power of a language. That is, these types are “semantic”.
  prefs: []
  type: TYPE_NORMAL
- en: Typing Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What went wrong above? The problem is that each application “uses up an arrow”
    in a function type; because a program text must be finite, it can contain at most
    a finite number of “arrows”, so eventually the program must terminate. To get
    around this, we need a way to effectively have an “infinite quiver”.
  prefs: []
  type: TYPE_NORMAL
- en: 'We typically do this by adding a recursive function construct to the language,
    and create a custom type for it. Let’s start with a type rule for the analogous,
    but simpler, `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ `|- E : T    `Γ[V <- T] `|- B : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (let V : T E B) : U`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we’re going to expect an annotation in `let`for the same reason we
    do for function definitions. So this says that we’ll check that `E`actually does
    have the type promised in the declaration, `T`; when we extend the type environment
    with the `V`having type `T`, if the body `B`produces type `U`, then that’s the
    type of the whole expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: Notice that there’s an assume-guarantee pair in the antecedent: the
    first term is guaranteeing the annotation, which the second term is assuming.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside:Technically, the type of `E`could be calculated. Therefore, the `T` annotation
    is not strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Observe that this is basically the type rule we would get from expanding the
    syntactic sugar for `let`. Therefore, this still doesn’t let us write a recursive
    definition. We need something more. Let’s introduce a new construct, `rec`, for
    recursive definitions. An example of a `rec` (in an untyped setting) might be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: In the typed world, we’ll want rec to have the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: so we’d instead have to write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: where `V`is `fact`, `T`is `(Number -> Number)`, `E`is the big `lambda`term,
    and `B`is `(fact 10)`.
  prefs: []
  type: TYPE_NORMAL
- en: So this introduces a recursive definition, and then uses it. How might we type
    this?
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (rec V : T E B) : U`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, clearly one part of it must be the same: we have to type the body in
    the extended environment, and the environment must be extended with the annotated
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '???    Γ[V <- T] `|- B : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (rec V : T E B) : U`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also know that we need to confirm that the annotation is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '??? `|- E : T`Γ[V <- T] `|- B : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (rec V : T E B) : U`'
  prefs: []
  type: TYPE_NORMAL
- en: 'But clearly, somethingneeds to be different, otherwise we’ve just reproduced
    `let`. Look at the example use of `rec`: the `E`term also needs to have `V`bound
    in it! In other words, both `E`and `B` are typed in the same environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ[V <- T] `|- E : T`Γ[V <- T] `|- B : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (rec V : T E B) : U`'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the type, we can read off how the recursion happens: the extended environment
    for `B` initiatesthe recursion, while that for `E` sustainsit. Essentially, the
    environment of `E` enables arbitrary recursive depth.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, to obtain arbitrary recursion—and hence infinite loops—we have to
    add a special construct to the language and its type-checker; we cannot obtain
    it just through desugaring. Once we add `rec` to the STLC, however, we obtain
    a conventional programming language again.
  prefs: []
  type: TYPE_NORMAL
- en: Safety and Soundness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A critical component of SMoL is the concept of safety: that some operations
    are partialover the set of all values, and that a SMoL language enforces this
    by reporting violations. Typical examples of partiality may include `+`applying
    only to certain types of values. However, I intentionally write “operations” rather
    than, say, “functions”, because these could be primitive operations like application
    (expecting the first position to be a function or method) as well. In fact, in
    some languages like JavaScript, there are very few violations, as the [Wat talk](https://www.google.com/url?q=https://www.destroyallsoftware.com/talks/wat&sa=D&source=editors&ust=1695232021400146&usg=AOvVaw1NOpkYKNjpy6IwTp-vrqEQ) shows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How must these be enforced? It can be either statically or dynamically. In
    Python and JavaScript, for instance, all safety violations are reported dynamically.
    In Java or OCaml, most of them are reported statically. Either way, safety means
    that data have integrity: there is some notion of “what they are”, and that identity
    is respected by operations. Put differently, data are not misinterpreted.'
  prefs: []
  type: TYPE_NORMAL
- en: These are all very abstract statements, which we will soon concretize.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Basic Calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with a very basic calculator that has two types, numbers and
    strings, and an operation (addition and concatenation, respectively) on them.
    Note that it helps to have more than one type if we want to talk about safety.
    We will skip most of the boilerplate code and focus on the core of the calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: You might have imagined the latter two functions to be merely convenient helpers,
    and hence wonder why they are part of the “core”. You will soon see why!
  prefs: []
  type: TYPE_NORMAL
- en: 'With a suitable parser, we can run tests such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The last two, in particular, show that the language is safe. The checks inside
    the primitives—in `num+`, for instance—are called safety checks.
  prefs: []
  type: TYPE_NORMAL
- en: Making Memory Explicit (Unsafely)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re going to do something fun: we’re going to make the memory allocation
    of values explicit. As we go through this, remember what we’ve said before: a
    value in SMoL is just a memory address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do this in stages. First, we’ll use a vector to represent memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: The value `-1`is useful for identifying parts of memory that have not yet been
    touched (assuming, of course, we don’t write a program that produces `-1`—which
    we can avoid doing easily enough in this illustration).
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: To run the code below, you will need to import some Racket primitives
    into plait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be useful to have a helper to use the next available bit of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s say we want to store a number in memory. We put it in the next available
    memory place, and return the addressof the place where the number was stored.
    Be careful here: the number we return is a memory address (which, here, is represented
    as an array index), which is not at all necessarily the same as the numeric value being
    stored.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Correspondingly, when we want to read a number, we simply return what is at
    the address corresponding to the number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the property that when we `read-num`from the address where we `store-num`a
    number, we get back that same number: for all `N`,'
  prefs: []
  type: TYPE_NORMAL
- en: '`(read-num (store-num N))`is `N`'
  prefs: []
  type: TYPE_NORMAL
- en: Aside: This is not quite exactly how numbers are stored in most languages. As
    we will see when we update the calculator below, this means every time we produce
    a particular number—`1730`, say—we store it afresh in memory. That would be extremely
    wasteful. Rather, language implementations use representation tricks to make sure
    there is only one copy of numbers and that they don’t need to take up space on
    the heap at all, as we describe below [[👉](PLAIVersion3.2.2_split_114.html#h.dirpjggvkz7z)].
    However, we will continue to work with this simple model because this optimization
    is not the focus of this chapter. In addition, some numbers—that don’t fit in
    a small amount of space—do need to be stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at strings. We are going to convert the string into a sequence
    of character codes, and store those codes explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the value stored at the address representing the string is the
    length of the string, followed by the individual characters. (Endless blood has
    been spent over whether strings should store their lengths at the front, or whether
    they should only be delimited by a special value, or both. The question is uninteresting
    here.) Thus, suppose with a fresh memory we run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: this would return the address `0`. The resulting value of MEMORY would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, at address `0`we have the length of the string, followed by five character
    codes; these six memory entries together constitute the five-character string
    `"hello"`. The rest of the memory remains untouched. To read a string we have
    to reassemble it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we want the result of reading a written string to give us the same
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s update the calculator. First, we’re in for a surprise: we no longer
    need (or want) a fancy Racket datatype to track values, because values are just
    addresses (i.e., array indices)! So:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: The typeof the calculator doesn’t change; it still produces values. It’s just
    that the representation of values has changed…dramatically. (Recall, again, that
    these `Number`s are addresses, not numeric values in the interpreted language.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculator remains the same. What has changed is in the helper functions.
    In the primitive value cases, we have to explicitly allocate them—which is what
    we were doing when we called the previous definitions of `numV`and `strV` (which
    store data on the heap), except it may not have been so evident. We will make
    it explicit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now to update the helper functions. Let’s focus on `num+`. The core logic
    is currently
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that now we’re calling it on the result of calling `calc`, i.e., on
    `Value`s. That means `num+` is going to get two addresses as arguments, and it
    needs to look up the corresponding numbers in memory, and then produce the resulting
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside: In case you’re wondering: yes, we’re cheating a tiny bit. We’re using
    Racket numbers rather than dealing with even lower-level representations. We’ll
    give ourselves this little bit of leeway since this is not the point we’re trying
    to illustrate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Analogously, we can define concatenation as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside: Yes, we’re cheating again, and quite a bit. If we were less lazy, we’d
    write a big loop over `MEMORY` that copies all the values from the first and second
    strings into a new, third string, explicitly. But we’re lazy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to update our tests as well. Because `calc`now returns addresses,
    all our answers appear to be incorrect. Instead, we have to obtain the corresponding
    numbers or strings at those addresses. Once we do so, `calc` passes the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'Except…does it? These two tests do not pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: In fact, how can they? In all the above code, there are no errors left! Rather,
    when we run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'we get an address back (maybe `69`; it depends on what you ran earlier and
    hence what is in `MEMORY`). In fact, we can decide how we want to treat this:
    as a number?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'How can something be both a number and a string? Well, actually, the situation
    is a bit more confusing than that: `69`above is just an address in memory from
    which we can read off whatever we want however we want it(i.e., the content of
    that address is interpreted by the function that reads from it), which can result
    in garbage. It can get even worse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '. . integer->char: contract violation'
  prefs: []
  type: TYPE_NORMAL
- en: 'expected: valid-unicode-scalar-value?'
  prefs: []
  type: TYPE_NORMAL
- en: 'given: -1'
  prefs: []
  type: TYPE_NORMAL
- en: That is, we’ve tried to read “off the end of memory”. It was dumb luck that
    we had a `-1`as the initial value; the `-1`triggered an error when we tried to
    convert it to a character because Racket’s primitives are safe, which halted the
    program. If `integer->char` did not have a safety check, we would have gotten
    some garbled string instead.
  prefs: []
  type: TYPE_NORMAL
- en: In short, what we have created is an unsafe language. Data have no integrity.
    Any value can be treated as any kind of datum. This, in short, is the memory model
    of C, and it’s largely proven to be a disaster for modern programming, which is
    why SMoL languages evolved.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering Safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fortunately, it does not take too much work to make the language safe again.
    What we’ve just written holds the key: every value needs to record what kind of
    value it is. And any use of that value needs to check that it’s the right kind
    of value. This information is called a tag; it takes a fixed amount of space,
    and represents metadata about the subsequent datum. All subsequent values are
    interpreted in accordance with the tag.'
  prefs: []
  type: TYPE_NORMAL
- en: We need two tags for the two kinds of values. Let’s use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: It’s important that the two tags be different, so they are unambiguous. However,
    we don’t need to worry about the tags themselves being confused with other data
    (e.g., numbers), because the tags will never be processed directly as program
    data (unless, of course, there is a bug in our implementation that accidentally
    does so…which is why language implementations need to be tested extensively).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we allocate a number, we write its tag into the first address, followed
    by the actual numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: (let ([a0 (write-and-bump NUMBER-TAG)])
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: a0))`)`
  prefs: []
  type: TYPE_NORMAL
- en: 'And when we try to read a number, we firstcheck that it really is a number,
    and only then obtain the actual numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: (if (= (vector-ref MEMORY a) NUMBER-TAG)
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-ref MEMORY` (add1 `a`)`)`'
  prefs: []
  type: TYPE_NORMAL
- en: (error 'number (number->string a)))`)`
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are analogous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '`(let ([a0 (write-and-bump` STRING-TAG`)])`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: (write-and-bump (string-length s))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: (if (= (vector-ref MEMORY a) STRING-TAG)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '`(loop (vector-ref MEMORY` (add1 `a`)`) (+ a` 2`)))))`'
  prefs: []
  type: TYPE_NORMAL
- en: (error 'string (number->string a)))`)`
  prefs: []
  type: TYPE_NORMAL
- en: So now, starting from a fresh memory, running
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'still produces `0`, but the content of `MEMORY` looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''#(`5712'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, at address `0`we first encounter the tag for strings. Only then do
    we get the string’s length, followed by its contents. Observe that now, storing
    the length up front makes even more sense: the first two locations contain the
    tag and the length, both of which are metadata that help us interpret what comes
    later, with the second (the length) refining the first (the tag).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, the interpreter stays unchanged, and effectively so do the
    helpers, other than using the new names we’ve chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '`  (store-num (+ (`safe-`read-num la) (`safe-`read-num ra))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '`  (store-str (string-append (`safe-`read-str la) (`safe-`read-str ra))))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'All our “good” tests still pass, but interestingly, our “bad” tests now fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: You may notice the error message strings above have changed slightly.
    Why?'
  prefs: []
  type: TYPE_NORMAL
- en: What Price Safety?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our safe evaluator has, however, come at a price relative to the unsafe evaluator.
    In terms of running time, we are now clearly paying for the overhead of safety
    checks. In terms of space, we are paying for the tags. Thus, we have had to get
    worse space and time.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the price of unsafe languages is so high—e.g., in the form of
    security problems—and the cost of safety is often so low, that programmers gladly
    pay this price (or do so without even particularly noticing it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, it would be nice if we didn’t have to pay the price at all. And there
    is a way to accomplish that: types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at our “bad” programs. These are programs that can staticallybe rejected
    by a type-checker. If we could reject all such programs, then—since no “bad” programs
    would be left—we can then run the program on the unsafe evaluator without worrying
    about negative consequences. This, in effect, is what most typed languages, like
    Java and OCaml, do. Thus we find another use for types: to improve program performance.
    But this requires care.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:Usually, in computer science, we talk about a space-time tradeoff.
    Yet here we seem to have a situation where we’ve improved (i.e., reduced the use
    of) both the space and the time! How is that possible?
  prefs: []
  type: TYPE_NORMAL
- en: Soundness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running on an unsafe evaluator is, as the name suggests, dangerous. Therefore,
    we should only do it if we can be sure that nothing can go wrong. That means that
    our type system needs to come with a guarantee.
  prefs: []
  type: TYPE_NORMAL
- en: The way this guarantee is usually formulated is as follows. Suppose we have
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: and suppose we evaluate it and find that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: The latter—its value—is the ground truth. The type checker’s job is to make
    sure it matches what the evaluator produces. That is, we would ideally like that
  prefs: []
  type: TYPE_NORMAL
- en: '`e : t`if and only if `e -> v`and `v : t`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This says that the type checker''s job is to perfectly mirror the evaluator:
    whatever type the program’s result value has is the same type the type-checker
    says it has.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, for a Turing-complete language, this full guarantee is impossible
    to obtain, because of [Rice’s Theorem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&sa=D&source=editors&ust=1695232021427399&usg=AOvVaw1_99VdJEVQ2qFHhOKxeYso).
    Instead, we have to compromise and see if we can get at least one of the two directions.
    When we think about it, we realize that, in a typed language, we’re only really
    interested in programs that pass the type-checker (i.e., have a type). Therefore,
    we expect that
  prefs: []
  type: TYPE_NORMAL
- en: 'If `e : t` then'
  prefs: []
  type: TYPE_NORMAL
- en: 'if `e -> v`, then `v : t`'
  prefs: []
  type: TYPE_NORMAL
- en: This says that whatever type the type-checker predicted is exactly the type
    that the program has. That means we can rely on the type-checker’s prediction.
    Which in turn means that we can be sure there are no type violations. Which tells
    us we can safely run the program atop an unsafe evaluator! This property is called
    type soundness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that soundness is not a given: it’s a property that must be formally,
    mathematically proven of a given type-checker and evaluator. The proof can be
    quite complex. This is because the “shape” of program evaluation and that of type-checking
    can be very different, as we have seen before for conditionals [[👉](PLAIVersion3.2.2_split_096.html#h.d70s6cjh8dnk)]
    and functions [[👉](PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg)]. And failure
    to prove it correctly—i.e., claiming it holds when in fact it doesn’t—means we’ve
    allowed a vulnerability to slip through. This can manifest as uncaught exceptions,
    crashes, segmentation faults, etc. In addition, a clever attacker can construct
    a program that exploits the vulnerability, and our system can be subjected to
    a security or other attack. Thus, any soundness violations are emergencies and
    result in panic.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Printing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the consequences of our tagged representation is that when extracting
    a value from memory, we don’t haveto know whether to use `safe-read-num`or `safe-read-str`;
    the tag at the address can tell us which to use. That is, we can define
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this code can’t be typed by plait because the two branches return
    different types. We can solve this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a hack: use `#lang plait #:untyped`, which provides the same syntactic
    language, features, and run-time behavior, but turns off the type-checker. (Curiously,
    we were using the type-checker to keep us disciplined: so that the only values
    we could store in `MEMORY` would be numbers! Therefore, it’s good to not use the
    untyped version often.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that in the end, what printers do is essentially print a string. Therefore,
    we just need to return a string in all cases: `(define (generic-read a)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'A consequence of having this function is that we can rewrite our tests to be
    more proper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: This is much closer to how we would write the test in the original interpreter;
    the only difference here is that the evaluator produces an address as the value,
    but we would like to inspect the value in a human-readable and -writable form,
    so we use `generic-read`.
  prefs: []
  type: TYPE_NORMAL
- en: Alert:If you run these tests in addition to the preceding ones, you may need
    to enlarge `MEMORY`.
  prefs: []
  type: TYPE_NORMAL
- en: The Representation of Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examining the content of `MEMORY`gives the impression that every single number
    we compute is stored afresh on the heap, and furthermore, if we compute a certain
    number (say `3`) twice, each instance will be stored and hence take up space.
    However, this is not the space consumption model of real implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'On most modern architectures, values are stored at [“word” boundaries](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Data_structure_alignment&sa=D&source=editors&ust=1695232021431461&usg=AOvVaw1zfmzCHLp7ziOLweunTDXZ):
    depending on the machine, starting at addresses that are multiples of 4 or 8\.
    For the purposes of illustration, let’s say we have a 32-bit machine, with 4-byte
    alignment. (The reasons for this are due to details of computer architecture that
    are outside the scope of this book.) That means every legal memory address, when
    viewed in binary, ends in …00\. However, there are four legal values for those
    two bits, only one of which is being used. This creates an opportunity.'
  prefs: []
  type: TYPE_NORMAL
- en: A common technique is to therefore use a pattern like …01 to be the tag for
    numbers. The actual number itself is stored in the remaining (say 30) bits of
    the “address”. That means, “addresses” that end in 01 are not true addresses,
    and must not be looked up; they are actually just numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in principle, the first thing to do with a value (that is, an address)
    is to test its 0’th bit. If this is 1, then shift the value right by 2 places.
    This drops the 01 tag, leaving the number in place. Similarly, when a number is
    constructed, provided it fits in 30 bits, it is shifted left by two places, and
    the last bit is made 1 (resulting in the 01 tag).
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, every number has a tag; but every number is also stored in
    registers and on the stack, not on the heap. All numbers with the same value have
    the same bit-pattern representation (the 30-bit numeric value followed by 01).
    Thus, there will be zero instances of them on the heap, and they can be accurately
    compared for equality in constant time.
  prefs: []
  type: TYPE_NORMAL
- en: Aside: Notice that the above technique only works for numbers that can fit in
    30 bits (or about 60 bits in a 64-bit machine). Larger numbers have to still be
    stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might imagine, we have further room to play: we still have the patterns
    …10 and …11\. Another good candidate for fitting entirely in the address is a
    Boolean, so the pattern …10 could be used for that. Very short strings might fit
    in a word. And so on. There are many architectural, instruction-set, and program
    considerations in designing these tags at the low level.'
  prefs: []
  type: TYPE_NORMAL
- en: Type Inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unannotated Programs and Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following plait program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'If we enter this program into plait, e.g., as follows, something remarkable
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'In response, plait figures outthe type of this function without our having
    to provide any annotations. This is in contrast to the type-checker we just wrote
    [[👉](PLAIVersion3.2.2_split_098.html#h.1hrl1xnfptjg)], which required us to extend
    the syntax just to provide (required) type annotations. That tells us that something
    different—and more—must be happening under plait. In contrast, consider another
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: This produces an error, observing that we are using `x`both in a position that
    requires it to be a Boolean (in `if`) and a number (in the two additions). Again,
    plait has figured this out without our having to write any annotations at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm that sits underneath plait is essentially the same algorithm
    under OCaml, Haskell, and several other programming languages. These languages
    provide type inference: figuring out (inferring) types automatically from the
    program source. Now we’re going to see how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: The key idea is to break this seemingly very complex problem into two rather
    simple parts. In the first, we recursively visit each sub-expression of the program
    (following SImPl) and generate a set of constraintsthat formally do what we’ve
    been doing informally above. The second phase solvesthis set of constraints, using
    a process that is a generalization of the process you used for solving “systems
    of simultaneous equations” in school. The solution is a type for each variable.
    That lets us fill in the annotations that the programmer left blank.
  prefs: []
  type: TYPE_NORMAL
- en: The process of generation will also have applied the type constraints, so there
    will be no further need to type-check the program; but we can use the annotations,
    for instance, in an IDE for tool-tips, in a compiler for optimization, etc. That
    is, with inference, we can program as if we’re in a “scripty” language without
    annotations, yet achieve most of the benefits of types. (I say “most” because
    one of the benefits is documentation; leaving off all annotations makes programs
    harder to read and understand. For that reason, inference should be used sparingly.)
  prefs: []
  type: TYPE_NORMAL
- en: Imagining a Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, our type checker has required us to annotate the parameter of every
    function. But let’s imagine someone handed us a piece of code without annotations;
    can we figure out the type anyway? For instance, consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'We clearly know the type of this; even our type-checker can calculate it for
    us without any annotations. But of course that’s not surprising: there are no
    variables to annotate. So now consider this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: With a moment’s inspection, we can tell that the function has type `(Num ->
    Num)`. But our type-checker couldn’t have calculated that, because it would have
    tripped on the empty annotation. So how can we figure it out?
  prefs: []
  type: TYPE_NORMAL
- en: Well, let’s see. First we have to figure out the type of `x`. To determine its
    type, we should look for usesof `x`. There is only one, and it’s used in an addition.
    But the rule for addition
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ `|- e1 : Num    `Γ `|- e2 : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (+ e1 e2) : Num`'
  prefs: []
  type: TYPE_NORMAL
- en: tells us that the term in that position must have type `Num`. There is no additional
    information we have about `x`(this remark will become clearer in a moment). Therefore,
    we can determine that its type must be `Num`. Furthermore, we know that the result
    of an addition is also a `Num`. From that, we can conclude that the function has
    type `(Num -> Num)`.
  prefs: []
  type: TYPE_NORMAL
- en: Unique Variable Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In what follows, we will assume that all variable names in the program are unique.
    That is, a given variable name is bound in at most one place in a program. This
    greatly simplifies the presentation below, because we can speak of the type of
    a variable and know which variable it refers to, instead of having to constantly
    qualify which variable of that name we mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'This restriction does not actually preclude any programs in a language with
    static scope. Consider this program, which produces `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'We can just as well consistently renameone of the `x`s to something else (heck,
    we can even use the DrRacket interface to have Racket do the renaming for us),
    and leave the program meaning exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: This renaming process is called alpha conversionor alpha renaming.
  prefs: []
  type: TYPE_NORMAL
- en: More Informal Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With that important detail out of the way, let’s return to our process of inferringor
    reconstructing the types of variables from the way they’re used in a program.
    Here’s another example with a two-parameter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we can’t just calculate its type with our type-checker; instead,
    we must reconstruct the type from the function body. Let’s do that. What can we
    tell? Let’s again refer to the conditional rule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ `|- C : Bool    `Γ `|- T : U    `Γ `|- E : U`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (if C T E) : U`'
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that what’s in the `C`position—here, `x`—must be a `Bool`. Furthermore,
    both branches `(+ y 1)`and `(+ y 2)`must have the same type. That’s all we can
    learn from the rule for `if`! But now we can (and must) recur into the sub-expressions.
    Each one is an addition, and the addition rule tells us that both arguments must
    be `Num`s. Both of these indicate that the type of `y`must be `Num`. Furthermore,
    both indicate that the overall addition returns a `Num`. From that we can tell
    that the entire expression must have the type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'By this process, we can figure out what types to put in the missing annotations.
    More subtly, notice that by running through this process, we have effectively
    applied all the typing rules; therefore, if we have successfully reconstructed
    the type annotations, we need not bother type-checking the program with those
    annotations: it will have to type-check.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s consider a slight variation on the above program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s figure out everything we can learn about `x` from the function’s
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x`is used in the conditional position of an `if`. Therefore, it must have
    type `Bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`is used as a parameter to `+`. Therefore, it must have type `Num`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`is again used as a parameter to `+`. Therefore, it must have type `Num`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that each of these conclusions is perfectly fine on its own. However,
    when we put them together(which is what we meant by “additional information” above),
    there’s a problem: `x`cannot be both of those. That is, we are unable to find
    a single type for `x`. This inability to find a type for `x`means that the program
    has a type error. And indeed, there is no type we could have given that would
    have enabled this program to execute safely.'
  prefs: []
  type: TYPE_NORMAL
- en: Observe something subtle. While we can report that the program clearly has a
    type error, our error message must necessarily be much more ambiguous. Previously,
    when we had a type annotation on `x`, we could pinpoint where the error occurred.
    Now, all we can say is that the program is not type-consistent, but cannot blame
    one spot or the other without potentially misleading the programmer. Instead,
    we must report all these locations and let the programmer decide where the error
    is based on their unstated intent (in the form of a type annotation).
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The details of this algorithm—called Hindley-Milner inference—are fascinating,
    and worked out in detail in both the first and second editions of [this book,
    PLAI](https://www.google.com/url?q=https://www.plai.org/&sa=D&source=editors&ust=1695232021443495&usg=AOvVaw1Jv2eQapvZVGeMGKdx7dFB) (Chapter
    30 in the first edition and Chapter 15.3.2 in the second edition). For several
    worked examples of both constraint generation and constraint solving, refer to
    the first edition. The first edition has a more algorithmic presentation, while
    the second provides code (it may be useful to compare the two). The prose in the
    second is different from that in the first, so different readers may prefer one
    over the other.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic Datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have written numerous `define-type` definitions so far, e.g., for expressions.
    Now we will study this mechanism, which is increasingly found in many new programming
    languages, in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify things, consider a simple plait data definition of a binary tree
    of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'The `define-type` construct here is doing three different things, and it’s
    worth teasing them apart:'
  prefs: []
  type: TYPE_NORMAL
- en: Giving a nameto a new type, `BT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allowing the type to be defined by multiple cases or variants (`mt`and `node`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Permitting a recursive definition (`BT`references `BT`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s worth asking whether all these pieces of functionality really have to be
    bundled together, or whether they can be handled separately. While they can indeed
    be separated, they often end up working in concert, especially when it comes to
    recursive definitions, which are quite common. A recursive definition needs a
    name for creating the recursion; therefore, the third feature requires the first.
    Furthermore, a recursive definition often needs a non-recursive case to “bottom
    out”; this requires there to be more than one variant, using the second feature.
    Putting the three together, therefore, makes a lot of sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'This construct is called an algebraic datatype, sometimes also known as a “sum
    of products”. That is because the variants are read as an “or”: a `BT`is an `mt` ora
    `node`. Each variant is an “and” of its fields: a node has a `v` andan `l` andan
    `r`. In Boolean algebra, “or” is analogous to a sum and “and” is analogous to
    a product.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will also see this referred to as a tagged union. The word “union”
    is because we can conceptually think of a `BT`as a union of `mt`s and `node`s.
    The tag is the constructor. This term makes more sense once we compare it against
    “untagged” union types [[👉](PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt)].
  prefs: []
  type: TYPE_NORMAL
- en: Generated Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now the question is, how do we type code that uses such a definition? First,
    let’s take an inventory of all the definitions that this might create. It at least
    creates two constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'We have been starting our interpretation and type-checking with the empty environment,
    but there is no reason we need to, nor do we do so in practice: the primordial
    environment can contain all kinds of pre-defined values and their types. Thus,
    we can imagine the `define-type`above adding the above two definitions to the
    initial type environment, enabling uses of `mt`and `node` to be type-checked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This much is standard across various languages. But less commonly, in plait
    you get two more families of functions: predicates for distinguishing between
    the variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'and accessors for getting the values out of fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Static Type Safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should be troubled by the types of these accessors. They seem to indiscriminately
    try to pull out field values, whether the variant has them or not. For instance,
    we can write and type-check this program, which is appealing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can just as well type-check this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: This should not type-check because it has a clear type-error. The type of `size-wrong` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'so it is perfectly type-correct to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: But running this, of course, results in a run-time error, the very kind of error
    we might have hoped the type-checker would catch.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern-Matching and Type-Checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This kind of error cannot occur naturally in languages like OCaml and Haskell.
    Instead of exposing all these predicates and accessors, instances of an algebraic
    datatype are deconstructed using pattern-matching. Thus, the size computation
    would be written as (`-pm` stands for “pattern matching”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'This might seem like a convenience—it certainly makes the code much more compact
    and perhaps also much more readable—but it’s also doing something more. The pattern-matcher
    is effectively baked into the way programs are type-checked. That is, the above
    algebraic datatype definition effectively adds the following typing rule to the
    type checker:'
  prefs: []
  type: TYPE_NORMAL
- en: Γ `|- e :` BT
  prefs: []
  type: TYPE_NORMAL
- en: Γ `|- e1 :` T
  prefs: []
  type: TYPE_NORMAL
- en: Γ[V <- Number, L <- BT, R <- BT] `|- e2 :` T
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Γ `|- (type-case BT e`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'The first antecedent is clear: we have to confirm that the expression `e`evaluates
    to a BTbefore we pattern-match `BT`patterns against it. The second type-checks
    `e1`in the sameenvironment as in the consequent because the `mt`variant does not
    add any local bindings. The type of this expression needs to be the sameas the
    type from the other branch, due to how we’re handling conditionals. Finally, to
    type-check `e2`, we have to extendthe consequent’s type environment with the bound
    variables; their types we can read off directly from the data definition. In short,
    the above typing rule can be defined automatically by desugaring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside:Notice that there is also an assume-guarantee here: we type-check `e2`in
    an environment that assumesthe annotated types; this is guaranteedby the `node` constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, observe what we couldn’tdo! We didn’t have awkward selectors,
    like `node-v`, for which we had to come up with some type. By saying they consumed
    a `BT`, we had to let them statically consume any kind of `BT`, which caused a
    problem at run-time. Here, there is no selector: pattern-matching means we can
    only write pattern-variables in variants where the algebraic datatype definition
    permits it, and the variables automatically gets the right type. Thus, pattern-matching
    plays a crucial role in the statically safe handling of types.'
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic Datatypes and Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we’ve seen that types can save us both time and space. We have to be
    a little more nuanced when it comes to algebraic datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new type introduced by an algebraic datatype still enjoys the space saving.
    Because the type checker can tell a `BT`apart from every other type, at run-time
    we don’t need to record that a value is a `BT`: it doesn’t need a type-tag. However,
    we still need to tell apart the different variants: the function `size-pm` effectively
    desugars into (`-ds` stands for “desugared”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: (We’ve introduced the `let`to bind the names introduced by the pattern.) What
    this shows is that at run-time, there are conditional checks that need to know
    what kind of `BT`is bound to `t` on this iteration. Therefore, we need just enough
    tagging to tell the variants apart. In practice, this means we need as many bits
    as the logarithm of the number of variants; since this number is usually small,
    this information can often be squeezed into other parts of the data representation.
  prefs: []
  type: TYPE_NORMAL
- en: Union Types and Retrofitted Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typed Racket is an instance of a retrofittedtype system: adding a type system
    to a language that did not previously have types. The original language, which
    does not have a static type system, is usually called dynamic. There are now numerous
    retrofitted type systems: e.g., TypeScript for JavaScript and Static Python for
    Python. There are even multiple retrofitted type systems for some languages: e.g.,
    both TypeScript and Flow add types to JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of a retrofitted type system is to turn run-time errors into static
    type errors. Due to the Halting Problem, we cannot precisely turn every single
    run-time error into a static one, so the designer of the type system must make
    some decisions about which errors matter more than others. In addition, programmers
    have already written considerable code in many dynamic languages, so changes that
    require programmers to rewrite code significantly would not be adopted. Instead,
    as much as possible, type system designers need to accommodate idiomatic type-safe
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic datatypes present a good example. Typically, they have tended to not
    be found in dynamic languages. Instead, these languages have some kind of structure
    definition mechanism (such as classes, or lightweight variants thereof, like Python’s
    [dataclasses](https://www.google.com/url?q=https://docs.python.org/3/library/dataclasses.html&sa=D&source=editors&ust=1695232021455665&usg=AOvVaw2l-qHVAvQWW6klXtg2zXhU)).
    Therefore, the elegant typing that goes with algebraic datatypes and their pattern-matching
    does not apply. Because it is not practical to force dynamic language programmers
    to wholesale change to this “new” (to that dynamic language) style of programming,
    type system designers must find the idioms they use (that happen to be type-safe)
    and try to bless them. We will look at some examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: A good working example of a retrofitted typed language is Typed Racket, which
    adds types to Racket while trying to preserve idiomatic Racket programs. (This
    is in contrast to plait, which is also a typed form of Racket but does not try
    very hard to preserve Racket idioms. The accessors we saw earlier, for algebraic
    datatypes [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)], are forgiving
    in what they accept, at the cost of static safety.)
  prefs: []
  type: TYPE_NORMAL
- en: You Get a Type! And You Get a Type! And You Get a Type!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s return [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)] to our non-statically-type-safe
    accessors in plait: e.g.,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'In a way, it’s not fair to blame the accessor: the fault is really with the
    constructor, because'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Once the `node`constructor creates a `BT`, the information about `node`-ness
    is lost, and there’s not much that the accessors can do. So perhaps the alternative
    is to notcreate a `BT`, but instead create a value of the `node` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s start over. This time, we’ll use a different typed language, Typed
    Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'In Typed Racket, we can create products, called structures, which define a
    new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a constructor with the type we’d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'It also creates a predicate, whose type is a bit different; previously we had
    a function that could only take a `BT`, because it didn’t make sense to apply
    `mt?`to any other type. Now, however, there isn’t even a concept of a `BT`(yet),
    so `mt?` will take values of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '(The additional text, `: mt`, is telling us when the Boolean is true; ignore
    this for now.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try to define nodes. Here we run into a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Union Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Oops—what do we write here?!? We have to also introduce a notion of a binary
    tree. But we already have two existing types, `mt`and (in progress) `node`. Therefore,
    we need a way to define a binary tree that has a sum that combines these two existing
    types. This suggests that we have a way of describing a new type as a union of
    existing types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Observe that in this case, there are no special constructors to distinguish
    between the two kinds of BT. Therefore, this is called an untagged union, in contrast
    to tagged unions [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)].
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go back and complete our definition of `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s look at what Typed Racket tells us are the types of `node`’s constructor,
    predicate, and selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these definitions we can create trees: e.g.,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'But now let’s try to write a program to compute its size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: It is not clear at all that this program should type-check. Consider the expression
    `(node-l t)`. The type of `node-l`expects its argument to be of type `node`. However,
    all we know is that `t`is of type `BT`. Yet this program type-checks!
  prefs: []
  type: TYPE_NORMAL
- en: The fact that this does type-check, however, should not fill us with too much
    joy. We saw how `size-wrong` type-checked, only to halt with an undesired run-time
    error. So what if we instead write its analog, which is this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'This program does nottype-check! Instead, it gives us a type error of exactly
    the sort we would have expected: `node-l`and `node-r`both complain that they were
    expecting an `node`and were given a `BT`. So the wonder is not that `size-tr-wrong`has
    a type-error, but rather that `size-tr` does not!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why it type-checks, we have to go back to the types of the predicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Critically, the `: mt`and `: node`are Typed Racket’s way of saying that the
    Boolean will be true only when the input is an `mt`or `node`, respectively. This
    crucial refinementinformation is picked up by the type-checker. In the right-hand-side
    of the `cond`clauses, it narrowsthe type of `t`to be `mt`and `node`, respectively.
    Thus, `(node-l t)`is type-checked in a type environment where the type of `t`is
    `node`and not `BT`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this theory, we can try another wrong program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have swapped the predicates. It is not only important that this version
    produces a type error, it is also instructive to understand why, by reading the
    type error. This explicitly says that the program expected an `node`(for instance,
    in `node-l`) and was given an `mt`(based on the `mt?`). This confirms that Typed
    Racket is refining the types in branches based on predicates.
  prefs: []
  type: TYPE_NORMAL
- en: If-Splitting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To summarize, `size-tr` type-checks is because the type-checker is doing something
    special when it sees the pattern
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'It knows that every `BT`is related to `mt`and `node`through the union. When
    it sees the predicate, it narrowsthe type from the full union to the branch of
    the union that the predicate has checked. Thus, in the `mt?`branch, it narrows
    the type of `t`from `BT`to `mt`; in the `node?`branch, similarly, it narrows the
    type of `t`to just `node`. Now, `node-l`, say, gets confirmation that it is indeed
    processing a `node`value, and the program is statically type-safe. In the absence
    of those predicates, in `size-tr-wrong`, the type of `t`does not get narrowed,
    resulting in the error. In `size-tr-w2`, swapping the predicates also gives an
    error. Here is one more version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: This program could go either way! It just so happens that it does type-check
    in typed/racket, because typed/racket is “smart” enough to determine that there
    are only two kinds of `BT`and one has been excluded, so in the `else`case, it
    must be the other kind. But one could also imagine a less clever checker that
    expects to see an explicit test of `node?` to be able to bless the second clause.
  prefs: []
  type: TYPE_NORMAL
- en: In short, both the algebraic datatype and union type approaches need some special
    treatment of syntax by the type-checker to handle variants. In the former case
    it’s through pattern-matching. The narrowing technique above is sometimes called
    if-splitting, because an `if`(which `cond`and other conditional constructs desugar
    to) “splits” the union. You will sometimes also see the terms occurrence typingand
    flow typing to describe variants of the ideas in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Aside:This idea was invented by [Typed Racket](https://www.google.com/url?q=https://docs.racket-lang.org/ts-guide/occurrence-typing.html&sa=D&source=editors&ust=1695232021469775&usg=AOvVaw0FOrR34cG9UC9PeiZoFxr8) by
    studying how programmers write code in Scheme and Racket programs. It has later
    proved to be relevant to many real-world retrofitted type systems.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Union Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed when evaluating conditionals [[👉](PLAIVersion3.2.2_split_000.html#h.d1lwuw2pv936)],
    union types can be useful to represent partial functions. There are several ways
    of handling them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dcic-world.org/2022-08-28/partial-domains.html](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&sa=D&source=editors&ust=1695232021470794&usg=AOvVaw0tfeqewvVEB-EA9H442jKE)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an option type avoids the need for ad-hoc type unions. If we have unions
    anyway, however, then we can give types to partial functions: e.g., `(V U Boolean)`in
    Racket or `(V U None)`in Python, respectively, where `V`is the normal return type.
    Thus, Racket’s `string->number`can be given the type `(Number U Boolean)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we’ve just seen is that with if-splitting, we can eliminate union types.
    That then raises the possibility that we can also introduce union types! One way
    is of course by giving union types to built-in functions, as above. But what about
    in user programs? Previously we had rejected such a solution: if we introduced
    a union, we had no way to deal with it. Now we can safely introduce them in languages
    that have solutions for deconstructing them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we introduce union types? Curiously, using the same construct that eliminates
    them! Observe that we no longer need both branches of a conditional to return
    the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ `|- C : Bool    `Γ `|- T : V    `Γ `|- E : W`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (if C T E) : (U V W)`'
  prefs: []
  type: TYPE_NORMAL
- en: where our notation means “the union of the types represented by `V`and `W`”.
  prefs: []
  type: TYPE_NORMAL
- en: How Many Unions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we wrote an algebraic datatype, the variants “belonged” to the new type.
    We had no mechanism for mixing-and-matching variants.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, with union types, a new type is a collection of existing types.
    There’s nothing that prevents those existing types from engaging in several different
    unions. For instance, we had
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: But we could also write, say,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: and reusing mt to define
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, given an mt, what “is” it? Is it a `BT`? A `LinkedList`? It’s all
    those, but it’s also just an `mt`, which can participate in any number of unions.
    This provides a degree of flexibility that we don’t get with algebraic datatypes—since
    we can create ad-hoc unions of existing types—but that also means it becomes harder
    to tell all the ways a value might be used, and also complicates inferring types
    (if we see an `mt`constructed, are we also constructing a `BT`? a `LinkedList`?).
    The Hindley-Milner inference algorithm [[👉](PLAIVersion3.2.2_split_115.html#h.bheym24u3ntv)]
    doesn’t cover these cases, though it can be extended to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Union Types and Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Therefore, union types combined with if-splitting gives us an alternate approach
    of obtaining something akin to algebraic datatypes in our programming language.
    However, we don’t obtain the space benefits of the algebraic datatype definition.
    We created two distinct types; in principle, that’s not a problem. However, to
    write programs, we needed to have predicates (`mt?`and `node?`) that took anyvalue.
    Therefore, those predicates need type-tags on the values to be able to tell what
    kind of value they are looking at. Observe that these are typetags, not variant tags,
    so the amount of space they need is proportional to the number of types in the
    whole program, not just the number of variants in that particular algebraic datatype
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: If-Splitting with Control Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern, of dispatching based on type-tests and values, is quite common
    in dynamic (or “scripting”) languages. These languages do not have a static type
    system, but they do have safe run-times, which attach type tags to values and
    provide predicates that can check them. Programmers then adopt programming patterns
    that take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside:The term dynamiclanguage seems to have no clear fixed definition. It
    means, at least, that the language doesn''t have static types. Sometimes it''s
    implicit that the language is nevertheless safe. But some people use it to mean
    that the language has features that let you do things like inspect or even modify
    the program as it''s running (features like `eval`). In this book I use it in
    the second sense: not-statically typed, but still safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: What, then, is a “scripting” language? I use the term to mean a dynamic
    language that is also very liberal with its types: e.g., many operations are either
    overloaded and/or very forgiving of what a statically-typed language would consider
    an error. Scripting languages tend to be dynamic in all three senses: they do
    not have a static type-system, they are safe, and they tend to have rich features
    for introspection and even modification. They are designed to maximize expressiveness
    and thus minimize just about any useful static analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, here’s an example from JavaScript, of a serialization function.
    A serializer takes a value of (almost) any type and converts it into a string
    to be stored or transmitted. (This version is adapted from version 1.6.1 of Prototype.js.)
  prefs: []
  type: TYPE_NORMAL
- en: '`function serialize(val) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose we’re trying to retrofit a type system onto JavaScript. We would
    need to type-check such programs. But before we even ask how to do it, we should
    know what answer to expect: i.e., is this program even type-safe?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is quite subtle. It uses JavaScript’s `typeof`operator to check the
    tags. For two kinds of values, it returns `false`(that is, the type of this function
    is not `Any -> String`, it’s actually `Any -> (String U Boolean)`, where the `false`value
    is used to signal that the value can’t be serialized—observe that an actual `false`value
    is serialized to `"false"`). For Booleans, numbers, and strings, it translates
    them appropriately into strings. In all these cases, execution returns. (Note,
    however, that the code also exploits JavaScript’s “fall-through” behavior in `switch`,
    so that `"undefined"`and `"function"` are treated the same without having to repeat
    code. The type-checker needs to understand this part of JavaScript semantics.)
  prefs: []
  type: TYPE_NORMAL
- en: If none of these cases apply, then execution falls through; we need to know
    enough JavaScript to know that this corresponds to the one other return from `typeof`,
    namely objects. Now the code splits between objects that are and aren’t `null`.
    In the non-`null` case, it iterates through each field, serializing it in turn.
    Therefore, this program is actually type-safe…but for very complicated reasons!
  prefs: []
  type: TYPE_NORMAL
- en: If-Splitting with Control Flow and State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s another program, taken from the Python 2.5.2 standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: This function inserts an element (`x`) into an already-sorted list (`a`). It
    also takes a low search interval index (`lo`), which defaults to `0`, and a high
    interval (`hi`), which defaults to `None`. It inserts the element into the right
    place in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s ask whether this is actually type-correct. Observe that `lo`and `hi` are
    used in several arithmetic operations. These are the ones we’re most interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it helps, here’s the code with type annotations in [Static Python](https://www.google.com/url?q=https://github.com/facebookincubator/cinder&sa=D&source=editors&ust=1695232021481698&usg=AOvVaw2pIqSg2CpkTCGrPRBDemlf):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: (In Static Python, `Optional[T]`is an abbreviation for `(T U None)`. So the
    annotation on `hi`above allows the user to pass in either an `int`or `None`. What
    makes the last two arguments optional is (perhaps confusingly) not the type `Optional` but
    rather the fact that they have default values in the function header.)
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easier to see what’s happening with `lo`: it’s allowed to be optional;
    if the optional argument is provided, it must be an `int`; and if it’s not provided,
    it has value `0`, which also has type `int`. So its type is effectively `(int
    U int)`, which is just `int`, so all uses of `lo`as an `int` are fine.'
  prefs: []
  type: TYPE_NORMAL
- en: But now consider the type of `hi`. It is also optional. If it is provided, it
    has to be an `int`, which would be fine. But if it’s notprovided, its value is
    `None`, which cannot be used in arithmetic. However, right at the top, the function
    checks whether it is `None`and, if so, changesit to the result of `len(a)`—which
    is an `int`. Therefore, once the if is done, no matter which path the program
    takes, `hi`is an `int`. Thus, the program is actually type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all well and good for us to reason about by hand. However, our job is
    to build a type-checker that will neither reject programs needlessly nor approve
    type-incorrect programs. This balance is very hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This represents the challenge retrofitted type system designers face: they
    must either reject idiomatic programs or add complexity to the type system to
    handle them. If we reject the program, we reject many other programs like it,
    which are idiomatically found in many “scripting” languages. The result would
    be very safe, but also very useless—indeed, safe because it would be very useless—type-checker
    (a type-checker that rejects every program would be extremely safe…). Instead,
    we need an even more complicated solution than what we have seen until now.'
  prefs: []
  type: TYPE_NORMAL
- en: Aside:See [this paper](https://www.google.com/url?q=https://cs.brown.edu/people/sk/Publications/Papers/Published/gsk-flow-typing-theory/&sa=D&source=editors&ust=1695232021485488&usg=AOvVaw2-6nKeOUE7cQ6F3KqzAJ7z) for
    how to type such programs.
  prefs: []
  type: TYPE_NORMAL
- en: The Price of Retrofitting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retrofitting a type-system onto an existing untyped language clearly puts a
    heavy burden on the creator of the type system. But it also puts a burden on developers.
    If the type system is to not reject a bunch of existing code, then it must be
    based on some heuristics about program structure. The more complex these heuristics
    grow (as we’ve seen hints of in this chapter), the stranger it will be when a
    program falls outside what they can handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might argue that it was ever thus: when type-checking algebraic datatypes,
    too, we had to use pattern-matching to help the type-checker. The difference there
    is that the type-checker was around at program construction time, so we adhered
    to its rules from the very start; we didn’t try to add types after the fact. The
    problem arises when programmers are allowed to write code however they like, and
    the type-checker must retroactively try to bless them.'
  prefs: []
  type: TYPE_NORMAL
- en: Types and Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we should clarify something important about the `typeof`operator in
    JavaScript, which is analogous to the `type`function in Python. When we impose
    a type system on JavaScript, we expect, say, the type `(Number -> String)`to be
    different from the type `(String -> Boolean)`. Similarly, an object that contains
    only the fields `x`and `y`is very different from the object that contains only
    the method `draw`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, these nuances are lost on `typeof`, which is innocent to even the
    existence of any such type systems. Therefore, all those functions are lumped
    under one tag, `"function"`, and all those objects are similarly treated uniformly
    as one tag, `"object"`(and analogously in Python). This is because their names
    are misleading: what they are reporting are not the typesbut rather the run-time
    tags.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between types and tags can grow arbitrarily big. After all, the
    number of types in a program can grow without bound, and so can their size (e.g.,
    you can have a list of lists of arrays of functions from …). But the set of tags
    is fixed in many languages, though in those that allow you to define new (data)classes,
    this set might grow. Nevertheless, tags are meant to take up a fixed amount of
    space and be checked in a small constant amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this difference is not inherently problematic. After all, even in
    statically-typed languages with algebraic datatypes, we still need space to track
    variants, which requires a kind of (intra-type) tag. The issue is rather with
    the choice of name: that `typeof`and `type`do not, actually, return “types”. A
    more accurate name for them would be something like `tagof`, leaving the term
    “type” free for actual static type systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Nominal Types, Structural Types, and Subtyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s go back to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: and ask how we could have represented this in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now: Represent this in Java!
  prefs: []
  type: TYPE_NORMAL
- en: How did you do it? Did you create a single class with `null` for the empty case?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: Why is that solution not object-oriented?
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic Datatypes Encoded With Nominal Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll take a different approach. Observe from the datatype definition that
    we have two constructors, and one type that represents their union. We can encode
    this in Java as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'How is the “if-splitting” addressed here? It’s done in a hidden way, through
    dynamic dispatch. When we invoke a method, Java makes sure we run the right method:
    there are actually two concrete `size`methods, and the run-time picks the right
    one. Once that choice is made, the class in which the method resides automatically
    determines what is bound. Thus, the `size`in `node`can safely use `this.l`and
    `this.r`, and the type-checker knows that those fields exist.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is, then, similar to, yet different from, our two prior solutions: using
    algebraic datatypes and union types. The solutions are structurally different,
    but they are all similar in that some syntactic pattern must be used to make the
    program statically type-able. With algebraic datatypes, it was pattern-matching;
    with union types, it was if-splitting; in Java, it’s the splitting of the code
    into separate methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The algebraic datatype and Java solutions are even more connected than we might
    imagine. With algebraic datatypes, we fixed the set of variants; but we were free
    to add new functions without having to edit existing code. In Java, we fix the
    set of behaviors (above, one method), but can add new variants without having
    to edit existing code. Therefore, neither has an inherent advantage over the other,
    and one’s strengths are the other’s weakness. How to do bothat once is the essence
    of the [Expression Problem](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Expression_problem&sa=D&source=editors&ust=1695232021492211&usg=AOvVaw3l4_wQP5pOCFZHndfQMdbX).
    See also the concrete examples and approaches given in these two papers, one focusing
    on a [Java-based approach](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&sa=D&source=editors&ust=1695232021492633&usg=AOvVaw2Xm1yq3fY2pVUVr5sWjXEr)and
    another [function-centric](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kf-ext-sw-def/&sa=D&source=editors&ust=1695232021492914&usg=AOvVaw0SbXWoMkkqB5ySEJa9jMG3).
  prefs: []
  type: TYPE_NORMAL
- en: Nominal Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type system in Java is representative of an entire class of languages. These
    have nominaltypes, which means the nameof a class matters. (“Nominal” comes from
    the Latin nomen, or name.) It’s easiest to explain with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above we have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now suppose we create another class that is identical in every respect
    but its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say we have a method that takes `mt` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'But observe that `empty`is a perfectly good substitute for `mt`: it too has
    a `size`method, which too takes no arguments, and it too returns an `int` (in
    fact, the very same value). Therefore, we try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '`System.out.println(m(new` empty`()));`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: But Java rejects this. That’s because it expects an object that was constructed
    by the actual class `mt`, not just one that “looks like” it. That is, what matters
    is which actual (named) class, not what structure of class, created the value.
  prefs: []
  type: TYPE_NORMAL
- en: Structural Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast, we can imagine a different type system: one where the type of
    each of the above classes is not its name but rather a description of what fields
    and methods it has: i.e., it’s structure, or its “services”. For instance, we
    might have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: That is, each of these is a collection of names (one name, to be precise), which
    is a method that takes no parameters and returns an `int`. Whenever two types
    are the same, objects of one can be used where objects of the other kind are expected.
    Indeed, it is unsurprising that both kinds of trees have the same type, because
    programs that process one will invariably also need to process the other because
    trees are a union of these two types. Similarly, we also have
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'The above m method might be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static int m(o` : {size : (-> int)}`) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, it only indicates what shape of object it expects, and doesn’t indicate
    which constructor should have made it. This is called structuraltyping, though
    the Internet appears to have decided to call this “duck” typing (though it’s hard
    to be clear: there is no actual theory of duck typing to compare against well-defined
    theories of structural typing: [Abadi and Cardelli](https://www.google.com/url?q=https://www.springer.com/gp/book/9780387947754&sa=D&source=editors&ust=1695232021498288&usg=AOvVaw3AweVzQ_7nSMI7klfzt2li)represent
    a classical viewpoint, and here’s an [extension](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/&sa=D&source=editors&ust=1695232021498703&usg=AOvVaw2EFVs5AkPquJx2jsIUl9pQ) for
    modern “scripting” languages).'
  prefs: []
  type: TYPE_NORMAL
- en: Nominal Subtyping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve been writing a bit gingerly about Java above: because we know that the
    `m`method will accept not only `mt`’s but also anything that is a sub-class of
    `mt`. Let’s explore this further.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify things, let’s make some basic classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also create a shell “runner”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'and try filling in different values for the blanks and seeing what output we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println((true ?` new B()`:` new B()`).who);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsurprisingly, this prints `"B"`. What about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println((true ?` new B()`:` new A()`).who);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might expect this to also print `"B"`, because that’s the value that we
    created. However, it actually prints `"A"`! Let’s see a few more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println((true ?` new B()`:` new C()`).who);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Will this print `"B"`? No, in fact, this also prints `"A"`! How about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println((true ?` new B()`:` new D()`).who)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println((true ?` new B()`:` 3`).who)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these produce a static error. It’s instructive to read the error message:
    in both cases they reference `Object`. In the former case, it’s because there
    is nothing else common to B and D. But in the latter case, the primitive value
    3 was effectively converted into an object—`new Integer(3)`—and those two object
    types were compared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is happening in the type system that causes this error? The cause is documented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3](https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html%23jls-15.25.3&sa=D&source=editors&ust=1695232021502810&usg=AOvVaw13Y12I72q4_WhlbdEUkvSr)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the document says:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the conditional expression is the result of applying capture conversion
    (§5.1.10) to lub(T1, T2).
  prefs: []
  type: TYPE_NORMAL
- en: 'where “lub” stands for “least upper bound”: the “lowest” class “above” all
    the given ones. This type is determined statically. That is, the type rule is
    essentially:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Γ `|- C : Bool    `Γ `|- T : V    `Γ `|- E : W    X = lub(V, W)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'Γ `|- (if C T E) : X`'
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this to the other rules we’ve seen for conditionals! The first type
    rule we saw was the most rigid, but produced the most usable values (because there
    was no ambiguity). The second type rule, for union types, was less rigid, but
    as a result the output type could have a union that needed to be split. This type
    rule is even less rigid (in terms of what the two branches produce), but the result
    could be as general as `Object`, with which we can do almost nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Subtyping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general principle here is called subtyping: we say that type `X`is a subtype
    of `Y`, written `X <: Y`(read the `<:`like a “less than” or “contained”), whenever
    `X`can be used wherever a `Y`was expected: i.e., `X`can safelybe substitutedfor
    `Y`.'
  prefs: []
  type: TYPE_NORMAL
- en: Java chose to make sub-classes into sub-types. Not all object-oriented languages
    do this, and indeed many consider it to be a mistake, but that’s the design Java
    has. Therefore, a sub-class is expected to offer at least as many services as
    its super-class; and hence, it can be substituted where a super-class is expected.
    The lub computation above finds the most specific common super-type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an account of how subtyping works for nominalsystems. This has the
    virtue of being fairly easy to understand. We can also define subtyping for structuralsystems,
    but that is rather more complex: some parts are easy to follow, other parts are
    a bit more tricky (but essential to obtain a sound type system). For a detailed
    explanation, with an illustrative example, see [section 33.6.1 of PAPL](https://www.google.com/url?q=https://papl.cs.brown.edu/2020/objects.html%23%2528part._subtyping%2529&sa=D&source=editors&ust=1695232021505625&usg=AOvVaw25ykJjwpXl83jpgPY6xeR9).'
  prefs: []
  type: TYPE_NORMAL
- en: Gradual Typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From Scripts to Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As dynamic language programs grow, they become increasingly hard to maintain.
    Programmers use types to define interfaces, communicate expectations of behavior,
    document, and so on, and in their absence, we need several ad hoc tools. Put differently,
    we want “scripts” to grow up and become “programs”.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, one of the most visible trends in programming languages over the past
    ten years is dynamic languages adding a static counterpart. In principle, this
    is as simple as adding a type-system to an existing language. As we’ve already
    seen when discussing retrofitted types [[👉](PLAIVersion3.2.2_split_125.html#h.tg4ohkq8ngzt)],
    however, such a type system needs to take into account the idiomatic style of
    programming in the language; otherwise it would report as erroneous too many programs
    that are actually type-correct, and this high false-positive rate would make people
    not use the type system at all. Therefore, we discussed some patterns of code
    that need to be supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another major obstacle to adoption is that people often have a large amount
    of code lying around, and it is simply impractical to convert all of it to a typed
    language in one go. In fact, some of it may not even be typeable by most reasonable
    type systems: e.g., the `eval`construct, which takes a dynamic string (e.g., one
    that may be constructed on-the-fly during program execution) and runs it. By definition,
    we statically do not know what this string is; without knowing it, we can’t possibly
    type it statically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, there are two reasons why we cannot expect the whole program to make
    an instant transition from untyped to typed:'
  prefs: []
  type: TYPE_NORMAL
- en: The program is too large, and programmers have other things to do with their
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some parts of the program may not even be typeable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (You don’t need `eval` to make things hard to type. Many dynamic constructs
    that look at program behavior and modify it have the same flavor. They enter the
    language because it’s dynamic and doesn’t have to worry about a static type discipline,
    and then create an obstacle for later typing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite this, type systems have been built for many real-world dynamic languages.
    These type systems exhibit a property called gradual typing: as the name suggests,
    you add types “gradually” to the program, hopefully making it more-and-more typed.
    What started out as an academic idea in the Scheme community (two papers in 2006
    introduced gradual typing for Scheme) is now [widely used in industry](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Gradual_typing&sa=D&source=editors&ust=1695232021507601&usg=AOvVaw0ZgqxCx2wfimBQuPFFxnVE).'
  prefs: []
  type: TYPE_NORMAL
- en: Micro Versus Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In gradual typing, we are going to add annotations to programs and then type-check
    the program. Within this broad principle, there are two schools of thought.
  prefs: []
  type: TYPE_NORMAL
- en: 'In “micro” gradual typing we can add annotations to any subset of the variables
    of the language. We saw this earlier in the Static Python example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have annotations on `lo`and `hi`, but not on `a`and `x`. Ergonomically,
    this is very convenient for the programmer: use annotations for the parts you
    care about, and not for the parts you don’t. Unfortunately, this comes at a cost:
    there is now a much more complex language where any parts of a program can be
    static and any other parts dynamic, and they can freely commingle in the same
    body of code, even in a single expression or line (e.g., from the same example:
    `hi = len(a)`). The type system needs to somehow deal with constructs it cannot
    meaningfully type (like `eval`). Also, previously we had a clean and simple soundness
    result for the typed program; now it is rather unclear what soundness means. In
    turn, that means that programmers may put a lot of effort into annotations, but
    without a clear guarantee of what they are getting in return. (A large body of
    literature now tries to make sense of this.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, there is another approach, often called “macro” gradual typing.
    In the macro approach, there are two languages: the typed and the dynamic one.
    They are expected to be very similar—so similar that they have the same run-time
    system and can freely share values—so we’ll refer to them as “sibling” languages.
    However, they may not have the same constructs (e.g., the typed language would
    not contain `eval`). Instead of freely mixing code between typed and untyped,
    we only have to figure out what happens when values travel between the languages,
    not within each one. The expectation is that the programmer will gradually migrate
    part of their codebase from the dynamic to the typed language, typically a function
    at a time. Each language can import code from the other, but when importing into
    typed code, the programmer must specify a type for the imported code.'
  prefs: []
  type: TYPE_NORMAL
- en: A canonical example of this approach is Typed Racket. Because Typed Racket is
    one of the oldest and most developed gradually typed languages (technically, it’s
    the combination of Racket and Typed Racket that is gradually typed—Typed Racket
    itself is fully typed), and also offers some of the most interesting perspective
    on what happens when values travel between languages, we will use that as our
    exemplar for study.
  prefs: []
  type: TYPE_NORMAL
- en: Typed Racket at Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In what follows, it’s critical to pay attention to the exact details of error
    messages!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s write the following function in `#lang racket` and test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: As we would expect,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: because the string represents a valid number,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: because the string doesn’t represent a valid number, and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'string->number: contract violation'
  prefs: []
  type: TYPE_NORMAL
- en: 'expected: string?'
  prefs: []
  type: TYPE_NORMAL
- en: 'given: 5'
  prefs: []
  type: TYPE_NORMAL
- en: because `5` isn’t a string at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s define it in Typed Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#lang typed/racket`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: The type-checker confirms that this program is well-typed.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise: As a test, try
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose we export this function from Typed Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'and import it into the Racket module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try the same three tests. Predictably, two of them work the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'The third still produces an error, but a rather different kind of error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'f: contract violation'
  prefs: []
  type: TYPE_NORMAL
- en: 'expected: string?'
  prefs: []
  type: TYPE_NORMAL
- en: 'given: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'in: the 1st argument of'
  prefs: []
  type: TYPE_NORMAL
- en: (-> string? any)
  prefs: []
  type: TYPE_NORMAL
- en: 'contract from: typed.rkt'
  prefs: []
  type: TYPE_NORMAL
- en: 'blaming: untyped.rkt'
  prefs: []
  type: TYPE_NORMAL
- en: (assuming the contract is correct)
  prefs: []
  type: TYPE_NORMAL
- en: 'at: typed.rkt:5:9'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what is happening. When we export f from Typed Racket, we don’t just
    export the function in its raw form. Rather, Typed Racket wraps the function in
    contracts that “protect” it in a dynamic setting. Thus, it is as if the function
    that was exported was
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '(with suitably different error messages). Notice that `wrapped-f`behaves exactly
    like our imported `f`does: the error when given `5` is from a contract check,
    rather than from an internal operation. Observe also that this wrapped version
    is quite easy to produce in a completely mechanical way, i.e., through desugaring:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (f [`s`:` String`]) :` Number'
  prefs: []
  type: TYPE_NORMAL
- en: (+ 1 (or (string->number s) 0))`)`
  prefs: []
  type: TYPE_NORMAL
- en: became
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (wrapped-f` s`)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  (if (`string?s`)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([b` (+ 1 (or (string->number s) 0))`])`'
  prefs: []
  type: TYPE_NORMAL
- en: '`        (if (`number?` b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '`(error ''contract "returned value was not a` Number`")))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(error ''contract "provided value was not a` String`")))`'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:Why do we bind `b` to the result of the body? Why not use the body
    expression directly?
  prefs: []
  type: TYPE_NORMAL
- en: The point of this wrapping is to put the type annotations to work in a dynamic
    setting. Essentially, the programmer who has put the effort to add annotations
    and get the program through the type-checker gets assurance that their function
    will not be abused through checks that are early and more informative than an
    internal error (that may not even occur, depending on the inputs, leaving the
    error to lurk!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a more interesting example. We define the following typed function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its Racket counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s assume we are trying to use both of these from Racket. We first define
    a function that produces strings from strings, i.e., one that does notmatch the
    function expected by either `h`or `j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'Now watch what happens when we run `(j str-dbl)`and `(h str-dbl)`. Both produce
    a run-time error, but very different ones. The former (which is entirely in Racket)
    gives an error at `+`: the “doubled” string is produced and makes it as far as
    `+`, which reports a violation. In contrast, in the latter case, the doubled string
    is produced but, when it tries to return from `(i "5")`, the type `(-> String
    Number)`has been turned into a contract, which halts execution saying that there
    is a contract violation!'
  prefs: []
  type: TYPE_NORMAL
- en: Aside:To get a sense of Racket’s contract system, see [Contracts](https://www.google.com/url?q=https://docs.racket-lang.org/guide/contracts.html&sa=D&source=editors&ust=1695232021518320&usg=AOvVaw3cHKDevH_K7R7ne4KDUsP7) in
    the Racket Guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Another interesting static-dynamic language combination is Racket
    with plait. plait does not try very much to accommodate Racket idioms, though
    it does to some extent: recall the predicates and accessors in algebraic dataytypes
    [[👉](PLAIVersion3.2.2_split_120.html#h.e43aokkp4uwk)], though at the cost of static
    type safety. Largely, however, plait is trying to implement the Standard ML type
    language. Nevertheless, because plait lives in the context of Racket, its values
    can be exported and used from Racket. Try the above examples in plait!'
  prefs: []
  type: TYPE_NORMAL
- en: ••••• Non-Standard Models •••••
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen some non-standard features, but they are in widespread
    use. Here we look at some that are less widely used (though some are growing in
    prominence, and others are enjoying a renaissance) but provide fascinating views
    of what programming languages can do.
  prefs: []
  type: TYPE_NORMAL
- en: Relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Language Genealogy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to record a genealogy of programming languages and determine
    which languages obtained ideas from which ones. We start by recording which languages
    directly borrowed ideas from which ones: e.g., Java directly borrowed from C++,
    and C++ directly borrowed from C. From that, we can also trace the descendants
    down a chain of borrowing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write some of these in the following, maybe peculiar, syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'means that the language `A`borrows from the language `B`(i.e., `A`is newer,
    `B`is older). For another peculiar reason, we will write constants not as quotes
    but as alphanumeric strings with a lower-case initial. Given that, here are some
    facts (with `cpp` standing for C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can express the notion of being a descendant: there are two ways that
    `A`can be a descendant of `B`. One is if `A`borrows directly from `B`. The other
    is if it borrows from some language `Z`that is itself a descendant of `B`. We
    express these two rules using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations, you’ve just written your first Prologprogram. To see this
    run, you can use [SWI Prolog online](https://www.google.com/url?q=https://swish.swi-prolog.org/&sa=D&source=editors&ust=1695232021521364&usg=AOvVaw3htfQEX93FhT5bpRmnE6re).
    But what does it mean to “run” this? Prolog answers questions: we can ask several
    questions like:'
  prefs: []
  type: TYPE_NORMAL
- en: Does `cpp`borrow from `c`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: → true
  prefs: []
  type: TYPE_NORMAL
- en: Does `cpp`borrow from `bcpl`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: → false
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we can see that Prolog is acting like a basic database. But we can
    do more:'
  prefs: []
  type: TYPE_NORMAL
- en: Does `cpp`descend from `bcpl`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: → true
  prefs: []
  type: TYPE_NORMAL
- en: Does `bcpl`descend from `cpp`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: → false
  prefs: []
  type: TYPE_NORMAL
- en: 'Aha: so Prolog will not only query basic facts, it will also process queries
    through rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can actually ask Prolog more sophisticated questions that look more
    like function applications. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: What does `cpp` borrow from?
  prefs: []
  type: TYPE_NORMAL
- en: borrows(cpp, X).
  prefs: []
  type: TYPE_NORMAL
- en: →
  prefs: []
  type: TYPE_NORMAL
- en: X= c
  prefs: []
  type: TYPE_NORMAL
- en: This seems to treat borrows like a rather funny function, calling it with a
    variable (a name that begins with a capital letter) and letting Prolog fill in
    the variable. Does that work only for basic definitions, or also for rules?
  prefs: []
  type: TYPE_NORMAL
- en: What does `cpp` descend from?
  prefs: []
  type: TYPE_NORMAL
- en: descends(cpp, X).
  prefs: []
  type: TYPE_NORMAL
- en: →
  prefs: []
  type: TYPE_NORMAL
- en: X= c
  prefs: []
  type: TYPE_NORMAL
- en: X= bcpl
  prefs: []
  type: TYPE_NORMAL
- en: Oh, this is interesting! Prolog didn’t return just one answer; it returned allthe
    answers. And this was done by using a variable(a name that begins with a capital
    letter). This naturally suggests the question, what if we did it the other way
    around?
  prefs: []
  type: TYPE_NORMAL
- en: What descends from `cpp`?
  prefs: []
  type: TYPE_NORMAL
- en: descends(X, cpp).
  prefs: []
  type: TYPE_NORMAL
- en: →
  prefs: []
  type: TYPE_NORMAL
- en: X= java
  prefs: []
  type: TYPE_NORMAL
- en: 'This is even stranger: it’s like passing a variable as an argument and asking
    what inputs will produce a particular result from the function!'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a function is just the wrong way to think about any of this. What is
    happening in Prolog is that we’re defining relations. So borrows and descends
    are actually relations, where one (borrows) is defined by concrete examples and
    the other (descends) by abstract rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we understand these are relations, we no longer need to limit ourselves
    to just one source of borrowing, to better reflect reality. That is, let’s say
    this is our set of facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can ask what all languages contributed to JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'From this set of facts, we learn:'
  prefs: []
  type: TYPE_NORMAL
- en: X= self
  prefs: []
  type: TYPE_NORMAL
- en: X= scheme
  prefs: []
  type: TYPE_NORMAL
- en: X= smalltalk
  prefs: []
  type: TYPE_NORMAL
- en: X= simula
  prefs: []
  type: TYPE_NORMAL
- en: X= algol
  prefs: []
  type: TYPE_NORMAL
- en: X= lisp
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can ask how widely Lisp’s influence spread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'And we learn that for this very limited set of languages:'
  prefs: []
  type: TYPE_NORMAL
- en: X= scheme
  prefs: []
  type: TYPE_NORMAL
- en: X= javascript
  prefs: []
  type: TYPE_NORMAL
- en: Encoding Type Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that we’re writing rules that are quite similar to the
    typing rules we’ve written. Let’s see whether we can encode them directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to encode the rules for syntactic constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: We will use the Prolog constant `numE` to stand for a syntactic numeric expression,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using just what we already know, we can encode the conditional rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is literally just a syntactic transformation of the rules we
    wrote before!
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can now use Prolog as a checker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: → true
  prefs: []
  type: TYPE_NORMAL
- en: 'and as a calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: →
  prefs: []
  type: TYPE_NORMAL
- en: Y= numT
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can do something much more intriguing: what if we leave variables in
    the program?'
  prefs: []
  type: TYPE_NORMAL
- en: tc(ifE(boolE, plusE(numE, Y), numE), numT).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is asking Prolog to come up with programs that will make this program
    have numeric type. Prolog responds with:'
  prefs: []
  type: TYPE_NORMAL
- en: Y= numE
  prefs: []
  type: TYPE_NORMAL
- en: Y= plusE(numE, numE)
  prefs: []
  type: TYPE_NORMAL
- en: Y= plusE(numE, plusE(numE, numE))
  prefs: []
  type: TYPE_NORMAL
- en: Y= plusE(numE, plusE(numE, plusE(numE, numE)))
  prefs: []
  type: TYPE_NORMAL
- en: (and many more; the structure of terms reveals something about how Prolog works).
    That is, Prolog is acting as a program synthesizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how to extend this to include the type environment. For that,
    we have to enlarge our typing rules to include an environment as well. Recall
    that the environment doesn’t matter for the axioms, while the other rules just
    pass the environment through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s add the three variable-oriented rules. We will use a list of `bind` relations
    to capture the environment. To look up a variable, we pattern-match on whether
    the variable is the first binding; if it is we can respond with the relevant type,
    otherwise we must search in the remaining bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: The Prolog notation `[ … | … ]`means to decompose a list into a first, or head,
    element to the left of the `|`and the rest, or tail, to the right of the `|`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two rules look much more like the type rules we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that in the above rule, we have done away with the type annotation!
    This rule looks more like what we would write with type inferencethan with type
    checking. Finally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use these definitions with the example we used for type inference.
    Let’s translate this program (we have only single-argument functions) from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass this to the `tc` relation, encoded as follows, with the type environment
    and result type left variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'Prolog produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: T= funT(boolT, funT(numT, numT))
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, it has effectively inferred the type of the function: `v`has
    Boolean type, `w` has numeric type, and the result of the whole expression is
    a number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, it has inferred the types of the parameters. Now let’s consider
    some type-erroneous programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: → false
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, Prolog tells us it can’t find any variable name that would satisfy this
    shape of program. But if instead we give it a program with holes to fill in for
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: 'Prolog tries to build bigger and bigger terms that might work, and goes into
    an infinite loop trying to find a program that is typeable! In general, this is
    a problem for synthesis systems: if the problem they are given has a solution
    they can often find one quickly, but if it does not have a solution, they have
    to spend a long time trying to find one—either very long, if it’s a large but
    finite space to search, or infinitely long, if the space is infinite. Often, synthesizers
    will use heuristics to truncate this search.'
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Canonical Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following canonical Python program that uses generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: produces `0 + 1 + 2`= `3`. But how does it work?
  prefs: []
  type: TYPE_NORMAL
- en: At a textual level, we can understand it as follows. `nats`looks like a function,
    but it has the keyword `yield`in it. This makes it not a function but a generator.
    Its body initializes `n`to `0`, then goes into an infinite loop. Each time through
    the loop, it yieldsthe current value of `n`, then increments it, before continuing
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Outside the definition of `nats`, we define `g`to be an instanceof the generator,
    and each call to `next`gets the next yielded value. This explains the result.
    What we need to do is understand what is going on inside `nats`, and hence what
    happens with generators in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is clear that we cannotthink of `nats`(or of the generator returned by it)
    as a function. If we do, then clearly it goes into an infinite loop. That means
    the very first `next`call would run forever; it would never produce a value, which
    enables the next `next` call, and then the third, producing the sum. To see this,
    imagine we had the following version instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Here, even though natsr (“`nats`with `return`”) has an infinite loop, every
    time Python runs the `return`, it halts the function and returns. Furthermore,
    on the next call, we start again from the beginning of `natsr`. As a result, each
    call produces `0`so the sum is also `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, that is clearly not what is happening in (the generator created
    by) `nats`. Rather, it’s clear that—as the name `yield`suggests—the computation
    is haltingwhen the `yield`occurs. When we call `next`, computation does not start
    at the top of `nats`; if it did, `n`would be `0`. Instead, it resumesfrom where
    it left off, so that the value of `n`is incremented and the next iteration of
    the `while` loop occurs.
  prefs: []
  type: TYPE_NORMAL
- en: If all of this sounds suspiciously like variables in a scope being held on to
    by a closure, you’re on the right track. To understand this more, though, we need
    to peer a bit more closely at the evaluation. While we could run this in the [Python
    Tutor](https://www.google.com/url?q=https://pythontutor.com/python-debugger.html%23mode%3Dedit&sa=D&source=editors&ust=1695232021543587&usg=AOvVaw1V3VjgOrP0CFbXmfhLsC-A),
    that tool does not really have the support necessary for us to understand what
    is happening in this program. Instead, we will turn to our Stacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: In Python, generators are merely syntactic sugar over the more general
    notion of iterators. Iterators respond to the `next`protocol. To learn how a generator
    desugars into an iterator, see [this StackOverflow post](https://www.google.com/url?q=https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators&sa=D&source=editors&ust=1695232021544241&usg=AOvVaw2tKB37Q1fKdFcreD_ejsF-).
    To understand Python generators in more depth, see sections 4.1 and 4.3 of [this
    paper](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&sa=D&source=editors&ust=1695232021544525&usg=AOvVaw1G24Y80eCAnFcayzoealQX).'
  prefs: []
  type: TYPE_NORMAL
- en: Translating to SMoL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following program is a rough simulation of the above Python program ifSMoL
    had a notion of `yield`, which it does not. To avoid unbound identifier errors,
    we will use the following simple definition of `yield`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then translate the above code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity, we’re ignoring the step where we instantiate the generator:
    i.e., we can have only one copy of the generator in this version, whereas the
    Python version lets us instantiate multiple. We will return to this later.'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that running the above program goes into an infinite loop, because `yield` does
    not “yield”. However, because the Stacker shows us intermediate steps in the computation,
    it still provides something very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this program, let’s run it through the Stacker. We will see
    a few preliminary states, and then one that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image10.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, the oldest frame represents the top-level expression, which is
    waiting for the first call to `gen`to compute. Inside `gen`, we have initialized
    `n`to `0`. Now we are about to start computing the (potentially) infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little bit later, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image20.png)'
  prefs: []
  type: TYPE_IMG
- en: This picture is the essence of generators. Understanding it is critical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what is happening here. The top-level computation is waiting for the
    call to `gen`to finish and produce an answer. Withinthe generator, the computation
    has initialized n and is about to yield its current value. What is critical is
    the context of this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: in @1678, which has no bindings and hence defers to @1909\. This binds `n`to
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we could break up this stack into two parts (with the environment
    and store shared as needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: in @1233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: in @1678
  prefs: []
  type: TYPE_NORMAL
- en: Observe that each part looks like a full-fledged stack in its own right! The
    environment @1233 refers to names that the top-level uses (such as `gen`), while
    the environment @1678 (and hence @1909) refers to ones that the generator uses
    (such as `n`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, however, we have acted as if a program has only one stack. The simplest
    conceptual model for a generator is:'
  prefs: []
  type: TYPE_NORMAL
- en: Each generator has its own local stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, the generator’s stack does not know about the computation in the main
    program or in any other generators. It only knows about the computation that it
    is performing. A `yield` does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It transparently (i.e., without the programmer’s knowledge) stores the local stack
    with the generator data structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the yielded value to the stack that invoked the generator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everything else—variables, aliasing, closures, growth and decline of the stack
    with functions calls and returns, etc.—stays exactly the same. The only difference
    is that calling a generator causes computation to start, or resume the context,
    in a separate, disconnected stack.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in the above model, after the first `yield` succeeds, the top-level stack
    frame would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: in @1233
  prefs: []
  type: TYPE_NORMAL
- en: invoking the generator. This would resume the previous stack, so `n` would be
    set to 1, and the next iteration of the loop would run, which would
  prefs: []
  type: TYPE_NORMAL
- en: Store the generator’s stack (which, conceptually, is exactly the same—only the
    value of `n` has changed, but that is in the environment), and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return the new value of `n`(i.e., `1`) to the top-level stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This would result in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: in @1233
  prefs: []
  type: TYPE_NORMAL
- en: repeating the above process, and hence producing `3`.
  prefs: []
  type: TYPE_NORMAL
- en: A Richer Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using what we have learned, let us consider another Python example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: 'This program has two distinct generator creators: the one we’ve already seen
    for natural numbers, and one more that filters the natural numbers to produce
    only odd numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: We can now think of control proceeding as follows. First, we make an instance
    of `odds`and bind it to `g`. This immediately creates an instance of `nats`and
    binds it (within the instance of `odds`) to `ns`. Now all our generators are set
    up and ready to compute.
  prefs: []
  type: TYPE_NORMAL
- en: We now begin the infinite loop in `odds`. This calls the natural number generator.
    At this point, the odd number generator’s local stack looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: in an environment where `ns`is bound to a generator and `n` is uninitialized
  prefs: []
  type: TYPE_NORMAL
- en: Because we have called a generator, not a function, computation now runs in
    that generator’s own stack. This is the natural number generator, which we have
    already studied. It binds `n`to `0`and then `yield`s, storing its local stack—
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: in an environment where `n`is bound to `0`
  prefs: []
  type: TYPE_NORMAL
- en: —and returning `0` to the odd number generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This resumes the odd generator’s stack. This binds n to 0 and performs the
    comparison. It fails, continuing the loop body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Now we are again ready to invoke the natural number generator. The odd number
    generator’s localstack is unchanged from before (same context, same environment,
    except this time the environment does have a binding for `n`, to `0`). Meanwhile,
    the natural’s generator resumes from
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: in an environment where `n`is bound to `0`
  prefs: []
  type: TYPE_NORMAL
- en: 'This increments `n` and resumes the loop body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: This immediately causes it to yield `1`, leaving the stack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: in an environment where `n`is bound to `1`
  prefs: []
  type: TYPE_NORMAL
- en: This resumes the odd generator’s stack. This binds `n`to `1`, so the conditional
    succeeds. Therefore, the stack at the point of yielding becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: in an environment where `ns`is bound to a generator and `n`is bound to `1`
  prefs: []
  type: TYPE_NORMAL
- en: This completes the first call to `next(g)`, enabling the top-level stack frame
    to have the context
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see the next two computations will produce `3`and `5`, and
    hence the total of `9`.
  prefs: []
  type: TYPE_NORMAL
- en: Laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Evaluation Strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back when we began to study evaluation [[👉](PLAIVersion3.2.2_split_015.html#h.nin2n4sergiw)],
    we saw that we had a choice when performing evaluation. During function application,
    we could substitute the actual parameter as an expressionor as a value. At that
    time, we indicated that SMoL is eager. Now we will investigate the other option,
    laziness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: When run eagerly in the Stacker, we see calls like
  prefs: []
  type: TYPE_NORMAL
- en: '![](image4.png)'
  prefs: []
  type: TYPE_IMG
- en: and the environment contents look like
  prefs: []
  type: TYPE_NORMAL
- en: '![](image9.png)'
  prefs: []
  type: TYPE_IMG
- en: Both the call and the environment reinforce that parameters are evaluated beforethe
    function body begins to execute, so names are bound to values.
  prefs: []
  type: TYPE_NORMAL
- en: Why Lazy Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose, instead, we evaluate this lazily. The evaluation would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: A natural question might be, why bother doing this?
  prefs: []
  type: TYPE_NORMAL
- en: A reason people often cite is that it can save time, in that we don’t need to
    evaluate parameters we don’t need. For instance, suppose we have `(deffun (f x
    y z)  (if (zero? x)      y      z))` and we call f with two expensive-to-compute
    parameters in the last two positions. In an eager language, we have evaluated
    both whether we want to or not. In a lazy language, we only evaluate the one we
    need. As we will see below, this is actually not a very compelling argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A second reason is that it enables us to add new, non-eager constructs to the
    language through functions. Consider `if`: in an eager language it can’t be a
    function because the whole point of `if`is to not evaluate one of the branches
    (which would become parameters that are evaluated). Again, this argument has somewhat
    limited merit: we have seen how we can add such constructs using macros, which
    can do a great deal more as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The most interesting reason is probably that the set of equations that govern
    the language changes. Consider the following. Suppose we have the expressions
    `E`and `(lambda (x) (E x))`. Are they the “same”? It would seem, intuitively,
    that they are. Suppose `E`is a function. In any setting where we apply `E`to a
    parameter, the second expression does exactly the same: it takes that parameter,
    binds it to `x`, and then applies `E`to `x`, which has the same effect.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, note that `E`may not be a function! It could be a `print` statement,` (/
    1 0)`, and so on. In those cases, `E`evaluates right away and has some observable
    effect, but the version “hidden under the `lambda`” will not until it is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why does this matter? It matters because many parts of programming implementations
    and tools want to replace some terms with other terms. An optimizing compiler
    does this (replacing a term with an equivalent one that is better by whatever
    optimizing criterion is in use), as do program refactoring engines, and more.
    Thus, the more terms that can be replaced, or the fewer conditions under which
    terms can be replaced, the better. Lazy languages allow more terms to be replaced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Terminology: This equivalence is called “rule eta” (η).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: You may see some people say that lazy languages have “referential
    transparency”. If you ask them to define it, they may say something like “you
    can replace equals with equals”. Think about that for a moment: you can alwaysreplace
    equals with equals. That is (by some definitions) literally what equality means:
    two things are equal exactly when you can replace one with the other. So that
    phrase tells us nothing. In fact, every language has some degree of “referential
    transparency”: you can always replace some things with other equivalent things.
    In lazy languages, the set of things you can replace is usually bigger: the referential
    transparency relation is larger. That’s all.'
  prefs: []
  type: TYPE_NORMAL
- en: One very important, practical reason is to create potentially-infinite data
    structures. See the example on streams below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More fundamentally, the famous paper [Why Functional Programming Matters](https://www.google.com/url?q=https://www.cse.chalmers.se/~rjmh/Papers/whyfp.html&sa=D&source=editors&ust=1695232021569949&usg=AOvVaw13ypvMWgaZXeEPuILJzYCX)argues
    that laziness is a modularity concept, and develops this argument through several
    beautiful examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strictness Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Coming back to our example from earlier: when we run such a program in a language
    with lazy evaluation, when, if ever, does all this arithmetic resolve and print
    a value?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we answer that question, let us also observe that sometimes programs
    can’t really defer decisions indefinitely. For instance, consider this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: What happens when we try to evaluate it? Presumably substitution reduces this
    to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: and now what? Presumably that could be considered “the answer”, but that doesn’t
    seem very useful; and in real programs, these terms would just grow larger and
    larger. Furthermore, suppose the program were
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: We can certainly produce as an answer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: but…then what? And for that matter, what is `fact` in this response? This does
    not seem like a very useful programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, lazy programming languages define certain points in the language as
    strictnesspoints, which are points where expressions are forced to compute and
    produce an answer. Different choices of strictness points will result in languages
    that behave slightly differently. Conventionally, the following are considered
    useful strictness points:'
  prefs: []
  type: TYPE_NORMAL
- en: The conditional portion of a conditional expression. This enables the language
    to determine which branch to take and which branch to ignore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arithmetic. This avoids long chains of computations building up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The printer in an interactive environment. This makes the environment useful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All three of these are pragmatic choices. Notice that our first example above
    concerned the top-level printer, while the second example has to do with conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these strictness points, a typical lazy language will in fact compute
    the programs we have seen above very similarly to an eager language. To get to
    something that really differentiates eagerness from laziness, we need to get to
    richer programs.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating Without Substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Above, we saw how we can think of lazy evaluation using substitution. While
    this is a useful mental model, as we have seen in earlier interpreters, we don’t
    really want to use substitution as our implementation strategy. That involves
    repeatedly rewriting program source, which is not how our interpreter worked.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s say we don’t pass the value but instead “the expression”. Does it mean
    the above sequence becomes this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '`→ (g (+ x x))`where `x`is bound to `(+ 2 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`→ (h (* y 2))`where `y`is bound to `(+ (+ 2 3) (+ 2 3)))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`→ (+ x 5)`where `x`is bound to `(* (+ (+ 2 3) (+ 2 3)) 2)`'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, even this isn’t quite right. It should rather be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '`→ (g (+ x x))`where `x`is bound to `(+ 2 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`→ (h (* y 2))`where `y`is bound to `(+ x x))`whose `x`is `(+ 2 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`→ (+ x 5)`where `x`is bound to `(* y 2)`whose `y`is `(+ x x))`whose `x`is
    `(+ 2 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we want to pass the unevaluated expression…but you can probably
    see where this is going! If we’re not careful, we will end up with dynamic scope.
    Even setting that aside, we can’t just pass the expression on its own, because
    when we eventually get a strictness point, we simply will have no idea what value
    a variable resolves to.
  prefs: []
  type: TYPE_NORMAL
- en: However, the solution also presents itself very naturally. We don’t just pass
    an expression, we pass along its corresponding environment. An expression and
    environment combine to form a…closure! Of course, this closure does not take any
    parameters; its only job is to suspend the evaluation of the expressionuntil we
    reach a strictness point, and at that point, evaluate it in the right environment.
    Fortunately, we don’t need to do any new work here; closure application already
    does it for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laziness Via Closures: Beyond Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laziness becomes more interesting when we consider data structures. Conventionally,
    data constructors are notstrict, so their arguments are not evaluated eagerly.
    We can illustrate this using lists, though technically we will be constructing
    streams (which are infinite, as opposed to lists, which are finite).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, read about streams represented using closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dcic-world.org/2022-08-28/func-as-data.html#%28part._streams-from-funs%29](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/func-as-data.html%23%2528part._streams-from-funs%2529&sa=D&source=editors&ust=1695232021577933&usg=AOvVaw3xFcgFEVIzH5OuDVgtWddP)'
  prefs: []
  type: TYPE_NORMAL
- en: What would the same code look like in a language that was already lazy?
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with that, we’ll now use the Racket language
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how some of these values print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'The word “promise” means these are thunksthat represent the stream. To view
    the thunk’s content, we need to “force” the “promise”, which we do using the `!` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `ones`, Racket is telling us that the rest of the stream is
    the samestream as the one we are viewing: i.e., it’s a cyclic stream. For `nats`,
    it tells us that the first element is `0`, followed by another promise. We can
    explore these streams a bit further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsurprisingly, `ones`does not change. But with `nats`, as we explore more
    of the stream, we run into more thunks. This is where `take`is useful: it gives
    us a finite prefix of the potentially infinite stream. Unfortunately, that also
    seems to just produce more thunks, and it seems like we would need to laboriously
    apply `!` to each part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: 'For situations like this, where we knowthe output is going to be finite, we
    might want to resolve all the thunks. For this, Lazy Racket provides `!!`, which
    recursively applies strictness to all contained thunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, we get the expected answer.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise:What happens if we apply `!!`to `ones`and to `nats`? Try it out, and
    explain what you see.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Laziness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to understand laziness is to study the encoding of streams in the
    Stacker. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Now run each of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'and study whenevaluation happens and what is being held on to by the closures.
    (You may find it helpful to view just one of these at a time: the definition and
    use of `ones`, and separately of `nats`and `nats-from`.)'
  prefs: []
  type: TYPE_NORMAL
- en: Laziness and Side-Effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the (potential) benefits of lazy evaluation, why is laziness not more
    widely used?
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that laziness makes it much harder to predict what will happen
    in programs that use state. Therefore, popular lazy languages do not have state,
    or have it in very controlled forms. (This is not a bad thing! State should only
    be used in very controlled ways, and Haskell, for instance, has very interesting
    designs that help with that. But programmers have traditionally expected to have
    unfettered access to state.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for instance, the following pair of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'On their own, they seem harmless. However, now consider this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: 'In an eager language, we know both strings would be printed right away. However,
    in a lazy language, only one will, and we cannot tell which one. To understand
    which, we can no longer treat `f`as an abstraction but instead have to peer into
    its implementation, which in turn forces us to examine the source of `g` as well.
    We would have to examine every call, and track all the strictness points along
    the way, to determine which effects will occur and when. Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, if we ran this eagerly, we know `n`would be set back to `0`before the
    body of `f`even begins to evaluate. In lazy evaluation, we cannot be sure what
    value `n`will have: it could be `-1`or `1`. Furthermore if, tomorrow, `g` were
    altered to be'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: then `n`remains `0`—but we can’t know without examining its code!
  prefs: []
  type: TYPE_NORMAL
- en: 'A natural reaction to reading these programs might be, “Don’t do that!” That
    is in fact an entirely legitimate reaction. The problem is not laziness: it’s
    the interaction between laziness and state. As we deprecate the use of unfettered
    state in programming, that increases the potential for laziness. Still, there
    are other situations—like errors—that we cannot avoid, and that can stay latent
    under lazy evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we use lazy programming without side effects, we get a nice benefit: each
    expression always produces the same result. In that case, we don’t ever have to
    recompute an expression; we can just store its result and reuse it on subsequent
    accesses. That is, we can cache the result, enabling us to trade space for time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: If you are not familiar with trading space for time in computation—as
    found in techniques such as memoization and dynamic programming—see DCIC: [https://dcic-world.org/2022-08-28/part_advtopics.html#%28part._avoid-recomp%29](https://www.google.com/url?q=https://dcic-world.org/2022-08-28/part_advtopics.html%23%2528part._avoid-recomp%2529&sa=D&source=editors&ust=1695232021588822&usg=AOvVaw1pcTCRspVLqsEkkFNFbtyj)'
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, two kinds of result caching one can perform.
  prefs: []
  type: TYPE_NORMAL
- en: One is what happens in Lazy Racket, where each expression’s result is cached
    locally. This means that if the same source location is evaluated multiple times,
    the cached value can be reused. Other implementation strategies can look for the
    same expression even in a dynamic setting (as happens, for instance, in a Fibonacci
    function, which dynamically generates sub-problems). This requires a rather different
    implementation approach, but can yield even bigger time-space trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Space Consumption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to automatically memoize computation seems to show even more benefit
    to making lazy evaluation a default. Why not do it?
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem is that lazy evaluation can often take up significant amounts of
    space, beyond the space consumed by memoization. To understand this, consider
    this squaring function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: Because we are evaluating lazily, `x`is bound to an expression represented as
    a closure. Now suppose our program looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: and beyond this we make no further reference to `v`. In an eager language, we
    would extract the second element of `v`and can reclaim all the remaining storage.
    But in a lazy language, the entire vector needs to stay alive until the last use
    of the closure that refers to it. Seemingly straightforward programs that have
    an intuitive space model in an eager language can have much more subtle and complicated
    space models in lazy programming. Observe that the issue above has nothing to
    do with memoization; it’s inherent in laziness.
  prefs: []
  type: TYPE_NORMAL
- en: Laziness in Eagerness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a result of these issues, laziness has not gained popularity as a default
    option. At the same time, it is very useful in some settings. As we have seen
    above, we can always simulatelaziness by using thunks. This can, however, be syntactically
    unwieldy, so some languages provide syntactic support for it. In languages like
    Racket, for instance, `delay`is a syntactic form that thunks its expression, and
    `force` is a function that evaluates it (caching the result).
  prefs: []
  type: TYPE_NORMAL
- en: Control on the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-Side Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: print(read("First number") + read("Second number"))
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we were to run this program on a traditional command-line operating
    system. What happens when we call `read`? The operating system’s synchronousinput-reading
    commands are invoked: synchronous meaning that the program suspends its execution—that
    is, the stack stays intact—waiting for the user to respond (if ever they do),
    and when they do, the program’s stack resumes, with the value typed in by the
    user becoming the value returned by `read`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This seems so straightforward that we might never think twice about how remarkable
    this ability is. To understand that, we should try to run this program on the
    Web. When we do, we run headlong into a central problem on the Web: that there
    is no such thing as a “read” operation. Why not?'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Web, a hypothetical `read`function can certainly send the prompt to
    the client. In principle, it should then wait for the client to respond with a
    value, which it returns. However, the statelessnature of the Web means that this
    can’t happen: the program has to terminate. This is an asynchronous operation.
    When the user responds (if they ever do), there is no computation waiting to go
    back to.'
  prefs: []
  type: TYPE_NORMAL
- en: Recording Contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Therefore, a Web computation has to be arranged in a very different way. The
    programmer must manually remember the rest of the computation, and store it somewhere.
    For instance, we would break up the above program in the following way: what is
    going to be done next:'
  prefs: []
  type: TYPE_NORMAL
- en: read("First number")
  prefs: []
  type: TYPE_NORMAL
- en: 'and what is waiting for the result:'
  prefs: []
  type: TYPE_NORMAL
- en: print(• + read("Second number"))
  prefs: []
  type: TYPE_NORMAL
- en: '(This is, of course, our old friend, a context.) But whereas the context is
    implicit on the program’s stack, because the program must terminate, the context
    needs to be written out explicitly. Of course, • is not a program operation; rather,
    we can think of the context as a function of one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: 'lam(•1): print(•1 + read("Second number"))'
  prefs: []
  type: TYPE_NORMAL
- en: and this is the function that is stored in a way associated with the outgoing
    prompt. Then, when (if) the user responds, their response value is bound to •1,
    allowing the program to resume. Suppose, for instance, the user types `5`. Then
    this program effectively becomes
  prefs: []
  type: TYPE_NORMAL
- en: print(5 + read("Second number"))
  prefs: []
  type: TYPE_NORMAL
- en: This needs to also perform a Web interaction, so we again split it into what
    must happen now
  prefs: []
  type: TYPE_NORMAL
- en: read("Second number")
  prefs: []
  type: TYPE_NORMAL
- en: 'and what is waiting for the result:'
  prefs: []
  type: TYPE_NORMAL
- en: print(5 + •)
  prefs: []
  type: TYPE_NORMAL
- en: 'which we can represent as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'lam(•2): print(5 + •2)'
  prefs: []
  type: TYPE_NORMAL
- en: If and when the user resumes, this function is applied to the value they supply,
    and the result prints as we would expect.
  prefs: []
  type: TYPE_NORMAL
- en: This explanation glosses over some important details. Real program evaluation,
    as we have seen, does not proceed by rewriting programs, so the second function
    is not really
  prefs: []
  type: TYPE_NORMAL
- en: 'lam(•2): print(5 + •2)'
  prefs: []
  type: TYPE_NORMAL
- en: but rather a closure with the body
  prefs: []
  type: TYPE_NORMAL
- en: 'lam(•2): print(•1 + •2)'
  prefs: []
  type: TYPE_NORMAL
- en: closed over an environment where •1is bound to 5. Getting into these details
    is interesting from a Web architecture perspective, but for us, all we care about
    is that contexts must be saved and restored.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating in the Stacker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can simulate the above using the Stacker, provided we forego the input operation
    and pretend it always returns some constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'At the point of the second call, we see that the state looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image23.png)'
  prefs: []
  type: TYPE_IMG
- en: Client-Side Termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the client-side Web, in JavaScript, we see the same phenomenon, but for
    a completely different reason. Imagine we write a factorial computation in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the loop checks for `n != 0`and not `n > 0`, so if we put this
    in a Web page and run it, the program will in principle run forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this creates a problem: the JavaScript virtual machine runs only one
    computation at a time, and the same JavaScript virtual machine also manages the
    page and the browser’s components. Therefore, if the program inside a page goes
    into an infinite loop, the entire page stops being responsive. For this reason,
    after a little while, the browser will pop up a window offering to kill the computation.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a solution to this in JavaScript, but it is hardly elegant. The programmer
    creates a closure—called a callback—that represents the rest of the computation.
    The programmer then calls
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: or, in more modern programs,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: (though the former version perhaps makes a bit clearer what is happening), where
    `C`is the callback. This creates an event to run `C`as soon as possible (after
    `0` units of time). The programmer then—does this sound familiar?—terminates the
    program. This returns control to the JavaScript virtual machine. It runs any other
    pending events, then arrives at this event, which it runs immediately—i.e., it
    “calls back” into the computation using `C`. If `C` was constructed correctly,
    then this properly resumes the computation, as if it had never halted. Phew!
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting the Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thus, we have the same problem on both the server and client sides of the Web.
    The reasons are very different, but the net effect is the same: the programmer
    has to manually keep track of information that needs to persist, store it somewhere,
    halt the computation to return control to whatever called it and, when resumed,
    fetch information back from storage; all this code must run exactly as if an interruption
    had never occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: This programming quandary is not new. Back in the early days of computing, programmers
    had to manually keep track of where in memory values resided; then we got compilers
    that did this for us. Then we had to manually keep track of allocation on the
    heap to later reclaim it; then we got garbage collectors to do this for us. The
    history of programming languages is full of tasks that programmers did manually
    until we learned to create language constructs and compilers that could do these
    automatically. It would be nice if we could do the same here to reduce the burden
    of writing such programs.
  prefs: []
  type: TYPE_NORMAL
- en: To study these phenomena better, it would be helpful if we could abstract away
    from the details of servers, clients, JavaScript, Web pages, timeouts, and so
    on, and examine the phenomenon in its essence.
  prefs: []
  type: TYPE_NORMAL
- en: Using Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can simulate the solution by assuming a new primitive, `get-number/k`. Instead
    of taking one argument, the prompt string, it also takes a second argument. This
    second argument is a closure that represents the restof the computation—i.e.,
    it’s the stack represented as a closure. This function binds that closure to a
    variable, `resume`, and then…does nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that we want the program to invoke this function and then halt; all
    remaining computation—the context—needs to be in the second parameter given to
    `get-number/k`. Thus, our program now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminology: The second argument—embodying the entire rest of the computation—is
    called the continuation, and it’s traditional to use the letter `k` for it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology: The program structure above has been turned inside-out: instead
    of the first operation being innermost and last operation outermost, the first
    one is outermost and the last one is innermost. This unwieldy program structure
    has a name: inversion of control. Instead of the client calling the helper function
    whose values it wants (in this case, `get-number`), the helper function (in this
    case `get-number/k`) calls the client. This leads to an unnatural, unwieldy, and
    error-prone programming style.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure enough, when we run this program, it just…halts with no output. It is
    instructive to look at the state of the program when it ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that `resume` is bound to a function that is awaiting a number. If we
    invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'then our state (unfortunately, we had to re-run the program) becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Observe that resume is now bound to a closure whose environment remembers the
    value of `•1`. If we now resume again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: 'the “program” halts naturally, with an output of `12`! (We use quotes around
    “program” because we have really fragmented our simple program into three: one
    that gets the prompts for the first input, one that remembers that value and prompts
    for the second, and the third that sums those two values.)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Racket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It turns out that Racket also has tools for manipulating continuations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have two tabs in DrRacket. In the first (let’s suppose we save it
    as `"yielder.rkt"`) we have the following mysterious program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation `let/cc`binds the named variable (here, `k`) to a continuation
    value: it turns the current stack into a value that can be treated as a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In another tab, we will write a simple program that pretends to be our long-running
    computation: a factorial function. We can run this directly in Racket, of course.
    But `fact`could run for a very long time, depending on the input; so following
    the rules of JavaScript, we want it to halt periodically, let’s say every time
    `n`is divisible by `5` (i.e., roughly every five iterations). That is, we would
    like to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'where `(yield)`makes it pause in a way that, when we run `(resume)`, the computation
    will pick up exactly where it left off. Indeed, we see the following outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: The first time it yields is when `n`is `5`. Yielding, in this case, means terminating the
    computation using the Racket exception mechanism. Resuming somehow causes computation
    to continue and run to completion but, remarkably, it produces the exact same
    answer as if computation had never halted at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that thanks to the use of `let/cc`, we have been able to invert the
    inverted control, i.e., write the program in what is called direct style. The
    language has taken care of storing and restoring the computation without the user
    program having to do it manually. Thus, continuations are useful tools for inverting
    inverted control. We will also see another language mechanism that does this:
    [Non-SMoL: Reactivity](https://www.google.com/url?q=https://docs.google.com/document/d/1ECyFV88K-jU-i0qHLfUNjbIYthChzpcjZ0eiostD3d8/edit%23&sa=D&source=editors&ust=1695232021608622&usg=AOvVaw1WfaeEjiDupGmDBj0AuHdK).'
  prefs: []
  type: TYPE_NORMAL
- en: Yielding on a Web Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Racket Web server has a special primitive that does just this for the Web.
    We’ll build it up in stages. First, we’ll use a special Racket language, designed
    to make it easier to write server-side Web programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'Programs in this language must have a “main” function, called `start`, which
    is given an initial request (whatever information is provided when we first run
    the computation). This function is then written assuming a convenient fiction:
    the existence of a function `get-number`that will print a prompt, send out a Web
    page, wait for its response, extract the value entered, and return it as a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '`(let ([result` (+ (get-number "first") (get-number "second"))`])`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: 'If we can make this fiction reality, then we can write a program like the above:
    it calls `get-number` in a “deep” context, twice, adds the results, and then converts
    the result into a string to embed it into a Web page.'
  prefs: []
  type: TYPE_NORMAL
- en: The question, of course, is how such a function can exist. First, we have to
    discuss some Web mechanics. When we create a Web form, it needs a field called
    the `action`, which holds a URL. When the user submits the form, the browser bundles
    up the information entered into the fields of the form and sends them—effectively,
    as a set of key-value pairs—to the URL, i.e., to the server, requesting it to
    run the program at that URL and provide the key-value pairs to that program.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can see that we’ve turned the problem of suspending the program’s
    execution into one of being able to fill in this URL with something meaningful.
    If the URL can somehow correspond to the stack, then perhaps the stack (and hence
    the computation) can be restored, and can be provided with these key-value pairs,
    from which the program can extract the required information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “secret sauce” that the Racket Web server provides is a primitive called
    `send/suspend`. It does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes a single-argument function as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It records the current stack as a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It stores this stack in a hash-table, associated with a unique, unguessable
    string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It turns this string into a URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then calls the given function with this URL string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting function can then use this URL string as the `action` field of
    the form.
  prefs: []
  type: TYPE_NORMAL
- en: Aside: This is not the only way to use it. The URL could also, for instance,
    be sent in an email message. This is a handy way to validate email addresses.
    Because the URL is unique and unguessable, the only way for someone to resume
    the computation would be to receive that URL, i.e., to have access to the email
    address. Thus, resuming the computation can be thought of as having validated
    the email address (assuming, of course, that an intruder is not reading emails
    and clicking on validation links that the email’s owner would not have clicked
    on).
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is an actual working implementation of get-number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: (response/xexpr
  prefs: []
  type: TYPE_NORMAL
- en: '`(html (head (title ,title))'
  prefs: []
  type: TYPE_NORMAL
- en: (body
  prefs: []
  type: TYPE_NORMAL
- en: (form ([action ,k-url])
  prefs: []
  type: TYPE_NORMAL
- en: ',title ": "'
  prefs: []
  type: TYPE_NORMAL
- en: (input ([name "number"]))
  prefs: []
  type: TYPE_NORMAL
- en: (input ([type "submit"])))))`))))`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: (extract-binding/single 'number
  prefs: []
  type: TYPE_NORMAL
- en: (request-bindings req))`))`
  prefs: []
  type: TYPE_NORMAL
- en: Observe that most of this function is just HTMLand APIbookkeeping. We have to
    construct the Web page with the relevant components. When (if) the computation
    resumes, it returns with the key-value pairs sent from the form. These are bound
    to `req`. From there, it’s a simple matter of extracting the right value using
    the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! That gives us a full, working program.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s think about how all this interacts with state. Let’s write a simple
    Web program that simply counts how many times we submitted a form.
  prefs: []
  type: TYPE_NORMAL
- en: 'One natural way to write it is as follows. We’ll have a mutable variable, `count`,
    that keeps the count. We’ll have a page that shows the current count and provides
    the user a button. When they click it, computation resumes; the resumed computation
    increments the count, and loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: We’ll call it the stateful counter.
  prefs: []
  type: TYPE_NORMAL
- en: This works as you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now let’s think about a different way to write this same program. Instead
    of using a global mutable variable, we could instead keep the count as a local
    variable and functionally update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: We’ll call this the functional counter.
  prefs: []
  type: TYPE_NORMAL
- en: This, too, works as you would expect. And it works the same as the previous
    program. And yet, somehow, these programs seem to be different. Are they in fact
    exactly the same?
  prefs: []
  type: TYPE_NORMAL
- en: They’re not!
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Map out the stacks, environments, and stores to simulate how these
    programs would run.'
  prefs: []
  type: TYPE_NORMAL
- en: Web Interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In conventional, desktop software, concurrency is an artifact of the program.
    If the program is not concurrent, we can’t really force it to behave concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Not so on the Web. There, we can copy URLs, duplicate them, and replay them.
    Therefore, the same program state can be invoked multiple times, returned to,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following sequence of interactions on the Web:'
  prefs: []
  type: TYPE_NORMAL
- en: A user visits a travel Web site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They enter a city and search for hotels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are given a list of hotels, L.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They click on one of the hotels, say L1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This takes them to a page for L1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They click the reservation link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They obtain a reservation at L1\. All this seems perfectly normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose instead they do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A user visits a travel Web site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They enter a city and search for hotels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are given a list of hotels, L.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They click on one of the hotels, say L1, in a new tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They click on another of the hotels, say L2, in another new tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They go back to L1’s tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They click the reservation link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Think about these two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At which hotel would you like the reservation to be made: L1 or L2?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Where do you expect the site to make the reservation: L1 or L2?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Naturally, we would expect the reservation at L1, because we clicked on the
    reservation link from L1’s page. But on many Web sites, you used to get a reservation
    at L2, not L1. This suggests that there is some interaction between the two tabs:
    specifically, there seems to be mutable state, the “current hotel”, that is shared
    between the two tabs. Opening a hotel’s page sets this. Thus, this is initially
    set to L1; the new tab for L2 sets it to L2; when we return to L1’s tab and make
    a reservation, this act reads the mutable state, which makes the reservation at
    the “current hotel”, namely L2.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the Counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s return to the two counters, armed with the ideas from the interactions
    above.
  prefs: []
  type: TYPE_NORMAL
- en: Run the stateful counter program and submit, say, 3 times. After that, the page
    will list the count as 3, and the URL will look something like
  prefs: []
  type: TYPE_NORMAL
- en: http://localhost:51264/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2097639995)%22))?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now copy this URL, create a newtab, paste it, and enter. This runs the computation
    associated with this URL. Perhaps surprisingly, this shows the count as 4\. Now
    go back to the previous tab and submit the form. That tab now shows a count not
    of 4 but of 5\. Return to the second tab and submit; it now shows 6\. The stacks
    help us see why: every return mutates the same `counter` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Now repeat the same process with the functional counter. After 3 submissions,
    we get a URL like
  prefs: []
  type: TYPE_NORMAL
- en: http://localhost:51379/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2028533532)%22))?
  prefs: []
  type: TYPE_NORMAL
- en: which seems very similar. Now copy this URL into a new tab, and repeat the interactions
    above.
  prefs: []
  type: TYPE_NORMAL
- en: What we see is very different. Each tab has its own local “memory”, much as
    we expected of the pages on the travel Web site. The continuation does not mutate
    a single shared variable, but rather makes a new call to loop, which creates a
    new binding that is distinct from previous bindings. Each time we submit we make
    another call, which makes another stack frame and its corresponding environment
    frame, which are distinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This distinction between creating a single, shared, mutable variable and creating
    distinct variables that each have their own immutable value should be familiar:
    it’s the exact same problem that we saw in the Loops assignment [[https://cs.brown.edu/courses/cs173/2022/loops.html](https://www.google.com/url?q=https://cs.brown.edu/courses/cs173/2022/loops.html&sa=D&source=editors&ust=1695232021622985&usg=AOvVaw0xjaprMcAAUZTQQEvCfWVs)].'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping between Web and Programming Language Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interestingly, there is a deep connection between features of Web programs and
    ideas from programming languages. On the Web, we have
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Server-side | Client-side |'
  prefs: []
  type: TYPE_TB
- en: '| Mutable | Database (page-independent) | Cookie (page-independent) |'
  prefs: []
  type: TYPE_TB
- en: '| Immutable |  | Hidden field (page-specific) |'
  prefs: []
  type: TYPE_TB
- en: Observe that when we have a single mutable entry, the net result will be that
    all pages that share it will end up seeing the effects of each other. Therefore,
    the bad travel Web site pattern is inherent in this style of programming. Unfortunately,
    Web APIs make cookies very easy to use, leading to programs following this bad
    pattern. In contrast, when we have immutable data that is specific to the page
    (the field is on the page…it’s just hidden), then each page keeps its own information
    separate from all the other pages. Notice also that hidden fields are key-value
    mappings. Therefore, a collection of hidden fields is an environment. Since a
    page also has a reference to code to run, a page with hidden fields is effectively
    a closure! In contrast, a page with shared mutable state is using the store(or
    heap). The Racket Web server simply makes these implicit ideas explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Readings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The work in this chapter is elaborated in several papers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Automatically Restructuring Programs for the Web](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/&sa=D&source=editors&ust=1695232021626503&usg=AOvVaw0dteFuRcMEar0kOBZ7ejqS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Modeling Web Interactions and Errors](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/&sa=D&source=editors&ust=1695232021627009&usg=AOvVaw0OKynkecNBanIitj-dtIoI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Implementation and Use of the PLT Scheme Web Server](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/&sa=D&source=editors&ust=1695232021627310&usg=AOvVaw2VVyDnhdzHGBVmpsp7j3xb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Putting in All the Stops: Execution Control for JavaScript](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/bnpkg-stopify/&sa=D&source=editors&ust=1695232021627644&usg=AOvVaw0ZxiewB1AmM3Se5hWPXBGb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned early on that SMoL languages evaluate formal arguments at a function
    call. We then saw laziness as a contrast to this: an argument is evaluated zero times
    at the call, and is maybe only evaluated later. (Of course, if the result is not
    cached, it may be evaluated many times.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will see another contrast to SMoL, focusing this time on the function
    call itself: where what syntactically looks like a single function call can actually
    be numerous, even an unbounded number.'
  prefs: []
  type: TYPE_NORMAL
- en: GUIs through Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do so, it helps to remind ourselves of the evaluation model in most graphical
    applications, these days embodied by JavaScript. Suppose we want to make a Web
    page with a timer that counts up every second, and whose value resets when we
    click on a Reset button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One version of the JavaScript code would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three parts to the logic here:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the elapsed time every second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resetting the timer on a button-press.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initiating the computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are accomplished as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When loaded, the Web page invokes `startTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `elapsedTime`to record how much time has elapsed, and create a timer,
    referenced by `timerID`. This installs a timer (and records a reference to it
    in case we need it later, which we don’t in this program) that runs every second
    (1000 milliseconds). Whenever the timer goes off, it invokes the function `doEverySecond`.
    That function increments the elapsed time, and writes the current value into the
    Web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the reset button has `resetElapsed`as its callback. This resets the
    value of `elapsedTime`, whose updated value is then shown the next time the display
    is updated. (In principle, we might want to update the display in this callback
    too.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us suppose we were given this program to maintain. We want to ask a simple
    question: what is the value of the Web page’s `curTime` element? Observe the reasoning
    we have to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: It is set inside `doEverySecond`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s set to the value of `elapsedTime`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That value is incremented in the previous statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That increment takes place every time `doEverySecond` is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That call takes place in the first argument of `setInterval`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That event is installed by `startTimer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which is called on page load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait. We also need to know the initial value, where `elapsedTime` is declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oh, but wait. We also see it reset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That happens inside `resetElapsed`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which is called when the button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In short, we have to follow all this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image19.png)'
  prefs: []
  type: TYPE_IMG
- en: Reactivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an alternative, called functional-reactive programming(FRP). We will
    see one particular instantiation, which is baked into Racket with an interesting
    user interface. The language is called FrTime. For technical reasons, we will
    not use a `#lang` but rather choose it from the Language menu (under Other Languages).
  prefs: []
  type: TYPE_NORMAL
- en: Do Now! Below are some expressions whose output is best experienced in DrRacket.
    Run them in DrRacket and see the output for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: 'FrTime essentially provides a basic version of Racket, so basic computations
    work exactly as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also ask for values like the current system time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'You will likely see a different value than the one shown above, because you
    are not reading this at the same time as when I wrote it. But that is a problem:
    indeed, even I am seeing a stale value, because time has passed since I ran the
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: The typical solution is to use callbacks. We can imagine a timer that takes
    a callback, which is called every time the time changes. However, this would invert
    control, which is exactly what happens in our timer example.
  prefs: []
  type: TYPE_NORMAL
- en: 'But FrTime, following the principles of FRP, provides a special kind of value.
    Try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: 'See what happens? `seconds`is a time-varying value: i.e., it is (technically:
    evaluates to) a value, but what it evaluates to changes over time. (It changes,
    in fact, every second.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we should ask: if `seconds` evaluates to a value, we can use it
    in expressions, so what happens if we write expressions like these?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: Notice that both `add1`and `modulo`demand that their first argument be numbers.
    `seconds` is a time-varying value that at every point in time is a number. Therefore,
    these expressions are well-typed, producing no errors, and in fact produce the
    answer we might expect (but also perhaps be a bit surprised by).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing prevents us from writing even longer expressions. Consider the function
    `build-list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we now use a time-varying value?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: 'Or build an even deeper expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: How Evaluation Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dataflow Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens when we write these expressions? FrTime rewrites the way function
    applications happen. If noargument to a function is time-varying, then the function
    evaluates just as it would in regular Racket. If, however, any of its arguments
    is time-varying, then FrTime constructs a node in a dataflow graph. This node
    is attached to the nodes corresponding to the time-varying arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'The act of calling length evaluates its argument, which is a call to build-list,
    which evaluates its two arguments. The second argument is an ordinary closure.
    The first argument is a call to modulo, which evaluates its two arguments. Again,
    the second argument is just a number, but the first argument is time-varying.
    Consequently, this turns into a dataflow graph node, where we use the context
    notation to indicate where time-varying values go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because `(modulo seconds 10)` evaluates to a time-varying value, so does the
    next outer expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'and finally the outermost one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image8.png)'
  prefs: []
  type: TYPE_IMG
- en: The program source therefore evaluates to this dataflow graph. Now, each time-varying
    value may evaluate at different rates and for different reasons. `seconds`, naturally,
    updates once every second. When it does, its updated value is pushed to all the
    nodes that depend on it, which update their value and push their values, and so
    on all the way through the graph. Finally, values may arrive at the REPL, which
    in FrTime is designed to display them automatically updating.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Essentially, we can think of reactivity being implemented by rewriting how function
    application works. In the simplest case, imagine we have a function application,
    `(f a)`. Let us assume that `f`is itself not a time-varying value. Then, this
    application rewrites `(f a)` as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: We will return to the `…`in a moment. Observe that this evaluates the argument
    expression and, if it is not currently a time-varying value, then computation
    proceeds exactly as it would have in regular Racket. This means that progams that
    don’t use time-varying values behave exactlyas they would in Racket, so this is
    a conservative extension of Racket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s consider what happens if the parameter istime-varying. That means,
    instead of immediately computing an answer, we have to create a node in the dataflow
    graph. We can imagine a time-varying value is an object of the class `tvv%` (`tvv`for
    time-varying value, and `%`using the Racket convention for classes). We will first
    illustrate how this might be used, then show its definition. This class has two
    methods: `add-consumer`, which provides another object of `tvv%`that will receive
    updated values, and `update`, which receives updated values. We reproduce the
    bottom three parts of the above dataflow graph as follows and, to keep the output
    short, compute the remainder relative to `5`rather than `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: In practice, `seconds`would be attached to a system timer that pushes an update
    every second. For simplicity, we make it an inert object that only changes when
    we manually call its `updater`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder node now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, every time it receives a value from `seconds`, it computes that value
    `modulo` `5`. Of course, right now it has no way of knowing that it must listen
    to `seconds`; we have to register it as a consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `build-list` expression creates a time-varying value object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'which too we must attach to its value producer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: Observe how the `v`parameters in `mod•5`and in `bl•id` correspond to the • in
    the dataflow graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, just as `seconds`is a source in the graph, we will define a sink that
    prints results, and send values from `bl•id` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re ready to test it all! If we simulate `seconds` updating for the first
    ten seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: 'we see the following output printed, just as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'So how did this work? The `tvv%`class keeps track of a list of consumers, of
    which above we have had only one per object. `add-consumer`merely augments this
    list. The `update`method receives a value, uses its `updater` function to compute
    a new current value, and broadcasts it to all of its consumers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s (most of) the core logic (but read on). This brings us back to the rewriting
    of applications: what goes in `…`? Well, we have to'
  prefs: []
  type: TYPE_NORMAL
- en: make a new `tvv%` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: supply it an updater function that corresponds to `(f •)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: registers that node as a consumer to the `tvv%`object that `a-value` references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: return the new `tvv%` instance as the result of this function “application”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: Turn the above rewriting idea into a proper macro. If you can, turn
    it into the `#%app`of a `#lang` so that one can program a module in a FrTime-like
    style.'
  prefs: []
  type: TYPE_NORMAL
- en: Non-Linear Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The above example may be a bit misleading in suggesting that an expression
    must always have at most one time-varying parameter. Consider this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: Its dataflow graph looks like
  prefs: []
  type: TYPE_NORMAL
- en: '![](image13.png)'
  prefs: []
  type: TYPE_IMG
- en: On every update of `seconds`, both expressions that depend on it update, and
    their result flows to the equality comparison. Every 15 seconds, we would expect
    to see 12 consecutive false values followed by three consecutive true values,
    and that is what we see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Does the above definition of `tvv%` permit non-linear graphs? Can
    you write the above example with it? If so, show how. If not, modify it to allow
    such a definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Glitches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These forks in the graph, however, might be a cause for concern. Let us see
    an even simpler example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us first be clear about what we expect this to produce: we want it to always
    be `#true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let us view how a simplistic dataflow graph evaluator might work.
    Here is the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image7.png)'
  prefs: []
  type: TYPE_IMG
- en: Suppose the value of `seconds`updates to become 10\. This value is pushed, as
    we would expect, to bothits listeners. This causes the `(add1 seconds)`node to
    update its value from `10`to `11`. However, the update to `seconds`might have
    caused the comparison to occur immediately. At that point FrTime would be evaluating
    `(< 10 10)`, which is clearly false. So for one instant this expression would
    evaluate to `#true`, before the update from `(add1 seconds)`arrives and it reverts
    to `#false`. This is called a glitch, a term borrowed from the same phenomenon
    in [electrical circuits](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Glitch&sa=D&source=editors&ust=1695232021650816&usg=AOvVaw2D-DrKG6J0VAjm-pDxm4Ri).
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding glitches is actually quite simple. Rather than updating a node in this
    eager manner, FrTime schedules the graph to be updated in [topographical order](https://www.google.com/url?q=https://en.wikipedia.org/wiki/Topological_sorting&sa=D&source=editors&ust=1695232021651423&usg=AOvVaw17recAG9rHgwYI9lEViEXR).
    That ensures that no node will ever see old, or “stale”, values, and the expression
    will evaluate correctly. Of course, we can only apply topological sorting to directed
    acyclic graphs, so handling cycles requires some additional work, which we do
    not discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Make the above definition of non-linear graphs behave glitch-free.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Time-Varying Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we have seen only one basic time-varying value, `seconds`. FrTime provides
    many others. For instance, `mouse-pos` is the current position of the mouse. If
    we run the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: we see a blue circle, and it automatically follows the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The function `display-shapes`in the FrTime animation library takes a list of
    shapes; above, we have only one. This function builds a list of (four) circles
    whose positions are determined by the mouse’s location, except each one is delayed,
    i.e., represents where the mouse used to be. (One might call this the Rhode Island
    mouse.) Therefore, as the mouse moves these circles appear to “follow” it around.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Even More Time-Varying Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have actually seen only one kind of time-varying value, called a behavior.
    There are actually two kinds of time-varying values, which is easy to see if we
    consider a few different kinds of stimuli from the world:'
  prefs: []
  type: TYPE_NORMAL
- en: Current mouse position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence of keystrokes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current user location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence of network responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current status of mode keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence of mouse-clicks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that several of those are “current…” and others are “sequence of…”. The
    former have the property that they always have a value, and the value may change
    at any time. The latter have the property that at any given moment they may not
    have a value—for instance, there may not be a “current keystroke”—and we don’t
    know when (or if) the next one will come, and there may be an infinite number
    of them. The latter are, of course, just streams, often called event streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to our original counter example, we had both present. The elapsed
    time was a behavior (always has a value, which changes either when a second finishes
    or when a button is clicked). The sequence of button presses is, conversely, an
    event stream: at any given moment there may not be a press, we don’t know when
    or even if the next one will come, and there may be an unbounded number of them
    (from a very bored user). To learn more, see the papers about the design and implementation
    of [FrTime](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ck-frtime/&sa=D&source=editors&ust=1695232021655719&usg=AOvVaw1rTfSyu1ttBqGmZrO7l9th),
    and a similar language for JavaScript called [Flapjax](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mgbcgbk-flapjax/&sa=D&source=editors&ust=1695232021656156&usg=AOvVaw05OqgMykYggyiyBjsWWIJU).'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to Our Timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can write the original timer program using FrTime’s GUI library. Here is
    the program, explained.
  prefs: []
  type: TYPE_NORMAL
- en: Elapsed Time Without Resetting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we will write a simpler version that simply shows the elapsed time since
    the program began. To do so, we need to load the GUI library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: and then we need to determine how much time has elapsed. It may be tempting
    to write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'and then make a GUI display object that presents this (after converting the
    number into a string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, however, we get a rather disappointing display that seems
    to always show `0`. That is because that’s what we asked for! We can check this
    by asking for the value of `init-time` in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do, we see that it is constantly changing. But that’s what we should
    expect: we defined it to be the same as `seconds`! Instead, we need to hold on
    to the value of `seconds` at the timewe started the program: i.e., we do not want
    it to automatically update. For that, we instead write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: and then the rest of the program works as we would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Resets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s add the button. We create a button object, which returns an event
    stream of its clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time there’s a click, we want the elapsed time to reset to `0`. That
    is, we want to keep track of when the reset occurred. Note that again we need
    to use `value-now`to get the time when it occurred, not the current time. We use
    `map-e` to map over event streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have two kinds of events: the start of the program, and the clicks. We
    want a single behavior that reflects when these occurred: starting with when the
    program began, and updating whenever there’s a click. The function `switch` does
    this, “switching” the behavior’s value whenever an event occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the elapsed time to show is how far the current time is from
    the last event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'Visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Putting this all together, and adding the output directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that in this program, there are two kinds of changes that can occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Another second elapses. Thus, `seconds`changes; so does `elapsed-time`; and
    so `make-message` updates its output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user clicks the button. Then `reset-clicks`has an event, so `click-times`has
    an event, `event-times`updates, and so does `elapsed-time`, thereby also causing
    `make-message` to also update its output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases `elapsed-time`updates, triggering a change in the output. But
    there are two inputs to the subtraction in `elapsed-time`, and they update for
    different reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'What may be lost in the above presentation, which is incremental to enhance
    readability, is that we actually have deeply nested expressions that we can think
    of algebraically. To make that clearer, here is the whole program written as a
    single expression, with each name replaced with the expression it was bound to
    (though this is almost certainly a less readable version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: The interested reader can prove properties of the time shown based purely on
    the rules of algebra, perhaps even identifying a slightly unsatisfying behavior
    in the time shown by the timer (which was also a problem with the callback version).
  prefs: []
  type: TYPE_NORMAL
- en: This example shows that we really can compose expressions in a conventional
    manner even though we are writing a reactive program using a GUI library. It is
    worth comparing the structure of this program against the callback-based version
    that we started with.
  prefs: []
  type: TYPE_NORMAL
- en: '[This paper](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ick-adapt-oo-fwk-frp/&sa=D&source=editors&ust=1695232021664301&usg=AOvVaw1WOPAKU7HpkFtzRQxaaDl3) shows
    how the GUI library was given a functional-reactive interface by exploiting the
    encapsulation of object-oriented state.'
  prefs: []
  type: TYPE_NORMAL
- en: ••••• What’s Next? •••••
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have just finished a detailed look at the landscape of programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a broad and rich landscape with many, many dimensions to consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book has largely eschewed programming language theory, because there are
    already many wonderful books about that. I recommend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Felleisen, Findler, Flatt: [Semantics Engineering with PLT Redex](https://www.google.com/url?q=https://mitpress.mit.edu/9780262062756/semantics-engineering-with-plt-redex/&sa=D&source=editors&ust=1695232021665409&usg=AOvVaw1KqS_Jy_nK815yWIVBp7ex)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Harper: [Practical Foundations for Programming Languages](https://www.google.com/url?q=https://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/practical-foundations-programming-languages-2nd-edition?format%3DHB%26isbn%3D9781107150300&sa=D&source=editors&ust=1695232021665792&usg=AOvVaw1AAwlEjddhBK-I2YGlk71l)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pierce: [Types and Programming Languages](https://www.google.com/url?q=https://mitpress.mit.edu/9780262162098/types-and-programming-languages/&sa=D&source=editors&ust=1695232021666106&usg=AOvVaw3g2h6FqQKLiHwO8ZNmsd-O)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for three rather different, but all foundational, perspectives on the further
    study of the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Equally, programming languages are more popular than ever before. Working programmers
    not only contribute to their development but also put a great deal of effort into
    understanding more advanced features and distilling them for others. Their work
    tends to be found on blogs or at various conferences (such as those [listed here](https://www.google.com/url?q=https://twitter.com/ShriramKMurthi/status/1600574419914854400&sa=D&source=editors&ust=1695232021666661&usg=AOvVaw0QxljIxYwpEq2ec0JQcfOL)).
  prefs: []
  type: TYPE_NORMAL
- en: We’re done! I hope you’ve enjoyed reading this as much as I enjoyed writing
    it!
  prefs: []
  type: TYPE_NORMAL

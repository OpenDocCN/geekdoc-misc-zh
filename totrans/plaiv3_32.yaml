- en: Adding Booleans
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ·»åŠ å¸ƒå°”å€¼
- en: Okay, so what if we wanted proper Booleans?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦çœŸæ­£çš„å¸ƒå°”å€¼æ€ä¹ˆåŠï¼Ÿ
- en: Again, to employ SImPl, we need to alter the AST, the evaluator, and the parser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œè¦ä½¿ç”¨SImPlï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹ASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰ã€è¯„ä¼°å™¨å’Œè§£æå™¨ã€‚
- en: 'We can add Booleans much like we did numbers: with a constructor that wraps
    a plait representation of the Boolean.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åƒå¤„ç†æ•°å­—ä¸€æ ·æ·»åŠ å¸ƒå°”å€¼ï¼šä½¿ç”¨ä¸€ä¸ªæ„é€ å‡½æ•°æ¥åŒ…è£…å¸ƒå°”å€¼çš„ç¼–ç»‡è¡¨ç¤ºã€‚
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Itâ€™s very important to keep in mind what the `num`and `bool`constructors stand
    for. Recall that this is abstract syntax: we are just (abstractly) representing
    the program that the user wrote, not the result of its evaluation. Therefore,
    these constructors are capturing syntactic constantsin the source program: values
    like `3.14`and `-1`for the former and `#true`and `#false`for the latter. They
    do notrepresent compound expressions that will evaluate toÂ numbers or Booleans.
    What an expression will evaluate to, for now, can only be determined by running
    it. Later [[ğŸ‘‰](PLAIVersion3.2.2_split_088.html#h.7rb3ecnk20em)], we will see there
    are other ways of doing it too!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½`num`å’Œ`bool`æ„é€ å‡½æ•°ä»£è¡¨ä»€ä¹ˆéå¸¸é‡è¦ã€‚å›æƒ³ä¸€ä¸‹ï¼Œè¿™æ˜¯æŠ½è±¡è¯­æ³•ï¼šæˆ‘ä»¬åªæ˜¯ï¼ˆæŠ½è±¡åœ°ï¼‰è¡¨ç¤ºç”¨æˆ·ç¼–å†™çš„ç¨‹åºï¼Œè€Œä¸æ˜¯å…¶è¯„ä¼°çš„ç»“æœã€‚å› æ­¤ï¼Œè¿™äº›æ„é€ å‡½æ•°æ­£åœ¨æ•è·æºç¨‹åºä¸­çš„å¥æ³•å¸¸é‡ï¼šå‰è€…å¦‚`3.14`å’Œ`-1`ï¼Œåè€…å¦‚`#true`å’Œ`#false`ã€‚å®ƒä»¬ä¸ä»£è¡¨å°†è¯„ä¼°ä¸ºæ•°å­—æˆ–å¸ƒå°”å€¼çš„å¤åˆè¡¨è¾¾å¼ã€‚ç›®å‰ï¼Œä¸€ä¸ªè¡¨è¾¾å¼å°†è¯„ä¼°ä¸ºä»€ä¹ˆï¼Œåªèƒ½é€šè¿‡è¿è¡Œå®ƒæ¥ç¡®å®šã€‚ç¨å
    [[ğŸ‘‰](PLAIVersion3.2.2_split_088.html#h.7rb3ecnk20em)]ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°è¿˜æœ‰å…¶ä»–æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼
- en: Aside:The abstract syntax does not dictate what concrete syntax we use. For
    instance, we may write numbers as `3`or as `III`. We might write Boolean values
    as `#t`, `#true`, `true`, `True`, â€¦. We may even have different concrete syntaxes
    for the same abstract syntax. This is precisely the abstractionÂ that abstract
    syntax provides!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æ—ç™½ï¼šæŠ½è±¡è¯­æ³•å¹¶ä¸è§„å®šæˆ‘ä»¬ä½¿ç”¨ä»€ä¹ˆå…·ä½“è¯­æ³•ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½å°†æ•°å­—å†™æˆ`3`æˆ–`III`ã€‚æˆ‘ä»¬å¯èƒ½å°†å¸ƒå°”å€¼å†™æˆ`#t`ã€`#true`ã€`true`ã€`True`ç­‰ç­‰ã€‚æˆ‘ä»¬ç”šè‡³å¯èƒ½ä¸ºç›¸åŒçš„æŠ½è±¡è¯­æ³•æœ‰ä¸åŒçš„å…·ä½“è¯­æ³•ã€‚è¿™æ­£æ˜¯æŠ½è±¡è¯­æ³•æä¾›çš„æŠ½è±¡ï¼
- en: 'Easy peasy! This naturally suggests what we should do in the evaluator:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€å•æ˜“è¡Œï¼è¿™è‡ªç„¶æç¤ºæˆ‘ä»¬åœ¨è¯„ä¼°å™¨ä¸­åº”è¯¥åšä»€ä¹ˆï¼š
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ohâ€¦oops. This version of `calc`Â doesnâ€™t type-check, because our calculator is
    supposed to return only numbers, not Booleans!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å“¦â€¦â€¦ç³Ÿç³•ã€‚è¿™ä¸ªç‰ˆæœ¬çš„`calc`æ²¡æœ‰ç±»å‹æ£€æŸ¥ï¼Œå› ä¸ºæˆ‘ä»¬çš„è®¡ç®—å™¨åº”è¯¥åªè¿”å›æ•°å­—ï¼Œè€Œä¸æ˜¯å¸ƒå°”å€¼ï¼
- en: 'In fact, we had to know that this couldnâ€™t last. We arenâ€™t interested only
    in calculators; we want to build full-fledged programming languages. They have
    a wide range of values, i.e., answers: numbers, Boolean, strings, images, functions,
    and more.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¿…é¡»çŸ¥é“è¿™ä¸å¯èƒ½æŒä¹…ã€‚æˆ‘ä»¬ä¸ä»…å¯¹è®¡ç®—å™¨æ„Ÿå…´è¶£ï¼›æˆ‘ä»¬æƒ³è¦æ„å»ºå®Œæ•´çš„ç¼–ç¨‹è¯­è¨€ã€‚å®ƒä»¬å…·æœ‰å¹¿æ³›çš„ä»·å€¼èŒƒå›´ï¼Œå³ç­”æ¡ˆï¼šæ•°å­—ã€å¸ƒå°”å€¼ã€å­—ç¬¦ä¸²ã€å›¾åƒã€å‡½æ•°ç­‰ç­‰ã€‚

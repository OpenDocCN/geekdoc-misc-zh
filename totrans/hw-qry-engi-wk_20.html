<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Testing</h1>
<blockquote>原文：<a href="https://howqueryengineswork.com/16-testing.html">https://howqueryengineswork.com/16-testing.html</a></blockquote>
                        
<p><em>The source code discussed in this chapter can be found in the test directories throughout the <a href="https://github.com/andygrove/how-query-engines-work">KQuery project</a>.</em></p>
<p>Query engines are complex systems where subtle bugs can cause queries to return incorrect results. Unlike a crash or obvious error, a query that silently returns wrong data is particularly dangerous because users may make decisions based on faulty information. Rigorous testing is essential.</p>
<h2 id="why-query-engines-are-hard-to-test"><a class="header" href="#why-query-engines-are-hard-to-test">Why Query Engines Are Hard to Test</a></h2>
<p>Several factors make testing query engines challenging:</p>
<p>The combinatorial explosion of operators and expressions means there are infinite ways to combine them. A simple query with three operators and two expressions per operator already has many possible combinations. Hand-written tests cannot cover them all.</p>
<p>Type coercion adds another dimension. An expression like <code>a &gt; b</code> must work correctly for integers, floats, strings, dates, and more. Each comparison operator multiplied by each type combination multiplied by null handling creates many test cases.</p>
<p>Edge cases abound: empty tables, single-row tables, tables with all nulls, extremely large values, NaN for floating point, and Unicode strings with special characters. Production data will eventually exercise all of these.</p>
<p>Query optimizers can introduce bugs. A query might work correctly without optimization but fail after the optimizer rewrites it. Or the optimizer might produce a plan that is semantically different from the original.</p>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<p>Unit tests verify that individual components work correctly in isolation. For a query engine, this means testing expressions, operators, and data sources independently before testing them in combination.</p>
<h3 id="testing-expressions"><a class="header" href="#testing-expressions">Testing Expressions</a></h3>
<p>Expression tests should verify that each expression produces correct results for valid inputs and handles edge cases appropriately.</p>
<p>Here is a test for the greater-than-or-equals expression across different numeric types:</p>
<pre><code class="language-kotlin">@Test
fun `gteq longs`() {
    val schema = Schema(listOf(
        Field("a", ArrowTypes.Int64Type),
        Field("b", ArrowTypes.Int64Type)
    ))

    val a: List&lt;Long&gt; = listOf(111, 222, 333, Long.MIN_VALUE, Long.MAX_VALUE)
    val b: List&lt;Long&gt; = listOf(111, 333, 222, Long.MAX_VALUE, Long.MIN_VALUE)

    val batch = Fuzzer().createRecordBatch(schema, listOf(a, b))

    val expr = GtEqExpression(ColumnExpression(0), ColumnExpression(1))
    val result = expr.evaluate(batch)

    assertEquals(a.size, result.size())
    (0 until result.size()).forEach {
        assertEquals(a[it] &gt;= b[it], result.getValue(it))
    }
}
</code></pre>
<p>This test includes MIN_VALUE and MAX_VALUE to verify boundary behavior. Similar tests should exist for bytes, shorts, integers, floats, doubles, and strings. Each numeric type can have different overflow or comparison semantics.</p>
<p>For floating point types, testing NaN behavior is critical:</p>
<pre><code class="language-kotlin">@Test
fun `gteq doubles`() {
    val schema = Schema(listOf(
        Field("a", ArrowTypes.DoubleType),
        Field("b", ArrowTypes.DoubleType)
    ))

    val a: List&lt;Double&gt; = listOf(0.0, 1.0,
        Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN)
    val b = a.reversed()

    val batch = Fuzzer().createRecordBatch(schema, listOf(a, b))

    val expr = GtEqExpression(ColumnExpression(0), ColumnExpression(1))
    val result = expr.evaluate(batch)

    assertEquals(a.size, result.size())
    (0 until result.size()).forEach {
        assertEquals(a[it] &gt;= b[it], result.getValue(it))
    }
}
</code></pre>
<p>NaN comparisons follow IEEE 754 semantics where NaN compared to anything (including itself) returns false. This surprises many developers, so explicit tests catch implementations that handle NaN incorrectly.</p>
<h3 id="creating-test-data"><a class="header" href="#creating-test-data">Creating Test Data</a></h3>
<p>Tests need a convenient way to create record batches with arbitrary data. A helper method that takes a schema and column values makes tests cleaner:</p>
<pre><code class="language-kotlin">fun createRecordBatch(schema: Schema, columns: List&lt;List&lt;Any?&gt;&gt;): RecordBatch {
    val rowCount = columns[0].size

    val root = VectorSchemaRoot.create(schema.toArrow(), rootAllocator)
    root.allocateNew()

    (0 until rowCount).forEach { row -&gt;
        (0 until columns.size).forEach { col -&gt;
            val v = root.getVector(col)
            val value = columns[col][row]
            when (v) {
                is BitVector -&gt; v.set(row, if (value as Boolean) 1 else 0)
                is TinyIntVector -&gt; v.set(row, value as Byte)
                is SmallIntVector -&gt; v.set(row, value as Short)
                is IntVector -&gt; v.set(row, value as Int)
                is BigIntVector -&gt; v.set(row, value as Long)
                is Float4Vector -&gt; v.set(row, value as Float)
                is Float8Vector -&gt; v.set(row, value as Double)
                is VarCharVector -&gt; v.set(row, (value as String).toByteArray())
                else -&gt; throw IllegalStateException()
            }
        }
    }
    root.rowCount = rowCount

    return RecordBatch(schema, root.fieldVectors.map { ArrowFieldVector(it) })
}
</code></pre>
<p>With this helper, tests become declarative: define the schema, provide the data, and verify the result.</p>
<h3 id="what-to-test"><a class="header" href="#what-to-test">What to Test</a></h3>
<p>Here are categories of unit tests that every query engine should have:</p>
<p>Type handling: What happens when an expression receives an unexpected type? For example, computing SUM on strings should produce a clear error.</p>
<p>Boundary values: Test minimum and maximum values for each numeric type. Test empty strings and very long strings.</p>
<p>Null handling: Every expression must handle null inputs correctly. Typically, any operation involving null produces null (SQL three-valued logic).</p>
<p>Overflow and underflow: What happens when multiplying two large integers overflows? The behavior should be documented and tested.</p>
<p>Special floating point values: Test positive and negative infinity, NaN, positive and negative zero.</p>
<h2 id="testing-sql-parsing"><a class="header" href="#testing-sql-parsing">Testing SQL Parsing</a></h2>
<p>SQL parsing deserves dedicated tests because the parser is a critical component that interprets user queries. Parser bugs can cause queries to be misinterpreted, potentially with serious consequences.</p>
<h3 id="testing-operator-precedence"><a class="header" href="#testing-operator-precedence">Testing Operator Precedence</a></h3>
<p>Mathematical expressions must respect operator precedence. These tests verify that multiplication binds tighter than addition:</p>
<pre><code class="language-kotlin">@Test
fun `1 + 2 * 3`() {
    val expr = parse("1 + 2 * 3")
    val expected = SqlBinaryExpr(
        SqlLong(1),
        "+",
        SqlBinaryExpr(SqlLong(2), "*", SqlLong(3))
    )
    assertEquals(expected, expr)
}

@Test
fun `1 * 2 + 3`() {
    val expr = parse("1 * 2 + 3")
    val expected = SqlBinaryExpr(
        SqlBinaryExpr(SqlLong(1), "*", SqlLong(2)),
        "+",
        SqlLong(3)
    )
    assertEquals(expected, expr)
}
</code></pre>
<p>The tree structure of the parsed expression reveals which operations bind first. In <code>1 + 2 * 3</code>, the <code>2 * 3</code> forms a subtree because multiplication has higher precedence.</p>
<h3 id="testing-query-structure"><a class="header" href="#testing-query-structure">Testing Query Structure</a></h3>
<p>Tests should verify that each SQL clause is parsed correctly:</p>
<pre><code class="language-kotlin">@Test
fun `parse SELECT with WHERE`() {
    val select = parseSelect(
        "SELECT id, first_name, last_name FROM employee WHERE state = 'CO'"
    )
    assertEquals(
        listOf(
            SqlIdentifier("id"),
            SqlIdentifier("first_name"),
            SqlIdentifier("last_name")
        ),
        select.projection
    )
    assertEquals(
        SqlBinaryExpr(SqlIdentifier("state"), "=", SqlString("CO")),
        select.selection
    )
    assertEquals("employee", select.tableName)
}

@Test
fun `parse SELECT with aggregates`() {
    val select = parseSelect(
        "SELECT state, MAX(salary) FROM employee GROUP BY state"
    )
    assertEquals(
        listOf(
            SqlIdentifier("state"),
            SqlFunction("MAX", listOf(SqlIdentifier("salary")))
        ),
        select.projection
    )
    assertEquals(listOf(SqlIdentifier("state")), select.groupBy)
}
</code></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<p>Integration tests verify that components work together correctly. For a query engine, this means executing complete queries and verifying the results.</p>
<h3 id="end-to-end-query-tests"><a class="header" href="#end-to-end-query-tests">End-to-End Query Tests</a></h3>
<p>These tests exercise the full query path from parsing through execution:</p>
<pre><code class="language-kotlin">@Test
fun `employees in CO using DataFrame`() {
    val ctx = ExecutionContext(mapOf())

    val df = ctx.csv(employeeCsv)
        .filter(col("state") eq lit("CO"))
        .project(listOf(col("id"), col("first_name"), col("last_name")))

    val batches = ctx.execute(df).asSequence().toList()
    assertEquals(1, batches.size)

    val batch = batches.first()
    assertEquals("2,Gregg,Langford\n" + "3,John,Travis\n", batch.toCSV())
}

@Test
fun `employees in CA using SQL`() {
    val ctx = ExecutionContext(mapOf())

    val employee = ctx.csv(employeeCsv)
    ctx.register("employee", employee)

    val df = ctx.sql(
        "SELECT id, first_name, last_name FROM employee WHERE state = 'CA'"
    )

    val batches = ctx.execute(df).asSequence().toList()
    assertEquals(1, batches.size)

    val batch = batches.first()
    assertEquals("1,Bill,Hopkins\n", batch.toCSV())
}
</code></pre>
<p>These tests use a small, static test file so the expected results are known. The CSV output format makes assertions readable and diff-friendly when tests fail.</p>
<h3 id="testing-complex-operations"><a class="header" href="#testing-complex-operations">Testing Complex Operations</a></h3>
<p>Aggregation, joins, and other complex operations need thorough integration testing:</p>
<pre><code class="language-kotlin">@Test
fun `aggregate query`() {
    val ctx = ExecutionContext(mapOf())

    val df = ctx.csv(employeeCsv)
        .aggregate(
            listOf(col("state")),
            listOf(Max(cast(col("salary"), ArrowType.Int(32, true))))
        )

    val batches = ctx.execute(df).asSequence().toList()
    assertEquals(1, batches.size)

    val batch = batches.first()
    val expected = "CO,11500\n" + "CA,12000\n" + ",11500\n"
    assertEquals(expected, batch.toCSV())
}

@Test
fun `inner join using DataFrame`() {
    val leftSchema = Schema(listOf(
        Field("id", ArrowTypes.Int32Type),
        Field("name", ArrowTypes.StringType)
    ))
    val rightSchema = Schema(listOf(
        Field("id", ArrowTypes.Int32Type),
        Field("dept", ArrowTypes.StringType)
    ))

    val leftData = Fuzzer().createRecordBatch(
        leftSchema,
        listOf(listOf(1, 2, 3), listOf("Alice", "Bob", "Carol"))
    )
    val rightData = Fuzzer().createRecordBatch(
        rightSchema,
        listOf(listOf(1, 2, 4), listOf("Engineering", "Sales", "Marketing"))
    )

    val leftSource = InMemoryDataSource(leftSchema, listOf(leftData))
    val rightSource = InMemoryDataSource(rightSchema, listOf(rightData))

    val ctx = ExecutionContext(mapOf())

    val leftDf = DataFrameImpl(Scan("left", leftSource, listOf()))
    val rightDf = DataFrameImpl(Scan("right", rightSource, listOf()))

    val joinedDf = leftDf.join(rightDf, JoinType.Inner, listOf("id" to "id"))

    val batches = ctx.execute(joinedDf).asSequence().toList()
    assertEquals(1, batches.size)

    val batch = batches.first()
    assertEquals(2, batch.rowCount())
    assertEquals("1,Alice,Engineering\n2,Bob,Sales\n", batch.toCSV())
}
</code></pre>
<p>The join test creates in-memory data sources to have precise control over the input data. This makes the expected output predictable and the test deterministic.</p>
<h3 id="comparative-testing"><a class="header" href="#comparative-testing">Comparative Testing</a></h3>
<p>Comparative testing executes the same query against a trusted reference implementation and verifies that both produce the same results. This is particularly valuable for catching subtle bugs.</p>
<p>Common approaches include:</p>
<ul>
<li>Running queries against PostgreSQL, DuckDB, or another established database and comparing results</li>
<li>Comparing DataFrame API queries against equivalent SQL queries within the same engine</li>
<li>Running optimized queries against unoptimized versions to verify the optimizer preserves semantics</li>
</ul>
<p>The challenge with comparative testing is handling differences in null ordering, floating point precision, and result ordering when ORDER BY is not specified.</p>
<h2 id="fuzzing"><a class="header" href="#fuzzing">Fuzzing</a></h2>
<p>Hand-written tests inevitably miss edge cases. Fuzzing generates random inputs to discover bugs that humans would not think to test.</p>
<h3 id="random-expression-generation"><a class="header" href="#random-expression-generation">Random Expression Generation</a></h3>
<p>The fuzzer creates random expression trees by recursively building either leaf nodes (columns, literals) or binary expressions:</p>
<pre><code class="language-kotlin">fun createExpression(input: DataFrame, depth: Int, maxDepth: Int): LogicalExpr {
    return if (depth == maxDepth) {
        // return a leaf node
        when (rand.nextInt(4)) {
            0 -&gt; ColumnIndex(rand.nextInt(input.schema().fields.size))
            1 -&gt; LiteralDouble(rand.nextDouble())
            2 -&gt; LiteralLong(rand.nextLong())
            3 -&gt; LiteralString(randomString(rand.nextInt(64)))
            else -&gt; throw IllegalStateException()
        }
    } else {
        // binary expressions
        val l = createExpression(input, depth+1, maxDepth)
        val r = createExpression(input, depth+1, maxDepth)
        return when (rand.nextInt(8)) {
            0 -&gt; Eq(l, r)
            1 -&gt; Neq(l, r)
            2 -&gt; Lt(l, r)
            3 -&gt; LtEq(l, r)
            4 -&gt; Gt(l, r)
            5 -&gt; GtEq(l, r)
            6 -&gt; And(l, r)
            7 -&gt; Or(l, r)
            else -&gt; throw IllegalStateException()
        }
    }
}
</code></pre>
<p>A depth limit prevents unbounded recursion. The random seed should be fixed for reproducibility.</p>
<h3 id="random-plan-generation"><a class="header" href="#random-plan-generation">Random Plan Generation</a></h3>
<p>Similarly, the fuzzer can generate random query plans:</p>
<pre><code class="language-kotlin">fun createPlan(input: DataFrame,
               depth: Int,
               maxDepth: Int,
               maxExprDepth: Int): DataFrame {

    return if (depth == maxDepth) {
        input
    } else {
        // recursively create an input plan
        val child = createPlan(input, depth+1, maxDepth, maxExprDepth)
        // apply a transformation to the plan
        when (rand.nextInt(2)) {
            0 -&gt; {
                val exprCount = 1.rangeTo(rand.nextInt(1, 5))
                child.project(exprCount.map {
                    createExpression(child, 0, maxExprDepth)
                })
            }
            1 -&gt; child.filter(createExpression(input, 0, maxExprDepth))
            else -&gt; throw IllegalStateException()
        }
    }
}
</code></pre>
<p>Here is an example of a generated plan:</p>
<pre><code>Filter: 'VejBmVBpYp7gHxHIUB6UcGx' OR 0.7762591612853446
  Filter: 'vHGbOKKqR' &lt;= 0.41876514212913307
    Filter: 0.9835090312561898 &lt;= 3342229749483308391
      Filter: -5182478750208008322 &lt; -8012833501302297790
        Filter: 0.3985688976088563 AND #1
          Filter: #5 OR 'WkaZ54spnoI4MBtFpQaQgk'
            Scan: employee.csv; projection=None
</code></pre>
<h3 id="enhanced-random-values"><a class="header" href="#enhanced-random-values">Enhanced Random Values</a></h3>
<p>Naive random number generation misses interesting edge cases. An enhanced random generator deliberately produces boundary values:</p>
<pre><code class="language-kotlin">class EnhancedRandom(val rand: Random) {

    fun nextDouble(): Double {
        return when (rand.nextInt(8)) {
            0 -&gt; Double.MIN_VALUE
            1 -&gt; Double.MAX_VALUE
            2 -&gt; Double.POSITIVE_INFINITY
            3 -&gt; Double.NEGATIVE_INFINITY
            4 -&gt; Double.NaN
            5 -&gt; -0.0
            6 -&gt; 0.0
            7 -&gt; rand.nextDouble()
            else -&gt; throw IllegalStateException()
        }
    }

    fun nextLong(): Long {
        return when (rand.nextInt(5)) {
            0 -&gt; Long.MIN_VALUE
            1 -&gt; Long.MAX_VALUE
            2 -&gt; -0
            3 -&gt; 0
            4 -&gt; rand.nextLong()
            else -&gt; throw IllegalStateException()
        }
    }
}
</code></pre>
<p>By weighting the distribution toward edge cases, the fuzzer finds bugs faster than pure random generation.</p>
<h3 id="handling-invalid-plans"><a class="header" href="#handling-invalid-plans">Handling Invalid Plans</a></h3>
<p>Most randomly generated plans are invalid. This is actually useful because it tests error handling. However, if you want to test execution specifically, the fuzzer can be made “smarter” by:</p>
<ul>
<li>Generating type-aware expressions (e.g., only compare compatible types)</li>
<li>Generating AND/OR expressions with Boolean operands</li>
<li>Ensuring aggregate expressions use aggregate functions</li>
</ul>
<p>The trade-off is that smarter fuzzers may miss bugs in error paths.</p>
<h3 id="using-fuzzing-effectively"><a class="header" href="#using-fuzzing-effectively">Using Fuzzing Effectively</a></h3>
<p>Some practical tips for fuzzing:</p>
<p>Fix the random seed: Use a constant seed so failures are reproducible. Log the seed if using system time.</p>
<p>Run many iterations: Fuzzing finds bugs probabilistically. Run thousands or millions of iterations.</p>
<p>Shrink failing cases: When fuzzing finds a bug, try to reduce the failing input to a minimal reproduction.</p>
<p>Keep regression tests: When fuzzing finds a bug, add the simplified case as a permanent test.</p>
<h2 id="golden-testing"><a class="header" href="#golden-testing">Golden Testing</a></h2>
<p>Golden testing (also called snapshot testing) captures the output of a query and stores it as the expected result. Future runs compare against this “golden” output.</p>
<p>This approach works well for:</p>
<ul>
<li>Query plan pretty-printing (verifying plan structure)</li>
<li>Explain output format</li>
<li>Error messages</li>
</ul>
<p>The downside is that golden tests can be brittle. Any change to output formatting breaks the tests, even if the underlying behavior is correct.</p>
<h2 id="testing-optimizations"><a class="header" href="#testing-optimizations">Testing Optimizations</a></h2>
<p>Optimizer bugs are particularly insidious because the unoptimized query works correctly. Test optimizations by:</p>
<ol>
<li>Verifying that optimized and unoptimized plans produce identical results</li>
<li>Verifying that specific optimizations fire when expected</li>
<li>Testing that invalid optimizations do not fire</li>
</ol>
<p>For example, to test projection push-down:</p>
<pre><code class="language-kotlin">@Test
fun `projection pushdown reduces columns read`() {
    val plan = // build a plan that selects 3 columns from a 10 column table

    val optimized = Optimizer().optimize(plan)

    // Verify the scan only reads the 3 needed columns
    val scan = findScan(optimized)
    assertEquals(3, scan.projection.size)
}

@Test
fun `optimization preserves query semantics`() {
    val plan = // build a query plan
    val optimized = Optimizer().optimize(plan)

    val originalResult = execute(plan)
    val optimizedResult = execute(optimized)

    assertEquals(originalResult, optimizedResult)
}
</code></pre>
<h2 id="debugging-test-failures"><a class="header" href="#debugging-test-failures">Debugging Test Failures</a></h2>
<p>When a test fails, the key is reproducing and understanding the failure.</p>
<p>Pretty-print plans: Implement a <code>pretty()</code> method on logical and physical plans. When a test fails, print the plan to understand what query was executed.</p>
<p>Log intermediate results: For debugging, add logging that shows data flowing through each operator.</p>
<p>Minimize the reproduction: Start with a failing query and systematically simplify it while keeping the failure. Remove unnecessary columns, filters, and joins until you have the smallest query that exhibits the bug.</p>
<p>Check boundary conditions: Many bugs occur at boundaries. If a test with 100 rows fails, try 0, 1, and 2 rows.</p>
<p>Verify test data: Sometimes the test itself is wrong. Double-check that the test data and expected results are correct.</p>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<p>Automated testing in CI catches regressions before they reach users. A good CI setup for a query engine includes:</p>
<ul>
<li>Run all unit tests on every commit</li>
<li>Run integration tests on every pull request</li>
<li>Run longer fuzzing sessions nightly or weekly</li>
<li>Track test execution time to catch performance regressions</li>
</ul>
<p>Test failures should block merging. Flaky tests (tests that sometimes pass and sometimes fail) must be fixed immediately because they train developers to ignore failures.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Testing query engines requires multiple complementary approaches. Unit tests verify individual components. Integration tests verify components work together. Fuzzing discovers edge cases that humans miss. Comparative testing catches semantic bugs by checking against a reference implementation.</p>
<p>Invest in testing infrastructure early. Good test utilities (for creating test data, comparing results, pretty-printing plans) make writing tests easier, which means more tests get written. A well-tested query engine gives users confidence that their query results are correct.</p>
<p><em>This book is also available for purchase in ePub, MOBI, and PDF format from <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a></em></p>
<p><strong>Copyright © 2020-2025 Andy Grove. All rights reserved.</strong></p>

                        
</body>
</html>
- en: Query Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://howqueryengineswork.com/12-optimizations.html](https://howqueryengineswork.com/12-optimizations.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The source code discussed in this chapter can be found in the `optimizer`
    module of the [KQuery project](https://github.com/andygrove/how-query-engines-work).*'
  prefs: []
  type: TYPE_NORMAL
- en: A query engine that executes plans exactly as written will produce correct results
    but may be slow. Users writing SQL or DataFrame queries naturally express what
    they want, not how to compute it efficiently. The optimizer transforms logical
    plans into equivalent but faster plans.
  prefs: []
  type: TYPE_NORMAL
- en: '[Why Optimize?](#why-optimize)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a query that joins two tables and then filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this literally means: join all employees with all departments, then
    filter to Colorado. If there are 100,000 employees and only 5,000 in Colorado,
    we do 95,000 unnecessary join lookups.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An optimizer recognizes that the filter on `state` only touches the `employees`
    table and can be applied before the join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we join only 5,000 employees instead of 100,000\. This produces the same
    result but is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[Rule-Based Optimization](#rule-based-optimization)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'KQuery uses rule-based optimization: a set of transformation rules that each
    improve the plan in some way. Rules are applied in sequence, each taking a logical
    plan and returning a (hopefully better) logical plan.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rules work by walking the plan tree and rebuilding it with modifications. This
    functional approach (build a new tree rather than mutate the old one) is simpler
    and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: '[Projection Push-Down](#projection-push-down)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Projection push-down reduces memory usage by reading only the columns that the
    query actually uses. If a table has 50 columns but the query only references 3,
    we should read only those 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule works by:'
  prefs: []
  type: TYPE_NORMAL
- en: Walking the plan top-down, collecting column names referenced in each operator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When reaching a Scan, replacing it with a Scan that projects only the needed
    columns
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need a helper to extract column references from expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the rule itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The optimizer produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Scan now reads only four columns instead of all columns in the table. For
    columnar formats like Parquet, this dramatically reduces I/O.
  prefs: []
  type: TYPE_NORMAL
- en: '[Predicate Push-Down](#predicate-push-down)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Predicate push-down moves filters closer to the data source, reducing the number
    of rows processed by later operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter references only `employee` columns, so it can move below the join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now the join processes fewer rows. This optimization becomes more important
    with larger tables and more selective predicates.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation must analyze which tables each predicate references and only
    push predicates that reference a single table below joins. Predicates referencing
    both sides of a join cannot be pushed below it.
  prefs: []
  type: TYPE_NORMAL
- en: 'KQuery does not currently implement predicate push-down, but the pattern is
    similar to projection push-down: walk the tree, identify opportunities, rebuild
    with filters moved down.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Eliminate Common Subexpressions](#eliminate-common-subexpressions)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the same expression appears multiple times, we can compute it once and
    reuse the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `price * qty` appears in both aggregates. Rather than compute
    it twice per row, we can add an intermediate projection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Optimized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This trades one multiplication per row (in the projection) against two multiplications
    per row (in the original aggregates). For large datasets, this adds up.
  prefs: []
  type: TYPE_NORMAL
- en: 'KQuery does not implement this optimization, but the approach involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding expressions that appear multiple times
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a projection that computes them once with generated names
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewriting later operators to reference the computed columns
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Cost-Based Optimization](#cost-based-optimization)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rule-based optimization applies transformations unconditionally. Cost-based
    optimization estimates the cost of different plans and chooses the cheapest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider join ordering. For three tables A, B, C:'
  prefs: []
  type: TYPE_NORMAL
- en: (A JOIN B) JOIN C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (A JOIN C) JOIN B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (B JOIN C) JOIN A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All produce the same result, but performance varies dramatically based on table
    sizes and join selectivity. If A has 1 million rows, B has 100 rows, and C has
    10,000 rows, joining B and C first (100 × 10,000 = 1 million intermediate rows
    at most) then joining A is likely faster than starting with A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cost-based optimizers need statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: Table row counts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column cardinality (number of distinct values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value distributions (histograms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Min/max values per column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With statistics, the optimizer can estimate:'
  prefs: []
  type: TYPE_NORMAL
- en: How many rows a filter will produce (selectivity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many rows a join will produce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory requirements for hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimizer generates candidate plans, estimates cost for each, and picks
    the cheapest.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Statistics Challenge](#the-statistics-challenge)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cost-based optimization sounds great but has practical challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering statistics is expensive. Scanning terabytes of data to build histograms
    takes time. For ad-hoc queries, this overhead may exceed the optimization benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Statistics become stale. As data changes, statistics drift from reality. Stale
    statistics lead to bad plans.
  prefs: []
  type: TYPE_NORMAL
- en: Estimation errors compound. Each estimate has error. In a complex plan with
    many operators, errors multiply, potentially leading to catastrophically bad plans.
  prefs: []
  type: TYPE_NORMAL
- en: Some formats provide partial statistics. Parquet and ORC files include min/max
    values and row counts per column chunk. This helps but is not enough for accurate
    cardinality estimation.
  prefs: []
  type: TYPE_NORMAL
- en: KQuery uses only rule-based optimization. Production systems like Spark, Presto,
    and traditional databases invest heavily in cost-based optimization, but it remains
    an area of active research and engineering.
  prefs: []
  type: TYPE_NORMAL
- en: '[Other Optimizations](#other-optimizations)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Query engines implement many other optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant folding: Evaluate constant expressions at planning time. `WHERE date
    > ''2024-01-01'' AND 1 = 1` becomes `WHERE date > ''2024-01-01''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dead column elimination: Remove columns from intermediate results when they
    are not needed downstream.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Join reordering: Choose the order of joins to minimize intermediate result
    sizes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Limit push-down: Push LIMIT operators down to reduce work. If we only need
    10 rows, stop early.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Partition pruning: Skip reading partitions that cannot contain matching data
    based on partition keys.'
  prefs: []
  type: TYPE_NORMAL
- en: The right set of optimizations depends on the workload and data characteristics.
    Simple rule-based optimizations provide significant benefits with minimal complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '*This book is also available for purchase in ePub, MOBI, and PDF format from
    [https://leanpub.com/how-query-engines-work](https://leanpub.com/how-query-engines-work)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copyright © 2020-2025 Andy Grove. All rights reserved.**'
  prefs: []
  type: TYPE_NORMAL

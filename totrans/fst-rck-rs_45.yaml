- en: Scoped Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html](https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the previous section, we explored the `spawn` method in the `thread` module
    and noted its limitation: it cannot borrow non-`''static` data because the compiler
    cannot guarantee that all threads will be joined before the lifetimes of any borrowed
    values expire. To address this issue, the `thread` module also offers the [`scope`
    function](https://doc.rust-lang.org/stable/std/thread/fn.scope.html), which works
    in conjunction with [`Scope`](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html).
    This combination allows for borrowing non-`''static` data by ensuring that all
    spawned threads within the scope are automatically joined before the function
    in which they were created returns, unless they were manually joined earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The `scope` Function](#the-scope-function)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the signature for the [`scope` function](https://doc.rust-lang.org/stable/std/thread/fn.scope.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `scope` function takes a closure (`f`) as an argument, which receives a
    `Scope` object (created by `scope`). This `Scope` object allows threads to be
    spawned using the [`spawn`](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html#method.spawn)
    method. The spawn method returns a [`ScopedJoinHandle`](https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html),
    which, as the name suggests, provides a [`join`](https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html#method.join)
    method to wait for the spawned thread to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scoped threads involve two lifetimes: `''scope` and `''env`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''env`: This is a lifetime parameter that represents the lifetime of the environment
    data that the `Scope` can borrow (meaning the data from outside the scope). It
    ensures that any references to the environment data outlive the scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''scope`: This is another lifetime parameter that represents the lifetime
    of the scope itself. This is the period during which new scoped threads can be
    spawned and running. It ensures that any running threads are joined before the
    lifetime ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In plain English, the `scope` function takes a closure `f` that can borrow data
    with a specific lifetime `'env` and ensures that all threads spawned within the
    scope are joined before the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit one of the examples from the previous section that failed to compile
    to better understand these concepts. Review the following code snippet and then
    run the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Through these ownership and type system tools, it is guaranteed that all threads
    created within `scope` are joined before their lifetimes end. This allows the
    Rust compiler to be certain that all borrowed data (in this case, the `error`
    `String`) remains valid for the lifetime of the threads. This is how Rust turns
    many runtime errors into compile-time errors. Concepts like this facilitate fearless
    concurrency in Rust!
  prefs: []
  type: TYPE_NORMAL

- en: Scoped Threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域线程
- en: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html](https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html](https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html)
- en: 'In the previous section, we explored the `spawn` method in the `thread` module
    and noted its limitation: it cannot borrow non-`''static` data because the compiler
    cannot guarantee that all threads will be joined before the lifetimes of any borrowed
    values expire. To address this issue, the `thread` module also offers the [`scope`
    function](https://doc.rust-lang.org/stable/std/thread/fn.scope.html), which works
    in conjunction with [`Scope`](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html).
    This combination allows for borrowing non-`''static` data by ensuring that all
    spawned threads within the scope are automatically joined before the function
    in which they were created returns, unless they were manually joined earlier.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个章节中，我们探讨了`thread`模块中的`spawn`方法，并指出其局限性：它不能借用非`'static`数据，因为编译器无法保证在所有借用值的生命周期之前，所有线程都将被连接。为了解决这个问题，`thread`模块还提供了`[`scope`函数](https://doc.rust-lang.org/stable/std/thread/fn.scope.html)`，它与`[`Scope`](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html)`一起工作。这种组合通过确保在作用域内创建的所有线程在它们创建的函数返回之前自动连接，除非它们之前已被手动连接，从而允许借用非`'static`数据。
- en: '[The `scope` Function](#the-scope-function)'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`scope`函数](#the-scope-function)'
- en: 'Here''s the signature for the [`scope` function](https://doc.rust-lang.org/stable/std/thread/fn.scope.html):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`[`scope`函数](https://doc.rust-lang.org/stable/std/thread/fn.scope.html)的签名：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `scope` function takes a closure (`f`) as an argument, which receives a
    `Scope` object (created by `scope`). This `Scope` object allows threads to be
    spawned using the [`spawn`](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html#method.spawn)
    method. The spawn method returns a [`ScopedJoinHandle`](https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html),
    which, as the name suggests, provides a [`join`](https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html#method.join)
    method to wait for the spawned thread to complete.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`scope`函数接受一个闭包（`f`）作为参数，该闭包接收一个`Scope`对象（由`scope`创建）。这个`Scope`对象允许使用`[`spawn`](https://doc.rust-lang.org/stable/std/thread/struct.Scope.html#method.spawn)方法来创建线程。`spawn`方法返回一个`[`ScopedJoinHandle`](https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html)，正如其名称所暗示的，提供了一个`[`join`](https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html#method.join)方法来等待创建的线程完成。'
- en: 'Scoped threads involve two lifetimes: `''scope` and `''env`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域线程涉及两个生命周期：`'scope`和`'env`：
- en: '`''env`: This is a lifetime parameter that represents the lifetime of the environment
    data that the `Scope` can borrow (meaning the data from outside the scope). It
    ensures that any references to the environment data outlive the scope.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''env`：这是一个生命周期参数，表示`Scope`可以借用（即作用域外部的数据）的环境数据的生命周期。它确保任何对环境数据的引用都超出作用域的生命周期。'
- en: '`''scope`: This is another lifetime parameter that represents the lifetime
    of the scope itself. This is the period during which new scoped threads can be
    spawned and running. It ensures that any running threads are joined before the
    lifetime ends.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''scope`：这是另一个生命周期参数，表示作用域本身的生命周期。这是在此期间可以创建和运行新的作用域线程的时期。它确保在生命周期结束时，任何正在运行的线程都被连接。'
- en: In plain English, the `scope` function takes a closure `f` that can borrow data
    with a specific lifetime `'env` and ensures that all threads spawned within the
    scope are joined before the function returns.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话说，`scope`函数接受一个闭包`f`，它可以借用具有特定生命周期`'env`的数据，并确保在函数返回之前，作用域内创建的所有线程都被连接。
- en: Let's revisit one of the examples from the previous section that failed to compile
    to better understand these concepts. Review the following code snippet and then
    run the program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前一个章节中未能编译的一个示例，以更好地理解这些概念。请审查以下代码片段，然后运行程序。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Through these ownership and type system tools, it is guaranteed that all threads
    created within `scope` are joined before their lifetimes end. This allows the
    Rust compiler to be certain that all borrowed data (in this case, the `error`
    `String`) remains valid for the lifetime of the threads. This is how Rust turns
    many runtime errors into compile-time errors. Concepts like this facilitate fearless
    concurrency in Rust!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些所有权和类型系统工具，可以保证在`scope`内创建的所有线程在它们的生命周期结束时都会被连接。这允许Rust编译器确定所有借用数据（在这种情况下，是`error`
    `String`）在线程的生命周期内保持有效。这就是Rust将许多运行时错误转换为编译时错误的方式。这样的概念有助于在Rust中实现无畏的并发！

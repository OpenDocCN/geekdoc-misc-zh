- en: Apache Arrow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Arrow
- en: 原文：[https://howqueryengineswork.com/02-apache-arrow.html](https://howqueryengineswork.com/02-apache-arrow.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://howqueryengineswork.com/02-apache-arrow.html](https://howqueryengineswork.com/02-apache-arrow.html)
- en: 'Before we start building our query engine, we need to choose how to represent
    data in memory. This choice affects everything: how we read files, how we pass
    data between operators, and how fast our computations run. We will use Apache
    Arrow, which has become the standard for in-memory columnar data.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建查询引擎之前，我们需要选择如何在内存中表示数据。这个选择会影响一切：我们如何读取文件，我们如何在算子之间传递数据，以及我们的计算运行得多快。我们将使用Apache
    Arrow，它已成为内存中列式数据的标准。
- en: '[Why Columnar?](#why-columnar)'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[为什么使用列式存储？](#why-columnar)'
- en: 'Traditional databases and programming languages typically store data row by
    row. If you have a table of employees, each employee record sits together in memory:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 传统数据库和编程语言通常按行存储数据。如果你有一个员工表，每个员工记录在内存中是连续存放的：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This layout is intuitive and works well when you need to access entire records.
    But query engines often process just a few columns at a time. Consider:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种布局直观且在需要访问整个记录时表现良好。但查询引擎通常一次只处理几个列。考虑：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This query only needs the `department` and `salary` columns. With row-based
    storage, we would load entire rows into memory just to access two fields.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询只需要`department`和`salary`列。在基于行的存储中，我们只需为了访问两个字段就将整个行加载到内存中。
- en: 'Columnar storage flips this around. Each column is stored contiguously:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列式存储则相反。每个列都是连续存储的：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now reading `salary` means reading one contiguous block of memory, with no
    jumping around to skip unwanted fields. This matters enormously for performance:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在读取`salary`意味着读取一块连续的内存，无需跳过不需要的字段。这对性能影响极大：
- en: Modern CPUs load memory in cache lines (typically 64 bytes). Columnar data packs
    more useful values per cache line.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代CPU以缓存行（通常是64字节）的形式加载内存。列式数据可以在每个缓存行中打包更多的有用值。
- en: Similar values grouped together compress much better. A column of departments
    might compress to just a few distinct values.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似值分组在一起可以更好地压缩。部门列可能压缩到只有几个不同的值。
- en: CPUs can apply the same operation to multiple values simultaneously (Single
    Instruction, Multiple Data). Columnar layout enables this.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU可以对多个值同时执行相同的操作（单指令，多数据）。列式布局使得这一点成为可能。
- en: '[What Is Apache Arrow?](#what-is-apache-arrow)'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Apache Arrow是什么？](#what-is-apache-arrow)'
- en: Apache Arrow is a specification for how to represent columnar data in memory,
    plus libraries implementing that specification in many languages. Think of it
    as a universal format that different systems can share.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Arrow是一个关于如何在内存中表示列式数据的规范，以及实现该规范的多种语言的库。将其视为一个不同系统可以共享的通用格式。
- en: 'The key insight behind Arrow is that data analytics involves many tools: Python
    for exploration, Spark for distributed processing, databases for storage, visualization
    tools for presentation. Traditionally, each tool has its own internal format,
    so moving data between tools means serializing and deserializing, converting formats
    repeatedly.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow背后的关键洞察是数据分析涉及许多工具：Python用于探索，Spark用于分布式处理，数据库用于存储，可视化工具用于展示。传统上，每个工具都有自己的内部格式，因此在不同工具之间移动数据意味着序列化和反序列化，反复转换格式。
- en: Arrow eliminates this overhead. If your Python code and your Java code both
    use Arrow format, they can share memory directly. A pointer to Arrow data is meaningful
    to any Arrow-aware system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow消除了这种开销。如果你的Python代码和Java代码都使用Arrow格式，它们可以直接共享内存。指向Arrow数据的指针对任何Arrow感知系统都是有意义的。
- en: '[Arrow Memory Layout](#arrow-memory-layout)'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[箭头内存布局](#arrow-memory-layout)'
- en: 'An Arrow column (called a “vector” or “array”) consists of:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头列（称为“向量”或“数组”）由以下内容组成：
- en: A data buffer containing the actual values, packed contiguously
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含实际值的缓冲区，这些值连续打包
- en: A validity buffer, which is a bitmap indicating which values are null
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个有效性缓冲区，它是一个位图，指示哪些值是null
- en: An optional offset buffer for variable-length types like strings
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选的偏移缓冲区，用于字符串等变长类型
- en: 'For a column of 32-bit integers `[1, null, 3, 4]`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个32位整数列 `[1, null, 3, 4]`：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For strings, we need offsets because strings vary in length:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串，我们需要偏移量，因为字符串的长度不同：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get string at index 1: read from offset[1]=5 to offset[2]=10, giving “world”.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取索引为1的字符串：从偏移量[1]=5读取到偏移量[2]=10，得到“world”。
- en: This layout is simple but powerful. Fixed-width types like integers require
    just one memory access per value. The validity bitmap uses just one bit per value,
    so checking for nulls is cheap.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种布局简单但强大。固定宽度的类型，如整数，每个值只需要一次内存访问。有效性位图每个值只需要一个位，因此检查空值成本低。
- en: '[Record Batches](#record-batches)'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[记录批次](#record-batches)'
- en: 'A single column is not very useful on its own. We need multiple columns together.
    Query engines typically group columns into record batches: a collection of equal-length
    columns with a schema describing their names and types. KQuery defines its own
    `RecordBatch` class for this purpose.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单个列本身并不很有用。我们需要多个列一起使用。查询引擎通常将列分组到记录批次中：具有描述其名称和类型的模式的等长列集合。KQuery为此定义了自己的`RecordBatch`类。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Query engines process data in batches rather than row by row or all at once.
    Batch processing hits the sweet spot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查询引擎以批量的方式处理数据，而不是逐行或一次性处理。批量处理击中了最佳点：
- en: Small enough to fit in CPU cache
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够小，可以放入CPU缓存。
- en: Large enough to amortize per-batch overhead
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够大，可以分摊每批开销。
- en: Enables streaming (process data as it arrives)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持流式处理（数据到达时进行处理）。
- en: Typical batch sizes range from 1,000 to 100,000 rows depending on the workload.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的批量大小从1,000到100,000行不等，具体取决于工作负载。
- en: '[Schemas and Types](#schemas-and-types)'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[模式和类型](#schemas-and-types)'
- en: 'Arrow defines a rich type system covering:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow定义了一个丰富的类型系统，涵盖：
- en: 'Integers: Int8, Int16, Int32, Int64 (signed and unsigned)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数：Int8、Int16、Int32、Int64（有符号和无符号）。
- en: 'Floating point: Float32 (single), Float64 (double)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数：Float32（单精度），Float64（双精度）。
- en: 'Binary: Variable-length byte arrays'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制：可变长度的字节数组。
- en: 'Strings: UTF-8 encoded text'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：UTF-8编码的文本。
- en: 'Temporal: Date, Time, Timestamp, Duration, Interval'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间：日期、时间、时间戳、持续时间、间隔
- en: 'Nested: List, Struct, Map, Union'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套：列表、结构、映射、联合。
- en: 'A schema names and types the columns:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模式命名和指定列：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Having explicit nullability in the schema lets the query engine optimize. If
    a column cannot be null, we can skip null checks entirely.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式中具有显式的可空性可以让查询引擎进行优化。如果一个列不能为空，我们可以完全跳过空值检查。
- en: '[Language Implementations](#language-implementations)'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[语言实现](#language-implementations)'
- en: Arrow has official implementations in C++, Java, Python, Rust, Go, JavaScript,
    C#, Ruby, and more. For this book, we will use the Java implementation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow在C++、Java、Python、Rust、Go、JavaScript、C#、Ruby等多种语言中都有官方实现。对于这本书，我们将使用Java实现。
- en: 'The Java API provides:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Java API提供：
- en: 'FieldVector: Base class for column vectors (IntVector, VarCharVector, etc.)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FieldVector：列向量的基类（IntVector、VarCharVector等）。
- en: 'VectorSchemaRoot: Container for a record batch'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VectorSchemaRoot：记录批次的容器。
- en: 'ArrowType: Represents data types'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ArrowType：表示数据类型。
- en: 'Schema/Field: Describes the structure of data'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式/字段：描述数据的结构。
- en: 'Here is a simple example creating an Arrow vector in Java:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在Java中创建Arrow向量的简单示例：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Why Arrow for Our Query Engine?](#why-arrow-for-our-query-engine)'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[为什么选择Arrow作为我们的查询引擎？](#why-arrow-for-our-query-engine)'
- en: 'We will use Arrow as the foundation of our query engine for several reasons:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Arrow作为我们查询引擎的基础，原因有几个：
- en: It is a standard format, so we can easily read/write Parquet files and integrate
    with other tools
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个标准格式，因此我们可以轻松地读写Parquet文件并与其他工具集成。
- en: The Java library is mature and well-tested
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java库成熟且经过充分测试。
- en: The columnar layout enables efficient query processing
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列式布局使得查询处理更加高效。
- en: Understanding Arrow helps you understand other data systems
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解Arrow有助于你理解其他数据系统。
- en: The next chapter builds our type system on top of Arrow, adding the abstractions
    our query engine needs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在Arrow之上构建我们的类型系统，添加查询引擎需要的抽象。
- en: '[Further Reading](#further-reading)'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading)'
- en: The [Arrow specification](https://arrow.apache.org/docs/format/Columnar.html)
    describes the memory format in detail. The [Arrow website](https://arrow.apache.org/)
    has documentation for each language implementation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[Arrow规范](https://arrow.apache.org/docs/format/Columnar.html)详细描述了内存格式。[Arrow网站](https://arrow.apache.org/)为每种语言实现提供了文档。'
- en: Arrow also provides protocols for transferring data over networks (Arrow Flight)
    and file formats (Arrow IPC, Feather), but we will not use those directly in this
    book. The core value for us is the in-memory columnar format.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow还提供了在网络上传输数据（Arrow Flight）和文件格式（Arrow IPC，Feather）的协议，但在这本书中我们不会直接使用它们。对我们来说，核心价值是内存中的列式格式。
- en: '*This book is also available for purchase in ePub, MOBI, and PDF format from
    [https://leanpub.com/how-query-engines-work](https://leanpub.com/how-query-engines-work)*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书也以ePub、MOBI和PDF格式在[https://leanpub.com/how-query-engines-work](https://leanpub.com/how-query-engines-work)上出售*。'
- en: '**Copyright © 2020-2025 Andy Grove. All rights reserved.**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**版权所有 © 2020-2025 安迪·格鲁夫。保留所有权利。**'

["```rs\nclass QueryPlanner {\n\n    fun createPhysicalPlan(plan: LogicalPlan): PhysicalPlan {\n        return when (plan) {\n            is Scan -> ...\n            is Selection -> ...\n            is Projection -> ...\n            is Aggregate -> ...\n            else -> throw IllegalStateException(\"Unknown plan: $plan\")\n        }\n    }\n\n    fun createPhysicalExpr(expr: LogicalExpr, input: LogicalPlan): Expression {\n        return when (expr) {\n            is Column -> ...\n            is LiteralLong -> ...\n            is BinaryExpr -> ...\n            else -> throw IllegalStateException(\"Unknown expression: $expr\")\n        }\n    }\n} \n```", "```rs\nis Column -> {\n    val i = input.schema().fields.indexOfFirst { it.name == expr.name }\n    if (i == -1) {\n        throw SQLException(\"No column named '${expr.name}'\")\n    }\n    ColumnExpression(i)\n} \n```", "```rs\nis LiteralLong -> LiteralLongExpression(expr.n)\nis LiteralDouble -> LiteralDoubleExpression(expr.n)\nis LiteralString -> LiteralStringExpression(expr.str) \n```", "```rs\nis BinaryExpr -> {\n    val l = createPhysicalExpr(expr.l, input)\n    val r = createPhysicalExpr(expr.r, input)\n    when (expr) {\n        // Comparison\n        is Eq -> EqExpression(l, r)\n        is Neq -> NeqExpression(l, r)\n        is Gt -> GtExpression(l, r)\n        is GtEq -> GtEqExpression(l, r)\n        is Lt -> LtExpression(l, r)\n        is LtEq -> LtEqExpression(l, r)\n\n        // Boolean\n        is And -> AndExpression(l, r)\n        is Or -> OrExpression(l, r)\n\n        // Math\n        is Add -> AddExpression(l, r)\n        is Subtract -> SubtractExpression(l, r)\n        is Multiply -> MultiplyExpression(l, r)\n        is Divide -> DivideExpression(l, r)\n\n        else -> throw IllegalStateException(\"Unsupported: $expr\")\n    }\n} \n```", "```rs\nis Alias -> {\n    // Aliases only affect naming during planning, not execution\n    createPhysicalExpr(expr.expr, input)\n} \n```", "```rs\nis Scan -> {\n    ScanExec(plan.dataSource, plan.projection)\n} \n```", "```rs\nis Selection -> {\n    val input = createPhysicalPlan(plan.input)\n    val filterExpr = createPhysicalExpr(plan.expr, plan.input)\n    SelectionExec(input, filterExpr)\n} \n```", "```rs\nis Projection -> {\n    val input = createPhysicalPlan(plan.input)\n    val projectionExpr = plan.expr.map { createPhysicalExpr(it, plan.input) }\n    val projectionSchema = Schema(plan.expr.map { it.toField(plan.input) })\n    ProjectionExec(input, projectionSchema, projectionExpr)\n} \n```", "```rs\nis Aggregate -> {\n    val input = createPhysicalPlan(plan.input)\n    val groupExpr = plan.groupExpr.map { createPhysicalExpr(it, plan.input) }\n    val aggregateExpr = plan.aggregateExpr.map {\n        when (it) {\n            is Max -> MaxExpression(createPhysicalExpr(it.expr, plan.input))\n            is Min -> MinExpression(createPhysicalExpr(it.expr, plan.input))\n            is Sum -> SumExpression(createPhysicalExpr(it.expr, plan.input))\n            is Avg -> AvgExpression(createPhysicalExpr(it.expr, plan.input))\n            is Count -> CountExpression(createPhysicalExpr(it.expr, plan.input))\n            else -> throw IllegalStateException(\"Unsupported: $it\")\n        }\n    }\n    HashAggregateExec(input, groupExpr, aggregateExpr, plan.schema())\n} \n```", "```rs\nSELECT department, AVG(salary)\nFROM employees\nWHERE state = 'CO'\nGROUP BY department \n```", "```rs\nAggregate: groupBy=[#department], aggr=[AVG(#salary)]\n    Selection: #state = 'CO'\n        Scan: employees \n```"]
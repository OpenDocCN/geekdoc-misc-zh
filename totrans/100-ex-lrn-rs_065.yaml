- en: Combinators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合器
- en: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/07_combinators.html](https://rust-exercises.com/100-exercises/06_ticket_management/07_combinators.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/07_combinators.html](https://rust-exercises.com/100-exercises/06_ticket_management/07_combinators.html)
- en: Iterators can do so much more than `for` loops!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器可以做得比 `for` 循环更多！
- en: If you look at the documentation for the `Iterator` trait, you'll find a **vast**
    collection of methods that you can leverage to transform, filter, and combine
    iterators in various ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `Iterator` 特性的文档，你会找到一个**庞大**的方法集合，你可以利用这些方法以各种方式转换、过滤和组合迭代器。
- en: 'Let''s mention the most common ones:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提及最常见的一些：
- en: '`map` applies a function to each element of the iterator.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 将函数应用于迭代器的每个元素。'
- en: '`filter` keeps only the elements that satisfy a predicate.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter` 只保留满足谓词的元素。'
- en: '`filter_map` combines `filter` and `map` in one step.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter_map` 在一步中结合了 `filter` 和 `map`。'
- en: '`cloned` converts an iterator of references into an iterator of values, cloning
    each element.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloned` 将引用迭代器转换为值迭代器，克隆每个元素。'
- en: '`enumerate` returns a new iterator that yields `(index, value)` pairs.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate` 返回一个新的迭代器，它产生 `(index, value)` 对。'
- en: '`skip` skips the first `n` elements of the iterator.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip` 跳过迭代器的前 `n` 个元素。'
- en: '`take` stops the iterator after `n` elements.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take` 在 `n` 个元素后停止迭代器。'
- en: '`chain` combines two iterators into one.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain` 将两个迭代器合并为一个。'
- en: These methods are called **combinators**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被称为**组合器**。
- en: 'They are usually **chained** together to create complex transformations in
    a concise and readable way:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常它们会被**链式**组合在一起，以简洁和可读的方式创建复杂的转换：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Closures](#closures)'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[闭包](#closures)'
- en: What's going on with the `filter` and `map` methods above?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `filter` 和 `map` 方法发生了什么？
- en: They take **closures** as arguments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它们接受**闭包**作为参数。
- en: Closures are **anonymous functions**, i.e. functions that are not defined using
    the `fn` syntax we are used to.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是**匿名函数**，即不是使用我们习惯的 `fn` 语法定义的函数。
- en: 'They are defined using the `|args| body` syntax, where `args` are the arguments
    and `body` is the function body. `body` can be a block of code or a single expression.
    For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它们使用 `|args| body` 语法定义，其中 `args` 是参数，`body` 是函数体。`body` 可以是一段代码块或单个表达式。例如：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Closures can take more than one argument:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以接受多个参数：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'They can also capture variables from their environment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以捕获它们环境中的变量：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If necessary, you can specify the types of the arguments and/or the return
    type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以指定参数的类型和/或返回类型：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[`collect`](#collect)'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`collect`](#collect)'
- en: What happens when you're done transforming an iterator using combinators?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用组合器完成迭代器的转换后会发生什么？
- en: You either iterate over the transformed values using a `for` loop, or you collect
    them into a collection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for` 循环遍历转换后的值，或者将它们收集到集合中。
- en: The latter is done using the `collect` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是通过 `collect` 方法实现的。
- en: '`collect` consumes the iterator and collects its elements into a collection
    of your choice.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect` 消耗迭代器并将元素收集到你选择的集合中。'
- en: 'For example, you can collect the squares of the even numbers into a `Vec`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将偶数的平方收集到 `Vec` 中：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`collect` is generic over its **return type**.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect` 对其**返回类型**是泛型的。'
- en: 'Therefore you usually need to provide a type hint to help the compiler infer
    the correct type. In the example above, we annotated the type of `squares_of_evens`
    to be `Vec<u32>`. Alternatively, you can use the **turbofish syntax** to specify
    the type:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常你需要提供一个类型提示来帮助编译器推断正确的类型。在上面的例子中，我们注释了 `squares_of_evens` 的类型为 `Vec<u32>`。或者，你也可以使用**尖括号语法**来指定类型：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Further reading](#further-reading)'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading)'
- en: '[`Iterator`''s documentation](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
    gives you an overview of the methods available for iterators in `std`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Iterator` 的文档](https://doc.rust-lang.org/std/iter/trait.Iterator.html) 提供了
    `std` 中迭代器可用方法的概述。'
- en: '[The `itertools` crate](https://docs.rs/itertools/) defines even **more** combinators
    for iterators.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`itertools` crate](https://docs.rs/itertools/) 定义了更多**组合器**用于迭代器。'
- en: '[Exercise](#exercise)'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`06_ticket_management/07_combinators`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/07_combinators)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于 [06_ticket_management/07_combinators](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/07_combinators)

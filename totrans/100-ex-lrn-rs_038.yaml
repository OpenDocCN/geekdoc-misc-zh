- en: Copying values, pt. 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值的复制，第 1 部分
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/11_clone.html](https://rust-exercises.com/100-exercises/04_traits/11_clone.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/04_traits/11_clone.html](https://rust-exercises.com/100-exercises/04_traits/11_clone.html)
- en: In the previous chapter we introduced ownership and borrowing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了所有权和借用。
- en: 'We stated, in particular, that:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别指出：
- en: Every value in Rust has a single owner at any given time.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何给定时间，Rust 中的每个值都有一个单一的所有者。
- en: When a function takes ownership of a value ("it consumes it"), the caller can't
    use that value anymore.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数接受一个值的所有权时（“它消耗了它”），调用者不能再使用该值。
- en: These restrictions can be somewhat limiting.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制可能有些限制性。
- en: Sometimes we might have to call a function that takes ownership of a value,
    but we still need to use that value afterward.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要调用一个接受值所有权的函数，但我们仍然需要在该函数之后使用该值。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's where `Clone` comes in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `Clone` 发挥作用的地方。
- en: '[`Clone`](#clone)'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`Clone` 特性](#clone)'
- en: '`Clone` is a trait defined in Rust''s standard library:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone` 是 Rust 标准库中定义的一个特质：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Its method, `clone`, takes a reference to `self` and returns a new **owned**
    instance of the same type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它的方法 `clone` 接收对 `self` 的引用并返回相同类型的新 **拥有** 实例。
- en: '[In action](#in-action)'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实战](#in-action)'
- en: 'Going back to the example above, we can use `clone` to create a new `String`
    instance before calling `consumer`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到上面的例子，我们可以在调用 `consumer` 之前使用 `clone` 创建一个新的 `String` 实例：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of giving ownership of `s` to `consumer`, we create a new `String` (by
    cloning `s`) and give that to `consumer` instead.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将 `s` 的所有权交给 `consumer`，而是创建一个新的 `String`（通过克隆 `s`）并将其交给 `consumer`。
- en: '`s` remains valid and usable after the call to `consumer`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `consumer` 之后，`s` 仍然有效且可使用。
- en: '[In memory](#in-memory)'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[内存中的情况](#内存中的情况)'
- en: 'Let''s look at what happened in memory in the example above. When `let mut
    s = String::from("hello");` is executed, the memory looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上面例子中内存中发生了什么。当执行 `let mut s = String::from("hello");` 时，内存看起来像这样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When `let t = s.clone()` is executed, a whole new region is allocated on the
    heap to store a copy of the data:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `let t = s.clone()` 时，在堆上分配了一个全新的区域来存储数据的副本：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you're coming from a language like Java, you can think of `clone` as a way
    to create a deep copy of an object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像 Java 这样的语言，你可以将 `clone` 视为创建对象深拷贝的一种方式。
- en: '[Implementing `Clone`](#implementing-clone)'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实现 `Clone` 特性](#实现-clone)'
- en: To make a type `Clone`-able, we have to implement the `Clone` trait for it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使类型 `Clone`-able，我们必须为它实现 `Clone` 特性。
- en: 'You almost always implement `Clone` by deriving it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是通过派生来实现 `Clone`：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The compiler implements `Clone` for `MyType` as you would expect: it clones
    each field of `MyType` individually and then constructs a new `MyType` instance
    using the cloned fields.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器按照预期为 `MyType` 实现 `Clone`：它单独克隆 `MyType` 的每个字段，然后使用克隆的字段构建一个新的 `MyType` 实例。
- en: Remember that you can use `cargo expand` (or your IDE) to explore the code generated
    by `derive` macros.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以使用 `cargo expand`（或你的 IDE）来探索由 `derive` 宏生成的代码。
- en: '[Exercise](#exercise)'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`04_traits/11_clone`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习位于 [`04_traits/11_clone`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone)

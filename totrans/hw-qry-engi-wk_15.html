<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Subqueries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Subqueries</h1>
<blockquote>原文：<a href="https://howqueryengineswork.com/11-subqueries.html">https://howqueryengineswork.com/11-subqueries.html</a></blockquote>
                        
<p>Subqueries are queries nested within other queries. They appear in SELECT lists, FROM clauses, and WHERE clauses. Supporting subqueries requires both parsing them correctly and planning them efficiently.</p>
<h2 id="types-of-subqueries"><a class="header" href="#types-of-subqueries">Types of Subqueries</a></h2>
<h3 id="scalar-subqueries"><a class="header" href="#scalar-subqueries">Scalar Subqueries</a></h3>
<p>A scalar subquery returns a single value and can appear wherever a scalar expression is valid:</p>
<pre><code class="language-sql">SELECT id, name,
       (SELECT AVG(salary) FROM employees) AS avg_salary
FROM employees
</code></pre>
<p>The subquery <code>(SELECT AVG(salary) FROM employees)</code> returns one value that applies to every row. If a scalar subquery returns more than one row, that is an error.</p>
<h3 id="correlated-subqueries"><a class="header" href="#correlated-subqueries">Correlated Subqueries</a></h3>
<p>A correlated subquery references columns from the outer query:</p>
<pre><code class="language-sql">SELECT id, name,
       (SELECT COUNT(*) FROM orders WHERE orders.customer_id = customers.id) AS order_count
FROM customers
</code></pre>
<p>The inner query references <code>customers.id</code> from the outer query. This correlation creates a dependency: conceptually, the inner query runs once per row of the outer query.</p>
<h3 id="uncorrelated-subqueries"><a class="header" href="#uncorrelated-subqueries">Uncorrelated Subqueries</a></h3>
<p>An uncorrelated subquery is self-contained:</p>
<pre><code class="language-sql">SELECT * FROM orders
WHERE total &gt; (SELECT AVG(total) FROM orders WHERE region = 'West')
</code></pre>
<p>The subquery does not reference the outer query, so it can be evaluated once and the result substituted.</p>
<h3 id="exists-and-in-subqueries"><a class="header" href="#exists-and-in-subqueries">EXISTS and IN Subqueries</a></h3>
<p>The <code>EXISTS</code> predicate tests whether a subquery returns any rows:</p>
<pre><code class="language-sql">SELECT id FROM customers
WHERE EXISTS (SELECT 1 FROM orders WHERE orders.customer_id = customers.id)
</code></pre>
<p>This returns customers who have at least one order.</p>
<p>The <code>IN</code> predicate tests membership in a set:</p>
<pre><code class="language-sql">SELECT * FROM products
WHERE category_id IN (SELECT id FROM categories WHERE active = true)
</code></pre>
<p>Both <code>NOT EXISTS</code> and <code>NOT IN</code> provide the negated forms.</p>
<h2 id="planning-subqueries"><a class="header" href="#planning-subqueries">Planning Subqueries</a></h2>
<h3 id="uncorrelated-subqueries-1"><a class="header" href="#uncorrelated-subqueries-1">Uncorrelated Subqueries</a></h3>
<p>Uncorrelated scalar subqueries are straightforward: execute them once during planning (or once at the start of execution) and substitute the result as a literal value.</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE total &gt; (SELECT AVG(total) FROM orders)
</code></pre>
<p>Becomes:</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE total &gt; 42500.00  -- after evaluating subquery
</code></pre>
<h3 id="correlated-subqueries-the-naive-approach"><a class="header" href="#correlated-subqueries-the-naive-approach">Correlated Subqueries: The Naive Approach</a></h3>
<p>A naive implementation executes the correlated subquery once per row of the outer query. For the order count example:</p>
<pre><code class="language-sql">SELECT id, name,
       (SELECT COUNT(*) FROM orders WHERE orders.customer_id = customers.id) AS order_count
FROM customers
</code></pre>
<p>If <code>customers</code> has 100,000 rows, we run 100,000 separate queries against <code>orders</code>. This is extremely slow.</p>
<h3 id="decorrelation-converting-subqueries-to-joins"><a class="header" href="#decorrelation-converting-subqueries-to-joins">Decorrelation: Converting Subqueries to Joins</a></h3>
<p>The solution is decorrelation: rewriting correlated subqueries as joins. The query above becomes:</p>
<pre><code class="language-sql">SELECT c.id, c.name, COALESCE(o.order_count, 0) AS order_count
FROM customers c
LEFT JOIN (
    SELECT customer_id, COUNT(*) AS order_count
    FROM orders
    GROUP BY customer_id
) o ON c.id = o.customer_id
</code></pre>
<p>Now we scan <code>orders</code> once, aggregate, and join, which is much faster.</p>
<h3 id="exists-to-semi-join"><a class="header" href="#exists-to-semi-join">EXISTS to Semi Join</a></h3>
<p>An <code>EXISTS</code> subquery becomes a semi join. A semi join returns rows from the left side where at least one match exists on the right, without duplicating left rows when multiple matches exist.</p>
<pre><code class="language-sql">SELECT id FROM foo WHERE EXISTS (SELECT 1 FROM bar WHERE foo.id = bar.id)
</code></pre>
<p>Becomes:</p>
<pre><code>Projection: foo.id
    LeftSemi Join: foo.id = bar.id
        Scan: foo
        Scan: bar
</code></pre>
<h3 id="not-exists-to-anti-join"><a class="header" href="#not-exists-to-anti-join">NOT EXISTS to Anti Join</a></h3>
<p><code>NOT EXISTS</code> becomes an anti join, which returns rows from the left side where no match exists on the right:</p>
<pre><code class="language-sql">SELECT id FROM foo WHERE NOT EXISTS (SELECT 1 FROM bar WHERE foo.id = bar.id)
</code></pre>
<p>Becomes:</p>
<pre><code>Projection: foo.id
    LeftAnti Join: foo.id = bar.id
        Scan: foo
        Scan: bar
</code></pre>
<h3 id="in-to-semi-join"><a class="header" href="#in-to-semi-join">IN to Semi Join</a></h3>
<p><code>IN</code> subqueries also become semi joins:</p>
<pre><code class="language-sql">SELECT * FROM products WHERE category_id IN (SELECT id FROM categories WHERE active = true)
</code></pre>
<p>Becomes:</p>
<pre><code>LeftSemi Join: products.category_id = categories.id
    Scan: products
    Filter: active = true
        Scan: categories
</code></pre>
<h2 id="implementation-complexity"><a class="header" href="#implementation-complexity">Implementation Complexity</a></h2>
<p>Subquery decorrelation is one of the more complex parts of a query engine. Challenges include:</p>
<p>Identifying correlation: The planner must determine which columns in the subquery reference the outer query.</p>
<p>Choosing the right join type: EXISTS maps to semi join, NOT EXISTS to anti join, scalar subqueries to left outer joins with aggregation.</p>
<p>Handling multiple correlations: A subquery might reference multiple outer tables in a complex query.</p>
<p>Preserving semantics: The rewritten query must produce exactly the same results, including handling of NULLs.</p>
<p>Nested subqueries: Subqueries can contain subqueries, requiring recursive decorrelation.</p>
<p>KQuery does not currently implement subqueries. Production query engines spend significant effort on subquery support since it is essential for SQL compatibility.</p>
<h2 id="when-decorrelation-is-not-possible"><a class="header" href="#when-decorrelation-is-not-possible">When Decorrelation Is Not Possible</a></h2>
<p>Some correlated subqueries cannot be decorrelated into standard joins. These “lateral” or “dependent” subqueries must be evaluated per-row. Modern databases support <code>LATERAL</code> joins for this case:</p>
<pre><code class="language-sql">SELECT c.*, recent_orders.*
FROM customers c,
LATERAL (SELECT * FROM orders WHERE customer_id = c.id ORDER BY date DESC LIMIT 3) recent_orders
</code></pre>
<p>This returns each customer with their three most recent orders. The <code>LIMIT 3</code> depends on which customer we are processing, so it cannot be rewritten as a simple join.</p>
<p>Handling lateral joins requires either per-row evaluation (slow) or specialized operators that combine joining with limiting.</p>
<p><em>This book is also available for purchase in ePub, MOBI, and PDF format from <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a></em></p>
<p><strong>Copyright © 2020-2025 Andy Grove. All rights reserved.</strong></p>

                        
</body>
</html>
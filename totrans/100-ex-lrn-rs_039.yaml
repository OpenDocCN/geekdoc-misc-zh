- en: Copying values, pt. 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制值，第2部分
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/12_copy.html](https://rust-exercises.com/100-exercises/04_traits/12_copy.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://rust-exercises.com/100-exercises/04_traits/12_copy.html](https://rust-exercises.com/100-exercises/04_traits/12_copy.html)
- en: 'Let''s consider the same example as before, but with a slight twist: using
    `u32` rather than `String` as a type.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑与之前相同的例子，但稍作修改：使用`u32`而不是`String`作为类型。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It'll compile without errors! What's going on here? What's the difference between
    `String` and `u32` that makes the latter work without `.clone()`?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它会编译无误！这里发生了什么？`String`和`u32`之间的区别是什么，使得后者在没有`.clone()`的情况下也能工作？
- en: '[`Copy`](#copy)'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`Copy`](#copy)'
- en: '`Copy` is another trait defined in Rust''s standard library:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy`是Rust标准库中定义的另一个特质：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is a marker trait, just like `Sized`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个标记特质，就像`Sized`一样。
- en: 'If a type implements `Copy`, there''s no need to call `.clone()` to create
    a new instance of the type: Rust does it **implicitly** for you.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型实现了`Copy`，则不需要调用`.clone()`来创建该类型的新实例：Rust会为你**隐式地**完成这项工作。
- en: '`u32` is an example of a type that implements `Copy`, which is why the example
    above compiles without errors: when `consumer(s)` is called, Rust creates a new
    `u32` instance by performing a **bitwise copy** of `s`, and then passes that new
    instance to `consumer`. It all happens behind the scenes, without you having to
    do anything.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`u32`是实现`Copy`的类型的例子，这就是为什么上面的例子可以编译无误：当调用`consumer(s)`时，Rust通过执行`s`的位复制来创建一个新的`u32`实例，然后将这个新实例传递给`consumer`。这一切都是在幕后发生的，你不需要做任何事情。'
- en: '[What can be `Copy`?](#what-can-be-copy)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[什么可以是`Copy`？](#what-can-be-copy)'
- en: '`Copy` is not equivalent to "automatic cloning", although it implies it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy`不等同于“自动克隆”，尽管它暗示了这一点。'
- en: Types must meet a few requirements in order to be allowed to implement `Copy`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类型必须满足一些要求才能允许实现`Copy`。
- en: 'First of all, it must implement `Clone`, since `Copy` is a subtrait of `Clone`.
    This makes sense: if Rust can create a new instance of a type *implicitly*, it
    should also be able to create a new instance *explicitly* by calling `.clone()`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它必须实现`Clone`，因为`Copy`是`Clone`的子特质。这很有道理：如果Rust可以隐式地创建一个类型的新实例，那么它也应该能够通过调用`.clone()`来显式地创建一个新实例。
- en: 'That''s not all, though. A few more conditions must be met:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有更多条件必须满足：
- en: The type doesn't manage any *additional* resources (e.g. heap memory, file handles,
    etc.) beyond the `std::mem::size_of` bytes that it occupies in memory.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类型不管理任何**额外**资源（例如堆内存、文件句柄等），除了它占用的内存中的`std::mem::size_of`字节。
- en: The type is not a mutable reference (`&mut T`).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类型不是可变引用（`&mut T`）。
- en: If both conditions are met, then Rust can safely create a new instance of the
    type by performing a **bitwise copy** of the original instance—this is often referred
    to as a `memcpy` operation, after the C standard library function that performs
    the bitwise copy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足这两个条件，那么Rust可以通过执行原始实例的**位复制**来安全地创建该类型的新实例——这通常被称为`memcpy`操作，这个名字来源于执行位复制的C标准库函数。
- en: '[Case study 1: `String`](#case-study-1-string)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[案例研究 1：`String`](#case-study-1-string)'
- en: '`String` is a type that doesn''t implement `Copy`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`是一个没有实现`Copy`的类型。'
- en: 'Why? Because it manages an additional resource: the heap-allocated memory buffer
    that stores the string''s data.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为它管理了一个额外的资源：存储字符串数据的堆分配内存缓冲区。
- en: Let's imagine that Rust allowed `String` to implement `Copy`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设Rust允许`String`实现`Copy`。
- en: 'Then, when a new `String` instance is created by performing a bitwise copy
    of the original instance, both the original and the new instance would point to
    the same memory buffer:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当通过执行原始实例的位复制来创建新的`String`实例时，原始实例和新实例都会指向同一个内存缓冲区：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is bad! Both `String` instances would try to free the memory buffer when
    they go out of scope, leading to a double-free error. You could also create two
    distinct `&mut String` references that point to the same memory buffer, violating
    Rust's borrowing rules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这很糟糕！当这两个`String`实例超出作用域时，它们都会尝试释放内存缓冲区，导致双重释放错误。你也可以创建两个指向同一内存缓冲区的不同`&mut String`引用，违反Rust的借用规则。
- en: '[Case study 2: `u32`](#case-study-2-u32)'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[案例研究 2：`u32`](#case-study-2-u32)'
- en: '`u32` implements `Copy`. All integer types do, in fact.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`u32`实现了`Copy`。实际上，所有整数类型都实现了。'
- en: An integer is "just" the bytes that represent the number in memory. There's
    nothing more! If you copy those bytes, you get another perfectly valid integer
    instance. Nothing bad can happen, so Rust allows it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 整数“只是”内存中表示数字的字节。没有更多！如果你复制这些字节，你会得到另一个完全有效的整数实例。不会发生任何坏事，所以Rust允许这样做。
- en: '[Case study 3: `&mut u32`](#case-study-3-mut-u32)'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[案例研究 3: `&mut u32`](#case-study-3-mut-u32)'
- en: 'When we introduced ownership and mutable borrows, we stated one rule quite
    clearly: there can only ever be *one* mutable borrow of a value at any given time.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍所有权和可变借用时，我们明确地提出了一条规则：在任何给定时间，一个值只能有一个可变借用。
- en: That's why `&mut u32` doesn't implement `Copy`, even though `u32` does.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，`&mut u32`不实现`Copy`，尽管`u32`实现了。
- en: If `&mut u32` implemented `Copy`, you could create multiple mutable references
    to the same value and modify it in multiple places at the same time. That'd be
    a violation of Rust's borrowing rules! It follows that `&mut T` never implements
    `Copy`, no matter what `T` is.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`&mut u32`实现了`Copy`，你就可以创建多个对同一值的可变引用，并在多个地方同时修改它。这将违反Rust的借用规则！因此，无论`T`是什么，`&mut
    T`永远不会实现`Copy`。
- en: '[Implementing `Copy`](#implementing-copy)'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实现`Copy`](#implementing-copy)'
- en: 'In most cases, you don''t need to manually implement `Copy`. You can just derive
    it, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要手动实现`Copy`。你可以直接推导它，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Exercise](#exercise)'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: The exercise for this section is located in [`04_traits/12_copy`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习位于[`04_traits/12_copy`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy)

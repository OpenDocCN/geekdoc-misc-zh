<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Query Optimizations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Query Optimizations</h1>
<blockquote>原文：<a href="https://howqueryengineswork.com/12-optimizations.html">https://howqueryengineswork.com/12-optimizations.html</a></blockquote>
                        
<p><em>The source code discussed in this chapter can be found in the <code>optimizer</code> module of the <a href="https://github.com/andygrove/how-query-engines-work">KQuery project</a>.</em></p>
<p>A query engine that executes plans exactly as written will produce correct results but may be slow. Users writing SQL or DataFrame queries naturally express what they want, not how to compute it efficiently. The optimizer transforms logical plans into equivalent but faster plans.</p>
<h2 id="why-optimize"><a class="header" href="#why-optimize">Why Optimize?</a></h2>
<p>Consider a query that joins two tables and then filters:</p>
<pre><code class="language-sql">SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.id
WHERE e.state = 'CO'
</code></pre>
<p>Executing this literally means: join all employees with all departments, then filter to Colorado. If there are 100,000 employees and only 5,000 in Colorado, we do 95,000 unnecessary join lookups.</p>
<p>An optimizer recognizes that the filter on <code>state</code> only touches the <code>employees</code> table and can be applied before the join:</p>
<pre><code>Before optimization:
  Filter: state = 'CO'
    Join: e.dept_id = d.id
      Scan: employees
      Scan: departments

After optimization:
  Join: e.dept_id = d.id
    Filter: state = 'CO'
      Scan: employees
    Scan: departments
</code></pre>
<p>Now we join only 5,000 employees instead of 100,000. This produces the same result but is much faster.</p>
<h2 id="rule-based-optimization"><a class="header" href="#rule-based-optimization">Rule-Based Optimization</a></h2>
<p>KQuery uses rule-based optimization: a set of transformation rules that each improve the plan in some way. Rules are applied in sequence, each taking a logical plan and returning a (hopefully better) logical plan.</p>
<pre><code class="language-kotlin">interface OptimizerRule {
    fun optimize(plan: LogicalPlan): LogicalPlan
}

class Optimizer {
    fun optimize(plan: LogicalPlan): LogicalPlan {
        var result = plan
        result = ProjectionPushDownRule().optimize(result)
        // Additional rules would be applied here
        return result
    }
}
</code></pre>
<p>Rules work by walking the plan tree and rebuilding it with modifications. This functional approach (build a new tree rather than mutate the old one) is simpler and less error-prone.</p>
<h2 id="projection-push-down"><a class="header" href="#projection-push-down">Projection Push-Down</a></h2>
<p>Projection push-down reduces memory usage by reading only the columns that the query actually uses. If a table has 50 columns but the query only references 3, we should read only those 3.</p>
<p>The rule works by:</p>
<ol>
<li>Walking the plan top-down, collecting column names referenced in each operator</li>
<li>When reaching a Scan, replacing it with a Scan that projects only the needed columns</li>
</ol>
<p>First, we need a helper to extract column references from expressions:</p>
<pre><code class="language-kotlin">fun extractColumns(expr: LogicalExpr, input: LogicalPlan, accum: MutableSet&lt;String&gt;) {
    when (expr) {
        is Column -&gt; accum.add(expr.name)
        is ColumnIndex -&gt; accum.add(input.schema().fields[expr.i].name)
        is BinaryExpr -&gt; {
            extractColumns(expr.l, input, accum)
            extractColumns(expr.r, input, accum)
        }
        is Alias -&gt; extractColumns(expr.expr, input, accum)
        is CastExpr -&gt; extractColumns(expr.expr, input, accum)
        is LiteralString, is LiteralLong, is LiteralDouble -&gt; { }
        else -&gt; throw IllegalStateException("Unsupported: $expr")
    }
}
</code></pre>
<p>Then the rule itself:</p>
<pre><code class="language-kotlin">class ProjectionPushDownRule : OptimizerRule {

    override fun optimize(plan: LogicalPlan): LogicalPlan {
        return pushDown(plan, mutableSetOf())
    }

    private fun pushDown(plan: LogicalPlan, columnNames: MutableSet&lt;String&gt;): LogicalPlan {
        return when (plan) {
            is Projection -&gt; {
                extractColumns(plan.expr, plan.input, columnNames)
                val input = pushDown(plan.input, columnNames)
                Projection(input, plan.expr)
            }
            is Selection -&gt; {
                extractColumns(plan.expr, plan.input, columnNames)
                val input = pushDown(plan.input, columnNames)
                Selection(input, plan.expr)
            }
            is Aggregate -&gt; {
                extractColumns(plan.groupExpr, plan.input, columnNames)
                extractColumns(plan.aggregateExpr.map { it.expr }, plan.input, columnNames)
                val input = pushDown(plan.input, columnNames)
                Aggregate(input, plan.groupExpr, plan.aggregateExpr)
            }
            is Scan -&gt; {
                val validFields = plan.dataSource.schema().fields.map { it.name }.toSet()
                val projection = validFields.filter { columnNames.contains(it) }.sorted()
                Scan(plan.path, plan.dataSource, projection)
            }
            else -&gt; throw IllegalStateException("Unsupported: $plan")
        }
    }
}
</code></pre>
<p>Given this plan:</p>
<pre><code>Projection: #id, #first_name, #last_name
    Filter: #state = 'CO'
        Scan: employee; projection=None
</code></pre>
<p>The optimizer produces:</p>
<pre><code>Projection: #id, #first_name, #last_name
    Filter: #state = 'CO'
        Scan: employee; projection=[first_name, id, last_name, state]
</code></pre>
<p>The Scan now reads only four columns instead of all columns in the table. For columnar formats like Parquet, this dramatically reduces I/O.</p>
<h2 id="predicate-push-down"><a class="header" href="#predicate-push-down">Predicate Push-Down</a></h2>
<p>Predicate push-down moves filters closer to the data source, reducing the number of rows processed by later operators.</p>
<p>Consider:</p>
<pre><code>Projection: #dept_name, #first_name, #last_name
    Filter: #state = 'CO'
        Join: #employee.dept_id = #dept.id
            Scan: employee
            Scan: dept
</code></pre>
<p>The filter references only <code>employee</code> columns, so it can move below the join:</p>
<pre><code>Projection: #dept_name, #first_name, #last_name
    Join: #employee.dept_id = #dept.id
        Filter: #state = 'CO'
            Scan: employee
        Scan: dept
</code></pre>
<p>Now the join processes fewer rows. This optimization becomes more important with larger tables and more selective predicates.</p>
<p>The implementation must analyze which tables each predicate references and only push predicates that reference a single table below joins. Predicates referencing both sides of a join cannot be pushed below it.</p>
<p>KQuery does not currently implement predicate push-down, but the pattern is similar to projection push-down: walk the tree, identify opportunities, rebuild with filters moved down.</p>
<h2 id="eliminate-common-subexpressions"><a class="header" href="#eliminate-common-subexpressions">Eliminate Common Subexpressions</a></h2>
<p>When the same expression appears multiple times, we can compute it once and reuse the result:</p>
<pre><code class="language-sql">SELECT sum(price * qty) AS total_price,
       sum(price * qty * tax_rate) AS total_tax
FROM sales
</code></pre>
<p>The expression <code>price * qty</code> appears in both aggregates. Rather than compute it twice per row, we can add an intermediate projection:</p>
<p>Original:</p>
<pre><code>Aggregate: sum(#price * #qty), sum(#price * #qty * #tax_rate)
    Scan: sales
</code></pre>
<p>Optimized:</p>
<pre><code>Aggregate: sum(#subtotal), sum(#subtotal * #tax_rate)
    Projection: #price * #qty AS subtotal, #tax_rate
        Scan: sales
</code></pre>
<p>This trades one multiplication per row (in the projection) against two multiplications per row (in the original aggregates). For large datasets, this adds up.</p>
<p>KQuery does not implement this optimization, but the approach involves:</p>
<ol>
<li>Finding expressions that appear multiple times</li>
<li>Creating a projection that computes them once with generated names</li>
<li>Rewriting later operators to reference the computed columns</li>
</ol>
<h2 id="cost-based-optimization"><a class="header" href="#cost-based-optimization">Cost-Based Optimization</a></h2>
<p>Rule-based optimization applies transformations unconditionally. Cost-based optimization estimates the cost of different plans and chooses the cheapest.</p>
<p>Consider join ordering. For three tables A, B, C:</p>
<ul>
<li>(A JOIN B) JOIN C</li>
<li>(A JOIN C) JOIN B</li>
<li>(B JOIN C) JOIN A</li>
</ul>
<p>All produce the same result, but performance varies dramatically based on table sizes and join selectivity. If A has 1 million rows, B has 100 rows, and C has 10,000 rows, joining B and C first (100 × 10,000 = 1 million intermediate rows at most) then joining A is likely faster than starting with A.</p>
<p>Cost-based optimizers need statistics:</p>
<ul>
<li>Table row counts</li>
<li>Column cardinality (number of distinct values)</li>
<li>Value distributions (histograms)</li>
<li>Min/max values per column</li>
</ul>
<p>With statistics, the optimizer can estimate:</p>
<ul>
<li>How many rows a filter will produce (selectivity)</li>
<li>How many rows a join will produce</li>
<li>Memory requirements for hash tables</li>
</ul>
<p>The optimizer generates candidate plans, estimates cost for each, and picks the cheapest.</p>
<h3 id="the-statistics-challenge"><a class="header" href="#the-statistics-challenge">The Statistics Challenge</a></h3>
<p>Cost-based optimization sounds great but has practical challenges:</p>
<p>Gathering statistics is expensive. Scanning terabytes of data to build histograms takes time. For ad-hoc queries, this overhead may exceed the optimization benefit.</p>
<p>Statistics become stale. As data changes, statistics drift from reality. Stale statistics lead to bad plans.</p>
<p>Estimation errors compound. Each estimate has error. In a complex plan with many operators, errors multiply, potentially leading to catastrophically bad plans.</p>
<p>Some formats provide partial statistics. Parquet and ORC files include min/max values and row counts per column chunk. This helps but is not enough for accurate cardinality estimation.</p>
<p>KQuery uses only rule-based optimization. Production systems like Spark, Presto, and traditional databases invest heavily in cost-based optimization, but it remains an area of active research and engineering.</p>
<h2 id="other-optimizations"><a class="header" href="#other-optimizations">Other Optimizations</a></h2>
<p>Query engines implement many other optimizations:</p>
<p>Constant folding: Evaluate constant expressions at planning time. <code>WHERE date &gt; '2024-01-01' AND 1 = 1</code> becomes <code>WHERE date &gt; '2024-01-01'</code>.</p>
<p>Dead column elimination: Remove columns from intermediate results when they are not needed downstream.</p>
<p>Join reordering: Choose the order of joins to minimize intermediate result sizes.</p>
<p>Limit push-down: Push LIMIT operators down to reduce work. If we only need 10 rows, stop early.</p>
<p>Partition pruning: Skip reading partitions that cannot contain matching data based on partition keys.</p>
<p>The right set of optimizations depends on the workload and data characteristics. Simple rule-based optimizations provide significant benefits with minimal complexity.</p>
<p><em>This book is also available for purchase in ePub, MOBI, and PDF format from <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a></em></p>
<p><strong>Copyright © 2020-2025 Andy Grove. All rights reserved.</strong></p>

                        
</body>
</html>
<html><head></head><body>
<h1 class="c29" id="h.z0lyikp7m3g"><span class="c4"/></h1><h1 class="c30" id="h.1p761zpi1hq7"><span class="c4">Evaluating Arithmetic</span></h1><h2 class="c23" id="h.pwumq0yryyjt"><span class="c4">Defining the Evaluator</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Having seen how to represent arithmetic programs, we turn to writing an evaluator program that turns them into answers.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">What is the type of this evaluator? Clearly it consumes programs, which here are represented by </span><code>Exp</code><span class="calibre3">s. What does it produce? In this case, all these expressions are going to produce numbers. For this reason, we’ll call this a calculator, or </span><code>calc</code><span class="calibre3"> for short, for now. We can thus give </span><code>calc</code><span class="c4"> the type</span></p><p class="c3"><span class="c4"/></p><pre>(calc : (Exp -&gt; Number))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Let’s now try to define its body. Clearly we must have</span></p><p class="c3"><span class="c4"/></p><pre>(define (calc e)
  …)</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">In the body, given an Exp, we will want to take it apart using type-case, which tells us there are two options, each with some additional data (this is the moral equivalent of the method dispatch we’d have used in Java):</span></p><p class="c3"><span class="c4"/></p><pre>  (type-case Exp e
    [(num n) …]
    [(plus l r) …])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">What happens in the case that the whole expression is already a number? Well, we have our answer, so we just return it. Otherwise, we have to add the two sides:</span></p><p class="c3"><span class="c4"/></p><pre>  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ l r)])</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">giving us an overall body of:</span></p><p class="c3"><span class="c4"/></p><pre>(define (calc e)
  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ l r)]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Let’s run it to…oops! We get a type error! It tells us that addition is expecting a number, but </span><code>l</code><span class="calibre3"> is not a number: it’s an </span><code>Exp</code><span class="calibre3">. Ah, that’s because </span><code>l</code><span class="calibre3"> and </span><code>r</code><span class="calibre3"> still represent </span><span class="c7">expressions</span><span class="calibre3">, not the </span><span class="c7">answer</span><span class="c4"> that the expressions evaluate to. To fix that, we need something that can turn an expression into a number…which is precisely what we’re defining! Thus, we instead write</span></p><p class="c3"><span class="c4"/></p><pre>(define (calc e)
  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ (calc l) (calc r))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The type-checker is happy now. And sure enough, we can confirm that our examples produce what we expect. For instance:</span></p><p class="c3"><span class="c4"/></p><pre>(calc (num 1))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">produces </span><code>1</code><span class="c4">,</span></p><p class="c3"><span class="c4"/></p><pre>(calc (plus (num 1) (num 2))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">produces </span><code>3</code><span class="c4">, and</span></p><p class="c3"><span class="c4"/></p><pre>(plus (num 1)
      (plus (num 2) (num 3)))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">produces</span><code> 6</code><span class="c4">.</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Aside:</span><span class="calibre3"> We’ve glossed over a detail: we’ve assumed that </span><code>+</code><span class="calibre3"> always means numeric addition (which was already implicit in calling it “</span><code>plus</code><span class="c4">” in the AST). But some languages allow any number of different types to be “added”: e.g., it can also concatenate strings. In such languages, the name in the AST might be something more generic, and the evaluator would need to handle the different possible behaviors.</span></p><p class="c51"><span class="c4"/></p><p class="c31"><span class="calibre3">In fact, we’ve glossed over something even more basic: what numeric addition means, or for that matter, even what numbers are. As we see from the Mystery Language: Arithmetic, there are many choices here. In our calculator, we have adopted numbers from plait (in </span><code>num</code><span class="calibre3">) and addition from plait (by using </span><code>+</code><span class="calibre3">). Those places in </span><code>calc</code><span class="c4"> also tell us where we would go to change those choices.</span></p></body></html>
<html><head></head><body>
<h2 class="c27" id="h.9c5xeccscifs"><span class="c4">Updating the Evaluator</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Now suppose we try to use our existing code:</span></p><p class="c3"><span class="c4"/></p><pre>[(plusE l r) (+ (calc l) (calc r))]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">This has two problems. The first is we can’t return a number; we have to return a </span><code>numV</code><span class="c4">:</span></p><p class="c3"><span class="c4"/></p><pre>[(plusE l r) (numV (+ (calc l) (calc r)))]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">But now we run into a subtler problem. The type-checker is not happy with this program. Why?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Because the result of </span><code>calc</code><span class="calibre3"> is a </span><code>Value</code><span class="calibre3">, and </span><code>+</code><span class="calibre3"> consumes only </span><code>Number</code><span class="calibre3">s. Indeed, the type checker is forcing us to </span><span class="c7">make a decision</span><span class="calibre3"> here: what happens if one of the sides of </span><code>+</code><span class="c4"> does not evaluate to a number?</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">First, let’s build an abstraction to handle this, so that we can keep the core of the interpreter relatively clean:</span></p><p class="c3"><span class="c4"/></p><pre>[(plusE l r) (add (calc l) (calc r))]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Now we can defer all the logic of evaluating </span><code>+</code><span class="calibre3"> to </span><code>add</code><span class="calibre3">. </span><span class="c7">Now we have to make a semantic decision</span><span class="c4">. Should we be allowed to “add” two Boolean values? What about adding a number to a Boolean or vice versa? Though there isn’t quite a SMoL decision here—some languages are very strict while others are very permissive—the least-non-standard policy is to require both branches to evaluate to numbers, which we would express as follows:</span></p><p class="c3"><span class="c4"/></p><pre>(define (add v1 v2)
  (type-case Value v1
    [(numV n1)
     (type-case Value v2
       [(numV n2) (numV (+ n1 n2))]
       [else (error '+ "expects RHS to be a number")])]
    [else (error '+ "expects LHS to be a number")]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that these </span><code>else</code><span class="c4"> clauses can easily represent other decisions. We can embed an entire family of mystery languages in the different choices available!</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Exercise:</span><span class="calibre3"> Why did we write the numV constructor in </span><code>add</code><span class="calibre3"> rather than in </span><code>calc</code><span class="c4">?</span></p><p class="c3"><span class="c4"/></p><p class="c31"><span class="c40">Pro Tip:</span><span class="c4"> You’ve just added a complex chunk of code. Now would be a very good time to test your evaluator. Here are two things to consider:</span></p><p class="c51"><span class="c4"/></p><ol class="c62" start="1"><li class="pcalibre8 c63"><span class="calibre3">Right now the code for conditionals </span><span class="c7">also</span><span class="calibre3"> does not type-check. You may find it convenient to replace the entire RHS with something semantically incorrect but type-correct, like </span><code>(numV 0)</code><span class="c4">, so you restore your working evaluator.<br class="calibre"/></span></li><li class="pcalibre8 c63"><span class="calibre3">Don’t forget to test for the error cases! You would do so using </span><code>test/exn</code><span class="calibre3">. For instance:<br class="calibre"/><br class="calibre"/></span><code>(test/exn (calc (plusE (numE 4) (boolE #false))) "RHS")</code></li></ol><p class="c51"><span class="c4"/></p><p class="c5"><span class="c4">Let’s now turn our attention to the conditional (with the constructor name updated):</span></p><p class="c3"><span class="c4"/></p><pre>[(cndE c t e) …]</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">The core logic must clearly be similar: check something about the condition, and based on it, evaluate only one of the other two clauses. Once again, we have to make decisions about how we handle the conditional: should we strictly require a Boolean value, or should we make a truthy/falsy decision? We can again defer that to a helper function:</span></p><p class="c3"><span class="c4"/></p><pre>    [(cndE c t e) (if (boolean-decision (calc c))
                      (calc t)
                      (calc e))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">Again, the least non-standard policy, and one that sets up later material, is to be strict about requiring a Boolean:</span></p><p class="c3"><span class="c4"/></p><pre>(define (boolean-decision v)
  (type-case Value v
    [(boolV b) b]
    [else (error 'if "expects conditional to evaluate to a boolean")]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">But again, starting from a strict interpretation, we can see where we can give in to any urges we feel to design a more liberal semantics: by replacing the </span><code>else</code><span class="c4"> clause.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe, by the way, that we did something different with conditionals than we did for addition. With </span><code>add</code><span class="calibre3">, we evaluated both branches and gave it their corresponding </span><code>Value</code><span class="calibre3">s. It would be a terrible idea to do that with conditionals, because the entire point of a conditional is to </span><span class="c40">not</span><span class="calibre3"> evaluate one of the branches! We could have sent the ASTs for the branches to a helper function, but what we have done above also works well: it localizes the </span><span class="c7">variation</span><span class="c4"> in the semantics to the helper function, but keeps what is not expected to change (the fact that a conditional syntax leads to a conditional evaluation) in the core of the evaluator.</span></p></body></html>
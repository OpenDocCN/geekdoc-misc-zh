- en: Why a Third Edition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the past several years, a significant part of [my research](https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/&sa=D&source=editors&ust=1695232021062166&usg=AOvVaw1RZYx27xWDC--rnWjNoVEQ) examines
    how students understand programming languages at many different levels. What I
    have learned has convinced me that we need a new approach to teaching this material.
    This edition is a first iteration to that end. (It was also a chance to rewrite
    the prose in my current “voice”, which has evolved a lot over two decades. Virtually
    no text is in common with the first edition, and only some with the second.)
  prefs: []
  type: TYPE_NORMAL
- en: We also live in a world of unprecedented linguistic diversity and novelty. It
    seems like every few weeks I learn about someone trying some new linguistic experiment.
    The wide availability of robust and interesting run-time systems—as diverse as
    Erlang’s, the Java Virtual Machine, the browser’s JavaScript, Racket’s, and more—makes
    it easy to get a working prototype “with batteries” and focus on novelty. This
    affects both people trying to learn new languages and those trying to build them.
  prefs: []
  type: TYPE_NORMAL
- en: Relatedly, the first edition took a very “classical” look at programming languages,
    shaped by my own formal training in the subject. The second edition started to
    migrate from it, but not entirely. The third edition has mostly broken free of
    those constraints, reflecting more of the current linguistic landscape. There
    are not many books that cover topics like “scripting” and “gradual typing” without
    reducing them to slogans and fluff; this book tries to cover them in more rigorous
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: But all this diversity brings up the important challenge of how to approach
    it. In other disciplines, we approach new objects by decomposing them into familiar
    constituent elements. Their commonalities provide an anchor, and a point of departure
    for what makes them novel. What are those elements for programming languages?
    Pedagogic tradition holds that “paradigms” are one such organizational medium,
    but I find them a moribund legacy of a period when computing wanted to be viewed
    as a “science” and felt the best way to do this was to put things in labeled boxes.
    But programming languages are artificial, not natural, entities, and nothing prevents
    designers from freely mixing between the boxes—as indeed many have. When virtually
    everything is “multiparadigm”, how can we make sense out of the world?
  prefs: []
  type: TYPE_NORMAL

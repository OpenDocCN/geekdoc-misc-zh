<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Enum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Enum</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/enum.html">https://freddiehaddad.github.io/fast-track-to-rust/enum.html</a></blockquote>
                        
<p>An <em><a href="https://doc.rust-lang.org/reference/items/enumerations.html">enumeration</a></em>, commonly known as an <em><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">enum</a></em>, is declared using the keyword
<code>enum</code>. Compared to other languges, enums in Rust offer greater flexibility and
power. For instance, they support generics (as seen with the <code>Option</code> <code>enum</code>)
and can encapsulate values within their variants! <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<h2 id="using-an-enum-for-errors"><a class="header" href="#using-an-enum-for-errors">Using an <code>enum</code> for Errors</a></h2>
<p>For our rustle program, we'll create an <code>enum</code> to represent possible errors
during <code>Interval</code> operations. For example, when a user creates an <code>Interval</code>,
the starting value must be less than or equal to the ending value. Additionally,
if a user wants to merge two intervals, they must overlap. If these conditions
aren't met, we'll return an error (<code>Err</code>) using one of our <code>enum</code> variants.</p>
<h2 id="defining-an-enum"><a class="header" href="#defining-an-enum">Defining an <code>enum</code></a></h2>
<p>Below is the <code>IntervalError</code> <code>enum</code>, which lists the errors that we may need to
return:</p>
<pre><code class="language-rust noplayground">enum IntervalError {
    StartEndRangeInvalid,
    NonOverlappingInterval,
}</code></pre>
<h2 id="updating-our-interval"><a class="header" href="#updating-our-interval">Updating our Interval</a></h2>
<p>First, we'll change the return type for the function <code>new</code> and the method
<code>merge</code> to a <code>Result</code> with the <code>Ok</code> variant being an <code>Interval</code> and the <code>Err</code>
variant the appropriate <code>IntervalError</code>:</p>
<pre><code class="language-rust noplayground">fn new(start: usize, end: usize) -&gt; Result&lt;Self, IntervalError&gt; {
    if start &lt;= end {
        Ok(Self { start, end })
    } else {
        Err(IntervalError::StartEndRangeInvalid)
    }
}</code></pre>
<pre><code class="language-rust noplayground">fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
    if self.overlaps(other) {
        Ok(Self {
            start: self.start,
            end: other.end,
        })
    } else {
        Err(IntervalError::NonOverlappingInterval)
    }
}</code></pre>
<blockquote>
<p>Observe how an <code>Interval</code> is created in <code>new</code> as opposed to <code>merge</code>. Since the
parameter names in new precisely match the fields in the <code>Interval</code> <code>struct</code>
definition, you can omit the field specifiers. This technique is referred to
as <em>field init shorthand</em> syntax. <sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup></p>
</blockquote>
<h2 id="updating-rustle"><a class="header" href="#updating-rustle">Updating Rustle</a></h2>
<p>With the <code>Interval</code> changes implemented, we need to update the
<code>create_intervals</code> and <code>merge_intervals</code> functions to accommodate the <code>Result</code>
return type.</p>
<pre><code class="language-rust noplayground">fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}</code></pre>
<p>In <code>create_intervals</code>, the only change was the return type, which changed from
<code>Vec&lt;Interval&gt;</code> to <code>Result&lt;Vec&lt;Interval&gt;, IntervalError&gt;</code>. You might wonder why
this works. The concise answer is that the <code>Result</code> type implements the
<a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> trait.</p>
<p>Imagine an intermediary collection of <code>Result</code> values created from calls to
<code>Interval::new(start, end)</code>. The <code>FromIterator</code> trait implementation allows an
iterator over <code>Result</code> values to be collected <em>into</em> a <code>Result</code> containing a
collection of the underlying values or an <code>Err</code>. <sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup> In other words, the value
contained in the <code>Result</code> returned by <code>Interval::new(start, end)</code> is stored in
the <code>Vec&lt;Interval&gt;</code> collection which is then wrapped in a <code>Result</code>.</p>
<blockquote>
<p>We'll be exploring traits in the next section.</p>
</blockquote>
<pre><code class="language-rust noplayground">fn merge_intervals(intervals: Vec&lt;Interval&gt;) -&gt; Vec&lt;Interval&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).or(Err((p, c))))
        .collect()
}</code></pre>
<p>In <code>merge_intervals</code>, the only change required is to the closure used in
<code>coalesce</code>. We attempt to merge two intervals and invoke the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.or"><code>or</code></a> method of
<code>Result</code>. If the merge is successful, returning <code>Ok</code>, the value is passed back
to <code>coalesce</code>. Otherwise, the <code>Err((p, c))</code> value provided to <code>or</code> is returned.</p>
<blockquote>
<p><code>Result</code> methods like <code>map_err</code>, <code>or</code>, and <code>or_else</code> are often used in error
handling because they allow benign errors to be managed while letting
successful results pass through. Since the <code>merge</code> method only merges
overlapping intervals, we replace the <code>Err</code> variant it returns with the tuple
<code>(p, c)</code> needed by <code>coalesce</code>.</p>
</blockquote>
<blockquote>
<p>Eager vs Lazy Evaluation</p>
<p>Depending on the use case, different <code>Result</code> methods may be more efficient.
It's important to read the documentation to determine the best choice. For
example, arguments passed to <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.or"><code>or</code></a> are eagerly evaluated. If you're passing
the result of a function call, it's better to use <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else"><code>or_else</code></a>, which is lazily
evaluated.</p>
</blockquote>
<p>The final change required is in <code>main</code>. Since <code>create_intervals</code> now returns a
<code>Result</code>, we use a <code>match</code> expression to check if the operation was successful.
In the case of an <code>Err</code>, since it's unrecoverable, we print an error message and
exit.</p>
<pre><code class="language-rust noplayground">// create intervals of the form [a,b] with the before/after context
let intervals =
    match create_intervals(match_lines, before_context, after_context) {
        Ok(intervals) =&gt; intervals,
        Err(_) =&gt; {
            eprintln!("An error occurred while creating intervals");
            exit(1);
        }
    };</code></pre>
<h1 id="updating-rustle-1"><a class="header" href="#updating-rustle-1">Updating Rustle</a></h1>
<p>With our changes in place, our Interval now supports error handling via <code>Result</code>
and our rustle program properly handles any errors.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused_imports)]
</span><span class="boring">extern crate regex; // this is needed for the playground
</span><span class="boring">use itertools::Itertools;
</span><span class="boring">use regex::Regex;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::io::{BufRead, BufReader};
</span><span class="boring">use std::process::exit;
</span><span class="boring">
</span><span class="boring">fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
</span><span class="boring">    lines
</span><span class="boring">        .iter()
</span><span class="boring">        .enumerate()
</span><span class="boring">        .filter_map(|(i, line)| match regex.is_match(line) {
</span><span class="boring">            true =&gt; Some(i),
</span><span class="boring">            false =&gt; None,
</span><span class="boring">        })
</span><span class="boring">        .collect() // turns anything iterable into a collection
</span><span class="boring">}
</span><span class="boring">
</span>fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&gt;) -&gt; Vec&lt;Interval&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).or(Err((p, c))))
        .collect()
}

<span class="boring">fn print_results(intervals: Vec&lt;Interval&gt;, lines: Vec&lt;String&gt;) {
</span><span class="boring">    for interval in intervals {
</span><span class="boring">        for (line_no, line) in lines
</span><span class="boring">            .iter()
</span><span class="boring">            .enumerate()
</span><span class="boring">            .take(interval.end + 1)
</span><span class="boring">            .skip(interval.start)
</span><span class="boring">        {
</span><span class="boring">            println!("{}: {}", line_no + 1, line)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
</span><span class="boring">    BufReader::new(file).lines().map_while(Result::ok).collect()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
<span class="boring">    let poem = "I have a little shadow that goes in and out with me,
</span><span class="boring">                And what can be the use of him is more than I can see.
</span><span class="boring">                He is very, very like me from the heels up to the head;
</span><span class="boring">                And I see him jump before me, when I jump into my bed.
</span><span class="boring">
</span><span class="boring">                The funniest thing about him is the way he likes to grow -
</span><span class="boring">                Not at all like proper children, which is always very slow;
</span><span class="boring">                For he sometimes shoots up taller like an india-rubber ball,
</span><span class="boring">                And he sometimes gets so little that there's none of him at all.";
</span><span class="boring">
</span><span class="boring">    let mock_file = std::io::Cursor::new(poem);
</span><span class="boring">
</span><span class="boring">    // command line arguments
</span><span class="boring">    let pattern = "(all)|(little)";
</span><span class="boring">    let before_context = 1;
</span><span class="boring">    let after_context = 1;
</span><span class="boring">
</span><span class="boring">    // attempt to open the file
</span><span class="boring">    let lines = read_file(mock_file);
</span><span class="boring">    //let lines = match File::open(filename) {
</span><span class="boring">    //    // convert the poem into lines
</span><span class="boring">    //    Ok(file) =&gt; read_file(file),
</span><span class="boring">    //    Err(e) =&gt; {
</span><span class="boring">    //        eprintln!("Error opening {filename}: {e}");
</span><span class="boring">    //        exit(1);
</span><span class="boring">    //    }
</span><span class="boring">    //};
</span><span class="boring">
</span><span class="boring">    // compile the regular expression
</span><span class="boring">    let regex = match Regex::new(pattern) {
</span><span class="boring">        Ok(re) =&gt; re, // bind re to regex
</span><span class="boring">        Err(e) =&gt; {
</span><span class="boring">            eprintln!("{e}"); // write to standard error
</span><span class="boring">            exit(1);
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    // store the 0-based line number for any matched line
</span><span class="boring">    let match_lines = find_matching_lines(&amp;lines, regex);
</span><span class="boring">
</span>    // create intervals of the form [a,b] with the before/after context
    let intervals =
        match create_intervals(match_lines, before_context, after_context) {
            Ok(intervals) =&gt; intervals,
            Err(_) =&gt; {
                eprintln!("An error occurred while creating intervals");
                exit(1);
            }
        };
<span class="boring">
</span><span class="boring">    // merge overlapping intervals
</span><span class="boring">    let intervals = merge_intervals(intervals);
</span><span class="boring">
</span><span class="boring">    // print the lines
</span><span class="boring">    print_results(intervals, lines);
</span>}

enum IntervalError {
    StartEndRangeInvalid,
    NonOverlappingInterval,
}

struct Interval {
    start: usize,
    end: usize,
}

impl Interval {
    fn new(start: usize, end: usize) -&gt; Result&lt;Self, IntervalError&gt; {
        if start &lt;= end {
            Ok(Self { start, end })
        } else {
            Err(IntervalError::StartEndRangeInvalid)
        }
    }

    fn overlaps(&amp;self, other: &amp;Interval) -&gt; bool {
        self.end &gt;= other.start
    }

    fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
        if self.overlaps(other) {
            Ok(Self {
                start: self.start,
                end: other.end,
            })
        } else {
            Err(IntervalError::NonOverlappingInterval)
        }
    }
}</code></pre></pre>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>The decision to use the <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> type for error handling in Rust provides a
robust and flexible way of managing errors such as:</p>
<ol>
<li><strong>Explicit Error Handling</strong>: Using <code>Result</code> makes error handling explicit.
Functions that can fail return a <code>Result</code>, which forces the caller to handle
the potential error, making the code more reliable and less prone to
unexpected failures.</li>
<li><strong>Recoverable Errors</strong>: The <code>Result</code> type allows for recoverable errors. By
returning a <code>Result</code>, the function gives the caller the option to handle the
error in a way that makes sense for their specific context, rather than
immediately terminating the program.</li>
<li><strong>Type Safety</strong>: Rust's type system ensures that errors are handled
correctly. The <code>Result</code> type is part of this system, helping to prevent
common errors like null pointer dereferencing and making the code safer and
more predictable.</li>
<li><strong>Composability</strong>: The <code>Result</code> type implements traits like <code>FromIterator</code>,
which allows for powerful and flexible error handling patterns. This makes it
easier to work with collections of results and to propagate errors through
multiple layers of function calls.</li>
</ol>
<p>Overall, the use of <code>Result</code> aligns with Rust's goals of safety, concurrency,
and performance, providing a clear and structured way to handle errors.</p>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<ul>
<li>
<p>Replace <code>Result::or</code> with <code>Result::map_err</code> in <code>merge_intervals</code>.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-rust noplayground">fn merge_intervals(intervals: Vec&lt;Interval&gt;) -&gt; Vec&lt;Interval&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).map_err(|_| (p, c)))
        .collect()
}</code></pre>
</details></li>
</ul>

<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(unused_imports)]
extern crate regex; // this is needed for the playground
use itertools::Itertools;
use regex::Regex;
use std::fs::File;
use std::io::Read;
use std::io::{BufRead, BufReader};
use std::process::exit;

fn find_matching_lines(lines: &amp;[String], regex: Regex) -&gt; Vec&lt;usize&gt; {
    lines
        .iter()
        .enumerate()
        .filter_map(|(i, line)| match regex.is_match(line) {
            true =&gt; Some(i),
            false =&gt; None,
        })
        .collect() // turns anything iterable into a collection
}

fn create_intervals(
    lines: Vec&lt;usize&gt;,
    before_context: usize,
    after_context: usize,
) -&gt; Result&lt;Vec&lt;Interval&gt;, IntervalError&gt; {
    lines
        .iter()
        .map(|line| {
            let start = line.saturating_sub(before_context);
            let end = line.saturating_add(after_context);
            Interval::new(start, end)
        })
        .collect()
}

fn merge_intervals(intervals: Vec&lt;Interval&gt;) -&gt; Vec&lt;Interval&gt; {
    // merge overlapping intervals
    intervals
        .into_iter()
        .coalesce(|p, c| p.merge(&amp;c).or(Err((p, c))))
        .collect()
}

fn print_results(intervals: Vec&lt;Interval&gt;, lines: Vec&lt;String&gt;) {
    for interval in intervals {
        for (line_no, line) in lines
            .iter()
            .enumerate()
            .take(interval.end + 1)
            .skip(interval.start)
        {
            println!("{}: {}", line_no + 1, line)
        }
    }
}

fn read_file(file: impl Read) -&gt; Vec&lt;String&gt; {
    BufReader::new(file).lines().map_while(Result::ok).collect()
}

fn main() {
    let poem = "I have a little shadow that goes in and out with me,
                And what can be the use of him is more than I can see.
                He is very, very like me from the heels up to the head;
                And I see him jump before me, when I jump into my bed.

                The funniest thing about him is the way he likes to grow -
                Not at all like proper children, which is always very slow;
                For he sometimes shoots up taller like an india-rubber ball,
                And he sometimes gets so little that there's none of him at all.";

    let mock_file = std::io::Cursor::new(poem);

    // command line arguments
    let pattern = "(all)|(little)";
    let before_context = 1;
    let after_context = 1;

    // attempt to open the file
    let lines = read_file(mock_file);
    //let lines = match File::open(filename) {
    //    // convert the poem into lines
    //    Ok(file) =&gt; read_file(file),
    //    Err(e) =&gt; {
    //        eprintln!("Error opening {filename}: {e}");
    //        exit(1);
    //    }
    //};

    // compile the regular expression
    let regex = match Regex::new(pattern) {
        Ok(re) =&gt; re, // bind re to regex
        Err(e) =&gt; {
            eprintln!("{e}"); // write to standard error
            exit(1);
        }
    };

    // store the 0-based line number for any matched line
    let match_lines = find_matching_lines(&amp;lines, regex);

    // create intervals of the form [a,b] with the before/after context
    let intervals =
        match create_intervals(match_lines, before_context, after_context) {
            Ok(intervals) =&gt; intervals,
            Err(_) =&gt; {
                eprintln!("An error occurred while creating intervals");
                exit(1);
            }
        };

    // merge overlapping intervals
    let intervals = merge_intervals(intervals);

    // print the lines
    print_results(intervals, lines);
}

enum IntervalError {
    StartEndRangeInvalid,
    NonOverlappingInterval,
}

struct Interval {
    start: usize,
    end: usize,
}

impl Interval {
    fn new(start: usize, end: usize) -&gt; Result&lt;Self, IntervalError&gt; {
        if start &lt;= end {
            Ok(Self { start, end })
        } else {
            Err(IntervalError::StartEndRangeInvalid)
        }
    }

    fn overlaps(&amp;self, other: &amp;Interval) -&gt; bool {
        self.end &gt;= other.start
    }

    fn merge(&amp;self, other: &amp;Self) -&gt; Result&lt;Self, IntervalError&gt; {
        if self.overlaps(other) {
            Ok(Self {
                start: self.start,
                end: other.end,
            })
        } else {
            Err(IntervalError::NonOverlappingInterval)
        }
    }
}</code></pre></pre>
<h1 id="next"><a class="header" href="#next">Next</a></h1>
<p>With our Interval complete, let's make it a module!</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-1">
<p>Refer to the documentation on <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#enum-values">enum values</a>. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Refer to the documentation on <em><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-the-field-init-shorthand">field init shorthand</a></em> syntax. <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>Refer to the documentation on <a href="https://doc.rust-lang.org/std/result/#collecting-into-result">Collecting into a <code>Result</code></a> for detailed
explanation. <a href="#fr-3-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>
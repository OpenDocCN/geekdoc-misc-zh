<html><head></head><body>
<h2 class="c27" id="h.6wnbyg9956qa"><span class="c4">Implementing Conditionals</span></h2><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Okay, so we have many decisions to make! To first get a working evaluator, without having to go beyond numbers, we can use a slightly different conditional construct: one that checks whether evaluates to a special numeric value, such as </span><code>0</code><span class="calibre3">. That is, instead of a proper </span><code>if</code><span class="calibre3">, we really have something we might call </span><code>if0</code><span class="c4"> that works only for numbers.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">How do we make this choice? Luckily, we’re writing our interpreter in plait, which of course already has a conditional. Therefore, we can just reuse it:</span></p><p class="c3"><span class="c4"/></p><pre>(define (calc e)
  (type-case Exp e
    [(num n) n]
    [(plus l r) (+ (calc l) (calc r))]
    [(cnd c t e) (if (zero? (calc c))
                     (calc t)
                     (calc e))]))</pre><p class="c3"><span class="c4"/></p><p class="c5"><span class="calibre3">Observe that the semantics of the conditional—that </span><code>0</code><span class="calibre3"> is true, and everything else is false—is now made manifest in the body of </span><code>calc</code><span class="c4">. If we want a different semantics, that’s the part of the program to zero into and change.</span></p><p class="c3"><span class="c4"/></p><p class="c5"><span class="c4">This solution, and indeed so far our entire evaluator, might feel a bit… disappointing? We have numbers and conditionals, sure, but all we’ve done is (mostly) deferred to plait to handle these. Here are some thoughts on this:</span></p><p class="c3"><span class="c4"/></p><ol class="c59" start="1"><li class="pcalibre7 c60"><span class="c4">This is true!</span></li><li class="pcalibre7 c60"><span class="c4">This is not entirely true. We have made some conscious decisions, like the handling of conditionals.</span></li><li class="pcalibre7 c60"><span class="c4">In fact, we have made even more decisions, whether or not we were conscious of them, such as the handling of numbers. We just happened to defer those to plait, but we could have made other decisions if we wanted.</span></li><li class="pcalibre7 c60"><span class="calibre3">This reuse is actually part of the </span><span class="c7">power</span><span class="c4"> of an interpreter: it lets you exploit features that have already been built instead of having to re-implement all of them from scratch.</span></li><li class="pcalibre7 c60"><span class="calibre3">By reusing the </span><span class="c7">host</span><span class="c4"> language (here, plait), we can zero in on the differences (like the handling of conditionals), which would otherwise be lost if we had to implement everything. Later we will see stronger departures from the semantics of plait.</span></li></ol></body></html>
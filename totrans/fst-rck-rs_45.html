<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Scoped Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Scoped Threads</h1>
<blockquote>原文：<a href="https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html">https://freddiehaddad.github.io/fast-track-to-rust/scoped_threads.html</a></blockquote>
                        
<p>In the previous section, we explored the <code>spawn</code> method in the <code>thread</code> module
and noted its limitation: it cannot borrow non-<code>'static</code> data because the
compiler cannot guarantee that all threads will be joined before the lifetimes
of any borrowed values expire. To address this issue, the <code>thread</code> module also
offers the <a href="https://doc.rust-lang.org/stable/std/thread/fn.scope.html"><code>scope</code> function</a>, which works in conjunction with <a href="https://doc.rust-lang.org/stable/std/thread/struct.Scope.html"><code>Scope</code></a>. This
combination allows for borrowing non-<code>'static</code> data by ensuring that all spawned
threads within the scope are automatically joined before the function in which
they were created returns, unless they were manually joined earlier.</p>
<h2 id="the-scope-function"><a class="header" href="#the-scope-function">The <code>scope</code> Function</a></h2>
<p>Here's the signature for the <a href="https://doc.rust-lang.org/stable/std/thread/fn.scope.html"><code>scope</code> function</a>:</p>
<pre><code class="language-rust noplayground">pub fn scope&lt;'env, F, T&gt;(f: F) -&gt; T
where
    F: for&lt;'scope&gt; FnOnce(&amp;'scope Scope&lt;'scope, 'env&gt;) -&gt; T,</code></pre>
<p>The <code>scope</code> function takes a closure (<code>f</code>) as an argument, which receives a
<code>Scope</code> object (created by <code>scope</code>). This <code>Scope</code> object allows threads to be
spawned using the <a href="https://doc.rust-lang.org/stable/std/thread/struct.Scope.html#method.spawn"><code>spawn</code></a> method. The spawn method returns a
<a href="https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html"><code>ScopedJoinHandle</code></a>, which, as the name suggests, provides a <a href="https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html#method.join"><code>join</code></a> method to
wait for the spawned thread to complete.</p>
<p>Scoped threads involve two lifetimes: <code>'scope</code> and <code>'env</code>:</p>
<ul>
<li><code>'env</code>: This is a lifetime parameter that represents the lifetime of the
environment data that the <code>Scope</code> can borrow (meaning the data from outside
the scope). It ensures that any references to the environment data outlive the
scope.</li>
<li><code>'scope</code>: This is another lifetime parameter that represents the lifetime of
the scope itself. This is the period during which new scoped threads can be
spawned and running. It ensures that any running threads are joined before the
lifetime ends.</li>
</ul>
<p>In plain English, the <code>scope</code> function takes a closure <code>f</code> that can borrow data
with a specific lifetime <code>'env</code> and ensures that all threads spawned within the
scope are joined before the function returns.</p>
<p>Let's revisit one of the examples from the previous section that failed to
compile to better understand these concepts. Review the following code snippet
and then run the program.</p>
<pre class="playground"><code class="language-rust edition2021">fn main() {
    use std::thread;

    let error = String::from("E0373"); // Compiler error E0373

    thread::scope(|s| {
        let handler = s.spawn(|| {
            println!("{error}");
        });

        s.spawn(|| {
            println!("{error}");
        });

        handler.join().unwrap(); // Manually join the first thread

        // Second thread is automatically joined when the closure returns.
    });
}</code></pre>
<p>Through these ownership and type system tools, it is guaranteed that all threads
created within <code>scope</code> are joined before their lifetimes end. This allows the
Rust compiler to be certain that all borrowed data (in this case, the <code>error</code>
<code>String</code>) remains valid for the lifetime of the threads. This is how Rust turns
many runtime errors into compile-time errors. Concepts like this facilitate
fearless concurrency in Rust!</p>

                        
</body>
</html>
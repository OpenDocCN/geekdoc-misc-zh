["```rs\ninterface PhysicalPlan {\n\n  fun schema(): Schema\n\n  /* Execute a physical plan and produce a series of record batches. */\n  fun execute(): Sequence<RecordBatch>\n\n  /*\n   * Returns the children (inputs) of this physical plan. This method is used\n   * to enable use of the visitor pattern to walk a query tree.\n   */\n  fun children(): List<PhysicalPlan>\n} \n```", "```rs\ninterface Expression {\n  fun evaluate(input: RecordBatch): ColumnVector\n} \n```", "```rs\nclass ColumnExpression(val i: Int) : Expression {\n\n  override fun evaluate(input: RecordBatch): ColumnVector {\n    return input.field(i)\n  }\n} \n```", "```rs\nclass LiteralValueVector(\n    val arrowType: ArrowType,\n    val value: Any?,\n    val size: Int\n) : ColumnVector {\n\n  override fun getType(): ArrowType = arrowType\n\n  override fun getValue(i: Int): Any? {\n    if (i < 0 || i >= size) {\n      throw IndexOutOfBoundsException()\n    }\n    return value\n  }\n\n  override fun size(): Int = size\n} \n```", "```rs\nclass LiteralDoubleExpression(val value: Double) : Expression {\n  override fun evaluate(input: RecordBatch): ColumnVector {\n    return LiteralValueVector(ArrowTypes.DoubleType, value, input.rowCount())\n  }\n} \n```", "```rs\nabstract class BinaryExpression(val l: Expression, val r: Expression) : Expression {\n\n  override fun evaluate(input: RecordBatch): ColumnVector {\n    val ll = l.evaluate(input)\n    val rr = r.evaluate(input)\n    assert(ll.size() == rr.size())\n    return evaluate(ll, rr)\n  }\n\n  abstract fun evaluate(l: ColumnVector, r: ColumnVector): ColumnVector\n} \n```", "```rs\nclass EqExpression(l: Expression, r: Expression) : BooleanExpression(l, r) {\n\n  override fun evaluate(l: Any?, r: Any?, arrowType: ArrowType): Boolean {\n    return when (arrowType) {\n      ArrowTypes.Int32Type -> (l as Int) == (r as Int)\n      ArrowTypes.Int64Type -> (l as Long) == (r as Long)\n      ArrowTypes.DoubleType -> (l as Double) == (r as Double)\n      ArrowTypes.StringType -> toString(l) == toString(r)\n      else -> throw IllegalStateException(\"Unsupported type: $arrowType\")\n    }\n  }\n} \n```", "```rs\nclass AddExpression(l: Expression, r: Expression) : MathExpression(l, r) {\n\n  override fun evaluate(l: Any?, r: Any?, arrowType: ArrowType): Any? {\n    return when (arrowType) {\n      ArrowTypes.Int32Type -> (l as Int) + (r as Int)\n      ArrowTypes.Int64Type -> (l as Long) + (r as Long)\n      ArrowTypes.DoubleType -> (l as Double) + (r as Double)\n      else -> throw IllegalStateException(\"Unsupported type: $arrowType\")\n    }\n  }\n} \n```", "```rs\ninterface AggregateExpression {\n  fun inputExpression(): Expression\n  fun createAccumulator(): Accumulator\n}\n\ninterface Accumulator {\n  fun accumulate(value: Any?)\n  fun finalValue(): Any?\n} \n```", "```rs\nclass MaxExpression(private val expr: Expression) : AggregateExpression {\n\n  override fun inputExpression(): Expression = expr\n\n  override fun createAccumulator(): Accumulator = MaxAccumulator()\n}\n\nclass MaxAccumulator : Accumulator {\n  var value: Any? = null\n\n  override fun accumulate(value: Any?) {\n    if (value != null) {\n      if (this.value == null) {\n        this.value = value\n      } else {\n        val isMax = when (value) {\n          is Int -> value > this.value as Int\n          is Long -> value > this.value as Long\n          is Double -> value > this.value as Double\n          else -> throw UnsupportedOperationException(\"MAX not supported for: ${value.javaClass}\")\n        }\n        if (isMax) {\n          this.value = value\n        }\n      }\n    }\n  }\n\n  override fun finalValue(): Any? = value\n} \n```", "```rs\nclass ScanExec(val ds: DataSource, val projection: List<String>) : PhysicalPlan {\n\n  override fun schema(): Schema = ds.schema().select(projection)\n\n  override fun children(): List<PhysicalPlan> = listOf()\n\n  override fun execute(): Sequence<RecordBatch> = ds.scan(projection)\n} \n```", "```rs\nclass ProjectionExec(\n    val input: PhysicalPlan,\n    val schema: Schema,\n    val expr: List<Expression>\n) : PhysicalPlan {\n\n  override fun schema(): Schema = schema\n\n  override fun children(): List<PhysicalPlan> = listOf(input)\n\n  override fun execute(): Sequence<RecordBatch> {\n    return input.execute().map { batch ->\n      val columns = expr.map { it.evaluate(batch) }\n      RecordBatch(schema, columns)\n    }\n  }\n} \n```", "```rs\nclass SelectionExec(\n    val input: PhysicalPlan,\n    val expr: Expression\n) : PhysicalPlan {\n\n  override fun schema(): Schema = input.schema()\n\n  override fun children(): List<PhysicalPlan> = listOf(input)\n\n  override fun execute(): Sequence<RecordBatch> {\n    return input.execute().map { batch ->\n      val result = expr.evaluate(batch) as BitVector\n      val filteredFields = batch.schema.fields.indices.map { i ->\n        filter(batch.field(i), result)\n      }\n      RecordBatch(batch.schema, filteredFields)\n    }\n  }\n\n  private fun filter(v: ColumnVector, selection: BitVector): ColumnVector {\n    // Count selected rows\n    var count = 0\n    (0 until selection.valueCount).forEach {\n      if (selection.get(it) == 1) count++\n    }\n\n    // Build filtered vector\n    val filtered = FieldVectorFactory.create(v.getType(), count)\n    var index = 0\n    (0 until selection.valueCount).forEach {\n      if (selection.get(it) == 1) {\n        filtered.set(index++, v.getValue(it))\n      }\n    }\n    return filtered\n  }\n} \n```", "```rs\nclass HashAggregateExec(\n    val input: PhysicalPlan,\n    val groupExpr: List<Expression>,\n    val aggregateExpr: List<AggregateExpression>,\n    val schema: Schema\n) : PhysicalPlan {\n\n  override fun schema(): Schema = schema\n\n  override fun children(): List<PhysicalPlan> = listOf(input)\n\n  override fun execute(): Sequence<RecordBatch> {\n    val map = HashMap<List<Any?>, List<Accumulator>>()\n\n    // Process all input batches\n    input.execute().forEach { batch ->\n      val groupKeys = groupExpr.map { it.evaluate(batch) }\n      val aggrInputs = aggregateExpr.map { it.inputExpression().evaluate(batch) }\n\n      // For each row, update accumulators\n      (0 until batch.rowCount()).forEach { row ->\n        val key = groupKeys.map { it.getValue(row) }\n\n        val accumulators = map.getOrPut(key) {\n          aggregateExpr.map { it.createAccumulator() }\n        }\n\n        accumulators.forEachIndexed { i, acc ->\n          acc.accumulate(aggrInputs[i].getValue(row))\n        }\n      }\n    }\n\n    // Build output batch from accumulated results\n    val root = VectorSchemaRoot.create(schema.toArrow(), allocator)\n    root.allocateNew()\n    root.rowCount = map.size\n\n    map.entries.forEachIndexed { rowIndex, entry ->\n      val (groupKey, accumulators) = entry\n\n      groupExpr.indices.forEach { i ->\n        root.getVector(i).set(rowIndex, groupKey[i])\n      }\n      aggregateExpr.indices.forEach { i ->\n        root.getVector(groupExpr.size + i).set(rowIndex, accumulators[i].finalValue())\n      }\n    }\n\n    return sequenceOf(RecordBatch(schema, root.fieldVectors.map { ArrowFieldVector(it) }))\n  }\n} \n```"]